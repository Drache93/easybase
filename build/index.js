import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/ready-resource/index.js
var require_ready_resource = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  module.exports = class ReadyResource extends EventEmitter {
    constructor() {
      super();
      this.opening = null;
      this.closing = null;
      this.opened = false;
      this.closed = false;
    }
    ready() {
      if (this.opening !== null)
        return this.opening;
      this.opening = open(this);
      return this.opening;
    }
    close() {
      if (this.closing !== null)
        return this.closing;
      this.closing = close(this);
      return this.closing;
    }
    async _open() {}
    async _close() {}
  };
  async function open(self) {
    if (self.closing !== null)
      return;
    try {
      await self._open();
    } catch (err) {
      self.close();
      throw err;
    }
    self.opened = true;
    self.emit("ready");
  }
  async function close(self) {
    try {
      if (self.opened === false && self.opening !== null)
        await self.opening;
    } catch {}
    if (self.opened === true || self.opening === null)
      await self._close();
    self.closed = true;
    self.emit("close");
  }
});

// node_modules/b4a/index.js
var require_b4a = __commonJS((exports, module) => {
  function isBuffer(value) {
    return Buffer.isBuffer(value) || value instanceof Uint8Array;
  }
  function isEncoding(encoding) {
    return Buffer.isEncoding(encoding);
  }
  function alloc(size, fill2, encoding) {
    return Buffer.alloc(size, fill2, encoding);
  }
  function allocUnsafe(size) {
    return Buffer.allocUnsafe(size);
  }
  function allocUnsafeSlow(size) {
    return Buffer.allocUnsafeSlow(size);
  }
  function byteLength(string, encoding) {
    return Buffer.byteLength(string, encoding);
  }
  function compare(a, b) {
    return Buffer.compare(a, b);
  }
  function concat(buffers, totalLength) {
    return Buffer.concat(buffers, totalLength);
  }
  function copy(source, target, targetStart, start, end) {
    return toBuffer(source).copy(target, targetStart, start, end);
  }
  function equals(a, b) {
    return toBuffer(a).equals(b);
  }
  function fill(buffer, value, offset, end, encoding) {
    return toBuffer(buffer).fill(value, offset, end, encoding);
  }
  function from(value, encodingOrOffset, length) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  function includes(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).includes(value, byteOffset, encoding);
  }
  function indexOf(buffer, value, byfeOffset, encoding) {
    return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
  }
  function lastIndexOf(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
  }
  function swap16(buffer) {
    return toBuffer(buffer).swap16();
  }
  function swap32(buffer) {
    return toBuffer(buffer).swap32();
  }
  function swap64(buffer) {
    return toBuffer(buffer).swap64();
  }
  function toBuffer(buffer) {
    if (Buffer.isBuffer(buffer))
      return buffer;
    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function toString(buffer, encoding, start, end) {
    return toBuffer(buffer).toString(encoding, start, end);
  }
  function write(buffer, string, offset, length, encoding) {
    return toBuffer(buffer).write(string, offset, length, encoding);
  }
  function writeDoubleLE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleLE(value, offset);
  }
  function writeFloatLE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatLE(value, offset);
  }
  function writeUInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32LE(value, offset);
  }
  function writeInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32LE(value, offset);
  }
  function readDoubleLE(buffer, offset) {
    return toBuffer(buffer).readDoubleLE(offset);
  }
  function readFloatLE(buffer, offset) {
    return toBuffer(buffer).readFloatLE(offset);
  }
  function readUInt32LE(buffer, offset) {
    return toBuffer(buffer).readUInt32LE(offset);
  }
  function readInt32LE(buffer, offset) {
    return toBuffer(buffer).readInt32LE(offset);
  }
  function writeDoubleBE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleBE(value, offset);
  }
  function writeFloatBE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatBE(value, offset);
  }
  function writeUInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32BE(value, offset);
  }
  function writeInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32BE(value, offset);
  }
  function readDoubleBE(buffer, offset) {
    return toBuffer(buffer).readDoubleBE(offset);
  }
  function readFloatBE(buffer, offset) {
    return toBuffer(buffer).readFloatBE(offset);
  }
  function readUInt32BE(buffer, offset) {
    return toBuffer(buffer).readUInt32BE(offset);
  }
  function readInt32BE(buffer, offset) {
    return toBuffer(buffer).readInt32BE(offset);
  }
  module.exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    writeDoubleLE,
    writeFloatLE,
    writeUInt32LE,
    writeInt32LE,
    readDoubleLE,
    readFloatLE,
    readUInt32LE,
    readInt32LE,
    writeDoubleBE,
    writeFloatBE,
    writeUInt32BE,
    writeInt32BE,
    readDoubleBE,
    readFloatBE,
    readUInt32BE,
    readInt32BE
  };
});

// node_modules/debounceify/index.js
var require_debounceify = __commonJS((exports, module) => {
  module.exports = function debounce(worker, context = null) {
    debounced.running = null;
    return debounced;
    async function debounced() {
      if (debounced.running !== null) {
        try {
          await debounced.running;
        } catch (_) {}
      }
      if (debounced.running !== null)
        return debounced.running;
      debounced.running = worker.call(context);
      try {
        return await debounced.running;
      } finally {
        debounced.running = null;
      }
    }
  };
});

// node_modules/compact-encoding/endian.js
var require_endian = __commonJS((exports) => {
  var LE = exports.LE = new Uint8Array(new Uint16Array([255]).buffer)[0] === 255;
  exports.BE = !LE;
});

// node_modules/compact-encoding/raw.js
var require_raw = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var { BE } = require_endian();
  exports = module.exports = {
    preencode(state, b) {
      state.end += b.byteLength;
    },
    encode(state, b) {
      state.buffer.set(b, state.start);
      state.start += b.byteLength;
    },
    decode(state) {
      const b = state.buffer.subarray(state.start, state.end);
      state.start = state.end;
      return b;
    }
  };
  var buffer = exports.buffer = {
    preencode(state, b) {
      if (b)
        uint8array.preencode(state, b);
      else
        state.end++;
    },
    encode(state, b) {
      if (b)
        uint8array.encode(state, b);
      else
        state.buffer[state.start++] = 0;
    },
    decode(state) {
      const b = state.buffer.subarray(state.start);
      if (b.byteLength === 0)
        return null;
      state.start = state.end;
      return b;
    }
  };
  exports.binary = {
    ...buffer,
    preencode(state, b) {
      if (typeof b === "string")
        utf8.preencode(state, b);
      else
        buffer.preencode(state, b);
    },
    encode(state, b) {
      if (typeof b === "string")
        utf8.encode(state, b);
      else
        buffer.encode(state, b);
    }
  };
  exports.arraybuffer = {
    preencode(state, b) {
      state.end += b.byteLength;
    },
    encode(state, b) {
      const view = new Uint8Array(b);
      state.buffer.set(view, state.start);
      state.start += b.byteLength;
    },
    decode(state) {
      const b = new ArrayBuffer(state.end - state.start);
      const view = new Uint8Array(b);
      view.set(state.buffer.subarray(state.start));
      state.start = state.end;
      return b;
    }
  };
  function typedarray(TypedArray, swap) {
    const n = TypedArray.BYTES_PER_ELEMENT;
    return {
      preencode(state, b) {
        state.end += b.byteLength;
      },
      encode(state, b) {
        const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
        if (BE && swap)
          swap(view);
        state.buffer.set(view, state.start);
        state.start += b.byteLength;
      },
      decode(state) {
        let b = state.buffer.subarray(state.start);
        if (b.byteOffset % n !== 0)
          b = new Uint8Array(b);
        if (BE && swap)
          swap(b);
        state.start = state.end;
        return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n);
      }
    };
  }
  var uint8array = exports.uint8array = typedarray(Uint8Array);
  exports.uint16array = typedarray(Uint16Array, b4a.swap16);
  exports.uint32array = typedarray(Uint32Array, b4a.swap32);
  exports.int8array = typedarray(Int8Array);
  exports.int16array = typedarray(Int16Array, b4a.swap16);
  exports.int32array = typedarray(Int32Array, b4a.swap32);
  exports.biguint64array = typedarray(BigUint64Array, b4a.swap64);
  exports.bigint64array = typedarray(BigInt64Array, b4a.swap64);
  exports.float32array = typedarray(Float32Array, b4a.swap32);
  exports.float64array = typedarray(Float64Array, b4a.swap64);
  function string(encoding) {
    return {
      preencode(state, s) {
        state.end += b4a.byteLength(s, encoding);
      },
      encode(state, s) {
        state.start += b4a.write(state.buffer, s, state.start, encoding);
      },
      decode(state) {
        const s = b4a.toString(state.buffer, encoding, state.start);
        state.start = state.end;
        return s;
      }
    };
  }
  var utf8 = exports.string = exports.utf8 = string("utf-8");
  exports.ascii = string("ascii");
  exports.hex = string("hex");
  exports.base64 = string("base64");
  exports.ucs2 = exports.utf16le = string("utf16le");
  exports.array = function array(enc) {
    return {
      preencode(state, list) {
        for (const value of list)
          enc.preencode(state, value);
      },
      encode(state, list) {
        for (const value of list)
          enc.encode(state, value);
      },
      decode(state) {
        const arr = [];
        while (state.start < state.end)
          arr.push(enc.decode(state));
        return arr;
      }
    };
  };
  exports.json = {
    preencode(state, v) {
      utf8.preencode(state, JSON.stringify(v));
    },
    encode(state, v) {
      utf8.encode(state, JSON.stringify(v));
    },
    decode(state) {
      return JSON.parse(utf8.decode(state));
    }
  };
  exports.ndjson = {
    preencode(state, v) {
      utf8.preencode(state, JSON.stringify(v) + `
`);
    },
    encode(state, v) {
      utf8.encode(state, JSON.stringify(v) + `
`);
    },
    decode(state) {
      return JSON.parse(utf8.decode(state));
    }
  };
});

// node_modules/compact-encoding/lexint.js
var require_lexint = __commonJS((exports, module) => {
  module.exports = {
    preencode,
    encode,
    decode
  };
  function preencode(state, num) {
    if (num < 251) {
      state.end++;
    } else if (num < 256) {
      state.end += 2;
    } else if (num < 65536) {
      state.end += 3;
    } else if (num < 16777216) {
      state.end += 4;
    } else if (num < 4294967296) {
      state.end += 5;
    } else {
      state.end++;
      const exp = Math.floor(Math.log(num) / Math.log(2)) - 32;
      preencode(state, exp);
      state.end += 6;
    }
  }
  function encode(state, num) {
    const max = 251;
    const x = num - max;
    if (num < max) {
      state.buffer[state.start++] = num;
    } else if (num < 256) {
      state.buffer[state.start++] = max;
      state.buffer[state.start++] = x;
    } else if (num < 65536) {
      state.buffer[state.start++] = max + 1;
      state.buffer[state.start++] = x >> 8 & 255;
      state.buffer[state.start++] = x & 255;
    } else if (num < 16777216) {
      state.buffer[state.start++] = max + 2;
      state.buffer[state.start++] = x >> 16;
      state.buffer[state.start++] = x >> 8 & 255;
      state.buffer[state.start++] = x & 255;
    } else if (num < 4294967296) {
      state.buffer[state.start++] = max + 3;
      state.buffer[state.start++] = x >> 24;
      state.buffer[state.start++] = x >> 16 & 255;
      state.buffer[state.start++] = x >> 8 & 255;
      state.buffer[state.start++] = x & 255;
    } else {
      const exp = Math.floor(Math.log(x) / Math.log(2)) - 32;
      state.buffer[state.start++] = 255;
      encode(state, exp);
      const rem = x / Math.pow(2, exp - 11);
      for (let i = 5;i >= 0; i--) {
        state.buffer[state.start++] = rem / Math.pow(2, 8 * i) & 255;
      }
    }
  }
  function decode(state) {
    const max = 251;
    if (state.end - state.start < 1)
      throw new Error("Out of bounds");
    const flag = state.buffer[state.start++];
    if (flag < max)
      return flag;
    if (state.end - state.start < flag - max + 1) {
      throw new Error("Out of bounds.");
    }
    if (flag < 252) {
      return state.buffer[state.start++] + max;
    }
    if (flag < 253) {
      return (state.buffer[state.start++] << 8) + state.buffer[state.start++] + max;
    }
    if (flag < 254) {
      return (state.buffer[state.start++] << 16) + (state.buffer[state.start++] << 8) + state.buffer[state.start++] + max;
    }
    if (flag < 255) {
      return state.buffer[state.start++] * 16777216 + (state.buffer[state.start++] << 16) + (state.buffer[state.start++] << 8) + state.buffer[state.start++] + max;
    }
    const exp = decode(state);
    if (state.end - state.start < 6)
      throw new Error("Out of bounds");
    let rem = 0;
    for (let i = 5;i >= 0; i--) {
      rem += state.buffer[state.start++] * Math.pow(2, 8 * i);
    }
    return rem * Math.pow(2, exp - 11) + max;
  }
});

// node_modules/compact-encoding/index.js
var require_compact_encoding = __commonJS((exports) => {
  var b4a = require_b4a();
  var { BE } = require_endian();
  exports.state = function(start = 0, end = 0, buffer2 = null) {
    return { start, end, buffer: buffer2, cache: null };
  };
  var raw = exports.raw = require_raw();
  var uint = exports.uint = {
    preencode(state, n) {
      state.end += n <= 252 ? 1 : n <= 65535 ? 3 : n <= 4294967295 ? 5 : 9;
    },
    encode(state, n) {
      if (n <= 252)
        uint8.encode(state, n);
      else if (n <= 65535) {
        state.buffer[state.start++] = 253;
        uint16.encode(state, n);
      } else if (n <= 4294967295) {
        state.buffer[state.start++] = 254;
        uint32.encode(state, n);
      } else {
        state.buffer[state.start++] = 255;
        uint64.encode(state, n);
      }
    },
    decode(state) {
      const a = uint8.decode(state);
      if (a <= 252)
        return a;
      if (a === 253)
        return uint16.decode(state);
      if (a === 254)
        return uint32.decode(state);
      return uint64.decode(state);
    }
  };
  var uint8 = exports.uint8 = {
    preencode(state, n) {
      state.end += 1;
    },
    encode(state, n) {
      validateUint(n);
      state.buffer[state.start++] = n;
    },
    decode(state) {
      if (state.start >= state.end)
        throw new Error("Out of bounds");
      return state.buffer[state.start++];
    }
  };
  var uint16 = exports.uint16 = {
    preencode(state, n) {
      state.end += 2;
    },
    encode(state, n) {
      validateUint(n);
      state.buffer[state.start++] = n;
      state.buffer[state.start++] = n >>> 8;
    },
    decode(state) {
      if (state.end - state.start < 2)
        throw new Error("Out of bounds");
      return state.buffer[state.start++] + state.buffer[state.start++] * 256;
    }
  };
  var uint24 = exports.uint24 = {
    preencode(state, n) {
      state.end += 3;
    },
    encode(state, n) {
      validateUint(n);
      state.buffer[state.start++] = n;
      state.buffer[state.start++] = n >>> 8;
      state.buffer[state.start++] = n >>> 16;
    },
    decode(state) {
      if (state.end - state.start < 3)
        throw new Error("Out of bounds");
      return state.buffer[state.start++] + state.buffer[state.start++] * 256 + state.buffer[state.start++] * 65536;
    }
  };
  var uint32 = exports.uint32 = {
    preencode(state, n) {
      state.end += 4;
    },
    encode(state, n) {
      validateUint(n);
      state.buffer[state.start++] = n;
      state.buffer[state.start++] = n >>> 8;
      state.buffer[state.start++] = n >>> 16;
      state.buffer[state.start++] = n >>> 24;
    },
    decode(state) {
      if (state.end - state.start < 4)
        throw new Error("Out of bounds");
      return state.buffer[state.start++] + state.buffer[state.start++] * 256 + state.buffer[state.start++] * 65536 + state.buffer[state.start++] * 16777216;
    }
  };
  var uint40 = exports.uint40 = {
    preencode(state, n) {
      state.end += 5;
    },
    encode(state, n) {
      validateUint(n);
      const r = Math.floor(n / 256);
      uint8.encode(state, n);
      uint32.encode(state, r);
    },
    decode(state) {
      if (state.end - state.start < 5)
        throw new Error("Out of bounds");
      return uint8.decode(state) + 256 * uint32.decode(state);
    }
  };
  var uint48 = exports.uint48 = {
    preencode(state, n) {
      state.end += 6;
    },
    encode(state, n) {
      validateUint(n);
      const r = Math.floor(n / 65536);
      uint16.encode(state, n);
      uint32.encode(state, r);
    },
    decode(state) {
      if (state.end - state.start < 6)
        throw new Error("Out of bounds");
      return uint16.decode(state) + 65536 * uint32.decode(state);
    }
  };
  var uint56 = exports.uint56 = {
    preencode(state, n) {
      state.end += 7;
    },
    encode(state, n) {
      validateUint(n);
      const r = Math.floor(n / 16777216);
      uint24.encode(state, n);
      uint32.encode(state, r);
    },
    decode(state) {
      if (state.end - state.start < 7)
        throw new Error("Out of bounds");
      return uint24.decode(state) + 16777216 * uint32.decode(state);
    }
  };
  var uint64 = exports.uint64 = {
    preencode(state, n) {
      state.end += 8;
    },
    encode(state, n) {
      validateUint(n);
      const r = Math.floor(n / 4294967296);
      uint32.encode(state, n);
      uint32.encode(state, r);
    },
    decode(state) {
      if (state.end - state.start < 8)
        throw new Error("Out of bounds");
      return uint32.decode(state) + 4294967296 * uint32.decode(state);
    }
  };
  var int = exports.int = zigZagInt(uint);
  exports.int8 = zigZagInt(uint8);
  exports.int16 = zigZagInt(uint16);
  exports.int24 = zigZagInt(uint24);
  exports.int32 = zigZagInt(uint32);
  exports.int40 = zigZagInt(uint40);
  exports.int48 = zigZagInt(uint48);
  exports.int56 = zigZagInt(uint56);
  exports.int64 = zigZagInt(uint64);
  var biguint64 = exports.biguint64 = {
    preencode(state, n) {
      state.end += 8;
    },
    encode(state, n) {
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8);
      view.setBigUint64(0, n, true);
      state.start += 8;
    },
    decode(state) {
      if (state.end - state.start < 8)
        throw new Error("Out of bounds");
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8);
      const n = view.getBigUint64(0, true);
      state.start += 8;
      return n;
    }
  };
  exports.bigint64 = zigZagBigInt(biguint64);
  var biguint = exports.biguint = {
    preencode(state, n) {
      let len = 0;
      for (let m = n;m; m = m >> 64n)
        len++;
      uint.preencode(state, len);
      state.end += 8 * len;
    },
    encode(state, n) {
      let len = 0;
      for (let m = n;m; m = m >> 64n)
        len++;
      uint.encode(state, len);
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8 * len);
      for (let m = n, i = 0;m; m = m >> 64n, i += 8) {
        view.setBigUint64(i, BigInt.asUintN(64, m), true);
      }
      state.start += 8 * len;
    },
    decode(state) {
      const len = uint.decode(state);
      if (state.end - state.start < 8 * len)
        throw new Error("Out of bounds");
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8 * len);
      let n = 0n;
      for (let i = len - 1;i >= 0; i--)
        n = (n << 64n) + view.getBigUint64(i * 8, true);
      state.start += 8 * len;
      return n;
    }
  };
  exports.bigint = zigZagBigInt(biguint);
  exports.lexint = require_lexint();
  exports.float32 = {
    preencode(state, n) {
      state.end += 4;
    },
    encode(state, n) {
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 4);
      view.setFloat32(0, n, true);
      state.start += 4;
    },
    decode(state) {
      if (state.end - state.start < 4)
        throw new Error("Out of bounds");
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 4);
      const float = view.getFloat32(0, true);
      state.start += 4;
      return float;
    }
  };
  exports.float64 = {
    preencode(state, n) {
      state.end += 8;
    },
    encode(state, n) {
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8);
      view.setFloat64(0, n, true);
      state.start += 8;
    },
    decode(state) {
      if (state.end - state.start < 8)
        throw new Error("Out of bounds");
      const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8);
      const float = view.getFloat64(0, true);
      state.start += 8;
      return float;
    }
  };
  var buffer = exports.buffer = {
    preencode(state, b) {
      if (b)
        uint8array.preencode(state, b);
      else
        state.end++;
    },
    encode(state, b) {
      if (b)
        uint8array.encode(state, b);
      else
        state.buffer[state.start++] = 0;
    },
    decode(state) {
      const len = uint.decode(state);
      if (len === 0)
        return null;
      if (state.end - state.start < len)
        throw new Error("Out of bounds");
      return state.buffer.subarray(state.start, state.start += len);
    }
  };
  exports.binary = {
    ...buffer,
    preencode(state, b) {
      if (typeof b === "string")
        utf8.preencode(state, b);
      else
        buffer.preencode(state, b);
    },
    encode(state, b) {
      if (typeof b === "string")
        utf8.encode(state, b);
      else
        buffer.encode(state, b);
    }
  };
  exports.arraybuffer = {
    preencode(state, b) {
      uint.preencode(state, b.byteLength);
      state.end += b.byteLength;
    },
    encode(state, b) {
      uint.encode(state, b.byteLength);
      const view = new Uint8Array(b);
      state.buffer.set(view, state.start);
      state.start += b.byteLength;
    },
    decode(state) {
      const len = uint.decode(state);
      const b = new ArrayBuffer(len);
      const view = new Uint8Array(b);
      view.set(state.buffer.subarray(state.start, state.start += len));
      return b;
    }
  };
  function typedarray(TypedArray, swap) {
    const n = TypedArray.BYTES_PER_ELEMENT;
    return {
      preencode(state, b) {
        uint.preencode(state, b.length);
        state.end += b.byteLength;
      },
      encode(state, b) {
        uint.encode(state, b.length);
        const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
        if (BE && swap)
          swap(view);
        state.buffer.set(view, state.start);
        state.start += b.byteLength;
      },
      decode(state) {
        const len = uint.decode(state);
        let b = state.buffer.subarray(state.start, state.start += len * n);
        if (b.byteLength !== len * n)
          throw new Error("Out of bounds");
        if (b.byteOffset % n !== 0)
          b = new Uint8Array(b);
        if (BE && swap)
          swap(b);
        return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n);
      }
    };
  }
  var uint8array = exports.uint8array = typedarray(Uint8Array);
  exports.uint16array = typedarray(Uint16Array, b4a.swap16);
  exports.uint32array = typedarray(Uint32Array, b4a.swap32);
  exports.int8array = typedarray(Int8Array);
  exports.int16array = typedarray(Int16Array, b4a.swap16);
  exports.int32array = typedarray(Int32Array, b4a.swap32);
  exports.biguint64array = typedarray(BigUint64Array, b4a.swap64);
  exports.bigint64array = typedarray(BigInt64Array, b4a.swap64);
  exports.float32array = typedarray(Float32Array, b4a.swap32);
  exports.float64array = typedarray(Float64Array, b4a.swap64);
  function string(encoding) {
    return {
      preencode(state, s) {
        const len = b4a.byteLength(s, encoding);
        uint.preencode(state, len);
        state.end += len;
      },
      encode(state, s) {
        const len = b4a.byteLength(s, encoding);
        uint.encode(state, len);
        b4a.write(state.buffer, s, state.start, encoding);
        state.start += len;
      },
      decode(state) {
        const len = uint.decode(state);
        if (state.end - state.start < len)
          throw new Error("Out of bounds");
        return b4a.toString(state.buffer, encoding, state.start, state.start += len);
      },
      fixed(n) {
        return {
          preencode(state) {
            state.end += n;
          },
          encode(state, s) {
            b4a.write(state.buffer, s, state.start, n, encoding);
            state.start += n;
          },
          decode(state) {
            if (state.end - state.start < n)
              throw new Error("Out of bounds");
            return b4a.toString(state.buffer, encoding, state.start, state.start += n);
          }
        };
      }
    };
  }
  var utf8 = exports.string = exports.utf8 = string("utf-8");
  exports.ascii = string("ascii");
  exports.hex = string("hex");
  exports.base64 = string("base64");
  exports.ucs2 = exports.utf16le = string("utf16le");
  exports.bool = {
    preencode(state, b) {
      state.end++;
    },
    encode(state, b) {
      state.buffer[state.start++] = b ? 1 : 0;
    },
    decode(state) {
      if (state.start >= state.end)
        throw Error("Out of bounds");
      return state.buffer[state.start++] === 1;
    }
  };
  var fixed = exports.fixed = function fixed(n) {
    return {
      preencode(state, s) {
        if (s.byteLength !== n)
          throw new Error("Incorrect buffer size");
        state.end += n;
      },
      encode(state, s) {
        state.buffer.set(s, state.start);
        state.start += n;
      },
      decode(state) {
        if (state.end - state.start < n)
          throw new Error("Out of bounds");
        return state.buffer.subarray(state.start, state.start += n);
      }
    };
  };
  exports.fixed32 = fixed(32);
  exports.fixed64 = fixed(64);
  exports.array = function array(enc) {
    return {
      preencode(state, list) {
        uint.preencode(state, list.length);
        for (let i = 0;i < list.length; i++)
          enc.preencode(state, list[i]);
      },
      encode(state, list) {
        uint.encode(state, list.length);
        for (let i = 0;i < list.length; i++)
          enc.encode(state, list[i]);
      },
      decode(state) {
        const len = uint.decode(state);
        if (len > 1048576)
          throw new Error("Array is too big");
        const arr = new Array(len);
        for (let i = 0;i < len; i++)
          arr[i] = enc.decode(state);
        return arr;
      }
    };
  };
  exports.frame = function frame(enc) {
    const dummy = exports.state();
    return {
      preencode(state, m) {
        const end = state.end;
        enc.preencode(state, m);
        uint.preencode(state, state.end - end);
      },
      encode(state, m) {
        dummy.end = 0;
        enc.preencode(dummy, m);
        uint.encode(state, dummy.end);
        enc.encode(state, m);
      },
      decode(state) {
        const end = state.end;
        const len = uint.decode(state);
        state.end = state.start + len;
        const m = enc.decode(state);
        state.start = state.end;
        state.end = end;
        return m;
      }
    };
  };
  exports.date = {
    preencode(state, d) {
      int.preencode(state, d.getTime());
    },
    encode(state, d) {
      int.encode(state, d.getTime());
    },
    decode(state, d) {
      return new Date(int.decode(state));
    }
  };
  exports.json = {
    preencode(state, v) {
      utf8.preencode(state, JSON.stringify(v));
    },
    encode(state, v) {
      utf8.encode(state, JSON.stringify(v));
    },
    decode(state) {
      return JSON.parse(utf8.decode(state));
    }
  };
  exports.ndjson = {
    preencode(state, v) {
      utf8.preencode(state, JSON.stringify(v) + `
`);
    },
    encode(state, v) {
      utf8.encode(state, JSON.stringify(v) + `
`);
    },
    decode(state) {
      return JSON.parse(utf8.decode(state));
    }
  };
  exports.none = {
    preencode(state, n) {},
    encode(state, n) {},
    decode(state) {
      return null;
    }
  };
  var anyArray = {
    preencode(state, arr) {
      uint.preencode(state, arr.length);
      for (let i = 0;i < arr.length; i++) {
        any.preencode(state, arr[i]);
      }
    },
    encode(state, arr) {
      uint.encode(state, arr.length);
      for (let i = 0;i < arr.length; i++) {
        any.encode(state, arr[i]);
      }
    },
    decode(state) {
      const arr = [];
      let len = uint.decode(state);
      while (len-- > 0) {
        arr.push(any.decode(state));
      }
      return arr;
    }
  };
  var anyObject = {
    preencode(state, o) {
      const keys = Object.keys(o);
      uint.preencode(state, keys.length);
      for (const key of keys) {
        utf8.preencode(state, key);
        any.preencode(state, o[key]);
      }
    },
    encode(state, o) {
      const keys = Object.keys(o);
      uint.encode(state, keys.length);
      for (const key of keys) {
        utf8.encode(state, key);
        any.encode(state, o[key]);
      }
    },
    decode(state) {
      let len = uint.decode(state);
      const o = {};
      while (len-- > 0) {
        const key = utf8.decode(state);
        o[key] = any.decode(state);
      }
      return o;
    }
  };
  var anyTypes = [
    exports.none,
    exports.bool,
    exports.string,
    exports.buffer,
    exports.uint,
    exports.int,
    exports.float64,
    anyArray,
    anyObject,
    exports.date
  ];
  var any = exports.any = {
    preencode(state, o) {
      const t = getType(o);
      uint.preencode(state, t);
      anyTypes[t].preencode(state, o);
    },
    encode(state, o) {
      const t = getType(o);
      uint.encode(state, t);
      anyTypes[t].encode(state, o);
    },
    decode(state) {
      const t = uint.decode(state);
      if (t >= anyTypes.length)
        throw new Error("Unknown type: " + t);
      return anyTypes[t].decode(state);
    }
  };
  function getType(o) {
    if (o === null || o === undefined)
      return 0;
    if (typeof o === "boolean")
      return 1;
    if (typeof o === "string")
      return 2;
    if (b4a.isBuffer(o))
      return 3;
    if (typeof o === "number") {
      if (Number.isInteger(o))
        return o >= 0 ? 4 : 5;
      return 6;
    }
    if (Array.isArray(o))
      return 7;
    if (o instanceof Date)
      return 9;
    if (typeof o === "object")
      return 8;
    throw new Error("Unsupported type for " + o);
  }
  exports.from = function from(enc) {
    if (typeof enc === "string")
      return fromNamed(enc);
    if (enc.preencode)
      return enc;
    if (enc.encodingLength)
      return fromAbstractEncoder(enc);
    return fromCodec(enc);
  };
  function fromNamed(enc) {
    switch (enc) {
      case "ascii":
        return raw.ascii;
      case "utf-8":
      case "utf8":
        return raw.utf8;
      case "hex":
        return raw.hex;
      case "base64":
        return raw.base64;
      case "utf16-le":
      case "utf16le":
      case "ucs-2":
      case "ucs2":
        return raw.ucs2;
      case "ndjson":
        return raw.ndjson;
      case "json":
        return raw.json;
      case "binary":
      default:
        return raw.binary;
    }
  }
  function fromCodec(enc) {
    let tmpM = null;
    let tmpBuf = null;
    return {
      preencode(state, m) {
        tmpM = m;
        tmpBuf = enc.encode(m);
        state.end += tmpBuf.byteLength;
      },
      encode(state, m) {
        raw.encode(state, m === tmpM ? tmpBuf : enc.encode(m));
        tmpM = tmpBuf = null;
      },
      decode(state) {
        return enc.decode(raw.decode(state));
      }
    };
  }
  function fromAbstractEncoder(enc) {
    return {
      preencode(state, m) {
        state.end += enc.encodingLength(m);
      },
      encode(state, m) {
        enc.encode(m, state.buffer, state.start);
        state.start += enc.encode.bytes;
      },
      decode(state) {
        const m = enc.decode(state.buffer, state.start, state.end);
        state.start += enc.decode.bytes;
        return m;
      }
    };
  }
  exports.encode = function encode(enc, m) {
    const state = exports.state();
    enc.preencode(state, m);
    state.buffer = b4a.allocUnsafe(state.end);
    enc.encode(state, m);
    return state.buffer;
  };
  exports.decode = function decode(enc, buffer2) {
    return enc.decode(exports.state(0, buffer2.byteLength, buffer2));
  };
  function zigZagInt(enc) {
    return {
      preencode(state, n) {
        enc.preencode(state, zigZagEncodeInt(n));
      },
      encode(state, n) {
        enc.encode(state, zigZagEncodeInt(n));
      },
      decode(state) {
        return zigZagDecodeInt(enc.decode(state));
      }
    };
  }
  function zigZagDecodeInt(n) {
    return n === 0 ? n : (n & 1) === 0 ? n / 2 : -(n + 1) / 2;
  }
  function zigZagEncodeInt(n) {
    return n < 0 ? 2 * -n - 1 : n === 0 ? 0 : 2 * n;
  }
  function zigZagBigInt(enc) {
    return {
      preencode(state, n) {
        enc.preencode(state, zigZagEncodeBigInt(n));
      },
      encode(state, n) {
        enc.encode(state, zigZagEncodeBigInt(n));
      },
      decode(state) {
        return zigZagDecodeBigInt(enc.decode(state));
      }
    };
  }
  function zigZagDecodeBigInt(n) {
    return n === 0n ? n : (n & 1n) === 0n ? n / 2n : -(n + 1n) / 2n;
  }
  function zigZagEncodeBigInt(n) {
    return n < 0n ? 2n * -n - 1n : n === 0n ? 0n : 2n * n;
  }
  function validateUint(n) {
    if (n >= 0 === false)
      throw new Error("uint must be positive");
  }
});

// node_modules/safety-catch/index.js
var require_safety_catch = __commonJS((exports, module) => {
  module.exports = safetyCatch;
  function isActuallyUncaught(err) {
    if (!err)
      return false;
    return err instanceof TypeError || err instanceof SyntaxError || err instanceof ReferenceError || err instanceof EvalError || err instanceof RangeError || err instanceof URIError || err.code === "ERR_ASSERTION";
  }
  function throwErrorNT(err) {
    queueMicrotask(() => {
      throw err;
    });
  }
  function safetyCatch(err) {
    if (isActuallyUncaught(err)) {
      throwErrorNT(err);
      throw err;
    }
  }
});

// node_modules/z32/index.js
var require_z32 = __commonJS((exports) => {
  var b4a = require_b4a();
  var ALPHABET = "ybndrfg8ejkmcpqxot1uwisza345h769";
  var MIN = 49;
  var MAX = 122;
  var REVERSE = new Int8Array(1 + MAX - MIN);
  REVERSE.fill(-1);
  for (let i = 0;i < ALPHABET.length; i++) {
    const v = ALPHABET.charCodeAt(i) - MIN;
    REVERSE[v] = i;
  }
  exports.encode = encode;
  exports.decode = decode;
  exports.ALPHABET = ALPHABET;
  function decode(s, out) {
    let pb = 0;
    let ps = 0;
    const r = s.length & 7;
    const q = (s.length - r) / 8;
    if (!out)
      out = b4a.allocUnsafe(Math.ceil(s.length * 5 / 8));
    for (let i = 0;i < q; i++) {
      const a2 = quintet(s, ps++);
      const b2 = quintet(s, ps++);
      const c2 = quintet(s, ps++);
      const d2 = quintet(s, ps++);
      const e2 = quintet(s, ps++);
      const f2 = quintet(s, ps++);
      const g2 = quintet(s, ps++);
      const h2 = quintet(s, ps++);
      out[pb++] = a2 << 3 | b2 >>> 2;
      out[pb++] = (b2 & 3) << 6 | c2 << 1 | d2 >>> 4;
      out[pb++] = (d2 & 15) << 4 | e2 >>> 1;
      out[pb++] = (e2 & 1) << 7 | f2 << 2 | g2 >>> 3;
      out[pb++] = (g2 & 7) << 5 | h2;
    }
    if (r === 0)
      return out.subarray(0, pb);
    const a = quintet(s, ps++);
    const b = quintet(s, ps++);
    out[pb++] = a << 3 | b >>> 2;
    if (r <= 2)
      return out.subarray(0, pb);
    const c = quintet(s, ps++);
    const d = quintet(s, ps++);
    out[pb++] = (b & 3) << 6 | c << 1 | d >>> 4;
    if (r <= 4)
      return out.subarray(0, pb);
    const e = quintet(s, ps++);
    out[pb++] = (d & 15) << 4 | e >>> 1;
    if (r <= 5)
      return out.subarray(0, pb);
    const f = quintet(s, ps++);
    const g = quintet(s, ps++);
    out[pb++] = (e & 1) << 7 | f << 2 | g >>> 3;
    if (r <= 7)
      return out.subarray(0, pb);
    const h = quintet(s, ps++);
    out[pb++] = (g & 7) << 5 | h;
    return out.subarray(0, pb);
  }
  function encode(buf) {
    if (typeof buf === "string")
      buf = b4a.from(buf);
    const max = buf.byteLength * 8;
    let s = "";
    for (let p = 0;p < max; p += 5) {
      const i = p >>> 3;
      const j = p & 7;
      if (j <= 3) {
        s += ALPHABET[buf[i] >>> 3 - j & 31];
        continue;
      }
      const of = j - 3;
      const h = buf[i] << of & 31;
      const l = (i >= buf.byteLength ? 0 : buf[i + 1]) >>> 8 - of;
      s += ALPHABET[h | l];
    }
    return s;
  }
  function quintet(s, i) {
    if (i > s.length) {
      return 0;
    }
    const v = s.charCodeAt(i);
    if (v < MIN || v > MAX) {
      throw Error('Invalid character in base32 input: "' + s[i] + '" at position ' + i);
    }
    const bits = REVERSE[v - MIN];
    if (bits === -1) {
      throw Error('Invalid character in base32 input: "' + s[i] + '" at position ' + i);
    }
    return bits;
  }
});

// node_modules/hypercore-id-encoding/index.js
var require_hypercore_id_encoding = __commonJS((exports, module) => {
  var z32 = require_z32();
  var b4a = require_b4a();
  module.exports = {
    encode,
    decode,
    normalize,
    isValid
  };
  function encode(key) {
    if (!b4a.isBuffer(key))
      throw new Error("Key must be a Buffer");
    if (key.byteLength !== 32)
      throw new Error("Key must be 32-bytes long");
    return z32.encode(key);
  }
  function decode(id) {
    if (b4a.isBuffer(id)) {
      if (id.byteLength !== 32)
        throw new Error("ID must be 32-bytes long");
      return id;
    }
    if (typeof id === "string") {
      if (id.startsWith("pear://"))
        id = id.slice(7).split("/")[0];
      if (id.length === 52)
        return z32.decode(id);
      if (id.length === 64) {
        const buf = b4a.from(id, "hex");
        if (buf.byteLength === 32)
          return buf;
      }
    }
    throw new Error("Invalid Hypercore key");
  }
  function normalize(any) {
    return encode(decode(any));
  }
  function isValid(any) {
    try {
      decode(any);
      return true;
    } catch {
      return false;
    }
  }
});

// node_modules/nanoassert/index.js
var require_nanoassert = __commonJS((exports, module) => {
  module.exports = assert;

  class AssertionError extends Error {
  }
  AssertionError.prototype.name = "AssertionError";
  function assert(t, m) {
    if (!t) {
      var err = new AssertionError(m);
      if (Error.captureStackTrace)
        Error.captureStackTrace(err, assert);
      throw err;
    }
  }
});

// node_modules/signal-promise/index.js
var require_signal_promise = __commonJS((exports, module) => {
  module.exports = class Signal {
    constructor() {
      this._resolve = null;
      this._reject = null;
      this._promise = null;
      this._bind = bind.bind(this);
      this._onerror = clear.bind(this);
      this._onsuccess = clear.bind(this, null);
      this._timers = new Set;
    }
    wait(max) {
      if (!this._promise) {
        this._promise = new Promise(this._bind);
        this._promise.then(this._onsuccess).catch(this._onerror);
      }
      if (max)
        return this._sleep(max);
      return this._promise;
    }
    _sleep(max) {
      const s = new Promise((resolve, reject) => {
        const done = () => {
          this._timers.delete(state);
          resolve(true);
        };
        const id = setTimeout(done, max);
        const state = { id, resolve, reject };
        this._timers.add(state);
      });
      return s;
    }
    notify(err) {
      if (!this._promise)
        return;
      const resolve = this._resolve;
      const reject = this._reject;
      this._promise = null;
      if (err)
        reject(err);
      else
        resolve(true);
    }
  };
  function clear(err) {
    for (const { id, resolve, reject } of this._timers) {
      clearTimeout(id);
      if (err)
        reject(err);
      else
        resolve(true);
    }
    this._timers.clear();
  }
  function bind(resolve, reject) {
    this._resolve = resolve;
    this._reject = reject;
  }
});

// node_modules/core-coupler/index.js
var require_core_coupler = __commonJS((exports, module) => {
  var safetyCatch = require_safety_catch();
  module.exports = class CoreCoupler {
    constructor(target, wakeup) {
      this.target = target;
      this.wakeup = wakeup;
      this.coupled = new Set;
      this._onpeeraddBound = this._onpeeradd.bind(this);
      this.target.on("peer-add", this._onpeeraddBound);
    }
    add(core) {
      const added = this.coupled.size;
      this.coupled.add(core);
      if (added !== this.coupled.size)
        this._couple(core);
    }
    remove(core) {
      this.coupled.delete(core);
    }
    destroy() {
      this.target.off("peer-add", this._onpeeraddBound);
    }
    async update(stream) {
      const muxer = stream.userData;
      if (!muxer)
        return;
      try {
        if (!await this._hasMuxer(this.target, muxer))
          return;
        let wakeup = null;
        for (const core of this.coupled) {
          if (await this._hasMuxer(core, muxer))
            continue;
          if (wakeup === null)
            wakeup = [];
          wakeup.push(core);
        }
        if (wakeup !== null) {
          this.wakeup(stream, wakeup);
        }
      } catch (err) {
        safetyCatch(err);
      }
    }
    async _couple(core) {
      try {
        let wakeup = null;
        for (const peer of this.target.peers) {
          if (await this._hasPeer(core, peer))
            continue;
          if (wakeup === null)
            wakeup = [];
          wakeup.push(peer);
        }
        if (wakeup !== null && this.coupled.has(core)) {
          for (const peer of wakeup)
            this.wakeup(peer.stream, [core]);
        }
      } catch (err) {
        safetyCatch(err);
      }
    }
    async _onpeeradd(peer) {
      try {
        let wakeup = null;
        for (const core of this.coupled) {
          if (await this._hasPeer(core, peer))
            continue;
          if (wakeup === null)
            wakeup = [];
          wakeup.push(core);
        }
        if (wakeup !== null) {
          this.wakeup(peer.stream, wakeup);
        }
      } catch (err) {
        safetyCatch(err);
      }
    }
    _hasMuxer(core, muxer) {
      const ch = muxer.getLastChannel({ protocol: "hypercore", id: core.discoveryKey });
      if (ch)
        return ch.fullyOpened();
      const cha = muxer.getLastChannel({ protocol: "hypercore/alpha", id: core.discoveryKey });
      if (cha)
        return cha.fullyOpened();
      return Promise.resolve(false);
    }
    _hasPeer(core, peer) {
      return this._hasMuxer(core, peer.protomux);
    }
  };
});

// node_modules/queue-tick/queue-microtask.js
var require_queue_microtask = __commonJS((exports, module) => {
  module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
});

// node_modules/queue-tick/process-next-tick.js
var require_process_next_tick = __commonJS((exports, module) => {
  module.exports = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : require_queue_microtask();
});

// node_modules/mutexify/index.js
var require_mutexify = __commonJS((exports, module) => {
  var queueTick = require_process_next_tick();
  var mutexify = function() {
    var queue = [];
    var used = null;
    var call = function() {
      used(release);
    };
    var acquire = function(fn) {
      if (used)
        return queue.push(fn);
      used = fn;
      acquire.locked = true;
      queueTick(call);
      return 0;
    };
    acquire.locked = false;
    var release = function(fn, err, value) {
      used = null;
      acquire.locked = false;
      if (queue.length)
        acquire(queue.shift());
      if (fn)
        fn(err, value);
    };
    return acquire;
  };
  module.exports = mutexify;
});

// node_modules/mutexify/promise.js
var require_promise = __commonJS((exports, module) => {
  var mutexify = require_mutexify();
  var mutexifyPromise = function() {
    var lock = mutexify();
    var acquire = function() {
      return new Promise(lock);
    };
    Object.defineProperty(acquire, "locked", {
      get: function() {
        return lock.locked;
      },
      enumerable: true
    });
    return acquire;
  };
  module.exports = mutexifyPromise;
});

// node_modules/require-addon/lib/runtime.js
var require_runtime = __commonJS((exports, module) => {
  module.exports = typeof Bare !== "undefined" ? "bare" : typeof process !== "undefined" ? "node" : "unknown";
});

// node_modules/require-addon/lib/runtime/bare.js
var require_bare = __commonJS((exports, module) => {
  module.exports = __require.addon.bind(__require);
});

// node_modules/bare-semver/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    EQ: 1,
    LT: 2,
    LTE: 3,
    GT: 4,
    GTE: 5
  };
});

// node_modules/bare-semver/lib/errors.js
var require_errors = __commonJS((exports, module) => {
  module.exports = class SemVerError extends Error {
    constructor(msg, code, fn = SemVerError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "SemVerError";
    }
    static INVALID_VERSION(msg, fn = SemVerError.INVALID_VERSION) {
      return new SemVerError(msg, "INVALID_VERSION", fn);
    }
    static INVALID_RANGE(msg, fn = SemVerError.INVALID_RANGE) {
      return new SemVerError(msg, "INVALID_RANGE", fn);
    }
  };
});

// node_modules/bare-semver/lib/version.js
var require_version = __commonJS((exports, module) => {
  var errors = require_errors();
  var Version = module.exports = exports = class Version2 {
    constructor(major, minor, patch, opts = {}) {
      const {
        prerelease = [],
        build = []
      } = opts;
      this.major = major;
      this.minor = minor;
      this.patch = patch;
      this.prerelease = prerelease;
      this.build = build;
    }
    compare(version) {
      return exports.compare(this, version);
    }
    toString() {
      let result = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        result += "-" + this.prerelease.join(".");
      }
      if (this.build.length) {
        result += "+" + this.build.join(".");
      }
      return result;
    }
  };
  exports.parse = function parse(input, state = { position: 0, partial: false }) {
    let i = state.position;
    let c;
    const unexpected = (expected) => {
      let msg;
      if (i >= input.length) {
        msg = `Unexpected end of input in '${input}'`;
      } else {
        msg = `Unexpected token '${input[i]}' in '${input}' at position ${i}`;
      }
      if (expected)
        msg += `, ${expected}`;
      throw errors.INVALID_VERSION(msg, unexpected);
    };
    const components = [];
    while (components.length < 3) {
      c = input[i];
      if (components.length > 0) {
        if (c === ".")
          c = input[++i];
        else
          unexpected("expected '.'");
      }
      if (c === "0") {
        components.push(0);
        i++;
      } else if (c >= "1" && c <= "9") {
        let j = 0;
        do
          c = input[i + ++j];
        while (c >= "0" && c <= "9");
        components.push(parseInt(input.substring(i, i + j)));
        i += j;
      } else
        unexpected("expected /[0-9]/");
    }
    const prerelease = [];
    if (input[i] === "-") {
      i++;
      while (true) {
        c = input[i];
        let tag = "";
        let j = 0;
        while (c >= "0" && c <= "9")
          c = input[i + ++j];
        let isNumeric = false;
        if (j) {
          tag += input.substring(i, i + j);
          c = input[i += j];
          isNumeric = tag[0] !== "0" || tag.length === 1;
        }
        j = 0;
        while (c >= "0" && c <= "9" || c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-")
          c = input[i + ++j];
        if (j) {
          tag += input.substring(i, i + j);
          c = input[i += j];
        } else if (!isNumeric)
          unexpected("expected /[a-zA-Z-]/");
        prerelease.push(tag);
        if (c === ".")
          c = input[++i];
        else
          break;
      }
    }
    const build = [];
    if (input[i] === "+") {
      i++;
      while (true) {
        c = input[i];
        let tag = "";
        let j = 0;
        while (c >= "0" && c <= "9" || c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-")
          c = input[i + ++j];
        if (j) {
          tag += input.substring(i, i + j);
          c = input[i += j];
        } else
          unexpected("expected /[0-9a-zA-Z-]/");
        build.push(tag);
        if (c === ".")
          c = input[++i];
        else
          break;
      }
    }
    if (i < input.length && state.partial === false)
      unexpected("expected end of input");
    state.position = i;
    return new Version(...components, { prerelease, build });
  };
  var integer = /^[0-9]+$/;
  exports.compare = function compare(a, b) {
    if (a.major > b.major)
      return 1;
    if (a.major < b.major)
      return -1;
    if (a.minor > b.minor)
      return 1;
    if (a.minor < b.minor)
      return -1;
    if (a.patch > b.patch)
      return 1;
    if (a.patch < b.patch)
      return -1;
    if (a.prerelease.length === 0)
      return b.prerelease.length === 0 ? 0 : 1;
    if (b.prerelease.length === 0)
      return -1;
    let i = 0;
    do {
      let x = a.prerelease[i];
      let y = b.prerelease[i];
      if (x === undefined)
        return y === undefined ? 0 : -1;
      if (y === undefined)
        return 1;
      if (x === y)
        continue;
      const xInt = integer.test(x);
      const yInt = integer.test(y);
      if (xInt && yInt) {
        x = +x;
        y = +y;
      } else {
        if (xInt)
          return -1;
        if (yInt)
          return 1;
      }
      return x > y ? 1 : -1;
    } while (++i);
  };
});

// node_modules/bare-semver/lib/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var constants = require_constants();
  var symbols = {
    [constants.EQ]: "=",
    [constants.LT]: "<",
    [constants.LTE]: "<=",
    [constants.GT]: ">",
    [constants.GTE]: ">="
  };
  module.exports = class Comparator {
    constructor(operator, version) {
      this.operator = operator;
      this.version = version;
    }
    test(version) {
      const result = version.compare(this.version);
      switch (this.operator) {
        case constants.LT:
          return result < 0;
        case constants.LTE:
          return result <= 0;
        case constants.GT:
          return result > 0;
        case constants.GTE:
          return result >= 0;
        default:
          return result === 0;
      }
    }
    toString() {
      return symbols[this.operator] + this.version;
    }
  };
});

// node_modules/bare-semver/lib/range.js
var require_range = __commonJS((exports, module) => {
  var constants = require_constants();
  var errors = require_errors();
  var Version = require_version();
  var Comparator = require_comparator();
  var Range = module.exports = exports = class Range2 {
    constructor(comparators = []) {
      this.comparators = comparators;
    }
    test(version) {
      for (const set of this.comparators) {
        let matches = true;
        for (const comparator of set) {
          if (comparator.test(version))
            continue;
          matches = false;
          break;
        }
        if (matches)
          return true;
      }
      return false;
    }
    toString() {
      let result = "";
      let first = true;
      for (const set of this.comparators) {
        if (first)
          first = false;
        else
          result += " || ";
        result += set.join(" ");
      }
      return result;
    }
  };
  exports.parse = function parse(input, state = { position: 0, partial: false }) {
    let i = state.position;
    let c;
    const unexpected = (expected) => {
      let msg;
      if (i >= input.length) {
        msg = `Unexpected end of input in '${input}'`;
      } else {
        msg = `Unexpected token '${input[i]}' in '${input}' at position ${i}`;
      }
      if (expected)
        msg += `, ${expected}`;
      throw errors.INVALID_VERSION(msg, unexpected);
    };
    const comparators = [];
    while (i < input.length) {
      const set = [];
      while (i < input.length) {
        c = input[i];
        let operator = constants.EQ;
        if (c === "<") {
          operator = constants.LT;
          c = input[++i];
          if (c === "=") {
            operator = constants.LTE;
            c = input[++i];
          }
        } else if (c === ">") {
          operator = constants.GT;
          c = input[++i];
          if (c === "=") {
            operator = constants.GTE;
            c = input[++i];
          }
        } else if (c === "=") {
          c = input[++i];
        }
        const state2 = { position: i, partial: true };
        set.push(new Comparator(operator, Version.parse(input, state2)));
        c = input[i = state2.position];
        while (c === " ")
          c = input[++i];
        if (c === "|" && input[i + 1] === "|") {
          c = input[i += 2];
          while (c === " ")
            c = input[++i];
          break;
        }
        if (c && c !== "<" && c !== ">")
          unexpected("expected '||', '<', or '>'");
      }
      if (set.length)
        comparators.push(set);
    }
    if (i < input.length && state.partial === false)
      unexpected("expected end of input");
    state.position = i;
    return new Range(comparators);
  };
});

// node_modules/bare-semver/index.js
var require_bare_semver = __commonJS((exports) => {
  exports.constants = require_constants();
  exports.errors = require_errors();
  var Version = exports.Version = require_version();
  var Range = exports.Range = require_range();
  exports.Comparator = require_comparator();
  exports.satisfies = function satisfies(version, range) {
    if (typeof version === "string")
      version = Version.parse(version);
    if (typeof range === "string")
      range = Range.parse(range);
    return range.test(version);
  };
});

// node_modules/bare-module-resolve/lib/errors.js
var require_errors2 = __commonJS((exports, module) => {
  module.exports = class ModuleResolveError extends Error {
    constructor(msg, code, fn = ModuleResolveError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "ModuleResolveError";
    }
    static INVALID_MODULE_SPECIFIER(msg) {
      return new ModuleResolveError(msg, "INVALID_MODULE_SPECIFIER", ModuleResolveError.INVALID_MODULE_SPECIFIER);
    }
    static INVALID_PACKAGE_TARGET(msg) {
      return new ModuleResolveError(msg, "INVALID_PACKAGE_TARGET", ModuleResolveError.INVALID_PACKAGE_TARGET);
    }
    static PACKAGE_PATH_NOT_EXPORTED(msg) {
      return new ModuleResolveError(msg, "PACKAGE_PATH_NOT_EXPORTED", ModuleResolveError.PACKAGE_PATH_NOT_EXPORTED);
    }
    static PACKAGE_IMPORT_NOT_DEFINED(msg) {
      return new ModuleResolveError(msg, "PACKAGE_IMPORT_NOT_DEFINED", ModuleResolveError.PACKAGE_IMPORT_NOT_DEFINED);
    }
    static UNSUPPORTED_ENGINE(msg) {
      return new ModuleResolveError(msg, "UNSUPPORTED_ENGINE", ModuleResolveError.UNSUPPORTED_ENGINE);
    }
  };
});

// node_modules/bare-module-resolve/index.js
var require_bare_module_resolve = __commonJS((exports, module) => {
  var { satisfies } = require_bare_semver();
  var errors = require_errors2();
  module.exports = exports = function resolve(specifier, parentURL, opts, readPackage) {
    if (typeof opts === "function") {
      readPackage = opts;
      opts = {};
    } else if (typeof readPackage !== "function") {
      readPackage = defaultReadPackage;
    }
    return {
      *[Symbol.iterator]() {
        const generator = exports.module(specifier, parentURL, opts);
        let next = generator.next();
        while (next.done !== true) {
          const value = next.value;
          if (value.package) {
            next = generator.next(readPackage(value.package));
          } else {
            next = generator.next(yield value.resolution);
          }
        }
        return next.value;
      },
      async* [Symbol.asyncIterator]() {
        const generator = exports.module(specifier, parentURL, opts);
        let next = generator.next();
        while (next.done !== true) {
          const value = next.value;
          if (value.package) {
            next = generator.next(await readPackage(value.package));
          } else {
            next = generator.next(yield value.resolution);
          }
        }
        return next.value;
      }
    };
  };
  function defaultReadPackage() {
    return null;
  }
  var UNRESOLVED = 0;
  var YIELDED = 1;
  var RESOLVED = YIELDED | 2;
  exports.constants = {
    UNRESOLVED,
    YIELDED,
    RESOLVED
  };
  exports.module = function* (specifier, parentURL, opts = {}) {
    const { resolutions = null, imports = null } = opts;
    if (exports.startsWithWindowsDriveLetter(specifier)) {
      specifier = "/" + specifier;
    }
    let status;
    if (resolutions) {
      status = yield* exports.preresolved(specifier, resolutions, parentURL, opts);
      if (status)
        return status;
    }
    status = yield* exports.url(specifier, parentURL, opts);
    if (status)
      return status;
    status = yield* exports.packageImports(specifier, parentURL, opts);
    if (status)
      return status;
    if (specifier === "." || specifier === ".." || specifier[0] === "/" || specifier[0] === "\\" || specifier.startsWith("./") || specifier.startsWith(".\\") || specifier.startsWith("../") || specifier.startsWith("..\\")) {
      if (imports) {
        status = yield* exports.packageImportsExports(specifier, imports, parentURL, true, opts);
        if (status)
          return status;
      }
      status = yield* exports.deferred(specifier, opts);
      if (status)
        return status;
      status = yield* exports.file(specifier, parentURL, false, opts);
      if (status === RESOLVED)
        return status;
      return yield* exports.directory(specifier, parentURL, opts);
    }
    return yield* exports.package(specifier, parentURL, opts);
  };
  exports.url = function* (url, parentURL, opts = {}) {
    const { imports = null, deferredProtocol = "deferred:" } = opts;
    let resolution;
    try {
      resolution = new URL(url);
    } catch {
      return UNRESOLVED;
    }
    if (imports) {
      const status = yield* exports.packageImportsExports(resolution.href, imports, parentURL, true, opts);
      if (status)
        return status;
    }
    if (resolution.protocol === deferredProtocol) {
      const specifier = resolution.pathname;
      return yield* exports.module(specifier, parentURL, opts);
    }
    if (resolution.protocol === "node:") {
      const specifier = resolution.pathname;
      if (specifier === "." || specifier === ".." || specifier[0] === "/" || specifier.startsWith("./") || specifier.startsWith("../")) {
        throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${url}' is not a valid package name`);
      }
      return yield* exports.package(specifier, parentURL, opts);
    }
    const resolved = yield { resolution };
    return resolved ? RESOLVED : YIELDED;
  };
  exports.preresolved = function* (specifier, resolutions, parentURL, opts = {}) {
    const imports = resolutions[parentURL.href];
    if (typeof imports === "object" && imports !== null) {
      return yield* exports.packageImportsExports(specifier, imports, parentURL, true, opts);
    }
    return UNRESOLVED;
  };
  exports.deferred = function* (specifier, opts = {}) {
    const { deferredProtocol = "deferred:", defer = [] } = opts;
    if (defer.includes(specifier)) {
      const resolved = yield { resolution: new URL(deferredProtocol + specifier) };
      return resolved ? RESOLVED : YIELDED;
    }
    return UNRESOLVED;
  };
  exports.package = function* (packageSpecifier, parentURL, opts = {}) {
    const { builtins = [] } = opts;
    if (packageSpecifier === "") {
      throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${packageSpecifier}' is not a valid package name`);
    }
    let packageName;
    if (packageSpecifier[0] !== "@") {
      packageName = packageSpecifier.split("/", 1).join();
    } else {
      if (!packageSpecifier.includes("/")) {
        throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${packageSpecifier}' is not a valid package name`);
      }
      packageName = packageSpecifier.split("/", 2).join("/");
    }
    if (packageName[0] === "." || packageName.includes("\\") || packageName.includes("%")) {
      throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${packageSpecifier}' is not a valid package name`);
    }
    let status;
    status = yield* exports.builtinTarget(packageSpecifier, null, builtins, opts);
    if (status)
      return status;
    status = yield* exports.deferred(packageSpecifier, opts);
    if (status)
      return status;
    let packageSubpath = "." + packageSpecifier.substring(packageName.length);
    status = yield* exports.packageSelf(packageName, packageSubpath, parentURL, opts);
    if (status)
      return status;
    parentURL = new URL(parentURL.href);
    do {
      const packageURL = new URL("node_modules/" + packageName + "/", parentURL);
      parentURL.pathname = parentURL.pathname.substring(0, parentURL.pathname.lastIndexOf("/"));
      const info = yield { package: new URL("package.json", packageURL) };
      if (info) {
        if (info.engines)
          exports.validateEngines(packageURL, info.engines, opts);
        if (info.exports) {
          return yield* exports.packageExports(packageURL, packageSubpath, info.exports, opts);
        }
        if (packageSubpath === ".") {
          if (typeof info.main === "string" && info.main !== "") {
            packageSubpath = info.main;
          } else {
            return yield* exports.file("index", packageURL, true, opts);
          }
        }
        status = yield* exports.file(packageSubpath, packageURL, false, opts);
        if (status === RESOLVED)
          return status;
        return yield* exports.directory(packageSubpath, packageURL, opts);
      }
    } while (parentURL.pathname !== "" && parentURL.pathname !== "/");
    return UNRESOLVED;
  };
  exports.packageSelf = function* (packageName, packageSubpath, parentURL, opts = {}) {
    for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {
      const info = yield { package: packageURL };
      if (info) {
        if (info.name !== packageName)
          return false;
        if (info.exports) {
          return yield* exports.packageExports(packageURL, packageSubpath, info.exports, opts);
        }
        if (packageSubpath === ".") {
          if (typeof info.main === "string" && info.main !== "") {
            packageSubpath = info.main;
          } else {
            return yield* exports.file("index", packageURL, true, opts);
          }
        }
        const status = yield* exports.file(packageSubpath, packageURL, false, opts);
        if (status === RESOLVED)
          return status;
        return yield* exports.directory(packageSubpath, packageURL, opts);
      }
    }
    return UNRESOLVED;
  };
  exports.packageExports = function* (packageURL, subpath, packageExports, opts = {}) {
    if (subpath === ".") {
      let mainExport;
      if (typeof packageExports === "string" || Array.isArray(packageExports)) {
        mainExport = packageExports;
      } else if (typeof packageExports === "object" && packageExports !== null) {
        const keys = Object.keys(packageExports);
        if (keys.some((key) => key.startsWith("."))) {
          if ("." in packageExports)
            mainExport = packageExports["."];
        } else {
          mainExport = packageExports;
        }
      }
      if (mainExport) {
        const status = yield* exports.packageTarget(packageURL, mainExport, null, false, opts);
        if (status)
          return status;
      }
    } else if (typeof packageExports === "object" && packageExports !== null) {
      const keys = Object.keys(packageExports);
      if (keys.every((key) => key.startsWith("."))) {
        const status = yield* exports.packageImportsExports(subpath, packageExports, packageURL, false, opts);
        if (status)
          return status;
      }
    }
    packageURL = new URL("package.json", packageURL);
    throw errors.PACKAGE_PATH_NOT_EXPORTED(`Package subpath '${subpath}' is not defined by "exports" in '${packageURL}'`);
  };
  exports.packageImports = function* (specifier, parentURL, opts = {}) {
    const { imports = null } = opts;
    if (specifier === "#" || specifier.startsWith("#/")) {
      throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${specifier}' is not a valid internal imports specifier`);
    }
    for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {
      const info = yield { package: packageURL };
      if (info) {
        if (info.imports) {
          const status = yield* exports.packageImportsExports(specifier, info.imports, packageURL, true, opts);
          if (status)
            return status;
        }
        if (specifier.startsWith("#")) {
          throw errors.PACKAGE_IMPORT_NOT_DEFINED(`Package import specifier '${specifier}' is not defined by "imports" in '${packageURL}'`);
        }
        break;
      }
    }
    if (imports) {
      const status = yield* exports.packageImportsExports(specifier, imports, parentURL, true, opts);
      if (status)
        return status;
    }
    return UNRESOLVED;
  };
  exports.packageImportsExports = function* (matchKey, matchObject, packageURL, isImports, opts = {}) {
    if (matchKey in matchObject && !matchKey.includes("*")) {
      const target = matchObject[matchKey];
      return yield* exports.packageTarget(packageURL, target, null, isImports, opts);
    }
    const expansionKeys = Object.keys(matchObject).filter((key) => key.includes("*")).sort(exports.patternKeyCompare);
    for (const expansionKey of expansionKeys) {
      const patternIndex = expansionKey.indexOf("*");
      const patternBase = expansionKey.substring(0, patternIndex);
      if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {
        const patternTrailer = expansionKey.substring(patternIndex + 1);
        if (patternTrailer === "" || matchKey.endsWith(patternTrailer) && matchKey.length >= expansionKey.length) {
          const target = matchObject[expansionKey];
          const patternMatch = matchKey.substring(patternBase.length, matchKey.length - patternTrailer.length);
          return yield* exports.packageTarget(packageURL, target, patternMatch, isImports, opts);
        }
      }
    }
    return UNRESOLVED;
  };
  exports.validateEngines = function validateEngines(packageURL, packageEngines, opts = {}) {
    const { engines = {} } = opts;
    for (const [engine, range] of Object.entries(packageEngines)) {
      if (engine in engines) {
        const version = engines[engine];
        if (!satisfies(version, range)) {
          packageURL = new URL("package.json", packageURL);
          throw errors.UNSUPPORTED_ENGINE(`Package not compatible with engine '${engine}' ${version}, requires range '${range}' defined by "engines" in '${packageURL}'`);
        }
      }
    }
  };
  exports.patternKeyCompare = function patternKeyCompare(keyA, keyB) {
    const patternIndexA = keyA.indexOf("*");
    const patternIndexB = keyB.indexOf("*");
    const baseLengthA = patternIndexA === -1 ? keyA.length : patternIndexA + 1;
    const baseLengthB = patternIndexB === -1 ? keyB.length : patternIndexB + 1;
    if (baseLengthA > baseLengthB)
      return -1;
    if (baseLengthB > baseLengthA)
      return 1;
    if (patternIndexA === -1)
      return 1;
    if (patternIndexB === -1)
      return -1;
    if (keyA.length > keyB.length)
      return -1;
    if (keyB.length > keyA.length)
      return 1;
    return 0;
  };
  exports.packageTarget = function* (packageURL, target, patternMatch, isImports, opts = {}) {
    const { conditions = [], matchedConditions = [] } = opts;
    if (typeof target === "string") {
      if (!target.startsWith("./") && !isImports) {
        packageURL = new URL("package.json", packageURL);
        throw errors.INVALID_PACKAGE_TARGET(`Invalid target '${target}' defined by "exports" in '${packageURL}'`);
      }
      if (patternMatch !== null) {
        target = target.replaceAll("*", patternMatch);
      }
      const status = yield* exports.url(target, packageURL, opts);
      if (status)
        return status;
      if (target === "." || target === ".." || target[0] === "/" || target.startsWith("./") || target.startsWith("../")) {
        const resolved = yield { resolution: new URL(target, packageURL) };
        return resolved ? RESOLVED : YIELDED;
      }
      return yield* exports.package(target, packageURL, opts);
    }
    if (Array.isArray(target)) {
      for (const targetValue of target) {
        const status = yield* exports.packageTarget(packageURL, targetValue, patternMatch, isImports, opts);
        if (status)
          return status;
      }
    } else if (typeof target === "object" && target !== null) {
      let status = UNRESOLVED;
      for (const [condition, targetValue, subset] of exports.conditionMatches(target, conditions, opts)) {
        matchedConditions.push(condition);
        status |= yield* exports.packageTarget(packageURL, targetValue, patternMatch, isImports, { ...opts, conditions: subset });
        matchedConditions.pop();
      }
      if (status)
        return status;
    }
    return UNRESOLVED;
  };
  exports.builtinTarget = function* (packageSpecifier, packageVersion, target, opts = {}) {
    const {
      builtinProtocol = "builtin:",
      conditions = [],
      matchedConditions = []
    } = opts;
    if (typeof target === "string") {
      const targetParts = target.split("@");
      let targetName;
      let targetVersion;
      if (target[0] !== "@") {
        targetName = targetParts[0];
        targetVersion = targetParts[1] || null;
      } else {
        targetName = targetParts.slice(0, 2).join("@");
        targetVersion = targetParts[2] || null;
      }
      if (packageSpecifier === targetName) {
        if (packageVersion === null && targetVersion === null) {
          const resolved = yield {
            resolution: new URL(builtinProtocol + packageSpecifier)
          };
          return resolved ? RESOLVED : YIELDED;
        }
        let version = null;
        if (packageVersion === null) {
          version = targetVersion;
        } else if (targetVersion === null || packageVersion === targetVersion) {
          version = packageVersion;
        }
        if (version !== null) {
          const resolved = yield {
            resolution: new URL(builtinProtocol + packageSpecifier + "@" + version)
          };
          return resolved ? RESOLVED : YIELDED;
        }
      }
    } else if (Array.isArray(target)) {
      for (const targetValue of target) {
        const status = yield* exports.builtinTarget(packageSpecifier, packageVersion, targetValue, opts);
        if (status)
          return status;
      }
    } else if (typeof target === "object" && target !== null) {
      let status = UNRESOLVED;
      for (const [condition, targetValue, subset] of exports.conditionMatches(target, conditions, opts)) {
        matchedConditions.push(condition);
        status |= yield* exports.builtinTarget(packageSpecifier, packageVersion, targetValue, { ...opts, conditions: subset });
        matchedConditions.pop();
      }
      if (status)
        return status;
    }
    return UNRESOLVED;
  };
  exports.conditionMatches = function* conditionMatches(target, conditions, opts = {}) {
    if (conditions.every((condition) => typeof condition === "string")) {
      const keys = Object.keys(target);
      for (const condition of keys) {
        if (condition === "default" || conditions.includes(condition)) {
          yield [condition, target[condition], conditions];
          return true;
        }
      }
      return false;
    }
    let yielded = false;
    for (const subset of conditions) {
      if (yield* conditionMatches(target, subset, opts)) {
        yielded = true;
      }
    }
    return yielded;
  };
  exports.lookupPackageScope = function* lookupPackageScope(url, opts = {}) {
    const { resolutions = null } = opts;
    if (resolutions) {
      for (const { resolution } of exports.preresolved("#package", resolutions, url, opts)) {
        if (resolution)
          return yield resolution;
      }
      for (const { resolution } of exports.preresolved("bare:package", resolutions, url, opts)) {
        if (resolution)
          return yield resolution;
      }
    }
    const scopeURL = new URL(url.href);
    do {
      if (scopeURL.pathname.endsWith("/node_modules"))
        break;
      yield new URL("package.json", scopeURL);
      scopeURL.pathname = scopeURL.pathname.substring(0, scopeURL.pathname.lastIndexOf("/"));
      if (scopeURL.pathname.length === 3 && exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))) {
        break;
      }
    } while (scopeURL.pathname !== "" && scopeURL.pathname !== "/");
  };
  exports.file = function* (filename, parentURL, isIndex, opts = {}) {
    if (filename === "." || filename === ".." || filename[filename.length - 1] === "/" || filename[filename.length - 1] === "\\") {
      return UNRESOLVED;
    }
    if (parentURL.protocol === "file:" && /%2f|%5c/i.test(filename)) {
      throw errors.INVALID_MODULE_SPECIFIER(`Module specifier '${filename}' is invalid`);
    }
    const { extensions = [] } = opts;
    let status = UNRESOLVED;
    if (!isIndex) {
      if (yield { resolution: new URL(filename, parentURL) }) {
        return RESOLVED;
      }
      status = YIELDED;
    }
    for (const ext of extensions) {
      if (yield { resolution: new URL(filename + ext, parentURL) }) {
        return RESOLVED;
      }
      status = YIELDED;
    }
    return status;
  };
  exports.directory = function* (dirname, parentURL, opts = {}) {
    let directoryURL;
    if (dirname[dirname.length - 1] === "/" || dirname[dirname.length - 1] === "\\") {
      directoryURL = new URL(dirname, parentURL);
    } else {
      directoryURL = new URL(dirname + "/", parentURL);
    }
    const info = yield { package: new URL("package.json", directoryURL) };
    if (info) {
      if (info.exports) {
        return yield* exports.packageExports(directoryURL, ".", info.exports, opts);
      }
      if (typeof info.main === "string" && info.main !== "") {
        const status = yield* exports.file(info.main, directoryURL, false, opts);
        if (status === RESOLVED)
          return status;
        return yield* exports.directory(info.main, directoryURL, opts);
      }
    }
    return yield* exports.file("index", directoryURL, true, opts);
  };
  function isASCIIUpperAlpha(c) {
    return c >= 65 && c <= 90;
  }
  function isASCIILowerAlpha(c) {
    return c >= 97 && c <= 122;
  }
  function isASCIIAlpha(c) {
    return isASCIIUpperAlpha(c) || isASCIILowerAlpha(c);
  }
  exports.isWindowsDriveLetter = function isWindowsDriveLetter(input) {
    return input.length >= 2 && isASCIIAlpha(input.charCodeAt(0)) && (input.charCodeAt(1) === 58 || input.charCodeAt(1) === 124);
  };
  exports.startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(input) {
    return input.length >= 2 && exports.isWindowsDriveLetter(input) && (input.length === 2 || input.charCodeAt(2) === 47 || input.charCodeAt(2) === 92 || input.charCodeAt(2) === 63 || input.charCodeAt(2) === 35);
  };
});

// node_modules/bare-addon-resolve/lib/errors.js
var require_errors3 = __commonJS((exports, module) => {
  module.exports = class AddonResolveError extends Error {
    constructor(msg, code, fn = AddonResolveError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "AddonResolveError";
    }
    static INVALID_ADDON_SPECIFIER(msg) {
      return new AddonResolveError(msg, "INVALID_ADDON_SPECIFIER", AddonResolveError.INVALID_ADDON_SPECIFIER);
    }
    static INVALID_PACKAGE_NAME(msg) {
      return new AddonResolveError(msg, "INVALID_PACKAGE_NAME", AddonResolveError.INVALID_PACKAGE_NAME);
    }
  };
});

// node_modules/bare-addon-resolve/index.js
var require_bare_addon_resolve = __commonJS((exports, module) => {
  var resolve = require_bare_module_resolve();
  var { Version } = require_bare_semver();
  var errors = require_errors3();
  module.exports = exports = function resolve(specifier, parentURL, opts, readPackage) {
    if (typeof opts === "function") {
      readPackage = opts;
      opts = {};
    } else if (typeof readPackage !== "function") {
      readPackage = defaultReadPackage;
    }
    return {
      *[Symbol.iterator]() {
        const generator = exports.addon(specifier, parentURL, opts);
        let next = generator.next();
        while (next.done !== true) {
          const value = next.value;
          if (value.package) {
            next = generator.next(readPackage(value.package));
          } else {
            next = generator.next(yield value.resolution);
          }
        }
        return next.value;
      },
      async* [Symbol.asyncIterator]() {
        const generator = exports.addon(specifier, parentURL, opts);
        let next = generator.next();
        while (next.done !== true) {
          const value = next.value;
          if (value.package) {
            next = generator.next(await readPackage(value.package));
          } else {
            next = generator.next(yield value.resolution);
          }
        }
        return next.value;
      }
    };
  };
  function defaultReadPackage() {
    return null;
  }
  var { UNRESOLVED, YIELDED, RESOLVED } = resolve.constants;
  exports.constants = {
    UNRESOLVED,
    YIELDED,
    RESOLVED
  };
  exports.addon = function* (specifier, parentURL, opts = {}) {
    const { resolutions = null } = opts;
    if (exports.startsWithWindowsDriveLetter(specifier)) {
      specifier = "/" + specifier;
    }
    let status;
    if (resolutions) {
      status = yield* resolve.preresolved(specifier, resolutions, parentURL, opts);
      if (status)
        return status;
    }
    status = yield* exports.url(specifier, parentURL, opts);
    if (status)
      return status;
    let version = null;
    const i = specifier.lastIndexOf("@");
    if (i > 0) {
      version = specifier.substring(i + 1);
      try {
        Version.parse(version);
        specifier = specifier.substring(0, i);
      } catch {
        version = null;
      }
    }
    if (specifier === "." || specifier === ".." || specifier[0] === "/" || specifier[0] === "\\" || specifier.startsWith("./") || specifier.startsWith(".\\") || specifier.startsWith("../") || specifier.startsWith("..\\")) {
      return yield* exports.directory(specifier, version, parentURL, opts);
    }
    return yield* exports.package(specifier, version, parentURL, opts);
  };
  exports.url = function* (url, parentURL, opts = {}) {
    let resolution;
    try {
      resolution = new URL(url);
    } catch {
      return UNRESOLVED;
    }
    const resolved = yield { resolution };
    return resolved ? RESOLVED : YIELDED;
  };
  exports.package = function* (packageSpecifier, packageVersion, parentURL, opts = {}) {
    if (packageSpecifier === "") {
      throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${packageSpecifier}' is not a valid package name`);
    }
    let packageName;
    if (packageSpecifier[0] !== "@") {
      packageName = packageSpecifier.split("/", 1).join();
    } else {
      if (!packageSpecifier.includes("/")) {
        throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${packageSpecifier}' is not a valid package name`);
      }
      packageName = packageSpecifier.split("/", 2).join("/");
    }
    if (packageName[0] === "." || packageName.includes("\\") || packageName.includes("%")) {
      throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${packageSpecifier}' is not a valid package name`);
    }
    const packageSubpath = "." + packageSpecifier.substring(packageName.length);
    const status = yield* exports.packageSelf(packageName, packageSubpath, packageVersion, parentURL, opts);
    if (status)
      return status;
    parentURL = new URL(parentURL.href);
    do {
      const packageURL = new URL("node_modules/" + packageName + "/", parentURL);
      parentURL.pathname = parentURL.pathname.substring(0, parentURL.pathname.lastIndexOf("/"));
      const info = yield { package: new URL("package.json", packageURL) };
      if (info) {
        return yield* exports.directory(packageSubpath, packageVersion, packageURL, opts);
      }
    } while (parentURL.pathname !== "" && parentURL.pathname !== "/");
    return UNRESOLVED;
  };
  exports.packageSelf = function* (packageName, packageSubpath, packageVersion, parentURL, opts = {}) {
    for (const packageURL of resolve.lookupPackageScope(parentURL, opts)) {
      const info = yield { package: packageURL };
      if (info) {
        if (info.name === packageName) {
          return yield* exports.directory(packageSubpath, packageVersion, packageURL, opts);
        }
        break;
      }
    }
    return UNRESOLVED;
  };
  exports.lookupPrebuildsScope = function* lookupPrebuildsScope(url, opts = {}) {
    const { resolutions = null } = opts;
    if (resolutions) {
      for (const { resolution } of resolve.preresolved("#prebuilds", resolutions, url, opts)) {
        if (resolution)
          return yield resolution;
      }
    }
    const scopeURL = new URL(url.href);
    do {
      yield new URL("prebuilds/", scopeURL);
      scopeURL.pathname = scopeURL.pathname.substring(0, scopeURL.pathname.lastIndexOf("/"));
      if (scopeURL.pathname.length === 3 && exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))) {
        break;
      }
    } while (scopeURL.pathname !== "" && scopeURL.pathname !== "/");
  };
  exports.file = function* (filename, parentURL, opts = {}) {
    if (parentURL.protocol === "file:" && /%2f|%5c/i.test(filename)) {
      throw errors.INVALID_ADDON_SPECIFIER(`Addon specifier '${filename}' is invalid`);
    }
    const { extensions = [] } = opts;
    let status = UNRESOLVED;
    for (const ext of extensions) {
      if (yield { resolution: new URL(filename + ext, parentURL) }) {
        return RESOLVED;
      }
      status = YIELDED;
    }
    return status;
  };
  exports.directory = function* (dirname, version, parentURL, opts = {}) {
    const {
      resolutions = null,
      host = null,
      hosts = host !== null ? [host] : [],
      builtins = [],
      matchedConditions = []
    } = opts;
    let directoryURL;
    if (dirname[dirname.length - 1] === "/" || dirname[dirname.length - 1] === "\\") {
      directoryURL = new URL(dirname, parentURL);
    } else {
      directoryURL = new URL(dirname + "/", parentURL);
    }
    if (resolutions) {
      const status2 = yield* resolve.preresolved("bare:addon", resolutions, directoryURL, opts);
      if (status2)
        return status2;
    }
    const unversioned = version === null;
    let name = null;
    const info = yield { package: new URL("package.json", directoryURL) };
    if (info) {
      if (typeof info.name === "string" && info.name !== "") {
        if (info.name.includes("__")) {
          throw errors.INVALID_PACKAGE_NAME(`Package name '${info.name}' is invalid`);
        }
        name = info.name.replace(/\//g, "__").replace(/^@/, "");
      } else {
        return UNRESOLVED;
      }
      if (typeof info.version === "string" && info.version !== "") {
        if (version !== null && info.version !== version)
          return UNRESOLVED;
        version = info.version;
      }
    } else {
      return UNRESOLVED;
    }
    let status;
    status = yield* resolve.builtinTarget(name, version, builtins, opts);
    if (status)
      return status;
    for (const prebuildsURL of exports.lookupPrebuildsScope(directoryURL, opts)) {
      status = UNRESOLVED;
      for (const host2 of hosts) {
        const conditions = host2.split("-");
        matchedConditions.push(...conditions);
        if (version !== null) {
          status |= yield* exports.file(host2 + "/" + name + "@" + version, prebuildsURL, opts);
        }
        if (unversioned) {
          status |= yield* exports.file(host2 + "/" + name, prebuildsURL, opts);
        }
        for (const _ of conditions)
          matchedConditions.pop();
      }
      if (status === RESOLVED)
        return status;
    }
    return yield* exports.linked(name, version, opts);
  };
  exports.linked = function* (name, version = null, opts = {}) {
    const {
      linked = true,
      host = null,
      hosts = host !== null ? [host] : [],
      matchedConditions = []
    } = opts;
    if (linked === false || hosts.length === 0)
      return UNRESOLVED;
    let status = UNRESOLVED;
    for (const host2 of hosts) {
      const [platform = null] = host2.split("-", 1);
      if (platform === null)
        continue;
      matchedConditions.push(platform);
      status |= yield* platformArtefact(name, version, platform, opts);
      matchedConditions.pop();
    }
    return status;
  };
  function* platformArtefact(name, version = null, platform, opts = {}) {
    const { linkedProtocol = "linked:" } = opts;
    if (platform === "darwin" || platform === "ios") {
      if (version !== null) {
        if (yield {
          resolution: new URL(`${linkedProtocol}${name}.${version}.framework/${name}.${version}`)
        }) {
          return RESOLVED;
        }
        if (platform === "darwin") {
          if (yield {
            resolution: new URL(`${linkedProtocol}lib${name}.${version}.dylib`)
          }) {
            return RESOLVED;
          }
        }
      }
      if (yield {
        resolution: new URL(`${linkedProtocol}${name}.framework/${name}`)
      }) {
        return RESOLVED;
      }
      if (platform === "darwin") {
        if (yield {
          resolution: new URL(`${linkedProtocol}lib${name}.dylib`)
        }) {
          return RESOLVED;
        }
      }
      return YIELDED;
    }
    if (platform === "linux" || platform === "android") {
      if (version !== null) {
        if (yield {
          resolution: new URL(`${linkedProtocol}lib${name}.${version}.so`)
        }) {
          return RESOLVED;
        }
      }
      if (yield {
        resolution: new URL(`${linkedProtocol}lib${name}.so`)
      }) {
        return RESOLVED;
      }
      return YIELDED;
    }
    if (platform === "win32") {
      if (version !== null) {
        if (yield {
          resolution: new URL(`${linkedProtocol}${name}-${version}.dll`)
        }) {
          return RESOLVED;
        }
      }
      if (yield {
        resolution: new URL(`${linkedProtocol}${name}.dll`)
      }) {
        return RESOLVED;
      }
    }
    return UNRESOLVED;
  }
  exports.isWindowsDriveLetter = resolve.isWindowsDriveLetter;
  exports.startsWithWindowsDriveLetter = resolve.startsWithWindowsDriveLetter;
});

// node_modules/require-addon/lib/runtime/node.js
var require_node = __commonJS((exports, module) => {
  if (typeof __require.addon === "function") {
    module.exports = __require.addon.bind(__require);
  } else {
    const url = __require("url");
    const resolve = require_bare_addon_resolve();
    const host = process.platform + "-" + process.arch;
    const conditions = ["node", process.platform, process.arch];
    const extensions = [".node"];
    module.exports = function addon(specifier, parentURL) {
      if (typeof parentURL === "string")
        parentURL = url.pathToFileURL(parentURL);
      for (const resolution of resolve(specifier, parentURL, { host, conditions, extensions }, readPackage)) {
        switch (resolution.protocol) {
          case "file:":
            try {
              return __require(url.fileURLToPath(resolution));
            } catch {
              continue;
            }
        }
      }
      throw new Error(`Cannot find addon '${specifier}' imported from '${parentURL.href}'`);
      function readPackage(packageURL) {
        try {
          return __require(url.fileURLToPath(packageURL));
        } catch (err) {
          return null;
        }
      }
    };
  }
});

// node_modules/require-addon/lib/runtime/default.js
var require_default = __commonJS((exports, module) => {
  if (typeof __require.addon === "function") {
    module.exports = __require.addon.bind(__require);
  } else {
    module.exports = function addon(specifier, parentURL) {
      throw new Error(`Cannot find addon '${specifier}' imported from '${parentURL}'`);
    };
  }
});

// node_modules/require-addon/index.js
var require_require_addon = __commonJS((exports, module) => {
  var runtime = require_runtime();
  if (runtime === "bare") {
    module.exports = require_bare();
  } else if (runtime === "node") {
    module.exports = require_node();
  } else {
    module.exports = require_default();
  }
});

// node_modules/sodium-native/binding.js
var require_binding = __commonJS((exports, module) => {
  var __filename = "/Users/odinsson/Dev/pear/easybase/node_modules/sodium-native/binding.js";
  __require.addon = require_require_addon();
  module.exports = __require.addon(".", __filename);
});

// node_modules/which-runtime/index.js
var require_which_runtime = __commonJS((exports) => {
  var { runtime, platform, arch } = typeof Bare !== "undefined" ? { runtime: "bare", platform: global.Bare.platform, arch: global.Bare.arch } : typeof process !== "undefined" ? { runtime: "node", platform: global.process.platform, arch: global.process.arch } : typeof Window !== "undefined" ? { runtime: "browser", platform: "unknown", arch: "unknown" } : { runtime: "unknown", platform: "unknown", arch: "unknown" };
  exports.runtime = runtime;
  exports.platform = platform;
  exports.arch = arch;
  exports.isBare = runtime === "bare";
  exports.isBareKit = exports.isBare && typeof BareKit !== "undefined";
  exports.isPear = exports.isBare && typeof Pear !== "undefined";
  exports.isNode = runtime === "node";
  exports.isBrowser = runtime === "browser";
  exports.isWindows = platform === "win32";
  exports.isLinux = platform === "linux";
  exports.isMac = platform === "darwin";
  exports.isIOS = platform === "ios" || platform === "ios-simulator";
  exports.isAndroid = platform === "android";
  exports.isElectron = typeof process !== "undefined" && !!global.process.versions.electron;
  exports.isElectronRenderer = exports.isElectron && global.process.type === "renderer";
  exports.isElectronWorker = exports.isElectron && global.process.type === "worker";
});

// node_modules/sodium-native/index.js
var require_sodium_native = __commonJS((exports, module) => {
  var binding = require_binding();
  var { isNode } = require_which_runtime();
  var OPTIONAL = Buffer.from(new ArrayBuffer(0));
  module.exports = exports = { ...binding };
  exports.sodium_memzero = function(buf) {
    binding.sodium_memzero(buf);
  };
  exports.sodium_mlock = function(buf) {
    const res = binding.sodium_mlock(buf);
    if (res !== 0)
      throw new Error("memory lock failed");
  };
  exports.sodium_munlock = function(buf) {
    const res = binding.sodium_munlock(buf);
    if (res !== 0)
      throw new Error("memory unlock failed");
  };
  exports.sodium_malloc = function(size) {
    if (size < 0)
      throw new Error("invalid size");
    const buf = Buffer.from(binding.sodium_malloc(size));
    buf.secure = true;
    return buf;
  };
  exports.sodium_free = function(buf) {
    if (!buf?.secure)
      return;
    binding.sodium_free(buf.buffer);
  };
  exports.sodium_mprotect_noaccess = function(buf) {
    const res = binding.sodium_mprotect_noaccess(buf.buffer);
    if (res !== 0)
      throw new Error("failed to lock buffer");
  };
  exports.sodium_mprotect_readonly = function(buf) {
    const res = binding.sodium_mprotect_readonly(buf.buffer);
    if (res !== 0)
      throw new Error("failed to unlock buffer");
  };
  exports.sodium_mprotect_readwrite = function(buf) {
    const res = binding.sodium_mprotect_readwrite(buf.buffer);
    if (res !== 0)
      throw new Error("failed to unlock buffer");
  };
  exports.randombytes_buf = function(buffer) {
    binding.randombytes_buf(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  };
  exports.randombytes_buf_deterministic = function(buffer, seed) {
    binding.randombytes_buf_deterministic(buffer.buffer, buffer.byteOffset, buffer.byteLength, seed.buffer, seed.byteOffset, seed.byteLength);
  };
  exports.sodium_memcmp = function(a, b) {
    if (a?.byteLength !== b?.byteLength)
      throw new Error('buffers must be of same length"');
    return binding.sodium_memcmp(a, b);
  };
  exports.sodium_add = function(a, b) {
    if (a?.byteLength !== b?.byteLength)
      throw new Error('buffers must be of same length"');
    binding.sodium_add(a, b);
  };
  exports.sodium_sub = function(a, b) {
    if (a?.byteLength !== b?.byteLength)
      throw new Error('buffers must be of same length"');
    binding.sodium_sub(a, b);
  };
  exports.sodium_compare = function(a, b) {
    if (a?.byteLength !== b?.byteLength)
      throw new Error('buffers must be of same length"');
    return binding.sodium_compare(a, b);
  };
  exports.sodium_is_zero = function(buffer, length) {
    if (!buffer)
      throw new Error("invalid buffer");
    length ??= buffer.byteLength;
    if (length > buffer.byteLength || length < 0)
      throw new Error("invalid length");
    return binding.sodium_is_zero(buffer, length);
  };
  exports.sodium_pad = function(buffer, unpaddedBuflen, blockSize) {
    if (unpaddedBuflen > buffer.byteLength)
      throw new Error("unpadded length cannot exceed buffer length");
    if (blockSize > buffer.byteLength)
      throw new Error("block size cannot exceed buffer length");
    if (blockSize < 1)
      throw new Error("block sizemust be at least 1 byte");
    if (buffer?.byteLength < unpaddedBuflen + (blockSize - unpaddedBuflen % blockSize))
      throw new Error("buf not long enough");
    return binding.sodium_pad(buffer, unpaddedBuflen, blockSize);
  };
  exports.sodium_unpad = function(buffer, paddedBuflen, blockSize) {
    if (paddedBuflen > buffer.byteLength)
      throw new Error("unpadded length cannot exceed buffer length");
    if (blockSize > buffer.byteLength)
      throw new Error("block size cannot exceed buffer length");
    if (blockSize < 1)
      throw new Error("block size must be at least 1 byte");
    return binding.sodium_unpad(buffer, paddedBuflen, blockSize);
  };
  exports.crypto_sign_keypair = function(pk, sk) {
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    const res = binding.crypto_sign_keypair(pk, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign_seed_keypair = function(pk, sk, seed) {
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    const res = binding.crypto_sign_seed_keypair(pk, sk, seed);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign = function(sm, m, sk) {
    if (sm?.byteLength !== binding.crypto_sign_BYTES + m.byteLength)
      throw new Error('sm must be "m.byteLength + crypto_sign_BYTES" bytes');
    if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)
      throw new Error("sk");
    const res = binding.crypto_sign(sm, m, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign_open = function(m, sm, pk) {
    if (sm?.byteLength < binding.crypto_sign_BYTES)
      throw new Error("sm");
    if (m?.byteLength !== sm.byteLength - binding.crypto_sign_BYTES)
      throw new Error('m must be "sm.byteLength - crypto_sign_BYTES" bytes');
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    const res = binding.crypto_sign_open(m, sm, pk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign_open = function(m, sm, pk) {
    if (sm?.byteLength < binding.crypto_sign_BYTES)
      throw new Error("sm");
    if (m?.byteLength !== sm.byteLength - binding.crypto_sign_BYTES)
      throw new Error('m must be "sm.byteLength - crypto_sign_BYTES" bytes');
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    return binding.crypto_sign_open(m, sm, pk);
  };
  exports.crypto_sign_detached = function(sig, m, sk) {
    if (sig?.byteLength !== binding.crypto_sign_BYTES)
      throw new Error("sig");
    if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)
      throw new Error("sk");
    const res = binding.crypto_sign_detached(sig, m, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign_verify_detached = function(sig, m, pk) {
    return binding.crypto_sign_verify_detached(sig.buffer, sig.byteOffset, sig.byteLength, m.buffer, m.byteOffset, m.byteLength, pk.buffer, pk.byteOffset, pk.byteLength);
  };
  exports.crypto_sign_ed25519_sk_to_pk = function(pk, sk) {
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)
      throw new Error("sk");
    const res = binding.crypto_sign_ed25519_sk_to_pk(pk, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign_ed25519_pk_to_curve25519 = function(x25519pk, ed25519pk) {
    if (x25519pk?.byteLength !== binding.crypto_box_PUBLICKEYBYTES)
      throw new Error("x25519_pk");
    if (ed25519pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("ed25519_pk");
    const res = binding.crypto_sign_ed25519_pk_to_curve25519(x25519pk, ed25519pk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_sign_ed25519_sk_to_curve25519 = function(x25519sk, ed25519sk) {
    if (x25519sk?.byteLength !== binding.crypto_box_SECRETKEYBYTES)
      throw new Error("x25519_sk");
    const edLen = ed25519sk.byteLength;
    if (edLen !== binding.crypto_sign_SECRETKEYBYTES && edLen !== binding.crypto_box_SECRETKEYBYTES) {
      throw new Error("ed25519_sk should either be 'crypto_sign_SECRETKEYBYTES' bytes or 'crypto_sign_SECRETKEYBYTES - crypto_sign_PUBLICKEYBYTES' bytes");
    }
    const res = binding.crypto_sign_ed25519_sk_to_curve25519(x25519sk, ed25519sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_box_keypair = function(pk, sk) {
    if (pk?.byteLength !== binding.crypto_box_PUBLICKEYBYTES)
      throw new Error("pk");
    if (sk?.byteLength !== binding.crypto_box_SECRETKEYBYTES)
      throw new Error("sk");
    const res = binding.crypto_box_keypair(pk, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_box_seed_keypair = function(pk, sk, seed) {
    if (pk?.byteLength !== binding.crypto_box_PUBLICKEYBYTES)
      throw new Error("pk");
    if (sk?.byteLength !== binding.crypto_box_SECRETKEYBYTES)
      throw new Error("sk");
    const res = binding.crypto_box_seed_keypair(pk, sk, seed);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_box_easy = function(c, m, n, pk, sk) {
    const res = binding.crypto_box_easy(c, m, n, pk, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_box_detached = function(c, mac, m, n, pk, sk) {
    const res = binding.crypto_box_detached(c, mac, m, n, pk, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_box_seal = function(c, m, pk) {
    const res = binding.crypto_box_seal(c, m, pk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_box_seal_open = function(m, c, pk, sk) {
    return binding.crypto_box_seal_open(m.buffer, m.byteOffset, m.byteLength, c.buffer, c.byteOffset, c.byteLength, pk.buffer, pk.byteOffset, pk.byteLength, sk.buffer, sk.byteOffset, sk.byteLength);
  };
  exports.crypto_secretbox_easy = function(c, m, n, k) {
    if (c?.byteLength !== m.byteLength + binding.crypto_secretbox_MACBYTES)
      throw new Error('c must be "m.byteLength + crypto_secretbox_MACBYTES" bytes');
    if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_secretbox_easy(c, m, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_secretbox_open_easy = function(m, c, n, k) {
    if (m?.byteLength !== c.byteLength - binding.crypto_secretbox_MACBYTES)
      throw new Error('m must be "c - crypto_secretbox_MACBYTES" bytes');
    if (c?.byteLength < binding.crypto_secretbox_MACBYTES)
      throw new Error("c");
    if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES)
      throw new Error("k");
    return binding.crypto_secretbox_open_easy(m, c, n, k);
  };
  exports.crypto_secretbox_detached = function(c, mac, m, n, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must "m.byteLength" bytes');
    if (mac?.byteLength !== binding.crypto_secretbox_MACBYTES)
      throw new Error("mac");
    if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_secretbox_detached(c, mac, m, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_secretbox_open_detached = function(m, c, mac, n, k) {
    if (m?.byteLength !== c.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (mac?.byteLength !== binding.crypto_secretbox_MACBYTES)
      throw new Error("mac");
    if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES)
      throw new Error("k");
    return binding.crypto_secretbox_open_detached(m, c, mac, n, k);
  };
  exports.crypto_generichash = function(output, input, key = OPTIONAL) {
    const res = binding.crypto_generichash(output.buffer, output.byteOffset, output.byteLength, input.buffer, input.byteOffset, input.byteLength, key.buffer, key.byteOffset, key.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_generichash_batch = function(output, batch, key) {
    if (isNode || batch.length < 4) {
      const res = binding.crypto_generichash_batch(output, batch, !!key, key || OPTIONAL);
      if (res !== 0)
        throw new Error("status: " + res);
    } else {
      const state = Buffer.alloc(binding.crypto_generichash_STATEBYTES);
      exports.crypto_generichash_init(state, key, output.byteLength);
      for (const buf of batch) {
        exports.crypto_generichash_update(state, buf);
      }
      exports.crypto_generichash_final(state, output);
    }
  };
  exports.crypto_generichash_keygen = function(key) {
    const res = binding.crypto_generichash_keygen(key.buffer, key.byteOffset, key.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_generichash_init = function(state, key, outputLength) {
    key ||= OPTIONAL;
    const res = binding.crypto_generichash_init(state.buffer, state.byteOffset, state.byteLength, key.buffer, key.byteOffset, key.byteLength, outputLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_generichash_update = function(state, input) {
    const res = binding.crypto_generichash_update(state.buffer, state.byteOffset, state.byteLength, input.buffer, input.byteOffset, input.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_generichash_final = function(state, output) {
    const res = binding.crypto_generichash_final(state.buffer, state.byteOffset, state.byteLength, output.buffer, output.byteOffset, output.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_secretstream_xchacha20poly1305_keygen = function(k) {
    binding.crypto_secretstream_xchacha20poly1305_keygen(k.buffer, k.byteOffset, k.byteLength);
  };
  exports.crypto_secretstream_xchacha20poly1305_init_push = function(state, header, k) {
    const res = binding.crypto_secretstream_xchacha20poly1305_init_push(state.buffer, state.byteOffset, state.byteLength, header.buffer, header.byteOffset, header.byteLength, k.buffer, k.byteOffset, k.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_secretstream_xchacha20poly1305_init_pull = function(state, header, k) {
    const res = binding.crypto_secretstream_xchacha20poly1305_init_pull(state.buffer, state.byteOffset, state.byteLength, header.buffer, header.byteOffset, header.byteLength, k.buffer, k.byteOffset, k.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_secretstream_xchacha20poly1305_push = function(state, c, m, ad, tag) {
    ad ||= OPTIONAL;
    const res = binding.crypto_secretstream_xchacha20poly1305_push(state.buffer, state.byteOffset, state.byteLength, c.buffer, c.byteOffset, c.byteLength, m.buffer, m.byteOffset, m.byteLength, ad.buffer, ad.byteOffset, ad.byteLength, tag);
    if (res < 0)
      throw new Error("push failed");
    return res;
  };
  exports.crypto_secretstream_xchacha20poly1305_pull = function(state, m, tag, c, ad) {
    ad ||= OPTIONAL;
    if (c?.byteLength < binding.crypto_secretstream_xchacha20poly1305_ABYTES)
      throw new Error("invalid cipher length");
    if (m?.byteLength !== c.byteLength - binding.crypto_secretstream_xchacha20poly1305_ABYTES)
      throw new Error("invalid message length");
    const res = binding.crypto_secretstream_xchacha20poly1305_pull(state.buffer, state.byteOffset, state.byteLength, m.buffer, m.byteOffset, m.byteLength, tag.buffer, tag.byteOffset, tag.byteLength, c.buffer, c.byteOffset, c.byteLength, ad.buffer, ad.byteOffset, ad.byteLength);
    if (res < 0)
      throw new Error("pull failed");
    return res;
  };
  exports.crypto_secretstream_xchacha20poly1305_rekey = function(state) {
    binding.crypto_secretstream_xchacha20poly1305_rekey(state.buffer, state.byteOffset, state.byteLength);
  };
  exports.crypto_stream = function(c, n, k) {
    if (n?.byteLength !== binding.crypto_stream_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream(c, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_xor = function(c, m, n, k) {
    const res = binding.crypto_stream_xor(c.buffer, c.byteOffset, c.byteLength, m.buffer, m.byteOffset, m.byteLength, n.buffer, n.byteOffset, n.byteLength, k.buffer, k.byteOffset, k.byteLength);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_chacha20 = function(c, n, k) {
    if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_chacha20(c, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_chacha20_xor = function(c, m, n, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_chacha20_xor(c, m, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_chacha20_xor_ic = function(c, m, n, ic, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_chacha20_xor_ic(c, m, n, ic, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_chacha20_ietf = function(c, n, k) {
    if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_chacha20_ietf(c, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_chacha20_ietf_xor = function(c, m, n, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_chacha20_ietf_xor(c, m, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_chacha20_ietf_xor_ic = function(c, m, n, ic, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_chacha20_ietf_xor_ic(c, m, n, ic, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_xchacha20 = function(c, n, k) {
    if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_xchacha20(c, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_xchacha20_xor = function(c, m, n, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_xchacha20_xor(c, m, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_xchacha20_xor_ic = function(c, m, n, ic, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_xchacha20_xor_ic(c, m, n, ic, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_salsa20 = function(c, n, k) {
    if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_salsa20(c, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_salsa20_xor = function(c, m, n, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_salsa20_xor(c, m, n, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_stream_salsa20_xor_ic = function(c, m, n, ic, k) {
    if (c?.byteLength !== m.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_stream_salsa20_xor_ic(c, m, n, ic, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_auth = function(out, input, k) {
    if (out?.byteLength !== binding.crypto_auth_BYTES)
      throw new Error("out");
    if (k?.byteLength !== binding.crypto_auth_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_auth(out, input, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_auth_verify = function(h, input, k) {
    if (h?.byteLength !== binding.crypto_auth_BYTES)
      throw new Error("h");
    if (k?.byteLength !== binding.crypto_auth_KEYBYTES)
      throw new Error("k");
    return binding.crypto_auth_verify(h, input, k);
  };
  exports.crypto_onetimeauth = function(out, input, k) {
    if (out?.byteLength !== binding.crypto_onetimeauth_BYTES)
      throw new Error("out");
    if (k?.byteLength !== binding.crypto_onetimeauth_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_onetimeauth(out, input, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_onetimeauth_init = function(state, k) {
    if (state?.byteLength !== binding.crypto_onetimeauth_STATEBYTES)
      throw new Error("state must be 'crypto_onetimeauth_STATEBYTES' bytes");
    if (k?.byteLength !== binding.crypto_onetimeauth_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_onetimeauth_init(state, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_onetimeauth_update = function(state, input) {
    if (state?.byteLength !== binding.crypto_onetimeauth_STATEBYTES)
      throw new Error("state must be 'crypto_onetimeauth_STATEBYTES' bytes");
    const res = binding.crypto_onetimeauth_update(state, input);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_onetimeauth_final = function(state, out) {
    if (state?.byteLength !== binding.crypto_onetimeauth_STATEBYTES)
      throw new Error("state must be 'crypto_onetimeauth_STATEBYTES' bytes");
    if (out?.byteLength !== binding.crypto_onetimeauth_BYTES)
      throw new Error("out");
    const res = binding.crypto_onetimeauth_final(state, out);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_onetimeauth_verify = function(h, input, k) {
    if (h?.byteLength !== binding.crypto_onetimeauth_BYTES)
      throw new Error("h");
    if (k?.byteLength !== binding.crypto_onetimeauth_KEYBYTES)
      throw new Error("k");
    return binding.crypto_onetimeauth_verify(h, input, k);
  };
  exports.crypto_pwhash = function(out, passwd, salt, opslimit, memlimit, alg) {
    if (out?.byteLength < binding.crypto_pwhash_BYTES_MIN)
      throw new Error("out");
    if (out?.byteLength > binding.crypto_pwhash_BYTES_MAX)
      throw new Error("out");
    if (salt?.byteLength !== binding.crypto_pwhash_SALTBYTES)
      throw new Error("salt");
    if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX)
      throw new Error("memlimit");
    if (alg < 1 || alg > 2)
      throw new Error("alg must be either Argon2i 1.3 or Argon2id 1.3");
    const res = binding.crypto_pwhash(out, passwd, salt, opslimit, memlimit, alg);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_pwhash_async = function(out, passwd, salt, opslimit, memlimit, alg, callback = undefined) {
    if (out?.byteLength < binding.crypto_pwhash_BYTES_MIN)
      throw new Error("out");
    if (out?.byteLength > binding.crypto_pwhash_BYTES_MAX)
      throw new Error("out");
    if (salt?.byteLength !== binding.crypto_pwhash_SALTBYTES)
      throw new Error("salt");
    if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX)
      throw new Error("memlimit");
    if (alg < 1 || alg > 2)
      throw new Error("alg must be either Argon2i 1.3 or Argon2id 1.3");
    const [done, promise] = checkStatus(callback);
    binding.crypto_pwhash_async(out.buffer, out.byteOffset, out.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, salt.buffer, salt.byteOffset, salt.byteLength, opslimit, memlimit, alg, done);
    return promise;
  };
  exports.crypto_pwhash_str = function(out, passwd, opslimit, memlimit) {
    if (out?.byteLength !== binding.crypto_pwhash_STRBYTES)
      throw new Error("out");
    if (typeof opslimit !== "number")
      throw new Error("opslimit");
    if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (typeof memlimit !== "number")
      throw new Error("memlimit");
    if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX)
      throw new Error("memlimit");
    const res = binding.crypto_pwhash_str(out, passwd, opslimit, memlimit);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_pwhash_str_async = function(out, passwd, opslimit, memlimit, callback = undefined) {
    if (out?.byteLength !== binding.crypto_pwhash_STRBYTES)
      throw new Error("out");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    if (typeof opslimit !== "number")
      throw new Error("opslimit");
    if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (typeof memlimit !== "number")
      throw new Error("memlimit");
    if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX)
      throw new Error("memlimit");
    const [done, promise] = checkStatus(callback);
    binding.crypto_pwhash_str_async(out.buffer, out.byteOffset, out.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, opslimit, memlimit, done);
    return promise;
  };
  exports.crypto_pwhash_str_verify = function(str, passwd) {
    if (str?.byteLength !== binding.crypto_pwhash_STRBYTES)
      throw new Error("str");
    return binding.crypto_pwhash_str_verify(str, passwd);
  };
  exports.crypto_pwhash_str_verify_async = function(str, passwd, callback = undefined) {
    if (str?.byteLength !== binding.crypto_pwhash_STRBYTES)
      throw new Error("str");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    const [done, promise] = checkStatus(callback, true);
    binding.crypto_pwhash_str_verify_async(str.buffer, str.byteOffset, str.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, done);
    return promise;
  };
  exports.crypto_pwhash_str_needs_rehash = function(str, opslimit, memlimit) {
    if (str?.byteLength !== binding.crypto_pwhash_STRBYTES)
      throw new Error("str");
    if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX)
      throw new Error("memlimit");
    return binding.crypto_pwhash_str_needs_rehash(str, opslimit, memlimit);
  };
  exports.crypto_pwhash_scryptsalsa208sha256 = function(out, passwd, salt, opslimit, memlimit) {
    if (out?.byteLength < binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MIN)
      throw new Error("out");
    if (out?.byteLength > binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MAX)
      throw new Error("out");
    if (salt?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_SALTBYTES)
      throw new Error("salt");
    if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)
      throw new Error("memlimit");
    const res = binding.crypto_pwhash_scryptsalsa208sha256(out, passwd, salt, opslimit, memlimit);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_pwhash_scryptsalsa208sha256_async = function(out, passwd, salt, opslimit, memlimit, callback = undefined) {
    if (out?.byteLength < binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MIN)
      throw new Error("out");
    if (out?.byteLength > binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MAX)
      throw new Error("out");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    if (salt?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_SALTBYTES)
      throw new Error("salt");
    if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)
      throw new Error("memlimit");
    const [done, promise] = checkStatus(callback);
    binding.crypto_pwhash_scryptsalsa208sha256_async(out.buffer, out.byteOffset, out.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, salt.buffer, salt.byteOffset, salt.byteLength, opslimit, memlimit, done);
    return promise;
  };
  exports.crypto_pwhash_scryptsalsa208sha256_str_async = function(out, passwd, opslimit, memlimit, callback = undefined) {
    if (out?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)
      throw new Error("out");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)
      throw new Error("memlimit");
    const [done, promise] = checkStatus(callback);
    binding.crypto_pwhash_scryptsalsa208sha256_str_async(out.buffer, out.byteOffset, out.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, opslimit, memlimit, done);
    return promise;
  };
  exports.crypto_pwhash_scryptsalsa208sha256_str = function(out, passwd, opslimit, memlimit) {
    if (out?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)
      throw new Error("out");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)
      throw new Error("memlimit");
    const res = binding.crypto_pwhash_scryptsalsa208sha256_str(out, passwd, opslimit, memlimit);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_pwhash_scryptsalsa208sha256_str_verify_async = function(str, passwd, callback = undefined) {
    if (str?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)
      throw new Error("str");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    const [done, promise] = checkStatus(callback, true);
    binding.crypto_pwhash_scryptsalsa208sha256_str_verify_async(str.buffer, str.byteOffset, str.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, done);
    return promise;
  };
  exports.crypto_pwhash_scryptsalsa208sha256_str_verify = function(str, passwd) {
    if (str?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)
      throw new Error("str");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    return binding.crypto_pwhash_scryptsalsa208sha256_str_verify(str, passwd);
  };
  exports.crypto_pwhash_scryptsalsa208sha256_str_needs_rehash = function(str, opslimit, memlimit) {
    if (str?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)
      throw new Error("str");
    if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN)
      throw new Error("opslimit");
    if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX)
      throw new Error("opslimit");
    if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN)
      throw new Error("memlimit");
    if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX)
      throw new Error("memlimit");
    return binding.crypto_pwhash_scryptsalsa208sha256_str_needs_rehash(str, opslimit, memlimit);
  };
  exports.crypto_kx_keypair = function(pk, sk) {
    if (pk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)
      throw new Error("pk");
    if (sk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES)
      throw new Error("sk");
    const res = binding.crypto_kx_keypair(pk, sk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_kx_seed_keypair = function(pk, sk, seed) {
    if (pk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)
      throw new Error("pk");
    if (sk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES)
      throw new Error("sk");
    if (seed?.byteLength !== binding.crypto_kx_SEEDBYTES)
      throw new Error("seed");
    const res = binding.crypto_kx_seed_keypair(pk, sk, seed);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_kx_client_session_keys = function(rx, tx, clientPk, clientSk, serverPk) {
    rx ??= undefined;
    tx ??= undefined;
    if (!rx && !tx)
      throw new Error("at least one session key must be specified");
    if (rx) {
      if (rx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)
        throw new Error('receiving key buffer must be "crypto_kx_SESSIONKEYBYTES" bytes or null');
    } else {
      if (tx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)
        throw new Error('transmitting key buffer must be "crypto_kx_SESSIONKEYBYTES" bytes or null');
    }
    if (clientPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)
      throw new Error("client_pk");
    if (clientSk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES)
      throw new Error("client_sk");
    if (serverPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)
      throw new Error("server_pk");
    const res = binding.crypto_kx_client_session_keys(rx, tx, clientPk, clientSk, serverPk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_kx_server_session_keys = function(rx, tx, serverPk, serverSk, clientPk) {
    rx ??= undefined;
    tx ??= undefined;
    if (!rx && !tx)
      throw new Error("at least one session key must be specified");
    if (rx) {
      if (rx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)
        throw new Error('receiving key buffer must be "crypto_kx_SESSIONKEYBYTES" bytes or null');
    } else {
      if (tx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)
        throw new Error('transmitting key buffer must be "crypto_kx_SESSIONKEYBYTES" bytes or null');
    }
    if (serverPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)
      throw new Error("server_pk");
    if (serverSk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES)
      throw new Error("server_sk");
    if (clientPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)
      throw new Error("client_pk");
    const res = binding.crypto_kx_server_session_keys(rx, tx, serverPk, serverSk, clientPk);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_scalarmult_base = function(q, n) {
    if (q?.byteLength !== binding.crypto_scalarmult_BYTES)
      throw new Error("q");
    if (n?.byteLength !== binding.crypto_scalarmult_SCALARBYTES)
      throw new Error("n");
    const res = binding.crypto_scalarmult_base(q, n);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_scalarmult = function(q, n, p) {
    if (q?.byteLength !== binding.crypto_scalarmult_BYTES)
      throw new Error("q");
    if (n?.byteLength !== binding.crypto_scalarmult_SCALARBYTES)
      throw new Error("n");
    if (p?.byteLength !== binding.crypto_scalarmult_BYTES)
      throw new Error("p");
    const res = binding.crypto_scalarmult(q, n, p);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_scalarmult_ed25519_base = function(q, n) {
    if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)
      throw new Error("q");
    if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)
      throw new Error("n");
    const res = binding.crypto_scalarmult_ed25519_base(q, n);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_scalarmult_ed25519 = function(q, n, p) {
    if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)
      throw new Error("q");
    if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)
      throw new Error("n");
    if (p?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)
      throw new Error("p");
    const res = binding.crypto_scalarmult_ed25519(q, n, p);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_core_ed25519_is_valid_point = function(p) {
    if (p?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("p");
    return binding.crypto_core_ed25519_is_valid_point(p);
  };
  exports.crypto_core_ed25519_from_uniform = function(p, r) {
    if (p?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("p");
    if (r?.byteLength !== binding.crypto_core_ed25519_UNIFORMBYTES)
      throw new Error("r");
    const res = binding.crypto_core_ed25519_from_uniform(p, r);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_scalarmult_ed25519_base_noclamp = function(q, n) {
    if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)
      throw new Error("q");
    if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)
      throw new Error("n");
    const res = binding.crypto_scalarmult_ed25519_base_noclamp(q, n);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_scalarmult_ed25519_noclamp = function(q, n, p) {
    if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)
      throw new Error("q");
    if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)
      throw new Error("n");
    if (p?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)
      throw new Error("p");
    const res = binding.crypto_scalarmult_ed25519_noclamp(q, n, p);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_core_ed25519_add = function(r, p, q) {
    if (r?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("r");
    if (p?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("p");
    if (q?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("q");
    const res = binding.crypto_core_ed25519_add(r, p, q);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_core_ed25519_sub = function(r, p, q) {
    if (r?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("r");
    if (p?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("p");
    if (q?.byteLength !== binding.crypto_core_ed25519_BYTES)
      throw new Error("q");
    const res = binding.crypto_core_ed25519_sub(r, p, q);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_core_ed25519_scalar_random = function(r) {
    if (r?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("r");
    binding.crypto_core_ed25519_scalar_random(r);
  };
  exports.crypto_core_ed25519_scalar_reduce = function(r, s) {
    if (r?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("r");
    if (s?.byteLength !== binding.crypto_core_ed25519_NONREDUCEDSCALARBYTES)
      throw new Error("s");
    binding.crypto_core_ed25519_scalar_reduce(r, s);
  };
  exports.crypto_core_ed25519_scalar_invert = function(recip, s) {
    if (recip?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("recip");
    if (s?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("s");
    binding.crypto_core_ed25519_scalar_invert(recip, s);
  };
  exports.crypto_core_ed25519_scalar_negate = function(neg, s) {
    if (neg?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("neg");
    if (s?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("s");
    binding.crypto_core_ed25519_scalar_negate(neg, s);
  };
  exports.crypto_core_ed25519_scalar_complement = function(comp, s) {
    if (comp?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("comp");
    if (s?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("s");
    binding.crypto_core_ed25519_scalar_complement(comp, s);
  };
  exports.crypto_core_ed25519_scalar_add = function(z, x, y) {
    if (z?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("z");
    if (x?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("x");
    if (y?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("y");
    binding.crypto_core_ed25519_scalar_add(z, x, y);
  };
  exports.crypto_core_ed25519_scalar_sub = function(z, x, y) {
    if (z?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("z");
    if (x?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("x");
    if (y?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)
      throw new Error("y");
    binding.crypto_core_ed25519_scalar_sub(z, x, y);
  };
  exports.crypto_shorthash = function(out, input, k) {
    if (out?.byteLength !== binding.crypto_shorthash_BYTES)
      throw new Error("out");
    if (k?.byteLength !== binding.crypto_shorthash_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_shorthash(out, input, k);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_kdf_keygen = function(key) {
    if (key?.byteLength !== binding.crypto_kdf_KEYBYTES)
      throw new Error("key");
    binding.crypto_kdf_keygen(key);
  };
  exports.crypto_kdf_derive_from_key = function(subkey, subkeyId, ctx, key) {
    if (subkey?.byteLength < binding.crypto_kdf_BYTES_MIN)
      throw new Error("subkey");
    if (subkey?.byteLength > binding.crypto_kdf_BYTES_MAX)
      throw new Error("subkey");
    if (ctx?.byteLength !== binding.crypto_kdf_CONTEXTBYTES)
      throw new Error("ctx");
    if (key?.byteLength !== binding.crypto_kdf_KEYBYTES)
      throw new Error("key");
    const res = binding.crypto_kdf_derive_from_key(subkey, subkeyId, ctx, key);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash = function(out, input) {
    if (out?.byteLength !== binding.crypto_hash_BYTES)
      throw new Error("out");
    const res = binding.crypto_hash(out, input);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha256 = function(out, input) {
    if (out?.byteLength !== binding.crypto_hash_sha256_BYTES)
      throw new Error("out");
    const res = binding.crypto_hash_sha256(out, input);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha256_init = function(state) {
    if (state?.byteLength !== binding.crypto_hash_sha256_STATEBYTES) {
      throw new Error("state must be 'crypto_hash_sha256_STATEBYTES' bytes");
    }
    const res = binding.crypto_hash_sha256_init(state);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha256_update = function(state, input) {
    if (state?.byteLength !== binding.crypto_hash_sha256_STATEBYTES) {
      throw new Error("state must be 'crypto_hash_sha256_STATEBYTES' bytes");
    }
    const res = binding.crypto_hash_sha256_update(state, input);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha256_final = function(state, out) {
    if (state?.byteLength !== binding.crypto_hash_sha256_STATEBYTES) {
      throw new Error("state must be 'crypto_hash_sha256_STATEBYTES' bytes");
    }
    if (out?.byteLength !== binding.crypto_hash_sha256_BYTES)
      throw new Error("state");
    const res = binding.crypto_hash_sha256_final(state, out);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha512 = function(out, input) {
    if (out?.byteLength !== binding.crypto_hash_sha512_BYTES)
      throw new Error("out");
    const res = binding.crypto_hash_sha512(out, input);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha512_init = function(state) {
    if (state?.byteLength !== binding.crypto_hash_sha512_STATEBYTES) {
      throw new Error("state must be 'crypto_hash_sha512_STATEBYTES' bytes");
    }
    const res = binding.crypto_hash_sha512_init(state);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha512_update = function(state, input) {
    if (state?.byteLength !== binding.crypto_hash_sha512_STATEBYTES) {
      throw new Error("state must be 'crypto_hash_sha512_STATEBYTES' bytes");
    }
    const res = binding.crypto_hash_sha512_update(state, input);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_hash_sha512_final = function(state, out) {
    if (state?.byteLength !== binding.crypto_hash_sha512_STATEBYTES) {
      throw new Error("state must be 'crypto_hash_sha512_STATEBYTES' bytes");
    }
    if (out?.byteLength !== binding.crypto_hash_sha512_BYTES)
      throw new Error("out");
    const res = binding.crypto_hash_sha512_final(state, out);
    if (res !== 0)
      throw new Error("status: " + res);
  };
  exports.crypto_aead_xchacha20poly1305_ietf_keygen = function(k) {
    if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    binding.crypto_aead_xchacha20poly1305_ietf_keygen(k);
  };
  exports.crypto_aead_xchacha20poly1305_ietf_encrypt = function(c, m, ad, nsec = null, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (c?.byteLength !== m.byteLength + binding.crypto_aead_xchacha20poly1305_ietf_ABYTES)
      throw new Error('c must "m.byteLength + crypto_aead_xchacha20poly1305_ietf_ABYTES" bytes');
    if (c?.byteLength > 4294967295)
      throw new Error("c.byteLength must be a 32bit integer");
    if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_xchacha20poly1305_ietf_encrypt(c, m, ad, npub, k);
    if (res < 0)
      throw new Error("could not encrypt data");
    return res;
  };
  exports.crypto_aead_xchacha20poly1305_ietf_decrypt = function(m, nsec = null, c, ad, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (m?.byteLength !== c.byteLength - binding.crypto_aead_xchacha20poly1305_ietf_ABYTES)
      throw new Error('m must "c.byteLength - crypto_aead_xchacha20poly1305_ietf_ABYTES" bytes');
    if (m?.byteLength > 4294967295)
      throw new Error("m.byteLength must be a 32bit integer");
    if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_xchacha20poly1305_ietf_decrypt(m, c, ad, npub, k);
    if (res < 0)
      throw new Error("could not verify data");
    return res;
  };
  exports.crypto_aead_xchacha20poly1305_ietf_encrypt_detached = function(c, mac, m, ad, nsec = null, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    if (mac?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_ABYTES)
      throw new Error("mac");
    if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_xchacha20poly1305_ietf_encrypt_detached(c, mac, m, ad, npub, k);
    if (res < 0)
      throw new Error("could not encrypt data");
    return res;
  };
  exports.crypto_aead_xchacha20poly1305_ietf_decrypt_detached = function(m, nsec = null, c, mac, ad, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (m?.byteLength !== c.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (mac?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_ABYTES)
      throw new Error("mac");
    if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_xchacha20poly1305_ietf_decrypt_detached(m, c, mac, ad, npub, k);
    if (res !== 0)
      throw new Error("could not verify data");
  };
  exports.crypto_aead_chacha20poly1305_ietf_keygen = function(k) {
    if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    binding.crypto_aead_chacha20poly1305_ietf_keygen(k);
  };
  exports.crypto_aead_chacha20poly1305_ietf_encrypt = function(c, m, ad, nsec = null, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (c?.byteLength !== m.byteLength + binding.crypto_aead_chacha20poly1305_ietf_ABYTES)
      throw new Error('c must "m.byteLength + crypto_aead_chacha20poly1305_ietf_ABYTES" bytes');
    if (c?.byteLength > 4294967295)
      throw new Error("c.byteLength must be a 32bit integer");
    if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_chacha20poly1305_ietf_encrypt(c, m, ad, npub, k);
    if (res < 0)
      throw new Error("could not encrypt data");
    return res;
  };
  exports.crypto_aead_chacha20poly1305_ietf_decrypt = function(m, nsec = null, c, ad, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (m?.byteLength !== c.byteLength - binding.crypto_aead_chacha20poly1305_ietf_ABYTES)
      throw new Error('m must "c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES" bytes');
    if (m?.byteLength > 4294967295)
      throw new Error("m.byteLength must be a 32bit integer");
    if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_chacha20poly1305_ietf_decrypt(m, c, ad, npub, k);
    if (res < 0)
      throw new Error("could not verify data");
    return res;
  };
  exports.crypto_aead_chacha20poly1305_ietf_encrypt_detached = function(c, mac, m, ad, nsec = null, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    if (mac?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_ABYTES)
      throw new Error("mac");
    if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_chacha20poly1305_ietf_encrypt_detached(c, mac, m, ad, npub, k);
    if (res < 0)
      throw new Error("could not encrypt data");
    return res;
  };
  exports.crypto_aead_chacha20poly1305_ietf_decrypt_detached = function(m, nsec = null, c, mac, ad, npub, k) {
    ad ??= undefined;
    if (nsec !== null)
      throw new Error("nsec must always be set to null");
    if (m?.byteLength !== c.byteLength)
      throw new Error('m must be "c.byteLength" bytes');
    if (mac?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_ABYTES)
      throw new Error("mac");
    if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
      throw new Error("npub");
    if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)
      throw new Error("k");
    const res = binding.crypto_aead_chacha20poly1305_ietf_decrypt_detached(m, c, mac, ad, npub, k);
    if (res !== 0)
      throw new Error("could not verify data");
  };
  exports.crypto_stream_xor_wrap_init = function(state, n, k) {
    if (state?.byteLength !== binding.sn_crypto_stream_xor_STATEBYTES) {
      throw new Error("state must be 'sn_crypto_stream_xor_STATEBYTES' bytes");
    }
    if (n?.byteLength !== binding.crypto_stream_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_KEYBYTES)
      throw new Error("k");
    binding.crypto_stream_xor_wrap_init(state, n, k);
  };
  exports.crypto_stream_xor_wrap_update = function(state, c, m) {
    if (state?.byteLength !== binding.sn_crypto_stream_xor_STATEBYTES) {
      throw new Error("state must be 'sn_crypto_stream_xor_STATEBYTES' bytes");
    }
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    binding.crypto_stream_xor_wrap_update(state, c, m);
  };
  exports.crypto_stream_xor_wrap_final = function(state) {
    if (state?.byteLength !== binding.sn_crypto_stream_xor_STATEBYTES) {
      throw new Error("state must be 'sn_crypto_stream_xor_STATEBYTES' bytes");
    }
    binding.crypto_stream_xor_wrap_final(state);
  };
  exports.crypto_stream_chacha20_xor_wrap_init = function(state, n, k) {
    if (state?.byteLength !== binding.crypto_stream_chacha20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_chacha20_xor_STATEBYTES' bytes");
    }
    if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)
      throw new Error("k");
    binding.crypto_stream_chacha20_xor_wrap_init(state, n, k);
  };
  exports.crypto_stream_chacha20_xor_wrap_update = function(state, c, m) {
    if (state?.byteLength !== binding.crypto_stream_chacha20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_chacha20_xor_STATEBYTES' bytes");
    }
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    binding.crypto_stream_chacha20_xor_wrap_update(state, c, m);
  };
  exports.crypto_stream_chacha20_xor_wrap_final = function(state) {
    if (state?.byteLength !== binding.crypto_stream_chacha20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_chacha20_xor_STATEBYTES' bytes");
    }
    binding.crypto_stream_chacha20_xor_wrap_final(state);
  };
  exports.crypto_stream_chacha20_ietf_xor_wrap_init = function(state, n, k) {
    if (state?.byteLength !== binding.crypto_stream_chacha20_ietf_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_chacha20_ietf_xor_STATEBYTES' bytes");
    }
    if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)
      throw new Error("k");
    binding.crypto_stream_chacha20_ietf_xor_wrap_init(state, n, k);
  };
  exports.crypto_stream_chacha20_ietf_xor_wrap_update = function(state, c, m) {
    if (state?.byteLength !== binding.crypto_stream_chacha20_ietf_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_chacha20_ietf_xor_STATEBYTES' bytes");
    }
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    binding.crypto_stream_chacha20_ietf_xor_wrap_update(state, c, m);
  };
  exports.crypto_stream_chacha20_ietf_xor_wrap_final = function(state) {
    if (state?.byteLength !== binding.crypto_stream_chacha20_ietf_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_chacha20_ietf_xor_STATEBYTES' bytes");
    }
    binding.crypto_stream_chacha20_ietf_xor_wrap_final(state);
  };
  exports.crypto_stream_xchacha20_xor_wrap_init = function(state, n, k) {
    if (state?.byteLength !== binding.crypto_stream_xchacha20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_xchacha20_xor_STATEBYTES' bytes");
    }
    if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)
      throw new Error("k");
    binding.crypto_stream_xchacha20_xor_wrap_init(state, n, k);
  };
  exports.crypto_stream_xchacha20_xor_wrap_update = function(state, c, m) {
    if (state?.byteLength !== binding.crypto_stream_xchacha20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_xchacha20_xor_STATEBYTES' bytes");
    }
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    binding.crypto_stream_xchacha20_xor_wrap_update(state, c, m);
  };
  exports.crypto_stream_xchacha20_xor_wrap_final = function(state) {
    if (state?.byteLength !== binding.crypto_stream_xchacha20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_xchacha20_xor_STATEBYTES' bytes");
    }
    binding.crypto_stream_xchacha20_xor_wrap_final(state);
  };
  exports.crypto_stream_salsa20_xor_wrap_init = function(state, n, k) {
    if (state?.byteLength !== binding.crypto_stream_salsa20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_salsa20_xor_STATEBYTES' bytes");
    }
    if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)
      throw new Error("n");
    if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)
      throw new Error("k");
    binding.crypto_stream_salsa20_xor_wrap_init(state, n, k);
  };
  exports.crypto_stream_salsa20_xor_wrap_update = function(state, c, m) {
    if (state?.byteLength !== binding.crypto_stream_salsa20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_salsa20_xor_STATEBYTES' bytes");
    }
    if (c?.byteLength !== m.byteLength)
      throw new Error('c must be "m.byteLength" bytes');
    binding.crypto_stream_salsa20_xor_wrap_update(state, c, m);
  };
  exports.crypto_stream_salsa20_xor_wrap_final = function(state) {
    if (state?.byteLength !== binding.crypto_stream_salsa20_xor_STATEBYTES) {
      throw new Error("state must be 'crypto_stream_salsa20_xor_STATEBYTES' bytes");
    }
    binding.crypto_stream_salsa20_xor_wrap_final(state);
  };
  exports.extension_tweak_ed25519_base = function(n, p, ns) {
    if (n?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("n");
    if (p?.byteLength !== binding.extension_tweak_ed25519_BYTES)
      throw new Error("p");
    binding.extension_tweak_ed25519_base(n, p, ns);
  };
  exports.extension_tweak_ed25519_sign_detached = function(sig, m, scalar, pk) {
    if (sig?.byteLength !== binding.crypto_sign_BYTES)
      throw new Error("sig");
    if (scalar?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar");
    if (pk && pk.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    const res = binding.extension_tweak_ed25519_sign_detached(sig, m, scalar, pk);
    if (res !== 0)
      throw new Error("failed to compute signature");
  };
  exports.extension_tweak_ed25519_sk_to_scalar = function(n, sk) {
    if (n?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("n");
    if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)
      throw new Error("sk");
    binding.extension_tweak_ed25519_sk_to_scalar(n, sk);
  };
  exports.extension_tweak_ed25519_scalar = function(scalarOut, scalar, ns) {
    if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar_out");
    if (scalar?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar");
    binding.extension_tweak_ed25519_scalar(scalarOut, scalar, ns);
  };
  exports.extension_tweak_ed25519_pk = function(tpk, pk, ns) {
    if (tpk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("tpk");
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    const res = binding.extension_tweak_ed25519_pk(tpk, pk, ns);
    if (res !== 0)
      throw new Error("failed to tweak public key");
  };
  exports.extension_tweak_ed25519_keypair = function(pk, scalarOut, scalarIn, ns) {
    if (pk?.byteLength !== binding.extension_tweak_ed25519_BYTES)
      throw new Error("pk");
    if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar_out");
    if (scalarIn?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar_in");
    binding.extension_tweak_ed25519_keypair(pk, scalarOut, scalarIn, ns);
  };
  exports.extension_tweak_ed25519_scalar_add = function(scalarOut, scalar, n) {
    if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar_out");
    if (scalar?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar");
    if (n?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("n");
    binding.extension_tweak_ed25519_scalar_add(scalarOut, scalar, n);
  };
  exports.extension_tweak_ed25519_pk_add = function(tpk, pk, p) {
    if (tpk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("tpk");
    if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("pk");
    if (p?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)
      throw new Error("p");
    const res = binding.extension_tweak_ed25519_pk_add(tpk, pk, p);
    if (res !== 0)
      throw new Error("failed to add tweak to public key");
  };
  exports.extension_tweak_ed25519_keypair_add = function(pk, scalarOut, scalarIn, tweak) {
    if (pk?.byteLength !== binding.extension_tweak_ed25519_BYTES)
      throw new Error("pk");
    if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar_out");
    if (scalarIn?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("scalar_in");
    if (tweak?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)
      throw new Error("tweak");
    const res = binding.extension_tweak_ed25519_keypair_add(pk, scalarOut, scalarIn, tweak);
    if (res !== 0)
      throw new Error("failed to add tweak to keypair");
  };
  exports.extension_pbkdf2_sha512_async = function(out, passwd, salt, iter, outlen, callback = undefined) {
    if (iter < binding.extension_pbkdf2_sha512_ITERATIONS_MIN)
      throw new Error("iterations");
    if (outlen > binding.extension_pbkdf2_sha512_BYTES_MAX)
      throw new Error("outlen");
    if (out?.byteLength < outlen)
      throw new Error("out");
    if (!out?.byteLength)
      throw new Error("out");
    if (!passwd?.byteLength)
      throw new Error("passwd");
    if (!salt?.byteLength)
      throw new Error("salt");
    const [done, promise] = checkStatus(callback);
    binding.extension_pbkdf2_sha512_async(out.buffer, out.byteOffset, out.byteLength, passwd.buffer, passwd.byteOffset, passwd.byteLength, salt.buffer, salt.byteOffset, salt.byteLength, iter, outlen, done);
    return promise;
  };
  exports.extension_pbkdf2_sha512 = function(out, passwd, salt, iter, outlen) {
    if (iter < binding.extension_pbkdf2_sha512_ITERATIONS_MIN)
      throw new Error("iterations");
    if (outlen > binding.extension_pbkdf2_sha512_BYTES_MAX)
      throw new Error("outlen");
    if (out?.byteLength < outlen)
      throw new Error("out");
    const res = binding.extension_pbkdf2_sha512(out, passwd, salt, iter, outlen);
    if (res !== 0)
      throw new Error("failed to add tweak to public key");
  };
  function checkStatus(callback, booleanResult = false) {
    let done, promise;
    if (typeof callback === "function") {
      done = function(status) {
        if (booleanResult)
          callback(null, status === 0);
        else if (status === 0)
          callback(null);
        else
          callback(new Error("status: " + status));
      };
    } else {
      promise = new Promise(function(resolve, reject) {
        done = function(status) {
          if (booleanResult)
            resolve(status === 0);
          else if (status === 0)
            resolve();
          else
            reject(new Error("status: " + status));
        };
      });
    }
    return [done, promise];
  }
});

// node_modules/hypercore-crypto/index.js
var require_hypercore_crypto = __commonJS((exports) => {
  var sodium = require_sodium_native();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var LEAF_TYPE = b4a.from([0]);
  var PARENT_TYPE = b4a.from([1]);
  var ROOT_TYPE = b4a.from([2]);
  var HYPERCORE = b4a.from("hypercore");
  exports.keyPair = function(seed) {
    const slab = b4a.allocUnsafeSlow(sodium.crypto_sign_PUBLICKEYBYTES + sodium.crypto_sign_SECRETKEYBYTES);
    const publicKey = slab.subarray(0, sodium.crypto_sign_PUBLICKEYBYTES);
    const secretKey = slab.subarray(sodium.crypto_sign_PUBLICKEYBYTES);
    if (seed)
      sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);
    else
      sodium.crypto_sign_keypair(publicKey, secretKey);
    return {
      publicKey,
      secretKey
    };
  };
  exports.validateKeyPair = function(keyPair) {
    const pk = b4a.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);
    sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey);
    return b4a.equals(pk, keyPair.publicKey);
  };
  exports.sign = function(message, secretKey) {
    const signature = b4a.allocUnsafeSlow(sodium.crypto_sign_BYTES);
    sodium.crypto_sign_detached(signature, message, secretKey);
    return signature;
  };
  exports.verify = function(message, signature, publicKey) {
    if (signature.byteLength !== sodium.crypto_sign_BYTES)
      return false;
    if (publicKey.byteLength !== sodium.crypto_sign_PUBLICKEYBYTES)
      return false;
    return sodium.crypto_sign_verify_detached(signature, message, publicKey);
  };
  exports.encrypt = function(message, publicKey) {
    const ciphertext = b4a.alloc(message.byteLength + sodium.crypto_box_SEALBYTES);
    sodium.crypto_box_seal(ciphertext, message, publicKey);
    return ciphertext;
  };
  exports.decrypt = function(ciphertext, keyPair) {
    if (ciphertext.byteLength < sodium.crypto_box_SEALBYTES)
      return null;
    const plaintext = b4a.alloc(ciphertext.byteLength - sodium.crypto_box_SEALBYTES);
    if (!sodium.crypto_box_seal_open(plaintext, ciphertext, keyPair.publicKey, keyPair.secretKey)) {
      return null;
    }
    return plaintext;
  };
  exports.encryptionKeyPair = function(seed) {
    const publicKey = b4a.alloc(sodium.crypto_box_PUBLICKEYBYTES);
    const secretKey = b4a.alloc(sodium.crypto_box_SECRETKEYBYTES);
    if (seed) {
      sodium.crypto_box_seed_keypair(publicKey, secretKey, seed);
    } else {
      sodium.crypto_box_keypair(publicKey, secretKey);
    }
    return {
      publicKey,
      secretKey
    };
  };
  exports.data = function(data) {
    const out = b4a.allocUnsafe(32);
    sodium.crypto_generichash_batch(out, [
      LEAF_TYPE,
      c.encode(c.uint64, data.byteLength),
      data
    ]);
    return out;
  };
  exports.parent = function(a, b) {
    if (a.index > b.index) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const out = b4a.allocUnsafe(32);
    sodium.crypto_generichash_batch(out, [
      PARENT_TYPE,
      c.encode(c.uint64, a.size + b.size),
      a.hash,
      b.hash
    ]);
    return out;
  };
  exports.tree = function(roots, out) {
    const buffers = new Array(3 * roots.length + 1);
    let j = 0;
    buffers[j++] = ROOT_TYPE;
    for (let i = 0;i < roots.length; i++) {
      const r = roots[i];
      buffers[j++] = r.hash;
      buffers[j++] = c.encode(c.uint64, r.index);
      buffers[j++] = c.encode(c.uint64, r.size);
    }
    if (!out)
      out = b4a.allocUnsafe(32);
    sodium.crypto_generichash_batch(out, buffers);
    return out;
  };
  exports.hash = function(data, out) {
    if (!out)
      out = b4a.allocUnsafe(32);
    if (!Array.isArray(data))
      data = [data];
    sodium.crypto_generichash_batch(out, data);
    return out;
  };
  exports.randomBytes = function(n) {
    const buf = b4a.allocUnsafe(n);
    sodium.randombytes_buf(buf);
    return buf;
  };
  exports.discoveryKey = function(key) {
    if (!key || key.byteLength !== 32)
      throw new Error("Must pass a 32 byte buffer");
    const digest = b4a.allocUnsafeSlow(32);
    sodium.crypto_generichash(digest, HYPERCORE, key);
    return digest;
  };
  if (sodium.sodium_free) {
    exports.free = function(secureBuf) {
      if (secureBuf.secure)
        sodium.sodium_free(secureBuf);
    };
  } else {
    exports.free = function() {};
  }
  exports.namespace = function(name, count) {
    const ids = typeof count === "number" ? range(count) : count;
    const buf = b4a.allocUnsafeSlow(32 * ids.length);
    const list = new Array(ids.length);
    const ns = b4a.allocUnsafe(33);
    sodium.crypto_generichash(ns.subarray(0, 32), typeof name === "string" ? b4a.from(name) : name);
    for (let i = 0;i < list.length; i++) {
      list[i] = buf.subarray(32 * i, 32 * i + 32);
      ns[32] = ids[i];
      sodium.crypto_generichash(list[i], ns);
    }
    return list;
  };
  function range(count) {
    const arr = new Array(count);
    for (let i = 0;i < count; i++)
      arr[i] = i;
    return arr;
  }
});

// node_modules/unslab/index.js
var require_unslab = __commonJS((exports, module) => {
  var b4a = require_b4a();
  unslab.all = all;
  unslab.is = is;
  module.exports = unslab;
  function unslab(buf) {
    if (buf === null || buf.buffer.byteLength === buf.byteLength)
      return buf;
    const copy = b4a.allocUnsafeSlow(buf.byteLength);
    copy.set(buf, 0);
    return copy;
  }
  function is(buf) {
    return buf.buffer.byteLength !== buf.byteLength;
  }
  function all(list) {
    let size = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      size += buf === null || buf.buffer.byteLength === buf.byteLength ? 0 : buf.byteLength;
    }
    const copy = b4a.allocUnsafeSlow(size);
    const result = new Array(list.length);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      let buf = list[i];
      if (buf !== null && buf.buffer.byteLength !== buf.byteLength) {
        copy.set(buf, offset);
        buf = copy.subarray(offset, offset += buf.byteLength);
      }
      result[i] = buf;
    }
    return result;
  }
});

// node_modules/protomux/index.js
var require_protomux = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var queueTick = require_process_next_tick();
  var safetyCatch = require_safety_catch();
  var unslab = require_unslab();
  var MAX_BUFFERED = 32768;
  var MAX_BACKLOG = Infinity;
  var MAX_BATCH = 8 * 1024 * 1024;

  class Channel {
    constructor(mux, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain) {
      this.userData = userData;
      this.protocol = protocol;
      this.aliases = aliases;
      this.id = id;
      this.handshake = null;
      this.messages = [];
      this.opened = false;
      this.closed = false;
      this.destroyed = false;
      this.onopen = onopen;
      this.onclose = onclose;
      this.ondestroy = ondestroy;
      this.ondrain = ondrain;
      this._handshake = handshake;
      this._mux = mux;
      this._info = info;
      this._localId = 0;
      this._remoteId = 0;
      this._active = 0;
      this._extensions = null;
      this._decBound = this._dec.bind(this);
      this._decAndDestroyBound = this._decAndDestroy.bind(this);
      this._openedPromise = null;
      this._openedResolve = null;
      this._destroyedPromise = null;
      this._destroyedResolve = null;
      for (const m of messages)
        this.addMessage(m);
    }
    get drained() {
      return this._mux.drained;
    }
    fullyOpened() {
      if (this.opened)
        return Promise.resolve(true);
      if (this.closed)
        return Promise.resolve(false);
      if (this._openedPromise)
        return this._openedPromise;
      this._openedPromise = new Promise((resolve) => {
        this._openedResolve = resolve;
      });
      return this._openedPromise;
    }
    fullyClosed() {
      if (this.destroyed)
        return Promise.resolve();
      if (this._destroyedPromise)
        return this._destroyedPromise;
      this._destroyedPromise = new Promise((resolve) => {
        this._destroyedResolve = resolve;
      });
      return this._destroyedPromise;
    }
    open(handshake) {
      const id = this._mux._free.length > 0 ? this._mux._free.pop() : this._mux._local.push(null) - 1;
      this._info.opened++;
      this._info.lastChannel = this;
      this._localId = id + 1;
      this._mux._local[id] = this;
      if (this._remoteId === 0) {
        this._info.outgoing.push(this._localId);
      }
      const state = { buffer: null, start: 2, end: 2 };
      c.uint.preencode(state, this._localId);
      c.string.preencode(state, this.protocol);
      c.buffer.preencode(state, this.id);
      if (this._handshake)
        this._handshake.preencode(state, handshake);
      state.buffer = this._mux._alloc(state.end);
      state.buffer[0] = 0;
      state.buffer[1] = 1;
      c.uint.encode(state, this._localId);
      c.string.encode(state, this.protocol);
      c.buffer.encode(state, this.id);
      if (this._handshake)
        this._handshake.encode(state, handshake);
      this._mux._write0(state.buffer);
    }
    _dec() {
      if (--this._active === 0 && this.closed === true)
        this._destroy();
    }
    _decAndDestroy(err) {
      this._dec();
      this._mux._safeDestroy(err);
    }
    _fullyOpenSoon() {
      this._mux._remote[this._remoteId - 1].session = this;
      queueTick(this._fullyOpen.bind(this));
    }
    _fullyOpen() {
      if (this.opened === true || this.closed === true)
        return;
      const remote = this._mux._remote[this._remoteId - 1];
      this.opened = true;
      this.handshake = this._handshake ? this._handshake.decode(remote.state) : null;
      this._track(this.onopen(this.handshake, this));
      remote.session = this;
      remote.state = null;
      if (remote.pending !== null)
        this._drain(remote);
      this._resolveOpen(true);
    }
    _resolveOpen(opened) {
      if (this._openedResolve !== null) {
        this._openedResolve(opened);
        this._openedResolve = this._openedPromise = null;
      }
    }
    _resolveDestroyed() {
      if (this._destroyedResolve !== null) {
        this._destroyedResolve();
        this._destroyedResolve = this._destroyedPromise = null;
      }
    }
    _drain(remote) {
      for (let i = 0;i < remote.pending.length; i++) {
        const p = remote.pending[i];
        this._mux._buffered -= byteSize(p.state);
        this._recv(p.type, p.state);
      }
      remote.pending = null;
      this._mux._resumeMaybe();
    }
    _track(p) {
      if (isPromise(p) === true) {
        this._active++;
        return p.then(this._decBound, this._decAndDestroyBound);
      }
      return null;
    }
    _close(isRemote) {
      if (this.closed === true)
        return;
      this.closed = true;
      this._info.opened--;
      if (this._info.lastChannel === this)
        this._info.lastChannel = null;
      if (this._remoteId > 0) {
        this._mux._remote[this._remoteId - 1] = null;
        this._remoteId = 0;
        this._mux._free.push(this._localId - 1);
      }
      this._mux._local[this._localId - 1] = null;
      this._localId = 0;
      this._mux._gc(this._info);
      this._track(this.onclose(isRemote, this));
      if (this._active === 0)
        this._destroy();
      this._resolveOpen(false);
    }
    _destroy() {
      if (this.destroyed === true)
        return;
      this.destroyed = true;
      this._track(this.ondestroy(this));
      this._resolveDestroyed();
    }
    _recv(type, state) {
      if (type < this.messages.length) {
        const m = this.messages[type];
        const p = m.recv(state, this);
        if (m.autoBatch === true)
          return p;
      }
      return null;
    }
    cork() {
      this._mux.cork();
    }
    uncork() {
      this._mux.uncork();
    }
    close() {
      if (this.closed === true)
        return;
      const state = { buffer: null, start: 2, end: 2 };
      c.uint.preencode(state, this._localId);
      state.buffer = this._mux._alloc(state.end);
      state.buffer[0] = 0;
      state.buffer[1] = 3;
      c.uint.encode(state, this._localId);
      this._close(false);
      this._mux._write0(state.buffer);
    }
    addMessage(opts) {
      if (!opts)
        return this._skipMessage();
      const type = this.messages.length;
      const autoBatch = opts.autoBatch !== false;
      const encoding = opts.encoding || c.raw;
      const onmessage = opts.onmessage || noop;
      const s = this;
      const typeLen = encodingLength(c.uint, type);
      const m = {
        type,
        autoBatch,
        encoding,
        onmessage,
        recv(state, session) {
          return session._track(m.onmessage(encoding.decode(state), session));
        },
        send(m2, session = s) {
          if (session.closed === true)
            return false;
          const mux = session._mux;
          const state = { buffer: null, start: 0, end: typeLen };
          if (mux._batch !== null) {
            encoding.preencode(state, m2);
            state.buffer = mux._alloc(state.end);
            c.uint.encode(state, type);
            encoding.encode(state, m2);
            mux._pushBatch(session._localId, state.buffer);
            return true;
          }
          c.uint.preencode(state, session._localId);
          encoding.preencode(state, m2);
          state.buffer = mux._alloc(state.end);
          c.uint.encode(state, session._localId);
          c.uint.encode(state, type);
          encoding.encode(state, m2);
          mux.drained = mux.stream.write(state.buffer);
          return mux.drained;
        }
      };
      this.messages.push(m);
      return m;
    }
    _skipMessage() {
      const type = this.messages.length;
      const m = {
        type,
        encoding: c.raw,
        onmessage: noop,
        recv(state, session) {},
        send(m2, session) {}
      };
      this.messages.push(m);
      return m;
    }
  }
  module.exports = class Protomux {
    constructor(stream, { alloc } = {}) {
      if (stream.userData === null)
        stream.userData = this;
      this.isProtomux = true;
      this.stream = stream;
      this.corked = 0;
      this.drained = true;
      this._alloc = alloc || (typeof stream.alloc === "function" ? stream.alloc.bind(stream) : b4a.allocUnsafe);
      this._safeDestroyBound = this._safeDestroy.bind(this);
      this._uncorkBound = this.uncork.bind(this);
      this._remoteBacklog = 0;
      this._buffered = 0;
      this._paused = false;
      this._remote = [];
      this._local = [];
      this._free = [];
      this._batch = null;
      this._batchState = null;
      this._infos = new Map;
      this._notify = new Map;
      this.stream.on("data", this._ondata.bind(this));
      this.stream.on("drain", this._ondrain.bind(this));
      this.stream.on("end", this._onend.bind(this));
      this.stream.on("error", noop);
      this.stream.on("close", this._shutdown.bind(this));
    }
    static from(stream, opts) {
      if (stream.userData && stream.userData.isProtomux)
        return stream.userData;
      if (stream.isProtomux)
        return stream;
      return new this(stream, opts);
    }
    static isProtomux(mux) {
      return typeof mux === "object" && mux.isProtomux === true;
    }
    *[Symbol.iterator]() {
      for (const session of this._local) {
        if (session !== null)
          yield session;
      }
    }
    isIdle() {
      return this._local.length === this._free.length;
    }
    cork() {
      if (++this.corked === 1) {
        this._batch = [];
        this._batchState = { buffer: null, start: 0, end: 1 };
      }
    }
    uncork() {
      if (--this.corked === 0) {
        this._sendBatch(this._batch, this._batchState);
        this._batch = null;
        this._batchState = null;
      }
    }
    getLastChannel({ protocol, id = null }) {
      const key = toKey(protocol, id);
      const info = this._infos.get(key);
      if (info)
        return info.lastChannel;
      return null;
    }
    pair({ protocol, id = null }, notify) {
      this._notify.set(toKey(protocol, id), notify);
    }
    unpair({ protocol, id = null }) {
      this._notify.delete(toKey(protocol, id));
    }
    opened({ protocol, id = null }) {
      const key = toKey(protocol, id);
      const info = this._infos.get(key);
      return info ? info.opened > 0 : false;
    }
    createChannel({ userData = null, protocol, aliases = [], id = null, unique = true, handshake = null, messages = [], onopen = noop, onclose = noop, ondestroy = noop, ondrain = noop }) {
      if (this.stream.destroyed)
        return null;
      const info = this._get(protocol, id, aliases);
      if (unique && info.opened > 0)
        return null;
      if (info.incoming.length === 0) {
        return new Channel(this, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain);
      }
      this._remoteBacklog--;
      const remoteId = info.incoming.shift();
      const r = this._remote[remoteId - 1];
      if (r === null)
        return null;
      const session = new Channel(this, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain);
      session._remoteId = remoteId;
      session._fullyOpenSoon();
      return session;
    }
    _pushBatch(localId, buffer) {
      if (this._batchState.end >= MAX_BATCH) {
        this._sendBatch(this._batch, this._batchState);
        this._batch = [];
        this._batchState = { buffer: null, start: 0, end: 1 };
      }
      if (this._batch.length === 0 || this._batch[this._batch.length - 1].localId !== localId) {
        this._batchState.end++;
        c.uint.preencode(this._batchState, localId);
      }
      c.buffer.preencode(this._batchState, buffer);
      this._batch.push({ localId, buffer });
    }
    _sendBatch(batch, state) {
      if (batch.length === 0)
        return;
      let prev = batch[0].localId;
      state.buffer = this._alloc(state.end);
      state.buffer[state.start++] = 0;
      state.buffer[state.start++] = 0;
      c.uint.encode(state, prev);
      for (let i = 0;i < batch.length; i++) {
        const b = batch[i];
        if (prev !== b.localId) {
          state.buffer[state.start++] = 0;
          c.uint.encode(state, prev = b.localId);
        }
        c.buffer.encode(state, b.buffer);
      }
      this.drained = this.stream.write(state.buffer);
    }
    _get(protocol, id, aliases = []) {
      const key = toKey(protocol, id);
      let info = this._infos.get(key);
      if (info)
        return info;
      info = { key, protocol, aliases: [], id, pairing: 0, opened: 0, incoming: [], outgoing: [], lastChannel: null };
      this._infos.set(key, info);
      for (const alias of aliases) {
        const key2 = toKey(alias, id);
        info.aliases.push(key2);
        this._infos.set(key2, info);
      }
      return info;
    }
    _gc(info) {
      if (info.opened === 0 && info.outgoing.length === 0 && info.incoming.length === 0) {
        this._infos.delete(info.key);
        for (const alias of info.aliases)
          this._infos.delete(alias);
      }
    }
    _ondata(buffer) {
      if (buffer.byteLength === 0)
        return;
      try {
        const state = { buffer, start: 0, end: buffer.byteLength };
        this._decode(c.uint.decode(state), state);
      } catch (err) {
        this._safeDestroy(err);
      }
    }
    _ondrain() {
      this.drained = true;
      for (const s of this._local) {
        if (s !== null)
          s._track(s.ondrain(s));
      }
    }
    _onend() {
      this.stream.end();
    }
    _decode(remoteId, state) {
      const type = c.uint.decode(state);
      if (remoteId === 0) {
        return this._oncontrolsession(type, state);
      }
      const r = remoteId <= this._remote.length ? this._remote[remoteId - 1] : null;
      if (r === null)
        return null;
      if (r.pending !== null) {
        this._bufferMessage(r, type, state);
        return null;
      }
      return r.session._recv(type, state);
    }
    _oncontrolsession(type, state) {
      switch (type) {
        case 0:
          this._onbatch(state);
          break;
        case 1:
          return this._onopensession(state);
        case 2:
          this._onrejectsession(state);
          break;
        case 3:
          this._onclosesession(state);
          break;
      }
      return null;
    }
    _bufferMessage(r, type, { buffer, start, end }) {
      const state = { buffer, start, end };
      r.pending.push({ type, state });
      this._buffered += byteSize(state);
      this._pauseMaybe();
    }
    _pauseMaybe() {
      if (this._paused === true || this._buffered <= MAX_BUFFERED)
        return;
      this._paused = true;
      this.stream.pause();
    }
    _resumeMaybe() {
      if (this._paused === false || this._buffered > MAX_BUFFERED)
        return;
      this._paused = false;
      this.stream.resume();
    }
    _onbatch(state) {
      const end = state.end;
      let remoteId = c.uint.decode(state);
      let waiting = null;
      while (state.end > state.start) {
        const len = c.uint.decode(state);
        if (len === 0) {
          remoteId = c.uint.decode(state);
          continue;
        }
        state.end = state.start + len;
        if (end !== state.end && waiting === null) {
          waiting = [];
          this.cork();
        }
        const p = this._decode(remoteId, state);
        if (waiting !== null && p !== null)
          waiting.push(p);
        state.start = state.end;
        state.end = end;
      }
      if (waiting !== null) {
        Promise.all(waiting).then(this._uncorkBound, this._safeDestroyBound);
      }
    }
    _onopensession(state) {
      const remoteId = c.uint.decode(state);
      const protocol = c.string.decode(state);
      const id = unslab(c.buffer.decode(state));
      if (remoteId === 0) {
        this._rejectSession(0);
        return null;
      }
      const rid = remoteId - 1;
      const info = this._get(protocol, id);
      if (this._remote.length === rid) {
        this._remote.push(null);
      }
      if (rid >= this._remote.length || this._remote[rid] !== null) {
        throw new Error("Invalid open message");
      }
      if (info.outgoing.length > 0) {
        const localId = info.outgoing.shift();
        const session = this._local[localId - 1];
        if (session === null) {
          this._free.push(localId - 1);
          return null;
        }
        this._remote[rid] = { state, pending: null, session: null };
        session._remoteId = remoteId;
        session._fullyOpen();
        return null;
      }
      const copyState = { buffer: state.buffer, start: state.start, end: state.end };
      this._remote[rid] = { state: copyState, pending: [], session: null };
      if (++this._remoteBacklog > MAX_BACKLOG) {
        throw new Error("Remote exceeded backlog");
      }
      info.pairing++;
      info.incoming.push(remoteId);
      return this._requestSession(protocol, id, info).catch(this._safeDestroyBound);
    }
    _onrejectsession(state) {
      const localId = c.uint.decode(state);
      for (const info of this._infos.values()) {
        const i = info.outgoing.indexOf(localId);
        if (i === -1)
          continue;
        info.outgoing.splice(i, 1);
        const session = this._local[localId - 1];
        this._free.push(localId - 1);
        if (session !== null)
          session._close(true);
        this._gc(info);
        return;
      }
      throw new Error("Invalid reject message");
    }
    _onclosesession(state) {
      const remoteId = c.uint.decode(state);
      if (remoteId === 0)
        return;
      const rid = remoteId - 1;
      const r = rid < this._remote.length ? this._remote[rid] : null;
      if (r === null)
        return;
      if (r.session !== null)
        r.session._close(true);
    }
    async _requestSession(protocol, id, info) {
      const notify = this._notify.get(toKey(protocol, id)) || this._notify.get(toKey(protocol, null));
      if (notify)
        await notify(id);
      if (--info.pairing > 0)
        return;
      while (info.incoming.length > 0) {
        this._rejectSession(info, info.incoming.shift());
      }
      this._gc(info);
    }
    _rejectSession(info, remoteId) {
      if (remoteId > 0) {
        const r = this._remote[remoteId - 1];
        if (r.pending !== null) {
          for (let i = 0;i < r.pending.length; i++) {
            this._buffered -= byteSize(r.pending[i].state);
          }
        }
        this._remote[remoteId - 1] = null;
        this._resumeMaybe();
      }
      const state = { buffer: null, start: 2, end: 2 };
      c.uint.preencode(state, remoteId);
      state.buffer = this._alloc(state.end);
      state.buffer[0] = 0;
      state.buffer[1] = 2;
      c.uint.encode(state, remoteId);
      this._write0(state.buffer);
    }
    _write0(buffer) {
      if (this._batch !== null) {
        this._pushBatch(0, buffer.subarray(1));
        return;
      }
      this.drained = this.stream.write(buffer);
    }
    destroy(err) {
      this.stream.destroy(err);
    }
    _safeDestroy(err) {
      safetyCatch(err);
      this.stream.destroy(err);
    }
    _shutdown() {
      for (const s of this._local) {
        if (s !== null)
          s._close(true);
      }
    }
  };
  function noop() {}
  function toKey(protocol, id) {
    return protocol + "##" + (id ? b4a.toString(id, "hex") : "");
  }
  function byteSize(state) {
    return 512 + (state.end - state.start);
  }
  function isPromise(p) {
    return !!(p && typeof p.then === "function");
  }
  function encodingLength(enc, val) {
    const state = { buffer: null, start: 0, end: 0 };
    enc.preencode(state, val);
    return state.end;
  }
});

// node_modules/hyperschema/runtime.cjs
var require_runtime2 = __commonJS((exports, module) => {
  module.exports = {
    c: require_compact_encoding()
  };
});

// node_modules/protomux-wakeup/spec/hyperschema/index.js
var require_hyperschema = __commonJS((exports, module) => {
  var VERSION = 1;
  var { c } = require_runtime2();
  var version = VERSION;
  var encoding0 = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      const flags = m.active ? 1 : 0;
      c.uint.encode(state, flags);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        active: (flags & 1) !== 0
      };
    }
  };
  var encoding1 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      c.fixed32.preencode(state, m.capability);
      state.end++;
    },
    encode(state, m) {
      const flags = m.active ? 1 : 0;
      c.uint.encode(state, m.version);
      c.fixed32.encode(state, m.capability);
      c.uint.encode(state, flags);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.fixed32.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: r0,
        capability: r1,
        active: (flags & 1) !== 0
      };
    }
  };
  var encoding2 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.key);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      const r0 = c.fixed32.decode(state);
      const r1 = c.uint.decode(state);
      return {
        key: r0,
        length: r1
      };
    }
  };
  var encoding3 = c.array(encoding2);
  var encoding4 = {
    preencode(state, m) {
      state.end++;
      if (m.hash)
        c.fixed32.preencode(state, m.hash);
    },
    encode(state, m) {
      const flags = m.hash ? 1 : 0;
      c.uint.encode(state, flags);
      if (m.hash)
        c.fixed32.encode(state, m.hash);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        hash: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  function setVersion(v) {
    version = v;
  }
  function encode(name, value, v = VERSION) {
    version = v;
    return c.encode(getEncoding(name), value);
  }
  function decode(name, buffer, v = VERSION) {
    version = v;
    return c.decode(getEncoding(name), buffer);
  }
  function getEnum(name) {
    switch (name) {
      default:
        throw new Error("Enum not found " + name);
    }
  }
  function getEncoding(name) {
    switch (name) {
      case "@wakeup/info":
        return encoding0;
      case "@wakeup/handshake":
        return encoding1;
      case "@wakeup/writer":
        return encoding2;
      case "@wakeup/announce":
        return encoding3;
      case "@wakeup/lookup":
        return encoding4;
      default:
        throw new Error("Encoder not found " + name);
    }
  }
  function getStruct(name, v = VERSION) {
    const enc = getEncoding(name);
    return {
      preencode(state, m) {
        version = v;
        enc.preencode(state, m);
      },
      encode(state, m) {
        version = v;
        enc.encode(state, m);
      },
      decode(state) {
        version = v;
        return enc.decode(state);
      }
    };
  }
  var resolveStruct = getStruct;
  module.exports = { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version };
});

// node_modules/protomux-wakeup/index.js
var require_protomux_wakeup = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var Protomux = require_protomux();
  var b4a = require_b4a();
  var schema = require_hyperschema();
  var [
    NS_INITATOR,
    NS_RESPONDER
  ] = crypto.namespace("wakeup", 2);
  var Handshake = schema.getEncoding("@wakeup/handshake");
  var Announce = schema.getEncoding("@wakeup/announce");
  var Lookup = schema.getEncoding("@wakeup/lookup");
  var Info = schema.getEncoding("@wakeup/info");
  module.exports = class WakeupSwarm {
    constructor(onwakeup = noop) {
      this.topics = new Map;
      this.topicsGC = new Set;
      this.muxers = new Set;
      this.onwakeup = onwakeup;
      this._gcInterval = null;
      this._gcBound = this._gc.bind(this);
    }
    session(capability, handlers = {}) {
      const id = handlers.discoveryKey || crypto.discoveryKey(capability);
      const active = handlers.active !== false;
      const hex = b4a.toString(id, "hex");
      let w = this.topics.get(hex);
      if (w)
        return w.addSession(handlers);
      w = new WakeupTopic(this, id, capability, active);
      this.topics.set(hex, w);
      for (const muxer of this.muxers) {
        w._onopen(muxer, true);
      }
      return w.addSession(handlers);
    }
    addStream(stream) {
      const noiseStream = stream.noiseStream || stream;
      if (!noiseStream.connected) {
        noiseStream.once("open", this.addStream.bind(this, noiseStream));
        return;
      }
      const muxer = getMuxer(noiseStream);
      muxer.pair({ protocol: "wakeup" }, (id) => this._onpair(id, muxer));
      this.muxers.add(muxer);
      noiseStream.on("close", () => this.muxers.delete(muxer));
      for (const w of this.topics.values()) {
        if (!w.isActive)
          continue;
        w._onopen(muxer, true);
      }
    }
    _onActive(w) {
      for (const m of this.muxers) {
        w._onopen(m, false);
      }
    }
    _addGC(topic) {
      if (topic.destroyed)
        return;
      this.topicsGC.add(topic);
      if (this._gcInterval === null) {
        this._gcInterval = setInterval(this._gcBound, 2000);
      }
    }
    _removeGC(topic) {
      this.topicsGC.delete(topic);
      if (this.topicsGC.size === 0 && this._gcInterval) {
        clearInterval(this._gcInterval);
        this._gcInterval = null;
      }
    }
    _gc() {
      const destroy = [];
      for (const w of this.topicsGC) {
        w.idleTicks++;
        if (w.idleTicks >= 5)
          destroy.push(w);
      }
      for (const w of destroy)
        w.teardown();
    }
    destroy() {
      if (this._gcInterval)
        clearInterval(this._gcInterval);
      this._gcInterval = null;
      for (const w of this.topics.values())
        w.teardown();
    }
    async _onpair(id, stream) {
      const hex = b4a.toString(id, "hex");
      const w = this.topics.get(hex);
      if (!w || !w.sessions.length)
        return this.onwakeup(id, stream);
      w._onopen(getMuxer(stream), false);
    }
  };

  class WakeupPeer {
    constructor(topic) {
      this.index = 0;
      this.userData = null;
      this.clock = 0;
      this.pending = true;
      this.removed = false;
      this.topic = topic;
      this.channel = null;
      this.stream = null;
      this.wireLookup = null;
      this.wireAnnounce = null;
      this.wireInfo = null;
    }
    unlink(list) {
      const head = list.pop();
      if (head === this)
        return;
      head.index = this.index;
      list[head.index] = head;
    }
  }

  class WakeupSession {
    constructor(topic, handlers) {
      this.index = 0;
      this.topic = topic;
      this.handlers = handlers;
      this.isActive = handlers.active !== false;
      this.destroyed = false;
    }
    get peers() {
      return this.topic.peers;
    }
    addStream(stream) {
      this.topic.addStream(stream);
    }
    getPeer(stream) {
      return this.topic.peersByStream.get(stream) || null;
    }
    broadcastLookup(req) {
      for (const peer of this.topic.pendingPeers) {
        this.lookup(peer, req);
      }
      for (const peer of this.topic.peers) {
        this.lookup(peer, req);
      }
    }
    lookupByStream(stream, req) {
      const peer = this.topic.peersByStream.get(stream);
      if (peer)
        this.lookup(peer, req);
    }
    lookup(peer, req) {
      peer.wireLookup.send(req || { hash: null });
    }
    announceByStream(stream, wakeup) {
      const peer = this.topic.peersByStream.get(stream);
      if (peer && !peer.pending)
        this.announce(peer, wakeup);
    }
    announce(peer, wakeup) {
      peer.wireAnnounce.send(wakeup);
    }
    active() {
      this.isActive = true;
      this.topic._bumpActivity();
    }
    inactive() {
      this.isActive = false;
      this.topic._bumpActivity();
    }
    destroy() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.topic.removeSession(this);
    }
  }

  class WakeupTopic {
    constructor(state, id, capability, active) {
      this.state = state;
      this.sessions = [];
      this.id = id;
      this.capability = capability;
      this.peers = [];
      this.pendingPeers = [];
      this.peersByStream = new Map;
      this.activePeers = 0;
      this.isActive = active;
      this.idleTicks = 0;
      this.gcing = false;
      this.destroyed = false;
    }
    addSession(handlers) {
      const session = new WakeupSession(this, handlers);
      session.index = this.sessions.length;
      this.sessions.push(session);
      this._bumpActivity();
      return session;
    }
    removeSession(session) {
      if (this.sessions.length <= session.index)
        return;
      if (this.sessions[session.index] !== session)
        return;
      const head = this.sessions.pop();
      if (head !== session) {
        head.index = session.index;
        this.sessions[head.index] = head;
      }
      this._bumpActivity();
      this._checkGC();
    }
    _bumpActivity() {
      let isActive = false;
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        if (this.sessions[i].isActive) {
          isActive = true;
          break;
        }
      }
      if (isActive)
        this.active();
      else
        this.inactive();
    }
    active() {
      if (this.isActive)
        return;
      this.idleTicks = 0;
      this.isActive = true;
      this._updateActive(true);
    }
    inactive() {
      if (!this.isActive)
        return;
      this.isActive = false;
      this._updateActive(false);
    }
    _updateActive(active) {
      const info = { active };
      for (const peer of this.pendingPeers)
        peer.wireInfo.send(info);
      for (const peer of this.peers)
        peer.wireInfo.send(info);
      this._checkGC();
      if (active)
        this.state._onActive(this);
    }
    teardown() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      for (let i = this.peers.length - 1;i >= 0; i--) {
        this.peers[i].channel.close();
      }
      for (let i = this.pendingPeers.length - 1;i >= 0; i--) {
        this.pendingPeers[i].channel.close();
      }
      const hex = b4a.toString(this.id, "hex");
      this.gcing = false;
      this.state.topics.delete(hex);
      this.state._removeGC(this);
    }
    addStream(stream) {
      this._onopen(getMuxer(stream), false);
    }
    _proveCapabilityTo(stream) {
      return this._makeCapability(stream.isInitiator, stream.handshakeHash);
    }
    _makeCapability(isInitiator, handshakeHash) {
      return crypto.hash([isInitiator ? NS_INITATOR : NS_RESPONDER, this.capability, handshakeHash]);
    }
    _addPeer(peer, open) {
      if (!b4a.equals(open.capability, this._makeCapability(!peer.stream.isInitiator, peer.stream.handshakeHash))) {
        peer.channel.close();
        return;
      }
      if (peer.pending) {
        peer.unlink(this.pendingPeers);
      }
      peer.active = open.active;
      peer.pending = false;
      peer.index = this.peers.push(peer) - 1;
      if (peer.active) {
        this.activePeers++;
        this._checkGC();
      }
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        const session = this.sessions[i];
        const handlers = session.handlers;
        if (handlers.onpeeradd)
          handlers.onpeeradd(peer, session);
        if (peer.active && handlers.onpeeractive)
          handlers.onpeeractive(peer, session);
      }
    }
    _checkGC() {
      const shouldGC = this.activePeers === 0 && this.sessions.length === 0;
      if (shouldGC) {
        if (!this.gcing) {
          this.gcing = true;
          this.state._addGC(this);
        }
      } else {
        if (this.gcing) {
          this.gcing = false;
          this.state._removeGC(this);
        }
      }
    }
    _removePeer(peer) {
      peer.removed = true;
      this.peersByStream.delete(peer.stream);
      if (peer.pending) {
        peer.unlink(this.pendingPeers);
        return;
      }
      const active = peer.active;
      if (active) {
        peer.active = false;
        this.activePeers--;
        this._checkGC();
      }
      peer.unlink(this.peers);
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        const session = this.sessions[i];
        const handlers = session.handlers;
        if (active && handlers.onpeerinactive)
          handlers.onpeerinactive(peer, session);
        if (handlers.onpeerremove)
          handlers.onpeerremove(peer, session);
      }
    }
    _onannounce(wakeup, peer) {
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        const session = this.sessions[i];
        const handlers = session.handlers;
        if (handlers.onannounce)
          handlers.onannounce(wakeup, peer, session);
      }
    }
    _onlookup(req, peer) {
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        const session = this.sessions[i];
        const handlers = session.handlers;
        if (handlers.onlookup)
          handlers.onlookup(req, peer, session);
      }
    }
    _oninfo(info, peer) {
      if (info.active) {
        if (!peer.active) {
          peer.active = true;
          this.activePeers++;
          this._checkGC();
          for (let i = this.sessions.length - 1;i >= 0; i--) {
            const session = this.sessions[i];
            const handlers = session.handlers;
            if (handlers.onpeeractive)
              handlers.onpeeractive(peer, session);
          }
        }
      } else {
        if (peer.active) {
          peer.active = false;
          this.activePeers--;
          this._checkGC();
          for (let i = this.sessions.length - 1;i >= 0; i--) {
            const session = this.sessions[i];
            const handlers = session.handlers;
            if (handlers.onpeerinactive)
              handlers.onpeerinactive(peer, session);
          }
        }
      }
    }
    _onopen(muxer, unique) {
      if (!unique && this.peersByStream.has(muxer.stream))
        return;
      const peer = new WakeupPeer(this);
      const ch = muxer.createChannel({
        userData: peer,
        protocol: "wakeup",
        id: this.id,
        handshake: Handshake,
        messages: [
          { encoding: Lookup, onmessage: onlookup },
          { encoding: Announce, onmessage: onannounce },
          { encoding: Info, onmessage: onchannelinfo }
        ],
        onopen: onchannelopen,
        onclose: onchannelclose
      });
      if (!ch)
        return;
      peer.channel = ch;
      peer.stream = muxer.stream;
      peer.wireLookup = ch.messages[0];
      peer.wireAnnounce = ch.messages[1];
      peer.wireInfo = ch.messages[2];
      peer.index = this.pendingPeers.push(peer) - 1;
      this.peersByStream.set(muxer.stream, peer);
      ch.open({
        version: 0,
        capability: this._proveCapabilityTo(muxer.stream),
        active: this.isActive
      });
    }
  }
  function onchannelopen(open, channel) {
    const peer = channel.userData;
    peer.topic._addPeer(peer, open);
  }
  function onchannelclose(close, channel) {
    const peer = channel.userData;
    peer.topic._removePeer(peer);
  }
  function onlookup(req, channel) {
    const peer = channel.userData;
    peer.topic._onlookup(req, peer);
  }
  function onannounce(wakeup, channel) {
    const peer = channel.userData;
    peer.topic._onannounce(wakeup, peer);
  }
  function onchannelinfo(info, channel) {
    const peer = channel.userData;
    peer.topic._oninfo(info, peer);
  }
  function getMuxer(stream) {
    if (Protomux.isProtomux(stream))
      return stream;
    if (stream.noiseStream.userData)
      return stream.noiseStream.userData;
    const mux = Protomux.from(stream.noiseStream);
    stream.noiseStream.userData = mux;
    return mux;
  }
  function noop() {}
});

// node_modules/resolve-reject-promise/index.js
var require_resolve_reject_promise = __commonJS((exports, module) => {
  var tmpResolve = null;
  var tmpReject = null;
  if (Promise.withResolvers) {
    module.exports = Promise.withResolvers.bind(Promise);
  } else {
    module.exports = function resolveRejectPromise() {
      const promise = new Promise(setTmp);
      const result = { promise, resolve: tmpResolve, reject: tmpReject };
      tmpResolve = tmpReject = null;
      return result;
    };
  }
  function setTmp(resolve, reject) {
    tmpResolve = resolve;
    tmpReject = reject;
  }
});

// node_modules/is-options/index.js
var require_is_options = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = function isOptions(opts) {
    return typeof opts === "object" && opts && !b4a.isBuffer(opts);
  };
});

// node_modules/rocksdb-native/binding.js
var require_binding2 = __commonJS((exports, module) => {
  var __filename = "/Users/odinsson/Dev/pear/easybase/node_modules/rocksdb-native/binding.js";
  __require.addon = require_require_addon();
  module.exports = __require.addon(".", __filename);
});

// node_modules/rocksdb-native/lib/filter-policy.js
var require_filter_policy = __commonJS((exports) => {
  exports.BloomFilterPolicy = class RocksDBBloomFilterPolicy {
    get type() {
      return 1;
    }
    constructor(bitsPerKey) {
      this.bitsPerKey = bitsPerKey;
    }
  };
  exports.RibbonFilterPolicy = class RocksDBRibbonFilterPolicy {
    get type() {
      return 2;
    }
    constructor(bloomEquivalentBitsPerKey, bloomBeforeLevel = 0) {
      this.bloomEquivalentBitsPerKey = bloomEquivalentBitsPerKey;
      this.bloomBeforeLevel = bloomBeforeLevel;
    }
  };
});

// node_modules/rocksdb-native/lib/column-family.js
var require_column_family = __commonJS((exports, module) => {
  var binding = require_binding2();
  var { BloomFilterPolicy } = require_filter_policy();

  class RocksDBColumnFamily {
    constructor(name, opts = {}) {
      const {
        enableBlobFiles = false,
        minBlobSize = 0,
        blobFileSize = 0,
        enableBlobGarbageCollection = true,
        tableBlockSize = 8192,
        tableCacheIndexAndFilterBlocks = true,
        tableFormatVersion = 6,
        optimizeFiltersForMemory = false,
        blockCache = true,
        filterPolicy = new BloomFilterPolicy(10)
      } = opts;
      this._name = name;
      this._flushing = null;
      this._options = {
        enableBlobFiles,
        minBlobSize,
        blobFileSize,
        enableBlobGarbageCollection,
        tableBlockSize,
        tableCacheIndexAndFilterBlocks,
        tableFormatVersion,
        optimizeFiltersForMemory,
        blockCache,
        filterPolicy
      };
      const filterPolicyArguments = [];
      if (filterPolicy === null)
        filterPolicyArguments.push(0);
      else {
        filterPolicyArguments.push(filterPolicy.type);
        switch (filterPolicy.type) {
          case 1:
            filterPolicyArguments.push(filterPolicy.bitsPerKey);
            break;
          case 2:
            filterPolicyArguments.push(filterPolicy.bloomEquivalentBitsPerKey, filterPolicy.bloomBeforeLevel);
            break;
        }
      }
      this._handle = binding.columnFamilyInit(name, enableBlobFiles, minBlobSize, blobFileSize, enableBlobGarbageCollection, tableBlockSize, tableCacheIndexAndFilterBlocks, tableFormatVersion, optimizeFiltersForMemory, blockCache === false, ...filterPolicyArguments);
    }
    cloneSettings(name) {
      return new RocksDBColumnFamily(name, this._options);
    }
    get name() {
      return this._name;
    }
    destroy() {
      if (this._handle === null)
        return;
      binding.columnFamilyDestroy(this._handle);
      this._handle = null;
    }
  }
  module.exports = RocksDBColumnFamily;
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS((exports, module) => {
  module.exports = class FixedFIFO {
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
        throw new Error("Max size for a FixedFIFO should be a power of two");
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    clear() {
      this.top = this.btm = 0;
      this.next = null;
      this.buffer.fill(undefined);
    }
    push(data) {
      if (this.buffer[this.top] !== undefined)
        return false;
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === undefined)
        return;
      this.buffer[this.btm] = undefined;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    peek() {
      return this.buffer[this.btm];
    }
    isEmpty() {
      return this.buffer[this.btm] === undefined;
    }
  };
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS((exports, module) => {
  var FixedFIFO = require_fixed_size();
  module.exports = class FastFIFO {
    constructor(hwm) {
      this.hwm = hwm || 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.length = 0;
    }
    clear() {
      this.head = this.tail;
      this.head.clear();
      this.length = 0;
    }
    push(val) {
      this.length++;
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      if (this.length !== 0)
        this.length--;
      const val = this.tail.shift();
      if (val === undefined && this.tail.next) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        return this.tail.shift();
      }
      return val;
    }
    peek() {
      const val = this.tail.peek();
      if (val === undefined && this.tail.next)
        return this.tail.next.peek();
      return val;
    }
    isEmpty() {
      return this.length === 0;
    }
  };
});

// node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class PassThroughDecoder {
    constructor(encoding) {
      this.encoding = encoding;
    }
    get remaining() {
      return 0;
    }
    decode(tail) {
      return b4a.toString(tail, this.encoding);
    }
    flush() {
      return "";
    }
  };
});

// node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class UTF8Decoder {
    constructor() {
      this.codePoint = 0;
      this.bytesSeen = 0;
      this.bytesNeeded = 0;
      this.lowerBoundary = 128;
      this.upperBoundary = 191;
    }
    get remaining() {
      return this.bytesSeen;
    }
    decode(data) {
      if (this.bytesNeeded === 0) {
        let isBoundary = true;
        for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength;i < n && isBoundary; i++) {
          isBoundary = data[i] <= 127;
        }
        if (isBoundary)
          return b4a.toString(data, "utf8");
      }
      let result = "";
      for (let i = 0, n = data.byteLength;i < n; i++) {
        const byte = data[i];
        if (this.bytesNeeded === 0) {
          if (byte <= 127) {
            result += String.fromCharCode(byte);
          } else {
            this.bytesSeen = 1;
            if (byte >= 194 && byte <= 223) {
              this.bytesNeeded = 2;
              this.codePoint = byte & 31;
            } else if (byte >= 224 && byte <= 239) {
              if (byte === 224)
                this.lowerBoundary = 160;
              else if (byte === 237)
                this.upperBoundary = 159;
              this.bytesNeeded = 3;
              this.codePoint = byte & 15;
            } else if (byte >= 240 && byte <= 244) {
              if (byte === 240)
                this.lowerBoundary = 144;
              if (byte === 244)
                this.upperBoundary = 143;
              this.bytesNeeded = 4;
              this.codePoint = byte & 7;
            } else {
              result += "�";
            }
          }
          continue;
        }
        if (byte < this.lowerBoundary || byte > this.upperBoundary) {
          this.codePoint = 0;
          this.bytesNeeded = 0;
          this.bytesSeen = 0;
          this.lowerBoundary = 128;
          this.upperBoundary = 191;
          result += "�";
          continue;
        }
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
        this.codePoint = this.codePoint << 6 | byte & 63;
        this.bytesSeen++;
        if (this.bytesSeen !== this.bytesNeeded)
          continue;
        result += String.fromCodePoint(this.codePoint);
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
      }
      return result;
    }
    flush() {
      const result = this.bytesNeeded > 0 ? "�" : "";
      this.codePoint = 0;
      this.bytesNeeded = 0;
      this.bytesSeen = 0;
      this.lowerBoundary = 128;
      this.upperBoundary = 191;
      return result;
    }
  };
});

// node_modules/text-decoder/index.js
var require_text_decoder = __commonJS((exports, module) => {
  var PassThroughDecoder = require_pass_through_decoder();
  var UTF8Decoder = require_utf8_decoder();
  module.exports = class TextDecoder {
    constructor(encoding = "utf8") {
      this.encoding = normalizeEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.decoder = new UTF8Decoder;
          break;
        case "utf16le":
        case "base64":
          throw new Error("Unsupported encoding: " + this.encoding);
        default:
          this.decoder = new PassThroughDecoder(this.encoding);
      }
    }
    get remaining() {
      return this.decoder.remaining;
    }
    push(data) {
      if (typeof data === "string")
        return data;
      return this.decoder.decode(data);
    }
    write(data) {
      return this.push(data);
    }
    end(data) {
      let result = "";
      if (data)
        result = this.push(data);
      result += this.decoder.flush();
      return result;
    }
  };
  function normalizeEncoding(encoding) {
    encoding = encoding.toLowerCase();
    switch (encoding) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return encoding;
      default:
        throw new Error("Unknown encoding: " + encoding);
    }
  }
});

// node_modules/streamx/index.js
var require_streamx = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var STREAM_DESTROYED = new Error("Stream was destroyed");
  var PREMATURE_CLOSE = new Error("Premature close");
  var FIFO = require_fast_fifo();
  var TextDecoder = require_text_decoder();
  var qmt = typeof queueMicrotask === "undefined" ? (fn) => global.process.nextTick(fn) : queueMicrotask;
  var MAX = (1 << 29) - 1;
  var OPENING = 1;
  var PREDESTROYING = 2;
  var DESTROYING = 4;
  var DESTROYED = 8;
  var NOT_OPENING = MAX ^ OPENING;
  var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
  var READ_ACTIVE = 1 << 4;
  var READ_UPDATING = 2 << 4;
  var READ_PRIMARY = 4 << 4;
  var READ_QUEUED = 8 << 4;
  var READ_RESUMED = 16 << 4;
  var READ_PIPE_DRAINED = 32 << 4;
  var READ_ENDING = 64 << 4;
  var READ_EMIT_DATA = 128 << 4;
  var READ_EMIT_READABLE = 256 << 4;
  var READ_EMITTED_READABLE = 512 << 4;
  var READ_DONE = 1024 << 4;
  var READ_NEXT_TICK = 2048 << 4;
  var READ_NEEDS_PUSH = 4096 << 4;
  var READ_READ_AHEAD = 8192 << 4;
  var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
  var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
  var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
  var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
  var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
  var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
  var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
  var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
  var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
  var READ_PAUSED = MAX ^ READ_RESUMED;
  var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
  var READ_NOT_ENDING = MAX ^ READ_ENDING;
  var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
  var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
  var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
  var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
  var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
  var WRITE_ACTIVE = 1 << 18;
  var WRITE_UPDATING = 2 << 18;
  var WRITE_PRIMARY = 4 << 18;
  var WRITE_QUEUED = 8 << 18;
  var WRITE_UNDRAINED = 16 << 18;
  var WRITE_DONE = 32 << 18;
  var WRITE_EMIT_DRAIN = 64 << 18;
  var WRITE_NEXT_TICK = 128 << 18;
  var WRITE_WRITING = 256 << 18;
  var WRITE_FINISHING = 512 << 18;
  var WRITE_CORKED = 1024 << 18;
  var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
  var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
  var WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
  var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
  var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
  var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
  var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
  var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
  var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
  var NOT_ACTIVE = MAX ^ ACTIVE;
  var DONE = READ_DONE | WRITE_DONE;
  var DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
  var OPEN_STATUS = DESTROY_STATUS | OPENING;
  var AUTO_DESTROY = DESTROY_STATUS | DONE;
  var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
  var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
  var TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
  var IS_OPENING = OPEN_STATUS | TICKING;
  var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
  var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
  var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
  var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
  var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
  var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
  var READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
  var READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
  var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
  var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
  var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
  var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
  var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
  var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
  var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
  var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
  var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
  var WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
  var WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
  var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");

  class WritableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
      this.stream = stream;
      this.queue = new FIFO;
      this.highWaterMark = highWaterMark;
      this.buffered = 0;
      this.error = null;
      this.pipeline = null;
      this.drains = null;
      this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
      this.map = mapWritable || map;
      this.afterWrite = afterWrite.bind(this);
      this.afterUpdateNextTick = updateWriteNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & WRITE_DONE) !== 0;
    }
    push(data) {
      if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0)
        return false;
      if (this.map !== null)
        data = this.map(data);
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      if (this.buffered < this.highWaterMark) {
        this.stream._duplexState |= WRITE_QUEUED;
        return true;
      }
      this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
      return false;
    }
    shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0)
        this.stream._duplexState &= WRITE_NOT_QUEUED;
      return data;
    }
    end(data) {
      if (typeof data === "function")
        this.stream.once("finish", data);
      else if (data !== undefined && data !== null)
        this.push(data);
      this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
    }
    autoBatch(data, cb) {
      const buffer = [];
      const stream = this.stream;
      buffer.push(data);
      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
        buffer.push(stream._writableState.shift());
      }
      if ((stream._duplexState & OPEN_STATUS) !== 0)
        return cb(null);
      stream._writev(buffer, cb);
    }
    update() {
      const stream = this.stream;
      stream._duplexState |= WRITE_UPDATING;
      do {
        while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
          const data = this.shift();
          stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
          stream._write(data, this.afterWrite);
        }
        if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === true);
      stream._duplexState &= WRITE_NOT_UPDATING;
    }
    updateNonPrimary() {
      const stream = this.stream;
      if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
        stream._duplexState = stream._duplexState | WRITE_ACTIVE;
        stream._final(afterFinal.bind(this));
        return;
      }
      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;
          stream._destroy(afterDestroy.bind(this));
        }
        return;
      }
      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
        stream._open(afterOpen.bind(this));
      }
    }
    continueUpdate() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0)
        return false;
      this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
      return true;
    }
    updateCallback() {
      if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTick() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
        return;
      this.stream._duplexState |= WRITE_NEXT_TICK;
      if ((this.stream._duplexState & WRITE_UPDATING) === 0)
        qmt(this.afterUpdateNextTick);
    }
  }

  class ReadableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
      this.stream = stream;
      this.queue = new FIFO;
      this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
      this.buffered = 0;
      this.readAhead = highWaterMark > 0;
      this.error = null;
      this.pipeline = null;
      this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
      this.map = mapReadable || map;
      this.pipeTo = null;
      this.afterRead = afterRead.bind(this);
      this.afterUpdateNextTick = updateReadNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & READ_DONE) !== 0;
    }
    pipe(pipeTo, cb) {
      if (this.pipeTo !== null)
        throw new Error("Can only pipe to one destination");
      if (typeof cb !== "function")
        cb = null;
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.pipeTo = pipeTo;
      this.pipeline = new Pipeline(this.stream, pipeTo, cb);
      if (cb)
        this.stream.on("error", noop);
      if (isStreamx(pipeTo)) {
        pipeTo._writableState.pipeline = this.pipeline;
        if (cb)
          pipeTo.on("error", noop);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      } else {
        const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
        const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
        pipeTo.on("error", onerror);
        pipeTo.on("close", onclose);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      }
      pipeTo.on("drain", afterDrain.bind(this));
      this.stream.emit("piping", pipeTo);
      pipeTo.emit("pipe", this.stream);
    }
    push(data) {
      const stream = this.stream;
      if (data === null) {
        this.highWaterMark = 0;
        stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
        return false;
      }
      if (this.map !== null) {
        data = this.map(data);
        if (data === null) {
          stream._duplexState &= READ_PUSHED;
          return this.buffered < this.highWaterMark;
        }
      }
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
      return this.buffered < this.highWaterMark;
    }
    shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0)
        this.stream._duplexState &= READ_NOT_QUEUED;
      return data;
    }
    unshift(data) {
      const pending = [this.map !== null ? this.map(data) : data];
      while (this.buffered > 0)
        pending.push(this.shift());
      for (let i = 0;i < pending.length - 1; i++) {
        const data2 = pending[i];
        this.buffered += this.byteLength(data2);
        this.queue.push(data2);
      }
      this.push(pending[pending.length - 1]);
    }
    read() {
      const stream = this.stream;
      if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false)
          stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0)
          stream.emit("data", data);
        return data;
      }
      if (this.readAhead === false) {
        stream._duplexState |= READ_READ_AHEAD;
        this.updateNextTick();
      }
      return null;
    }
    drain() {
      const stream = this.stream;
      while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false)
          stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0)
          stream.emit("data", data);
      }
    }
    update() {
      const stream = this.stream;
      stream._duplexState |= READ_UPDATING;
      do {
        this.drain();
        while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
          stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
          stream._read(this.afterRead);
          this.drain();
        }
        if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
          stream._duplexState |= READ_EMITTED_READABLE;
          stream.emit("readable");
        }
        if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === true);
      stream._duplexState &= READ_NOT_UPDATING;
    }
    updateNonPrimary() {
      const stream = this.stream;
      if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
        stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
        stream.emit("end");
        if ((stream._duplexState & AUTO_DESTROY) === DONE)
          stream._duplexState |= DESTROYING;
        if (this.pipeTo !== null)
          this.pipeTo.end();
      }
      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;
          stream._destroy(afterDestroy.bind(this));
        }
        return;
      }
      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
        stream._open(afterOpen.bind(this));
      }
    }
    continueUpdate() {
      if ((this.stream._duplexState & READ_NEXT_TICK) === 0)
        return false;
      this.stream._duplexState &= READ_NOT_NEXT_TICK;
      return true;
    }
    updateCallback() {
      if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTickIfOpen() {
      if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0)
        return;
      this.stream._duplexState |= READ_NEXT_TICK;
      if ((this.stream._duplexState & READ_UPDATING) === 0)
        qmt(this.afterUpdateNextTick);
    }
    updateNextTick() {
      if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
        return;
      this.stream._duplexState |= READ_NEXT_TICK;
      if ((this.stream._duplexState & READ_UPDATING) === 0)
        qmt(this.afterUpdateNextTick);
    }
  }

  class TransformState {
    constructor(stream) {
      this.data = null;
      this.afterTransform = afterTransform.bind(stream);
      this.afterFinal = null;
    }
  }

  class Pipeline {
    constructor(src, dst, cb) {
      this.from = src;
      this.to = dst;
      this.afterPipe = cb;
      this.error = null;
      this.pipeToFinished = false;
    }
    finished() {
      this.pipeToFinished = true;
    }
    done(stream, err) {
      if (err)
        this.error = err;
      if (stream === this.to) {
        this.to = null;
        if (this.from !== null) {
          if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
            this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
          }
          return;
        }
      }
      if (stream === this.from) {
        this.from = null;
        if (this.to !== null) {
          if ((stream._duplexState & READ_DONE) === 0) {
            this.to.destroy(this.error || new Error("Readable stream closed before ending"));
          }
          return;
        }
      }
      if (this.afterPipe !== null)
        this.afterPipe(this.error);
      this.to = this.from = this.afterPipe = null;
    }
  }
  function afterDrain() {
    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.updateCallback();
  }
  function afterFinal(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & DESTROY_STATUS) === 0) {
      stream._duplexState |= WRITE_DONE;
      stream.emit("finish");
    }
    if ((stream._duplexState & AUTO_DESTROY) === DONE) {
      stream._duplexState |= DESTROYING;
    }
    stream._duplexState &= WRITE_NOT_FINISHING;
    if ((stream._duplexState & WRITE_UPDATING) === 0)
      this.update();
    else
      this.updateNextTick();
  }
  function afterDestroy(err) {
    const stream = this.stream;
    if (!err && this.error !== STREAM_DESTROYED)
      err = this.error;
    if (err)
      stream.emit("error", err);
    stream._duplexState |= DESTROYED;
    stream.emit("close");
    const rs = stream._readableState;
    const ws = stream._writableState;
    if (rs !== null && rs.pipeline !== null)
      rs.pipeline.done(stream, err);
    if (ws !== null) {
      while (ws.drains !== null && ws.drains.length > 0)
        ws.drains.shift().resolve(false);
      if (ws.pipeline !== null)
        ws.pipeline.done(stream, err);
    }
  }
  function afterWrite(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    stream._duplexState &= WRITE_NOT_ACTIVE;
    if (this.drains !== null)
      tickDrains(this.drains);
    if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
      stream._duplexState &= WRITE_DRAINED;
      if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
        stream.emit("drain");
      }
    }
    this.updateCallback();
  }
  function afterRead(err) {
    if (err)
      this.stream.destroy(err);
    this.stream._duplexState &= READ_NOT_ACTIVE;
    if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0)
      this.stream._duplexState &= READ_NO_READ_AHEAD;
    this.updateCallback();
  }
  function updateReadNT() {
    if ((this.stream._duplexState & READ_UPDATING) === 0) {
      this.stream._duplexState &= READ_NOT_NEXT_TICK;
      this.update();
    }
  }
  function updateWriteNT() {
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
      this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
      this.update();
    }
  }
  function tickDrains(drains) {
    for (let i = 0;i < drains.length; i++) {
      if (--drains[i].writes === 0) {
        drains.shift().resolve(true);
        i--;
      }
    }
  }
  function afterOpen(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & DESTROYING) === 0) {
      if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
        stream._duplexState |= READ_PRIMARY;
      if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
        stream._duplexState |= WRITE_PRIMARY;
      stream.emit("open");
    }
    stream._duplexState &= NOT_ACTIVE;
    if (stream._writableState !== null) {
      stream._writableState.updateCallback();
    }
    if (stream._readableState !== null) {
      stream._readableState.updateCallback();
    }
  }
  function afterTransform(err, data) {
    if (data !== undefined && data !== null)
      this.push(data);
    this._writableState.afterWrite(err);
  }
  function newListener(name) {
    if (this._readableState !== null) {
      if (name === "data") {
        this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
      }
      if (name === "readable") {
        this._duplexState |= READ_EMIT_READABLE;
        this._readableState.updateNextTick();
      }
    }
    if (this._writableState !== null) {
      if (name === "drain") {
        this._duplexState |= WRITE_EMIT_DRAIN;
        this._writableState.updateNextTick();
      }
    }
  }

  class Stream extends EventEmitter {
    constructor(opts) {
      super();
      this._duplexState = 0;
      this._readableState = null;
      this._writableState = null;
      if (opts) {
        if (opts.open)
          this._open = opts.open;
        if (opts.destroy)
          this._destroy = opts.destroy;
        if (opts.predestroy)
          this._predestroy = opts.predestroy;
        if (opts.signal) {
          opts.signal.addEventListener("abort", abort.bind(this));
        }
      }
      this.on("newListener", newListener);
    }
    _open(cb) {
      cb(null);
    }
    _destroy(cb) {
      cb(null);
    }
    _predestroy() {}
    get readable() {
      return this._readableState !== null ? true : undefined;
    }
    get writable() {
      return this._writableState !== null ? true : undefined;
    }
    get destroyed() {
      return (this._duplexState & DESTROYED) !== 0;
    }
    get destroying() {
      return (this._duplexState & DESTROY_STATUS) !== 0;
    }
    destroy(err) {
      if ((this._duplexState & DESTROY_STATUS) === 0) {
        if (!err)
          err = STREAM_DESTROYED;
        this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
        if (this._readableState !== null) {
          this._readableState.highWaterMark = 0;
          this._readableState.error = err;
        }
        if (this._writableState !== null) {
          this._writableState.highWaterMark = 0;
          this._writableState.error = err;
        }
        this._duplexState |= PREDESTROYING;
        this._predestroy();
        this._duplexState &= NOT_PREDESTROYING;
        if (this._readableState !== null)
          this._readableState.updateNextTick();
        if (this._writableState !== null)
          this._writableState.updateNextTick();
      }
    }
  }

  class Readable extends Stream {
    constructor(opts) {
      super(opts);
      this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
      this._readableState = new ReadableState(this, opts);
      if (opts) {
        if (this._readableState.readAhead === false)
          this._duplexState &= READ_NO_READ_AHEAD;
        if (opts.read)
          this._read = opts.read;
        if (opts.eagerOpen)
          this._readableState.updateNextTick();
        if (opts.encoding)
          this.setEncoding(opts.encoding);
      }
    }
    setEncoding(encoding) {
      const dec = new TextDecoder(encoding);
      const map = this._readableState.map || echo;
      this._readableState.map = mapOrSkip;
      return this;
      function mapOrSkip(data) {
        const next = dec.push(data);
        return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
      }
    }
    _read(cb) {
      cb(null);
    }
    pipe(dest, cb) {
      this._readableState.updateNextTick();
      this._readableState.pipe(dest, cb);
      return dest;
    }
    read() {
      this._readableState.updateNextTick();
      return this._readableState.read();
    }
    push(data) {
      this._readableState.updateNextTickIfOpen();
      return this._readableState.push(data);
    }
    unshift(data) {
      this._readableState.updateNextTickIfOpen();
      return this._readableState.unshift(data);
    }
    resume() {
      this._duplexState |= READ_RESUMED_READ_AHEAD;
      this._readableState.updateNextTick();
      return this;
    }
    pause() {
      this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
      return this;
    }
    static _fromAsyncIterator(ite, opts) {
      let destroy;
      const rs = new Readable({
        ...opts,
        read(cb) {
          ite.next().then(push).then(cb.bind(null, null)).catch(cb);
        },
        predestroy() {
          destroy = ite.return();
        },
        destroy(cb) {
          if (!destroy)
            return cb(null);
          destroy.then(cb.bind(null, null)).catch(cb);
        }
      });
      return rs;
      function push(data) {
        if (data.done)
          rs.push(null);
        else
          rs.push(data.value);
      }
    }
    static from(data, opts) {
      if (isReadStreamx(data))
        return data;
      if (data[asyncIterator])
        return this._fromAsyncIterator(data[asyncIterator](), opts);
      if (!Array.isArray(data))
        data = data === undefined ? [] : [data];
      let i = 0;
      return new Readable({
        ...opts,
        read(cb) {
          this.push(i === data.length ? null : data[i++]);
          cb(null);
        }
      });
    }
    static isBackpressured(rs) {
      return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
    static isPaused(rs) {
      return (rs._duplexState & READ_RESUMED) === 0;
    }
    [asyncIterator]() {
      const stream = this;
      let error = null;
      let promiseResolve = null;
      let promiseReject = null;
      this.on("error", (err) => {
        error = err;
      });
      this.on("readable", onreadable);
      this.on("close", onclose);
      return {
        [asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
            const data = stream.read();
            if (data !== null)
              ondata(data);
            else if ((stream._duplexState & DESTROYED) !== 0)
              ondata(null);
          });
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function onreadable() {
        if (promiseResolve !== null)
          ondata(stream.read());
      }
      function onclose() {
        if (promiseResolve !== null)
          ondata(null);
      }
      function ondata(data) {
        if (promiseReject === null)
          return;
        if (error)
          promiseReject(error);
        else if (data === null && (stream._duplexState & READ_DONE) === 0)
          promiseReject(STREAM_DESTROYED);
        else
          promiseResolve({ value: data, done: data === null });
        promiseReject = promiseResolve = null;
      }
      function destroy(err) {
        stream.destroy(err);
        return new Promise((resolve, reject) => {
          if (stream._duplexState & DESTROYED)
            return resolve({ value: undefined, done: true });
          stream.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: undefined, done: true });
          });
        });
      }
    }
  }

  class Writable extends Stream {
    constructor(opts) {
      super(opts);
      this._duplexState |= OPENING | READ_DONE;
      this._writableState = new WritableState(this, opts);
      if (opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
        if (opts.eagerOpen)
          this._writableState.updateNextTick();
      }
    }
    cork() {
      this._duplexState |= WRITE_CORKED;
    }
    uncork() {
      this._duplexState &= WRITE_NOT_CORKED;
      this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    static isBackpressured(ws) {
      return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
    }
    static drained(ws) {
      if (ws.destroyed)
        return Promise.resolve(false);
      const state = ws._writableState;
      const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
      const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
      if (writes === 0)
        return Promise.resolve(true);
      if (state.drains === null)
        state.drains = [];
      return new Promise((resolve) => {
        state.drains.push({ writes, resolve });
      });
    }
    write(data) {
      this._writableState.updateNextTick();
      return this._writableState.push(data);
    }
    end(data) {
      this._writableState.updateNextTick();
      this._writableState.end(data);
      return this;
    }
  }

  class Duplex extends Readable {
    constructor(opts) {
      super(opts);
      this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
      this._writableState = new WritableState(this, opts);
      if (opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
      }
    }
    cork() {
      this._duplexState |= WRITE_CORKED;
    }
    uncork() {
      this._duplexState &= WRITE_NOT_CORKED;
      this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    write(data) {
      this._writableState.updateNextTick();
      return this._writableState.push(data);
    }
    end(data) {
      this._writableState.updateNextTick();
      this._writableState.end(data);
      return this;
    }
  }

  class Transform extends Duplex {
    constructor(opts) {
      super(opts);
      this._transformState = new TransformState(this);
      if (opts) {
        if (opts.transform)
          this._transform = opts.transform;
        if (opts.flush)
          this._flush = opts.flush;
      }
    }
    _write(data, cb) {
      if (this._readableState.buffered >= this._readableState.highWaterMark) {
        this._transformState.data = data;
      } else {
        this._transform(data, this._transformState.afterTransform);
      }
    }
    _read(cb) {
      if (this._transformState.data !== null) {
        const data = this._transformState.data;
        this._transformState.data = null;
        cb(null);
        this._transform(data, this._transformState.afterTransform);
      } else {
        cb(null);
      }
    }
    destroy(err) {
      super.destroy(err);
      if (this._transformState.data !== null) {
        this._transformState.data = null;
        this._transformState.afterTransform();
      }
    }
    _transform(data, cb) {
      cb(null, data);
    }
    _flush(cb) {
      cb(null);
    }
    _final(cb) {
      this._transformState.afterFinal = cb;
      this._flush(transformAfterFlush.bind(this));
    }
  }

  class PassThrough extends Transform {
  }
  function transformAfterFlush(err, data) {
    const cb = this._transformState.afterFinal;
    if (err)
      return cb(err);
    if (data !== null && data !== undefined)
      this.push(data);
    this.push(null);
    cb(null);
  }
  function pipelinePromise(...streams) {
    return new Promise((resolve, reject) => {
      return pipeline(...streams, (err) => {
        if (err)
          return reject(err);
        resolve();
      });
    });
  }
  function pipeline(stream, ...streams) {
    const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
    const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
    if (all.length < 2)
      throw new Error("Pipeline requires at least 2 streams");
    let src = all[0];
    let dest = null;
    let error = null;
    for (let i = 1;i < all.length; i++) {
      dest = all[i];
      if (isStreamx(src)) {
        src.pipe(dest, onerror);
      } else {
        errorHandle(src, true, i > 1, onerror);
        src.pipe(dest);
      }
      src = dest;
    }
    if (done) {
      let fin = false;
      const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
      dest.on("error", (err) => {
        if (error === null)
          error = err;
      });
      dest.on("finish", () => {
        fin = true;
        if (!autoDestroy)
          done(error);
      });
      if (autoDestroy) {
        dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
      }
    }
    return dest;
    function errorHandle(s, rd, wr, onerror2) {
      s.on("error", onerror2);
      s.on("close", onclose);
      function onclose() {
        if (rd && s._readableState && !s._readableState.ended)
          return onerror2(PREMATURE_CLOSE);
        if (wr && s._writableState && !s._writableState.ended)
          return onerror2(PREMATURE_CLOSE);
      }
    }
    function onerror(err) {
      if (!err || error)
        return;
      error = err;
      for (const s of all) {
        s.destroy(err);
      }
    }
  }
  function echo(s) {
    return s;
  }
  function isStream(stream) {
    return !!stream._readableState || !!stream._writableState;
  }
  function isStreamx(stream) {
    return typeof stream._duplexState === "number" && isStream(stream);
  }
  function isEnded(stream) {
    return !!stream._readableState && stream._readableState.ended;
  }
  function isFinished(stream) {
    return !!stream._writableState && stream._writableState.ended;
  }
  function getStreamError(stream, opts = {}) {
    const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
    return !opts.all && err === STREAM_DESTROYED ? null : err;
  }
  function isReadStreamx(stream) {
    return isStreamx(stream) && stream.readable;
  }
  function isDisturbed(stream) {
    return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
  }
  function isTypedArray(data) {
    return typeof data === "object" && data !== null && typeof data.byteLength === "number";
  }
  function defaultByteLength(data) {
    return isTypedArray(data) ? data.byteLength : 1024;
  }
  function noop() {}
  function abort() {
    this.destroy(new Error("Stream aborted."));
  }
  function isWritev(s) {
    return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
  }
  module.exports = {
    pipeline,
    pipelinePromise,
    isStream,
    isStreamx,
    isEnded,
    isFinished,
    isDisturbed,
    getStreamError,
    Stream,
    Writable,
    Readable,
    Duplex,
    Transform,
    PassThrough
  };
});

// node_modules/rocksdb-native/lib/iterator.js
var require_iterator = __commonJS((exports, module) => {
  var { Readable } = require_streamx();
  var c = require_compact_encoding();
  var binding = require_binding2();
  var empty = Buffer.alloc(0);
  module.exports = class RocksDBIterator extends Readable {
    constructor(db, opts = {}) {
      const {
        gt = null,
        gte = null,
        lt = null,
        lte = null,
        reverse = false,
        values = true,
        limit = Infinity,
        capacity = 8
      } = opts;
      super();
      db._ref();
      this._db = db;
      this._gt = gt ? this._encodeKey(gt) : empty;
      this._gte = gte ? this._encodeKey(gte) : empty;
      this._lt = lt ? this._encodeKey(lt) : empty;
      this._lte = lte ? this._encodeKey(lte) : empty;
      this._reverse = reverse;
      this._values = values;
      this._limit = limit < 0 ? Infinity : limit;
      this._capacity = capacity;
      this._opened = false;
      this._pendingOpen = null;
      this._pendingRead = null;
      this._pendingDestroy = null;
      this._buffer = null;
      this._handle = null;
      if (this._db._state.opened === true)
        this.ready();
    }
    _onopen(err) {
      const cb = this._pendingOpen;
      this._pendingOpen = null;
      this._opened = true;
      this._db._state.io.dec();
      cb(err);
    }
    _onread(err, keys, values) {
      const cb = this._pendingRead;
      this._pendingRead = null;
      this._db._state.io.dec();
      if (err)
        return cb(err);
      const n = keys.length;
      this._limit -= n;
      for (let i = 0;i < n; i++) {
        this.push({
          key: this._decodeKey(Buffer.from(keys[i])),
          value: this._values ? this._decodeValue(Buffer.from(values[i])) : null
        });
      }
      if (n < this._capacity)
        this.push(null);
      cb(null);
    }
    _onclose(err) {
      const cb = this._pendingDestroy;
      this._pendingDestroy = null;
      this._db._state.io.dec();
      this._db._unref();
      cb(err);
    }
    _resize() {
      if (this._handle !== null) {
        this._buffer = binding.iteratorBuffer(this._handle, this._capacity);
      }
    }
    async ready() {
      if (this._handle !== null)
        return;
      if (this._db._state.opened === false)
        await this._db._state.ready();
      this._init();
    }
    _init() {
      this._handle = binding.iteratorInit();
      this._buffer = binding.iteratorBuffer(this._handle, this._capacity);
    }
    async _open(cb) {
      await this.ready();
      this._db._state.io.inc();
      if (this._db._state.resumed !== null) {
        const resumed = await this._db._state.resumed.promise;
        if (!resumed) {
          this._db._state.io.dec();
          return cb(new Error("RocksDB session is closed"));
        }
      }
      this._pendingOpen = cb;
      try {
        binding.iteratorOpen(this._db._state._handle, this._handle, this._db._columnFamily._handle, this._gt, this._gte, this._lt, this._lte, this._reverse, !this._values, this._db._snapshot ? this._db._snapshot._handle : null, this, this._onopen, this._onclose, this._onread);
      } catch (err) {
        this._db._state.io.dec();
        throw err;
      }
    }
    async _read(cb) {
      this._db._state.io.inc();
      if (this._db._state.resumed !== null) {
        const resumed = await this._db._state.resumed.promise;
        if (!resumed) {
          this._db._state.io.dec();
          return cb(new Error("RocksDB session is closed"));
        }
      }
      this._pendingRead = cb;
      try {
        binding.iteratorRead(this._handle, Math.min(this._capacity, this._limit));
      } catch (err) {
        this._db._state.io.dec();
        throw err;
      }
    }
    async _destroy(cb) {
      await this.ready();
      this._db._state.io.inc();
      this._pendingDestroy = cb;
      if (this._opened === false) {
        this._db._state.io.dec();
        return this._onclose(null);
      }
      try {
        binding.iteratorClose(this._handle);
      } catch (err) {
        this._db._state.io.dec();
        throw err;
      }
    }
    _encodeKey(k) {
      if (this._db._keyEncoding !== null)
        return c.encode(this._db._keyEncoding, k);
      if (typeof k === "string")
        return Buffer.from(k);
      return k;
    }
    _decodeKey(b) {
      if (this._db._keyEncoding !== null)
        return c.decode(this._db._keyEncoding, b);
      return b;
    }
    _decodeValue(b) {
      if (this._db._valueEncoding !== null)
        return c.decode(this._db._valueEncoding, b);
      return b;
    }
  };
});

// node_modules/rocksdb-native/lib/snapshot.js
var require_snapshot = __commonJS((exports, module) => {
  var binding = require_binding2();
  module.exports = class RocksDBSnapshot {
    constructor(state) {
      this._state = state;
      this._handle = null;
      this._refs = 0;
      if (state.deferSnapshotInit === false)
        this._init();
    }
    _init() {
      this._handle = binding.snapshotCreate(this._state._handle);
    }
    ref() {
      this._refs++;
    }
    unref() {
      if (--this._refs > 0)
        return;
      if (this._handle === null)
        return;
      binding.snapshotDestroy(this._handle);
      this._handle = null;
    }
  };
});

// node_modules/refcounter/index.js
var require_refcounter = __commonJS((exports, module) => {
  module.exports = class RefCounter {
    constructor() {
      this.count = 0;
      this._onidle = null;
      this._idle = null;
    }
    isIdle() {
      return this.count === 0;
    }
    idle() {
      if (this.count === 0)
        return Promise.resolve();
      if (this._idle !== null)
        return this._idle;
      this._idle = new Promise((resolve) => {
        this._onidle = resolve;
      });
      return this._idle;
    }
    inc() {
      this.count++;
    }
    dec() {
      if (--this.count > 0)
        return;
      if (this._onidle !== null) {
        const resolve = this._onidle;
        this._idle = null;
        this._onidle = null;
        resolve();
      }
    }
  };
});

// node_modules/rocksdb-native/lib/batch.js
var require_batch = __commonJS((exports) => {
  var c = require_compact_encoding();
  var binding = require_binding2();
  var empty = Buffer.alloc(0);
  var resolved = Promise.resolve();

  class RocksDBBatch {
    constructor(db, opts = {}) {
      const { capacity = 8, autoDestroy = false } = opts;
      db._ref();
      this._db = db;
      this._destroyed = false;
      this._capacity = capacity;
      this._operations = [];
      this._promises = [];
      this._enqueuePromise = this._enqueuePromise.bind(this);
      this._request = null;
      this._resolve = null;
      this._reject = null;
      this._handle = null;
      this._buffer = null;
      this._autoDestroy = autoDestroy;
      if (db._state.opened === true)
        this.ready();
    }
    _reuse(db, opts = {}) {
      const { autoDestroy = false } = opts;
      db._ref();
      this._db = db;
      this._destroyed = false;
      this._autoDestroy = autoDestroy;
    }
    _onfinished(err) {
      const resolve = this._resolve;
      const reject = this._reject;
      if (this._request)
        this._db._state.io.dec();
      this._operations = [];
      this._promises = [];
      this._request = null;
      this._resolve = null;
      this._reject = null;
      if (this._autoDestroy === true)
        this.destroy();
      if (reject !== null && err)
        reject(err);
      else if (resolve !== null)
        resolve();
    }
    _resize() {
      if (this._operations.length <= this._capacity)
        return false;
      while (this._operations.length > this._capacity) {
        this._capacity *= 2;
      }
      return true;
    }
    async ready() {
      if (this._handle !== null)
        return;
      if (this._db._state.opened === false)
        await this._db._state.ready();
      this._init();
    }
    destroy() {
      if (this._request)
        throw new Error("Request in progress");
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (this._promises.length)
        this._abort();
      this._db._unref();
      this._onfree();
    }
    _onfree() {
      this._db._state.freeBatch(this, false);
      this._db = null;
    }
    _abort() {
      for (let i = 0;i < this._promises.length; i++) {
        const promise = this._promises[i];
        if (promise !== null)
          promise.reject(new Error("Batch is destroyed"));
      }
      this._onfinished(new Error("Batch is destroyed"));
    }
    async flush() {
      if (this._request)
        throw new Error("Request in progress");
      if (this._destroyed)
        throw new Error("Batch is destroyed");
      this._request = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
      this._flush();
      return this._request;
    }
    tryFlush() {
      if (this._request)
        throw new Error("Request in progress");
      if (this._destroyed)
        throw new Error("Batch is destroyed");
      this._request = resolved;
      this._flush();
    }
    async _flush() {
      if (this._handle === null)
        await this.ready();
      this._db._state.io.inc();
      if (this._db._state.resumed !== null) {
        const resumed = await this._db._state.resumed.promise;
        if (!resumed) {
          if (this._destroyed) {
            this._db._state.io.dec();
          } else {
            this._destroyed = true;
            this._abort();
            this._db._unref();
          }
        }
      }
    }
    _enqueuePromise(resolve, reject) {
      this._promises.push({ resolve, reject });
    }
    _encodeKey(k) {
      if (this._db._keyEncoding)
        return c.encode(this._db._keyEncoding, k);
      if (typeof k === "string")
        return Buffer.from(k);
      return k;
    }
    _encodeValue(v) {
      if (this._db._valueEncoding)
        return c.encode(this._db._valueEncoding, v);
      if (v === null)
        return empty;
      if (typeof v === "string")
        return Buffer.from(v);
      return v;
    }
    _decodeValue(b) {
      if (this._db._valueEncoding)
        return c.decode(this._db._valueEncoding, b);
      return b;
    }
  }
  exports.ReadBatch = class RocksDBReadBatch extends RocksDBBatch {
    _init() {
      this._handle = binding.readInit();
      this._buffer = binding.readBuffer(this._handle, this._capacity);
    }
    _resize() {
      if (super._resize() && this._handle !== null) {
        this._buffer = binding.readBuffer(this._handle, this._capacity);
      }
    }
    async _flush() {
      await super._flush();
      if (this._destroyed)
        return;
      try {
        binding.read(this._db._state._handle, this._handle, this._operations, this._db._snapshot ? this._db._snapshot._handle : null, this, this._onread);
      } catch (err) {
        this._db._state.io.dec();
        throw err;
      }
    }
    _onread(errs, values) {
      let applied = true;
      for (let i = 0, n = this._promises.length;i < n; i++) {
        const promise = this._promises[i];
        if (promise === null)
          continue;
        const err = errs[i];
        if (err) {
          applied = false;
          promise.reject(new Error(err));
        } else {
          promise.resolve(values[i] ? this._decodeValue(Buffer.from(values[i])) : null);
        }
      }
      this._onfinished(applied ? null : new Error("Batch was not applied"));
    }
    get(key) {
      if (this._request)
        throw new Error("Request already in progress");
      const promise = new Promise(this._enqueuePromise);
      this._operations.push(new RocksDBGet(this._encodeKey(key), this._db._columnFamily));
      this._resize();
      return promise;
    }
  };
  exports.WriteBatch = class RocksDBWriteBatch extends RocksDBBatch {
    _init() {
      this._handle = binding.writeInit();
      this._buffer = binding.writeBuffer(this._handle, this._capacity);
    }
    _resize() {
      if (super._resize() && this._handle !== null) {
        this._buffer = binding.writeBuffer(this._handle, this._capacity);
      }
    }
    _onfree() {
      this._db._state.freeBatch(this, true);
    }
    async _flush() {
      await super._flush();
      if (this._destroyed)
        return;
      try {
        binding.write(this._db._state._handle, this._handle, this._operations, this, this._onwrite);
      } catch (err) {
        this._db._state.io.dec();
        throw err;
      }
    }
    _onwrite(err) {
      let applied = true;
      for (let i = 0, n = this._promises.length;i < n; i++) {
        const promise = this._promises[i];
        if (promise === null)
          continue;
        if (err) {
          applied = false;
          promise.reject(new Error(err));
        } else {
          promise.resolve();
        }
      }
      this._onfinished(applied ? null : new Error("Batch was not applied"));
    }
    put(key, value) {
      if (this._request)
        throw new Error("Request already in progress");
      const promise = new Promise(this._enqueuePromise);
      this._operations.push(new RocksDBPut(this._encodeKey(key), this._encodeValue(value), this._db._columnFamily));
      this._resize();
      return promise;
    }
    tryPut(key, value) {
      if (this._request)
        throw new Error("Request already in progress");
      this._operations.push(new RocksDBPut(this._encodeKey(key), this._encodeValue(value), this._db._columnFamily));
      this._promises.push(null);
      this._resize();
    }
    delete(key) {
      if (this._request)
        throw new Error("Request already in progress");
      const promise = new Promise(this._enqueuePromise);
      this._operations.push(new RocksDBDelete(this._encodeKey(key), this._db._columnFamily));
      this._resize();
      return promise;
    }
    tryDelete(key) {
      if (this._request)
        throw new Error("Request already in progress");
      this._operations.push(new RocksDBDelete(this._encodeKey(key), this._db._columnFamily));
      this._promises.push(null);
      this._resize();
    }
    deleteRange(start, end) {
      if (this._request)
        throw new Error("Request already in progress");
      const promise = new Promise(this._enqueuePromise);
      this._operations.push(new RocksDBDeleteRange(this._encodeKey(start), this._encodeKey(end), this._db._columnFamily));
      this._resize();
      return promise;
    }
    tryDeleteRange(start, end) {
      if (this._request)
        throw new Error("Request already in progress");
      this._operations.push(new RocksDBDeleteRange(this._encodeKey(start), this._encodeKey(end), this._db._columnFamily));
      this._promises.push(null);
      this._resize();
    }
  };

  class RocksDBGet {
    constructor(key, columnFamily) {
      this.key = key;
      this.columnFamily = columnFamily._handle;
    }
    get type() {
      return binding.GET;
    }
  }

  class RocksDBPut {
    constructor(key, value, columnFamily) {
      this.key = key;
      this.value = value;
      this.columnFamily = columnFamily._handle;
    }
    get type() {
      return binding.PUT;
    }
  }

  class RocksDBDelete {
    constructor(key, columnFamily) {
      this.key = key;
      this.columnFamily = columnFamily._handle;
    }
    get type() {
      return binding.DELETE;
    }
  }

  class RocksDBDeleteRange {
    constructor(start, end, columnFamily) {
      this.start = start;
      this.end = end;
      this.columnFamily = columnFamily._handle;
    }
    get type() {
      return binding.DELETE_RANGE;
    }
  }
});

// node_modules/rocksdb-native/lib/state.js
var require_state = __commonJS((exports, module) => {
  var ReadyResource = require_ready_resource();
  var RefCounter = require_refcounter();
  var rrp = require_resolve_reject_promise();
  var { ReadBatch, WriteBatch } = require_batch();
  var ColumnFamily = require_column_family();
  var binding = require_binding2();
  var MAX_BATCH_REUSE = 64;
  module.exports = class RocksDBState extends ReadyResource {
    constructor(db, path, opts) {
      super();
      const {
        columnFamily = new ColumnFamily("default", opts),
        columnFamilies = [],
        readOnly = false,
        createIfMissing = true,
        createMissingColumnFamilies = true,
        maxBackgroundJobs = 6,
        bytesPerSync = 1048576,
        maxOpenFiles = -1,
        useDirectReads = false
      } = opts;
      this.path = path;
      this.db = db;
      this.handles = new RefCounter;
      this.io = new RefCounter;
      this.sessions = [];
      this.columnFamilies = [columnFamily];
      this.deferSnapshotInit = true;
      this.resumed = null;
      this._suspended = false;
      this._suspending = null;
      this._resuming = null;
      this._columnsFlushed = false;
      this._readBatches = [];
      this._writeBatches = [];
      for (const columnFamily2 of columnFamilies) {
        this.columnFamilies.push(typeof columnFamily2 === "string" ? new ColumnFamily(columnFamily2, opts) : columnFamily2);
      }
      this._handle = binding.init(readOnly, createIfMissing, createMissingColumnFamilies, maxBackgroundJobs, bytesPerSync, maxOpenFiles, useDirectReads);
    }
    createReadBatch(db, opts) {
      if (this._readBatches.length === 0)
        return new ReadBatch(db, opts);
      const batch = this._readBatches.pop();
      batch._reuse(db, opts);
      return batch;
    }
    createWriteBatch(db, opts) {
      if (this._writeBatches.length === 0)
        return new WriteBatch(db, opts);
      const batch = this._writeBatches.pop();
      batch._reuse(db, opts);
      return batch;
    }
    freeBatch(batch, writable) {
      const queue = writable ? this._writeBatches : this._readBatches;
      if (queue.length >= MAX_BATCH_REUSE)
        return;
      queue.push(batch);
    }
    addSession(db) {
      db._index = this.sessions.push(db) - 1;
      if (db._snapshot)
        db._snapshot.ref();
    }
    removeSession(db) {
      const head = this.sessions.pop();
      if (head !== db)
        this.sessions[head._index = db._index] = head;
      db._index = -1;
      if (db._snapshot)
        db._snapshot.unref();
    }
    upsertColumnFamily(c) {
      if (typeof c === "string") {
        let col = this.getColumnFamilyByName(c);
        if (col)
          return col;
        col = this.columnFamilies[0].cloneSettings(c);
        this.columnFamilies.push(col);
        return col;
      }
      if (this.columnFamilies.includes(c))
        return c;
      this.columnFamilies.push(c);
      return c;
    }
    getColumnFamily(c) {
      if (!c)
        return this.columnFamilies[0];
      if (!this._columnsFlushed)
        return this.upsertColumnFamily(c);
      if (typeof c !== "string")
        return c;
      const col = this.getColumnFamilyByName(c);
      if (col === null)
        throw new Error("Unknown column family");
      return col;
    }
    getColumnFamilyByName(name) {
      for (const col of this.columnFamilies) {
        if (col.name === name)
          return col;
      }
      return null;
    }
    async _open() {
      await Promise.resolve();
      const req = { resolve: null, reject: null, handle: null };
      const promise = new Promise((resolve, reject) => {
        req.resolve = resolve;
        req.reject = reject;
      });
      this._columnsFlushed = true;
      req.handle = binding.open(this._handle, this, this.path, this.columnFamilies.map((c) => c._handle), req, onopen);
      await promise;
      this.deferSnapshotInit = false;
      for (const session of this.sessions) {
        if (session._snapshot)
          session._snapshot._init();
      }
      function onopen(err) {
        if (err)
          req.reject(new Error(err));
        else
          req.resolve();
      }
    }
    async _close() {
      if (this.resumed)
        this.resumed.resolve(false);
      while (!this.io.isIdle())
        await this.io.idle();
      while (!this.handles.isIdle())
        await this.handles.idle();
      while (this.sessions.length > 0) {
        await this.sessions[this.sessions.length - 1].close();
      }
      for (const columnFamily of this.columnFamilies)
        columnFamily.destroy();
      const req = { resolve: null, reject: null, handle: null };
      const promise = new Promise((resolve, reject) => {
        req.resolve = resolve;
        req.reject = reject;
      });
      req.handle = binding.close(this._handle, req, onclose);
      await promise;
      function onclose(err) {
        if (err)
          req.reject(new Error(err));
        else
          req.resolve();
      }
    }
    async flush(db, opts) {
      if (this.opened === false)
        await this.ready();
      this.io.inc();
      if (this.resumed !== null) {
        const resumed = await this.resumed.promise;
        if (!resumed) {
          this.io.dec();
          throw new Error("RocksDB session is closed");
        }
      }
      const req = { resolve: null, reject: null, handle: null };
      const promise = new Promise((resolve, reject) => {
        req.resolve = resolve;
        req.reject = reject;
      });
      try {
        req.handle = binding.flush(this._handle, db._columnFamily._handle, req, onflush);
        await promise;
      } finally {
        this.io.dec();
      }
      function onflush(err) {
        if (err)
          req.reject(new Error(err));
        else
          req.resolve();
      }
    }
    async suspend() {
      if (this._suspending === null)
        this._suspending = this._suspend();
      return this._suspending;
    }
    async _suspend() {
      if (this.opened === false)
        await this.ready();
      this.io.inc();
      if (this._resuming !== null)
        await this._resuming;
      this.io.dec();
      if (this._suspended === true)
        return;
      while (!this.io.isIdle())
        await this.io.idle();
      this.io.inc();
      this.resumed = rrp();
      const req = { resolve: null, reject: null, handle: null };
      const promise = new Promise((resolve, reject) => {
        req.resolve = resolve;
        req.reject = reject;
      });
      try {
        req.handle = binding.suspend(this._handle, req, onsuspend);
        await promise;
        this._suspended = true;
      } finally {
        this.io.dec();
        this._suspending = null;
      }
      function onsuspend(err) {
        if (err)
          req.reject(new Error(err));
        else
          req.resolve();
      }
    }
    resume() {
      if (this._resuming === null)
        this._resuming = this._resume();
      return this._resuming;
    }
    async _resume() {
      if (this.opened === false)
        await this.ready();
      this.io.inc();
      if (this._suspending !== null)
        await this._suspending;
      if (this._suspended === false)
        return this.io.dec();
      const req = { resolve: null, reject: null, handle: null };
      const promise = new Promise((resolve, reject) => {
        req.resolve = resolve;
        req.reject = reject;
      });
      try {
        req.handle = binding.resume(this._handle, req, onresume);
        await promise;
        this._suspended = false;
      } finally {
        this.io.dec();
        this._resuming = null;
      }
      const resumed = this.resumed;
      this.resumed = null;
      resumed.resolve(true);
      function onresume(err) {
        if (err)
          req.reject(new Error(err));
        else
          req.resolve();
      }
    }
  };
});

// node_modules/rocksdb-native/index.js
var require_rocksdb_native = __commonJS((exports, module) => {
  var ColumnFamily = require_column_family();
  var Iterator = require_iterator();
  var Snapshot = require_snapshot();
  var State = require_state();
  var { BloomFilterPolicy, RibbonFilterPolicy } = require_filter_policy();

  class RocksDB {
    constructor(path, opts = {}) {
      const {
        columnFamily,
        state = new State(this, path, opts),
        snapshot = null,
        keyEncoding = null,
        valueEncoding = null
      } = opts;
      this._state = state;
      this._snapshot = snapshot;
      this._columnFamily = state.getColumnFamily(columnFamily);
      this._keyEncoding = keyEncoding;
      this._valueEncoding = valueEncoding;
      this._index = -1;
      this._state.addSession(this);
    }
    get opened() {
      return this._state.opened;
    }
    get closed() {
      return this.isRoot() ? this._state.closed : this._index === -1;
    }
    get path() {
      return this._state.path;
    }
    get snapshotted() {
      return this._snapshot !== null;
    }
    get defaultColumnFamily() {
      return this._columnFamily;
    }
    session({
      columnFamily = this._columnFamily,
      snapshot = this._snapshot !== null,
      keyEncoding = this._keyEncoding,
      valueEncoding = this._valueEncoding
    } = {}) {
      maybeClosed(this);
      return new RocksDB(null, {
        state: this._state,
        columnFamily,
        snapshot: snapshot ? this._snapshot || new Snapshot(this._state) : null,
        keyEncoding,
        valueEncoding
      });
    }
    columnFamily(name, opts) {
      return this.session({ ...opts, columnFamily: name });
    }
    snapshot() {
      return this.session({ snapshot: true });
    }
    isRoot() {
      return this === this._state.db;
    }
    ready() {
      return this._state.ready();
    }
    async close({ force } = {}) {
      if (this._index !== -1)
        this._state.removeSession(this);
      if (force) {
        while (this._state.sessions.length > 0) {
          await this._state.sessions[this._state.sessions.length - 1].close();
        }
      }
      return this.isRoot() ? this._state.close() : Promise.resolve();
    }
    suspend() {
      maybeClosed(this);
      return this._state.suspend();
    }
    resume() {
      maybeClosed(this);
      return this._state.resume();
    }
    isIdle() {
      return this._state.handles.isIdle();
    }
    idle() {
      return this._state.handles.idle();
    }
    iterator(range, opts) {
      maybeClosed(this);
      return new Iterator(this, { ...range, ...opts });
    }
    async* keys(range, opts) {
      for await (const { key } of this.iterator(range, {
        ...opts,
        values: false
      })) {
        yield key;
      }
    }
    async peek(range, opts) {
      for await (const value of this.iterator({ ...range, ...opts, limit: 1 })) {
        return value;
      }
      return null;
    }
    read(opts) {
      maybeClosed(this);
      return this._state.createReadBatch(this, opts);
    }
    write(opts) {
      maybeClosed(this);
      return this._state.createWriteBatch(this, opts);
    }
    flush(opts) {
      maybeClosed(this);
      return this._state.flush(this, opts);
    }
    async get(key, opts) {
      const batch = this.read({ ...opts, capacity: 1, autoDestroy: true });
      const value = batch.get(key);
      batch.tryFlush();
      return value;
    }
    async put(key, value, opts) {
      const batch = this.write({ ...opts, capacity: 1, autoDestroy: true });
      batch.tryPut(key, value);
      await batch.flush();
    }
    async delete(key, opts) {
      const batch = this.write({ ...opts, capacity: 1, autoDestroy: true });
      batch.tryDelete(key);
      await batch.flush();
    }
    async deleteRange(start, end, opts) {
      const batch = this.write({ ...opts, capacity: 1, autoDestroy: true });
      batch.tryDeleteRange(start, end);
      await batch.flush();
    }
    _ref() {
      if (this._snapshot)
        this._snapshot.ref();
      this._state.handles.inc();
    }
    _unref() {
      if (this._snapshot)
        this._snapshot.unref();
      this._state.handles.dec();
    }
  }
  module.exports = exports = RocksDB;
  exports.ColumnFamily = ColumnFamily;
  exports.BloomFilterPolicy = BloomFilterPolicy;
  exports.RibbonFilterPolicy = RibbonFilterPolicy;
  function maybeClosed(db) {
    if (db._state.closing || db._index === -1)
      throw new Error("RocksDB session is closed");
  }
});

// node_modules/scope-lock/index.js
var require_scope_lock = __commonJS((exports, module) => {
  var tmpResolve = null;
  module.exports = class ScopeLock {
    constructor({ debounce = false } = {}) {
      this.debounce = debounce;
      this.waiting = [];
      this.locked = false;
      this.skip = 0;
      this.destroyed = false;
    }
    flush() {
      if (this.locked === false && this.waiting.length === 0)
        return Promise.resolve(this.destroyed === false);
      const promise = new Promise(setTmpResolve);
      const resolve = tmpResolve;
      tmpResolve = null;
      this.waiting.push({ lock: false, resolve });
      return promise;
    }
    destroy() {
      this.destroyed = true;
    }
    lock() {
      const promise = new Promise(setTmpResolve);
      const resolve = tmpResolve;
      tmpResolve = null;
      if (this.locked === true) {
        this.waiting.push({ lock: true, resolve });
        return promise;
      }
      if (this.destroyed === true) {
        resolve(false);
        return promise;
      }
      this.locked = true;
      resolve(true);
      return promise;
    }
    unlock() {
      if (this.destroyed === true) {
        for (let i = 0;i < this.waiting.length; i++) {
          this.waiting[i].resolve(false);
        }
        this.waiting = [];
        this.skip = 0;
        this.locked = false;
        return;
      }
      if (this.skip !== 0) {
        for (let i = 0;i < this.skip; i++) {
          const { lock, resolve: resolve2 } = this.waiting[i];
          resolve2(lock === false);
        }
        this.waiting = this.waiting.slice(this.skip);
        this.skip = 0;
      }
      while (this.waiting.length > 0 && this.waiting[0].lock === false) {
        this.waiting.shift().resolve(true);
      }
      if (this.waiting.length === 0) {
        this.locked = false;
        return;
      }
      const { resolve } = this.waiting.shift();
      if (this.debounce === true)
        this.skip = this.waiting.length;
      resolve(true);
    }
  };
  function setTmpResolve(resolve) {
    tmpResolve = resolve;
  }
});

// node_modules/fs-native-extensions/binding.js
var require_binding3 = __commonJS((exports, module) => {
  var __filename = "/Users/odinsson/Dev/pear/easybase/node_modules/fs-native-extensions/binding.js";
  __require.addon = require_require_addon();
  module.exports = __require.addon(".", __filename);
});

// node_modules/fs-native-extensions/index.js
var require_fs_native_extensions = __commonJS((exports) => {
  var { isWindows } = require_which_runtime();
  var binding = require_binding3();
  function onwork(err, result) {
    if (err)
      this.reject(err);
    else
      this.resolve(result);
  }
  exports.tryLock = function tryLock(fd, offset = 0, length = 0, opts = {}) {
    if (typeof offset === "object") {
      opts = offset;
      offset = 0;
    }
    if (typeof length === "object") {
      opts = length;
      length = 0;
    }
    if (typeof opts !== "object") {
      opts = {};
    }
    try {
      binding.fs_ext_napi_try_lock(fd, offset, length, opts.shared ? 0 : 1);
    } catch (err) {
      if (err.code === "EAGAIN")
        return false;
      throw err;
    }
    return true;
  };
  exports.waitForLock = function waitForLock(fd, offset = 0, length = 0, opts = {}) {
    if (typeof offset === "object") {
      opts = offset;
      offset = 0;
    }
    if (typeof length === "object") {
      opts = length;
      length = 0;
    }
    if (typeof opts !== "object") {
      opts = {};
    }
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_wait_for_lock(req, fd, offset, length, opts.shared ? 0 : 1, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.tryDowngradeLock = function tryDowngradeLock(fd, offset = 0, length = 0) {
    try {
      binding.fs_ext_napi_try_downgrade_lock(fd, offset, length);
    } catch (err) {
      if (err.code === "EAGAIN")
        return false;
      throw err;
    }
    return true;
  };
  exports.waitForDowngradeLock = function downgradeLock(fd, offset = 0, length = 0) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_wait_for_downgrade_lock(req, fd, offset, length, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.tryUpgradeLock = function tryUpgradeLock(fd, offset = 0, length = 0) {
    try {
      binding.fs_ext_napi_try_upgrade_lock(fd, offset, length);
    } catch (err) {
      if (err.code === "EAGAIN")
        return false;
      throw err;
    }
    return true;
  };
  exports.waitForUpgradeLock = function upgradeLock(fd, offset = 0, length = 0) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_wait_for_upgrade_lock(req, fd, offset, length, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.unlock = function unlock(fd, offset = 0, length = 0) {
    binding.fs_ext_napi_unlock(fd, offset, length);
  };
  exports.trim = function trim(fd, offset, length) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_trim_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_trim(req, fd, offset, length, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.sparse = function sparse(fd) {
    if (!isWindows)
      return Promise.resolve();
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_sparse_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_sparse(req, fd, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.swap = function swap(from, to) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_swap_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_swap(req, from, to, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.getAttr = function getAttr(fd, name) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_get_attr_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_get_attr(req, fd, name, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise.then((buffer) => buffer === null ? null : Buffer.from(buffer));
  };
  exports.setAttr = function setAttr(fd, name, value, encoding) {
    if (typeof value === "string")
      value = Buffer.from(value, encoding);
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_set_attr_t);
    const ctx = {
      req,
      value,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_set_attr(req, fd, name, value, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.removeAttr = function removeAttr(fd, name) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_remove_attr_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_remove_attr(req, fd, name, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
  exports.listAttrs = function listAttrs(fd) {
    const req = Buffer.alloc(binding.sizeof_fs_ext_napi_list_attrs_t);
    const ctx = {
      req,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
    try {
      binding.fs_ext_napi_list_attrs(req, fd, ctx, onwork);
    } catch (err) {
      return Promise.reject(err);
    }
    return promise;
  };
});

// node_modules/device-file/index.js
var require_device_file = __commonJS((exports) => {
  var fs = __require("fs");
  var fsx = require_fs_native_extensions();
  var b4a = require_b4a();
  var PLATFORM = global.Bare ? global.Bare.platform : global.process.platform;
  var IS_WIN = PLATFORM === "win32";
  var IS_LINUX = PLATFORM === "linux";
  var MODIFIED_SLACK = 5000;
  var EMPTY = b4a.alloc(0);
  var ATTR = IS_LINUX ? "user.device-file" : "device-file";
  var nl = IS_WIN ? `\r
` : `
`;
  exports.create = writeDeviceFile;
  exports.resume = verifyDeviceFile;
  async function writeDeviceFile(filename, data = {}) {
    let s = "";
    for (const [key, value] of Object.entries(data)) {
      if (value === null)
        continue;
      s += key + "=" + value + nl;
    }
    const fd = await open(filename, "w");
    const st = await fstat(fd);
    const created = Date.now();
    s += "device/platform=" + PLATFORM + nl;
    s += "device/inode=" + st.ino + nl;
    s += "device/created=" + created + nl;
    if (await setAttr(fd, ATTR, b4a.from("original"))) {
      s += "device/attribute=original" + nl;
    }
    await write(fd, b4a.from(s));
    await close(fd);
  }
  async function verifyDeviceFile(filename, data = {}) {
    let fd = 0;
    try {
      fd = await open(filename, "r");
    } catch {
      fd = 0;
    }
    if (fd === 0)
      return null;
    const buf = await read(fd);
    const result = {};
    const s = b4a.toString(buf).trim().split(`
`);
    let inode = 0;
    let created = 0;
    let attr = "";
    let platform = "";
    for (const ln of s) {
      const i = ln.indexOf("=");
      if (i === -1)
        continue;
      const k = ln.slice(0, i).trim();
      const v = ln.slice(i + 1).trim();
      switch (k) {
        case "device/platform":
          platform = v;
          break;
        case "device/inode":
          inode = Number(v);
          break;
        case "device/created":
          created = Number(v);
          break;
        case "device/attribute":
          attr = v;
          break;
        default:
          result[k] = v;
          break;
      }
    }
    for (const [k, v] of Object.entries(data)) {
      if (v === null)
        continue;
      if (result[k] === undefined)
        continue;
      if (result[k] !== "" + v) {
        throw new Error("Invalid device file, " + k + " has changed");
      }
    }
    const st = await fstat(fd);
    const at = await getAttr(fd, ATTR);
    await close(fd);
    const sameAttr = b4a.toString(at || EMPTY) === attr;
    const modified = Math.max(st.mtime.getTime(), st.birthtime.getTime());
    if (platform && platform !== PLATFORM) {
      throw new Error("Invalid device file, was made on different platform");
    }
    if (!sameAttr) {
      throw new Error("Invalid device file, was moved unsafely");
    }
    if (st.ino !== inode || created && Math.abs(modified - created) >= MODIFIED_SLACK) {
      throw new Error("Invalid device file, was modified");
    }
    return result;
  }
  async function getAttr(fd, name) {
    try {
      return await fsx.getAttr(fd, name);
    } catch {
      return null;
    }
  }
  async function setAttr(fd, name, value) {
    try {
      await fsx.setAttr(fd, name, value);
      return true;
    } catch {
      return false;
    }
  }
  function fstat(fd) {
    return new Promise((resolve, reject) => {
      fs.fstat(fd, (err, st) => {
        if (err)
          reject(err);
        resolve(st);
      });
    });
  }
  function close(fd) {
    return new Promise((resolve, reject) => {
      fs.close(fd, (err, st) => {
        if (err)
          reject(err);
        resolve(st);
      });
    });
  }
  function write(fd, buf) {
    return new Promise((resolve, reject) => {
      let offset = 0;
      onwrite(null, 0);
      function onwrite(err, wrote) {
        if (err)
          return reject(err);
        if (offset === buf.byteLength)
          return resolve();
        offset += wrote;
        fs.write(fd, buf, offset, buf.byteLength - offset, offset, onwrite);
      }
    });
  }
  function read(fd) {
    const buf = b4a.allocUnsafe(4096);
    return new Promise((resolve, reject) => {
      let offset = 0;
      fs.read(fd, buf, 0, buf.byteLength, 0, onread);
      function onread(err, read2) {
        if (err)
          return reject(err);
        if (read2 === 0)
          return resolve(buf.subarray(0, offset));
        offset += read2;
        fs.read(fd, buf, offset, buf.byteLength - offset, offset, onread);
      }
    });
  }
  function open(filename, flags) {
    return new Promise((resolve, reject) => {
      fs.open(filename, flags, (err, fd) => {
        if (err)
          reject(err);
        resolve(fd);
      });
    });
  }
});

// node_modules/hypercore-storage/lib/close-error-stream.js
var require_close_error_stream = __commonJS((exports, module) => {
  var { Readable } = require_streamx();
  module.exports = class CloseErrorStream extends Readable {
    constructor(err) {
      super();
      this.error = err;
    }
    _open(cb) {
      cb(this.error);
    }
  };
});

// node_modules/hypercore-storage/lib/view.js
var require_view = __commonJS((exports, module) => {
  var { Readable, getStreamError } = require_streamx();
  var CloseErrorStream = require_close_error_stream();
  var b4a = require_b4a();

  class OverlayStream extends Readable {
    constructor(stream, start, end, reverse, changes, cleared) {
      super();
      this.start = start;
      this.end = end;
      this.reverse = reverse;
      this.changes = changes;
      this.cleared = cleared;
      this.change = 0;
      this.range = 0;
      this._stream = stream;
      this._drained = false;
      this._stream.on("readable", this._drainMaybe.bind(this));
      this._stream.on("error", noop);
      this._stream.on("close", this._onclose.bind(this));
    }
    _drainMaybe() {
      if (this._drained === true)
        return;
      this._drained = this._onreadable();
    }
    _onclose() {
      if (this.destroying)
        return;
      const err = getStreamError(this._stream);
      if (err !== null) {
        this.destroy(err);
        return;
      }
      while (this.change < this.changes.length) {
        const c = this.changes[this.change++];
        const key = c[0];
        const value = c[1];
        if (value !== null && this._inRange(key))
          this.push({ key, value });
      }
      this.push(null);
      this._stream = null;
    }
    _onreadable() {
      let data = this._stream.read();
      if (data === null)
        return false;
      let drained = false;
      do {
        if (this._push(data) === true)
          drained = true;
        data = this._stream.read();
      } while (data !== null);
      return drained;
    }
    _read(cb) {
      this._drained = this._onreadable();
      cb(null);
    }
    _predestroy() {
      this.stream.destroy();
    }
    _push(entry) {
      const key = entry.key;
      while (this.range < this.cleared.length) {
        const c = this.cleared[this.range];
        if (this.reverse ? b4a.compare(key, c[0]) < 0 : b4a.compare(c[2], key) <= 0) {
          this.range++;
          continue;
        }
        if (b4a.compare(c[0], key) <= 0 && b4a.compare(key, c[2]) < 0) {
          return false;
        }
        break;
      }
      let updated = false;
      while (this.change < this.changes.length) {
        const c = this.changes[this.change];
        const key2 = c[0];
        const value = typeof c[1] === "string" ? b4a.from(c[1]) : c[1];
        const cmp = b4a.compare(key2, entry.key);
        if (cmp === 0) {
          this.change++;
          if (value === null || this._inRange(key2) === false)
            return updated;
          this.push({ key: key2, value });
          return true;
        }
        if (this.reverse ? cmp > 0 : cmp < 0) {
          this.change++;
          if (value === null || this._inRange(key2) === false)
            continue;
          this.push({ key: key2, value });
          updated = true;
          continue;
        }
        this.push(entry);
        return true;
      }
      this.push(entry);
      return true;
    }
    _inRange(key) {
      return b4a.compare(this.start, key) <= 0 && b4a.compare(key, this.end) < 0;
    }
  }

  class Overlay {
    constructor() {
      this.indexed = 0;
      this.changes = null;
      this.cleared = null;
      this.reverse = false;
    }
    update(view, reverse) {
      if (view.indexed === this.indexed)
        return;
      const changes = view.map === null ? [] : [...view.map.values()];
      const cleared = view.cleared === null ? [] : view.cleared.slice(0);
      const cmp = reverse ? cmpChangeReverse : cmpChange;
      changes.sort(cmp);
      cleared.sort(cmp);
      this.indexed = view.indexed;
      this.changes = changes;
      this.cleared = cleared;
      this.reverse = reverse;
    }
    createStream(stream, start, end, reverse) {
      return new OverlayStream(stream, start, end, reverse, this.reverse === reverse ? this.changes : reverseArray(this.changes), this.reverse === reverse ? this.cleared : reverseArray(this.cleared));
    }
  }

  class View {
    constructor() {
      this.map = null;
      this.indexed = 0;
      this.changes = null;
      this.cleared = null;
      this.overlay = null;
      this.snap = null;
      this.readers = 0;
    }
    snapshot() {
      if (this._attached())
        return this.snap.snapshot();
      const snap = new View;
      snap.map = this.map;
      snap.indexed = this.indexed;
      snap.changes = this.changes;
      snap.cleared = this.cleared;
      if (this._frozen())
        return snap;
      this.readers++;
      snap.snap = this;
      return snap;
    }
    readStart() {
      if (this.snap !== null)
        this.readers++;
    }
    readStop() {
      if (this.snap !== null && --this.readers === 0)
        this.snap.readers--;
    }
    size() {
      return this.changes === null ? 0 : this.changes.length;
    }
    updated() {
      return this.changes === null;
    }
    get(read, key) {
      return this.changes === null ? read.get(key) : this._indexAndGet(read, key);
    }
    reset() {
      this.indexed = 0;
      this.snap = this.map = this.changes = this.cleared = this.overlay = null;
    }
    iterator(db, start, end, reverse) {
      if (dbClosing(db))
        return new CloseErrorStream(new Error("RocksDB session is closed"));
      const stream = db.iterator({ gte: start, lt: end, reverse });
      if (this.changes === null)
        return stream;
      this._index();
      if (this.overlay === null)
        this.overlay = new Overlay;
      this.overlay.update(this, reverse);
      return this.overlay.createStream(stream, start, end, reverse);
    }
    _indexAndGet(read, key) {
      this._index();
      const change = this.map.get(b4a.toString(key, "hex"));
      if (change === undefined) {
        return this.cleared === null ? read.get(key) : this._readAndMaybeDrop(read, key);
      }
      return Promise.resolve(change[1]);
    }
    async _readAndMaybeDrop(read, key) {
      const cleared = this.cleared;
      const value = await read.get(key);
      if (value === null)
        return null;
      for (let i = 0;i < cleared.length; i++) {
        const c = cleared[i];
        if (b4a.compare(c[0], key) <= 0 && b4a.compare(key, c[2]) < 0)
          return null;
      }
      return value;
    }
    _attached() {
      return this.snap !== null && this.changes === this.snap.changes;
    }
    _frozen() {
      return this.changes === null || this.snap !== null && this.changes !== this.snap.changes;
    }
    _index() {
      if (this._attached()) {
        this.snap._index();
        this.map = this.snap.map;
        this.cleared = this.snap.cleared;
        this.indexed = this.snap.indexed;
        return;
      }
      if (this.map === null)
        this.map = new Map;
      if (this.changes.length === this.indexed)
        return;
      while (this.indexed < this.changes.length) {
        const c = this.changes[this.indexed++];
        if (c[2] === null)
          this.map.set(b4a.toString(c[0], "hex"), c);
        else
          this._indexRange(c);
      }
    }
    _indexRange(range) {
      const s = b4a.toString(range[0], "hex");
      const e = b4a.toString(range[2], "hex");
      for (const [key, c] of this.map) {
        if (s <= key && key < e)
          this.map.set(key, [c[0], null, null]);
      }
      if (this.cleared === null)
        this.cleared = [];
      this.cleared.push(range);
    }
    apply(changes) {
      if (this.snap !== null)
        throw new Error("Illegal to push changes to a snapshot");
      if (this.readers !== 0 && this.changes !== null) {
        this.changes = this.changes.slice(0);
        this.cleared = this.cleared === null ? null : this.cleared.slice(0);
        this.map = this.map === null ? null : new Map([...this.map]);
      }
      if (this.changes === null) {
        this.changes = changes;
        return;
      }
      for (let i = 0;i < changes.length; i++) {
        this.changes.push(changes[i]);
      }
    }
    static async flush(changes, db) {
      if (changes === null)
        return true;
      const w = db.write({ autoDestroy: true });
      for (const [start, value, end] of changes) {
        if (end !== null)
          w.tryDeleteRange(start, end);
        else if (value !== null)
          w.tryPut(start, value);
        else
          w.tryDelete(start);
      }
      await w.flush();
      return true;
    }
  }
  module.exports = View;
  function cmpChange(a, b) {
    const c = b4a.compare(a[0], b[0]);
    return c === 0 ? b4a.compare(a[2], b[2]) : c;
  }
  function cmpChangeReverse(a, b) {
    return cmpChange(b, a);
  }
  function noop() {}
  function reverseArray(list) {
    const r = new Array(list.length);
    for (let i = 0;i < list.length; i++)
      r[r.length - 1 - i] = list[i];
    return r;
  }
  function dbClosing(db) {
    return db._state.closing || db._index === -1;
  }
});

// node_modules/index-encoder/index.js
var require_index_encoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var EMPTY = b4a.alloc(0);
  var MAX = b4a.from([255]);
  var BUFFER = {};
  BUFFER.preencode = function(state, buf) {
    if (buf === null)
      buf = EMPTY;
    let i = 0;
    let extra = 3;
    while ((i = b4a.indexOf(buf, 0, i)) > -1) {
      i++;
      extra++;
    }
    state.end += buf.byteLength + extra;
  };
  BUFFER.encode = function(state, buf) {
    if (buf === null)
      buf = EMPTY;
    state.buffer[state.start++] = 0;
    let prev = 0;
    let i = 0;
    while ((i = b4a.indexOf(buf, 0, i)) > -1) {
      const slice2 = buf.subarray(prev, ++i);
      state.buffer.set(slice2, state.start);
      state.start += slice2.byteLength;
      state.buffer[state.start++] = 2;
      prev = i;
    }
    const slice = buf.subarray(prev);
    state.buffer.set(slice, state.start);
    state.start += slice.byteLength;
    state.buffer[state.start++] = 0;
    state.buffer[state.start++] = 1;
  };
  BUFFER.decode = function(state) {
    if (state.start >= state.end)
      throw new Error("Out of bounds");
    if (state.buffer[state.start++] !== 0)
      throw new Error("Invalid start of string");
    let escaped = null;
    let prev = state.start;
    let i = state.start;
    while ((i = b4a.indexOf(state.buffer, 0, i)) > -1) {
      const next = ++i < state.end ? state.buffer[i] : 0;
      i++;
      if (next === 1) {
        break;
      }
      if (next === 2) {
        if (escaped === null)
          escaped = [];
        escaped.push(state.buffer.subarray(prev, i - 1));
        prev = i;
        continue;
      }
      throw new Error("Unknown value in terminator");
    }
    if (i === -1) {
      throw new Error("No terminator found");
    }
    state.start = i;
    const last = state.buffer.subarray(prev, i - 2);
    if (escaped === null)
      return last;
    escaped.push(last);
    return b4a.concat(escaped);
  };
  var STRING = {};
  STRING.preencode = function(state, str) {
    BUFFER.preencode(state, b4a.from(str || ""));
  };
  STRING.encode = function(state, str) {
    BUFFER.encode(state, b4a.from(str || ""));
  };
  STRING.decode = function(state, str) {
    return b4a.toString(BUFFER.decode(state));
  };
  var UINT = {};
  UINT.preencode = function(state, n) {
    state.end += n <= 251 ? 1 : n <= 65535 ? 3 : n <= 4294967295 ? 5 : n === Infinity ? 1 : 9;
  };
  UINT.encode = function(state, n) {
    if (n === Infinity) {
      state.buffer[state.start++] = 255;
      return;
    }
    if (n <= 251) {
      state.buffer[state.start++] = n;
      return;
    }
    if (n <= 65535) {
      state.buffer[state.start++] = 252;
      state.buffer[state.start++] = n >>> 8;
      state.buffer[state.start++] = n;
      return;
    }
    if (n <= 4294967295) {
      state.buffer[state.start++] = 253;
      encodeUint32(state, n);
      return;
    }
    if (Number.isSafeInteger(n)) {
      state.buffer[state.start++] = 254;
      const r = Math.floor(n / 4294967296);
      encodeUint32(state, r);
      encodeUint32(state, n);
      return;
    }
    throw new Error("Invalid number " + n);
  };
  UINT.decode = function(state) {
    if (state.start >= state.end)
      throw new Error("Out of bounds");
    const a = state.buffer[state.start++];
    if (a <= 251)
      return a;
    if (a === 252) {
      if (state.end - state.start < 2)
        throw new Error("Out of bounds");
      return state.buffer[state.start++] * 256 + state.buffer[state.start++];
    }
    if (a === 253) {
      return decodeUint32(state);
    }
    if (a === 254) {
      return decodeUint32(state) * 4294967296 + decodeUint32(state);
    }
    return Infinity;
  };
  var BOOL = {};
  BOOL.preencode = (state, b) => UINT.preencode(state, b ? 1 : 0);
  BOOL.encode = (state, b) => UINT.encode(state, b ? 1 : 0);
  BOOL.decode = (state, b) => !!UINT.decode(state);
  module.exports = class IndexEncoder {
    constructor(encodings, { prefix = -1 } = {}) {
      this.encodings = encodings;
      this.prefix = prefix;
    }
    static BUFFER = BUFFER;
    static STRING = STRING;
    static UINT = UINT;
    static BOOL = BOOL;
    static lookup(c) {
      switch (c) {
        case "uint":
          return UINT;
        case "uint8":
          return UINT;
        case "uint16":
          return UINT;
        case "uint24":
          return UINT;
        case "uint32":
          return UINT;
        case "uint40":
          return UINT;
        case "uint48":
          return UINT;
        case "uint56":
          return UINT;
        case "uint64":
          return UINT;
        case "string":
          return STRING;
        case "utf8":
          return STRING;
        case "ascii":
          return STRING;
        case "hex":
          return STRING;
        case "base64":
          return STRING;
        case "fixed32":
          return BUFFER;
        case "fixed64":
          return BUFFER;
        case "buffer":
          return BUFFER;
        case "bool":
          return BOOL;
      }
      throw new Error("Unknown type");
    }
    encode(keys) {
      return this._encode(keys, false);
    }
    _encode(keys, terminate) {
      if (b4a.isBuffer(keys))
        return keys;
      const state = { start: 0, end: 0, buffer: null };
      if (this.prefix !== -1)
        UINT.preencode(state, this.prefix);
      for (let i = 0;i < keys.length; i++) {
        this.encodings[i].preencode(state, keys[i]);
      }
      if (terminate && keys.length < this.encodings.length) {
        state.end++;
      }
      state.buffer = b4a.allocUnsafe(state.end);
      if (this.prefix !== -1)
        UINT.encode(state, this.prefix);
      for (let i = 0;i < keys.length; i++) {
        this.encodings[i].encode(state, keys[i]);
      }
      if (terminate && keys.length < this.encodings.length) {
        state.buffer[state.start++] = MAX[0];
      }
      return state.buffer;
    }
    decode(buffer) {
      const state = { start: 0, end: buffer.byteLength, buffer };
      const result = [];
      if (this.prefix !== -1)
        UINT.decode(state);
      for (const enc of this.encodings) {
        const key = state.start < state.end ? enc.decode(state) : enc === UINT ? 0 : null;
        result.push(key);
      }
      return result;
    }
    encodeRange({ gt, gte, lt, lte }) {
      const range = {
        gt: gt && this._encode(gt, true),
        gte: gte && this._encode(gte, false),
        lt: lt && this._encode(lt, false),
        lte: lte && this._encode(lte, true)
      };
      if (this.prefix !== -1) {
        if (!gt && !gte)
          range.gte = encodeUint(this.prefix);
        if (!lt && !lte)
          range.lt = encodeUint(this.prefix + 1);
      }
      return range;
    }
  };
  function encodeUint(n) {
    const state = { start: 0, end: 0, buffer: null };
    UINT.preencode(state, n);
    state.buffer = b4a.allocUnsafe(state.end);
    UINT.encode(state, n);
    return state.buffer;
  }
  function encodeUint32(state, n) {
    state.buffer[state.start++] = n >>> 24;
    state.buffer[state.start++] = n >>> 16;
    state.buffer[state.start++] = n >>> 8;
    state.buffer[state.start++] = n;
  }
  function decodeUint32(state, n) {
    if (state.end - state.start < 4)
      throw new Error("Out of bounds");
    return state.buffer[state.start++] * 16777216 + state.buffer[state.start++] * 65536 + state.buffer[state.start++] * 256 + state.buffer[state.start++];
  }
});

// node_modules/hypercore-storage/lib/keys.js
var require_keys = __commonJS((exports, module) => {
  var { UINT, STRING } = require_index_encoder();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var TL_HEAD = 0;
  var TL_CORE_BY_DKEY = 1;
  var TL_CORE_BY_ALIAS = 2;
  var TL_CORE = 3;
  var TL_DATA = 4;
  var TL_END = TL_DATA + 1;
  var CORE_AUTH = 0;
  var CORE_SESSIONS = 1;
  var DATA_HEAD = 0;
  var DATA_DEPENDENCY = 1;
  var DATA_HINTS = 2;
  var DATA_BLOCK = 3;
  var DATA_TREE = 4;
  var DATA_BITFIELD = 5;
  var DATA_USER_DATA = 6;
  var DATA_LOCAL = 7;
  var slab = { buffer: b4a.allocUnsafe(65536), start: 0, end: 0 };
  var store = {};
  var core = {};
  store.clear = function() {
    const state = alloc();
    let start = state.start;
    UINT.encode(state, 0);
    const a = state.buffer.subarray(start, state.start);
    start = state.start;
    UINT.encode(state, TL_END);
    const b = state.buffer.subarray(start, state.start);
    return [a, b];
  };
  store.head = function() {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_HEAD);
    return state.buffer.subarray(start, state.start);
  };
  store.core = function(discoveryKey) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE_BY_DKEY);
    c.fixed32.encode(state, discoveryKey);
    return state.buffer.subarray(start, state.start);
  };
  store.coreStart = function() {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE_BY_DKEY);
    return state.buffer.subarray(start, state.start);
  };
  store.coreEnd = function() {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE_BY_DKEY + 1);
    return state.buffer.subarray(start, state.start);
  };
  store.coreByAlias = function({ namespace, name }) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE_BY_ALIAS);
    c.fixed32.encode(state, namespace);
    STRING.encode(state, name);
    return state.buffer.subarray(start, state.start);
  };
  store.coreByAliasStart = function(namespace) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE_BY_ALIAS);
    if (namespace)
      c.fixed32.encode(state, namespace);
    return state.buffer.subarray(start, state.start);
  };
  store.coreByAliasEnd = function(namespace) {
    const state = alloc();
    const start = state.start;
    if (namespace) {
      UINT.encode(state, TL_CORE_BY_ALIAS);
      c.fixed32.encode(state, namespace);
      state.buffer[state.start++] = 255;
    } else {
      UINT.encode(state, TL_CORE_BY_ALIAS + 1);
    }
    return state.buffer.subarray(start, state.start);
  };
  store.alias = function(buffer) {
    const state = { buffer, start: 0, end: buffer.byteLength };
    UINT.decode(state);
    const namespace = c.fixed32.decode(state);
    const name = STRING.decode(state);
    return { namespace, name };
  };
  store.discoveryKey = function(buffer) {
    const state = { buffer, start: 0, end: buffer.byteLength };
    UINT.decode(state);
    return c.fixed32.decode(state);
  };
  core.core = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE);
    UINT.encode(state, ptr);
    return state.buffer.subarray(start, state.start);
  };
  core.data = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    return state.buffer.subarray(start, state.start);
  };
  core.auth = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE);
    UINT.encode(state, ptr);
    UINT.encode(state, CORE_AUTH);
    return state.buffer.subarray(start, state.start);
  };
  core.sessions = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_CORE);
    UINT.encode(state, ptr);
    UINT.encode(state, CORE_SESSIONS);
    return state.buffer.subarray(start, state.start);
  };
  core.head = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_HEAD);
    return state.buffer.subarray(start, state.start);
  };
  core.dependency = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_DEPENDENCY);
    return state.buffer.subarray(start, state.start);
  };
  core.hints = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_HINTS);
    return state.buffer.subarray(start, state.start);
  };
  core.block = function(ptr, index) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_BLOCK);
    UINT.encode(state, index);
    return state.buffer.subarray(start, state.start);
  };
  core.tree = function(ptr, index) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_TREE);
    UINT.encode(state, index);
    return state.buffer.subarray(start, state.start);
  };
  core.bitfield = function(ptr, index, type) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_BITFIELD);
    UINT.encode(state, index);
    UINT.encode(state, type);
    return state.buffer.subarray(start, state.start);
  };
  core.userData = function(ptr, key) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_USER_DATA);
    STRING.encode(state, key);
    return state.buffer.subarray(start, state.start);
  };
  core.userDataEnd = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_USER_DATA + 1);
    return state.buffer.subarray(start, state.start);
  };
  core.local = function(ptr, key) {
    if (key.byteLength > 2048) {
      throw new Error("local keys has an upper limit of 2048 bytes atm");
    }
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_LOCAL);
    state.buffer.set(key, state.start);
    state.start += key.byteLength;
    return state.buffer.subarray(start, state.start);
  };
  core.localEnd = function(ptr) {
    const state = alloc();
    const start = state.start;
    UINT.encode(state, TL_DATA);
    UINT.encode(state, ptr);
    UINT.encode(state, DATA_LOCAL + 1);
    return state.buffer.subarray(start, state.start);
  };
  core.blockIndex = function(buffer) {
    const state = { buffer, start: 0, end: buffer.byteLength };
    UINT.decode(state);
    UINT.decode(state);
    UINT.decode(state);
    return UINT.decode(state);
  };
  core.bitfieldIndexAndType = function(buffer) {
    const state = { buffer, start: 0, end: buffer.byteLength };
    UINT.decode(state);
    UINT.decode(state);
    UINT.decode(state);
    return [UINT.decode(state), UINT.decode(state)];
  };
  core.userDataKey = function(buffer) {
    const state = { buffer, start: 0, end: buffer.byteLength };
    UINT.decode(state);
    UINT.decode(state);
    UINT.decode(state);
    return STRING.decode(state);
  };
  core.localKey = function(buffer) {
    const state = { buffer, start: 0, end: buffer.byteLength };
    UINT.decode(state);
    UINT.decode(state);
    UINT.decode(state);
    return state.buffer.subarray(state.start, state.end);
  };
  module.exports = { store, core };
  function alloc() {
    if (slab.buffer.byteLength - slab.start < 4096) {
      slab.buffer = b4a.allocUnsafe(slab.buffer.byteLength);
      slab.start = 0;
    }
    return slab;
  }
});

// node_modules/hypercore-storage/spec/hyperschema/index.js
var require_hyperschema2 = __commonJS((exports, module) => {
  var VERSION = 1;
  var { c } = require_runtime2();
  var version = VERSION;
  var encoding0 = {
    preencode(state, m) {
      c.uint.preencode(state, m.cores);
      c.uint.preencode(state, m.datas);
    },
    encode(state, m) {
      c.uint.encode(state, m.cores);
      c.uint.encode(state, m.datas);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.uint.decode(state);
      return {
        cores: r0,
        datas: r1
      };
    }
  };
  var encoding1 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      state.end++;
      if (m.allocated)
        encoding0.preencode(state, m.allocated);
      if (m.seed)
        c.fixed32.preencode(state, m.seed);
      if (m.defaultDiscoveryKey)
        c.fixed32.preencode(state, m.defaultDiscoveryKey);
    },
    encode(state, m) {
      const flags = (m.allocated ? 1 : 0) | (m.seed ? 2 : 0) | (m.defaultDiscoveryKey ? 4 : 0);
      c.uint.encode(state, m.version);
      c.uint.encode(state, flags);
      if (m.allocated)
        encoding0.encode(state, m.allocated);
      if (m.seed)
        c.fixed32.encode(state, m.seed);
      if (m.defaultDiscoveryKey)
        c.fixed32.encode(state, m.defaultDiscoveryKey);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: r0,
        allocated: (flags & 1) !== 0 ? encoding0.decode(state) : null,
        seed: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,
        defaultDiscoveryKey: (flags & 4) !== 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  var encoding2 = {
    preencode(state, m) {
      c.string.preencode(state, m.name);
      c.fixed32.preencode(state, m.namespace);
    },
    encode(state, m) {
      c.string.encode(state, m.name);
      c.fixed32.encode(state, m.namespace);
    },
    decode(state) {
      const r0 = c.string.decode(state);
      const r1 = c.fixed32.decode(state);
      return {
        name: r0,
        namespace: r1
      };
    }
  };
  var encoding3 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      c.uint.preencode(state, m.corePointer);
      c.uint.preencode(state, m.dataPointer);
      state.end++;
      if (m.alias)
        encoding2.preencode(state, m.alias);
    },
    encode(state, m) {
      const flags = m.alias ? 1 : 0;
      c.uint.encode(state, m.version);
      c.uint.encode(state, m.corePointer);
      c.uint.encode(state, m.dataPointer);
      c.uint.encode(state, flags);
      if (m.alias)
        encoding2.encode(state, m.alias);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.uint.decode(state);
      const r2 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: r0,
        corePointer: r1,
        dataPointer: r2,
        alias: (flags & 1) !== 0 ? encoding2.decode(state) : null
      };
    }
  };
  var encoding4_enum = {
    blake2b: "blake2b"
  };
  var encoding4 = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      switch (m) {
        case "blake2b":
          c.uint.encode(state, 0);
          break;
        default:
          throw new Error("Unknown enum");
      }
    },
    decode(state) {
      switch (c.uint.decode(state)) {
        case 0:
          return "blake2b";
        default:
          return null;
      }
    }
  };
  var encoding5_enum = {
    ed25519: "ed25519"
  };
  var encoding5 = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      switch (m) {
        case "ed25519":
          c.uint.encode(state, 0);
          break;
        default:
          throw new Error("Unknown enum");
      }
    },
    decode(state) {
      switch (c.uint.decode(state)) {
        case 0:
          return "ed25519";
        default:
          return null;
      }
    }
  };
  var encoding6 = {
    preencode(state, m) {
      c.uint.preencode(state, m.index);
      c.uint.preencode(state, m.size);
      c.fixed32.preencode(state, m.hash);
    },
    encode(state, m) {
      c.uint.encode(state, m.index);
      c.uint.encode(state, m.size);
      c.fixed32.encode(state, m.hash);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.uint.decode(state);
      const r2 = c.fixed32.decode(state);
      return {
        index: r0,
        size: r1,
        hash: r2
      };
    }
  };
  var encoding7 = {
    preencode(state, m) {
      encoding5.preencode(state, m.signature);
      c.fixed32.preencode(state, m.namespace);
      c.fixed32.preencode(state, m.publicKey);
    },
    encode(state, m) {
      encoding5.encode(state, m.signature);
      c.fixed32.encode(state, m.namespace);
      c.fixed32.encode(state, m.publicKey);
    },
    decode(state) {
      const r0 = encoding5.decode(state);
      const r1 = c.fixed32.decode(state);
      const r2 = c.fixed32.decode(state);
      return {
        signature: r0,
        namespace: r1,
        publicKey: r2
      };
    }
  };
  var encoding8 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.hash);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.hash);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      const r0 = c.fixed32.decode(state);
      const r1 = c.uint.decode(state);
      return {
        hash: r0,
        length: r1
      };
    }
  };
  var encoding9_4 = c.array(encoding7);
  var encoding9_6 = c.array(c.fixed32);
  var encoding9 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      state.end++;
      encoding4.preencode(state, m.hash);
      c.uint.preencode(state, m.quorum);
      encoding9_4.preencode(state, m.signers);
      if (m.prologue)
        encoding8.preencode(state, m.prologue);
      if (m.linked)
        encoding9_6.preencode(state, m.linked);
      if (m.userData)
        c.buffer.preencode(state, m.userData);
    },
    encode(state, m) {
      const flags = (m.allowPatch ? 1 : 0) | (m.prologue ? 2 : 0) | (m.linked ? 4 : 0) | (m.userData ? 8 : 0);
      c.uint.encode(state, m.version);
      c.uint.encode(state, flags);
      encoding4.encode(state, m.hash);
      c.uint.encode(state, m.quorum);
      encoding9_4.encode(state, m.signers);
      if (m.prologue)
        encoding8.encode(state, m.prologue);
      if (m.linked)
        encoding9_6.encode(state, m.linked);
      if (m.userData)
        c.buffer.encode(state, m.userData);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: r0,
        hash: encoding4.decode(state),
        quorum: c.uint.decode(state),
        allowPatch: (flags & 1) !== 0,
        signers: encoding9_4.decode(state),
        prologue: (flags & 2) !== 0 ? encoding8.decode(state) : null,
        linked: (flags & 4) !== 0 ? encoding9_6.decode(state) : null,
        userData: (flags & 8) !== 0 ? c.buffer.decode(state) : null
      };
    }
  };
  var encoding10 = {
    preencode(state, m) {
      c.buffer.preencode(state, m.publicKey);
      c.buffer.preencode(state, m.secretKey);
    },
    encode(state, m) {
      c.buffer.encode(state, m.publicKey);
      c.buffer.encode(state, m.secretKey);
    },
    decode(state) {
      const r0 = c.buffer.decode(state);
      const r1 = c.buffer.decode(state);
      return {
        publicKey: r0,
        secretKey: r1
      };
    }
  };
  var encoding11_2 = c.frame(encoding9);
  var encoding11 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.fixed32.preencode(state, m.discoveryKey);
      state.end++;
      if (m.manifest)
        encoding11_2.preencode(state, m.manifest);
      if (m.keyPair)
        encoding10.preencode(state, m.keyPair);
      if (m.encryptionKey)
        c.buffer.preencode(state, m.encryptionKey);
    },
    encode(state, m) {
      const flags = (m.manifest ? 1 : 0) | (m.keyPair ? 2 : 0) | (m.encryptionKey ? 4 : 0);
      c.fixed32.encode(state, m.key);
      c.fixed32.encode(state, m.discoveryKey);
      c.uint.encode(state, flags);
      if (m.manifest)
        encoding11_2.encode(state, m.manifest);
      if (m.keyPair)
        encoding10.encode(state, m.keyPair);
      if (m.encryptionKey)
        c.buffer.encode(state, m.encryptionKey);
    },
    decode(state) {
      const r0 = c.fixed32.decode(state);
      const r1 = c.fixed32.decode(state);
      const flags = c.uint.decode(state);
      return {
        key: r0,
        discoveryKey: r1,
        manifest: (flags & 1) !== 0 ? encoding11_2.decode(state) : null,
        keyPair: (flags & 2) !== 0 ? encoding10.decode(state) : null,
        encryptionKey: (flags & 4) !== 0 ? c.buffer.decode(state) : null
      };
    }
  };
  var encoding12 = {
    preencode(state, m) {
      c.uint.preencode(state, m.fork);
      c.uint.preencode(state, m.length);
      c.fixed32.preencode(state, m.rootHash);
      c.buffer.preencode(state, m.signature);
    },
    encode(state, m) {
      c.uint.encode(state, m.fork);
      c.uint.encode(state, m.length);
      c.fixed32.encode(state, m.rootHash);
      c.buffer.encode(state, m.signature);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.uint.decode(state);
      const r2 = c.fixed32.decode(state);
      const r3 = c.buffer.decode(state);
      return {
        fork: r0,
        length: r1,
        rootHash: r2,
        signature: r3
      };
    }
  };
  var encoding13 = {
    preencode(state, m) {
      state.end++;
      if (m.contiguousLength)
        c.uint.preencode(state, m.contiguousLength);
    },
    encode(state, m) {
      const flags = m.contiguousLength ? 1 : 0;
      c.uint.encode(state, flags);
      if (m.contiguousLength)
        c.uint.encode(state, m.contiguousLength);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        contiguousLength: (flags & 1) !== 0 ? c.uint.decode(state) : 0
      };
    }
  };
  var encoding14 = {
    preencode(state, m) {
      c.string.preencode(state, m.name);
      c.uint.preencode(state, m.dataPointer);
    },
    encode(state, m) {
      c.string.encode(state, m.name);
      c.uint.encode(state, m.dataPointer);
    },
    decode(state) {
      const r0 = c.string.decode(state);
      const r1 = c.uint.decode(state);
      return {
        name: r0,
        dataPointer: r1
      };
    }
  };
  var encoding15 = c.array(encoding14);
  var encoding16 = {
    preencode(state, m) {
      c.uint.preencode(state, m.dataPointer);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.dataPointer);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.uint.decode(state);
      return {
        dataPointer: r0,
        length: r1
      };
    }
  };
  function setVersion(v) {
    version = v;
  }
  function encode(name, value, v = VERSION) {
    version = v;
    return c.encode(getEncoding(name), value);
  }
  function decode(name, buffer, v = VERSION) {
    version = v;
    return c.decode(getEncoding(name), buffer);
  }
  function getEnum(name) {
    switch (name) {
      case "@core/hashes":
        return encoding4_enum;
      case "@core/signatures":
        return encoding5_enum;
      default:
        throw new Error("Enum not found " + name);
    }
  }
  function getEncoding(name) {
    switch (name) {
      case "@corestore/allocated":
        return encoding0;
      case "@corestore/head":
        return encoding1;
      case "@corestore/alias":
        return encoding2;
      case "@corestore/core":
        return encoding3;
      case "@core/hashes":
        return encoding4;
      case "@core/signatures":
        return encoding5;
      case "@core/tree-node":
        return encoding6;
      case "@core/signer":
        return encoding7;
      case "@core/prologue":
        return encoding8;
      case "@core/manifest":
        return encoding9;
      case "@core/keyPair":
        return encoding10;
      case "@core/auth":
        return encoding11;
      case "@core/head":
        return encoding12;
      case "@core/hints":
        return encoding13;
      case "@core/session":
        return encoding14;
      case "@core/sessions":
        return encoding15;
      case "@core/dependency":
        return encoding16;
      default:
        throw new Error("Encoder not found " + name);
    }
  }
  function getStruct(name, v = VERSION) {
    const enc = getEncoding(name);
    return {
      preencode(state, m) {
        version = v;
        enc.preencode(state, m);
      },
      encode(state, m) {
        version = v;
        enc.encode(state, m);
      },
      decode(state) {
        version = v;
        return enc.decode(state);
      }
    };
  }
  var resolveStruct = getStruct;
  module.exports = { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version };
});

// node_modules/flat-tree/index.js
var require_flat_tree = __commonJS((exports) => {
  exports.fullRoots = function(index, result) {
    if (index & 1)
      throw new Error("You can only look up roots for depth(0) blocks");
    if (!result)
      result = [];
    index /= 2;
    let offset = 0;
    let factor = 1;
    while (true) {
      if (!index)
        return result;
      while (factor * 2 <= index)
        factor *= 2;
      result.push(offset + factor - 1);
      offset = offset + 2 * factor;
      index -= factor;
      factor = 1;
    }
  };
  exports.futureRoots = function(index, result) {
    if (index & 1)
      throw new Error("You can only look up future roots for depth(0) blocks");
    if (!result)
      result = [];
    let factor = 1;
    while (factor * 2 <= index)
      factor *= 2;
    if (factor * 2 - 2 === index)
      return result;
    let pos = factor / 2 - 1;
    while (pos + factor / 2 - 1 !== index) {
      pos += factor;
      while (pos + factor / 2 - 1 > index) {
        factor /= 2;
        pos -= factor / 2;
      }
      result.push(pos - factor / 2);
    }
    return result;
  };
  exports.patch = function(from, to) {
    if (from === 0 || from >= to)
      return [];
    const roots = exports.fullRoots(from);
    const target = exports.fullRoots(to);
    let i = 0;
    for (;i < target.length; i++) {
      if (i >= roots.length || roots[i] !== target[i])
        break;
    }
    const patch = [];
    if (i < roots.length) {
      let prev = roots.length - 1;
      const ite = exports.iterator(roots[prev--]);
      while (ite.index !== target[i]) {
        ite.sibling();
        if (prev >= 0 && ite.index === roots[prev]) {
          prev--;
        } else {
          patch.push(ite.index);
        }
        patch.push(ite.parent());
      }
      i++;
    }
    for (;i < target.length; i++)
      patch.push(target[i]);
    return patch;
  };
  exports.depth = function(index) {
    let depth = 0;
    index += 1;
    while (!(index & 1)) {
      depth++;
      index = rightShift(index);
    }
    return depth;
  };
  exports.sibling = function(index, depth) {
    if (!depth)
      depth = exports.depth(index);
    const offset = exports.offset(index, depth);
    return exports.index(depth, offset & 1 ? offset - 1 : offset + 1);
  };
  exports.parent = function(index, depth) {
    if (!depth)
      depth = exports.depth(index);
    const offset = exports.offset(index, depth);
    return exports.index(depth + 1, rightShift(offset));
  };
  exports.leftChild = function(index, depth) {
    if (!(index & 1))
      return -1;
    if (!depth)
      depth = exports.depth(index);
    return exports.index(depth - 1, exports.offset(index, depth) * 2);
  };
  exports.rightChild = function(index, depth) {
    if (!(index & 1))
      return -1;
    if (!depth)
      depth = exports.depth(index);
    return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2);
  };
  exports.children = function(index, depth) {
    if (!(index & 1))
      return null;
    if (!depth)
      depth = exports.depth(index);
    const offset = exports.offset(index, depth) * 2;
    return [
      exports.index(depth - 1, offset),
      exports.index(depth - 1, offset + 1)
    ];
  };
  exports.leftSpan = function(index, depth) {
    if (!(index & 1))
      return index;
    if (!depth)
      depth = exports.depth(index);
    return exports.offset(index, depth) * twoPow(depth + 1);
  };
  exports.rightSpan = function(index, depth) {
    if (!(index & 1))
      return index;
    if (!depth)
      depth = exports.depth(index);
    return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2;
  };
  exports.nextLeaf = function(index) {
    let factor = 1;
    let r = index;
    while ((r & 1) === 1) {
      r = (r - 1) / 2;
      factor *= 2;
    }
    return index + factor + 1;
  };
  exports.count = function(index, depth) {
    if (!(index & 1))
      return 1;
    if (!depth)
      depth = exports.depth(index);
    return twoPow(depth + 1) - 1;
  };
  exports.countLeaves = function(index) {
    return (exports.count(index) + 1) / 2;
  };
  exports.spans = function(index, depth) {
    if (!(index & 1))
      return [index, index];
    if (!depth)
      depth = exports.depth(index);
    const offset = exports.offset(index, depth);
    const width = twoPow(depth + 1);
    return [offset * width, (offset + 1) * width - 2];
  };
  exports.index = function(depth, offset) {
    return (1 + 2 * offset) * twoPow(depth) - 1;
  };
  exports.offset = function(index, depth) {
    if (!(index & 1))
      return index / 2;
    if (!depth)
      depth = exports.depth(index);
    return ((index + 1) / twoPow(depth) - 1) / 2;
  };
  exports.iterator = function(index) {
    const ite = new Iterator;
    ite.seek(index || 0);
    return ite;
  };
  function twoPow(n) {
    return n < 31 ? 1 << n : (1 << 30) * (1 << n - 30);
  }
  function rightShift(n) {
    return (n - (n & 1)) / 2;
  }
  function Iterator() {
    this.index = 0;
    this.offset = 0;
    this.factor = 0;
  }
  Iterator.prototype.seek = function(index) {
    this.index = index;
    if (this.index & 1) {
      this.offset = exports.offset(index);
      this.factor = twoPow(exports.depth(index) + 1);
    } else {
      this.offset = index / 2;
      this.factor = 2;
    }
  };
  Iterator.prototype.isLeft = function() {
    return (this.offset & 1) === 0;
  };
  Iterator.prototype.isRight = function() {
    return (this.offset & 1) === 1;
  };
  Iterator.prototype.contains = function(index) {
    return index > this.index ? index < this.index + this.factor / 2 : index < this.index ? index > this.index - this.factor / 2 : true;
  };
  Iterator.prototype.prev = function() {
    if (!this.offset)
      return this.index;
    this.offset--;
    this.index -= this.factor;
    return this.index;
  };
  Iterator.prototype.next = function() {
    this.offset++;
    this.index += this.factor;
    return this.index;
  };
  Iterator.prototype.count = function() {
    if (!(this.index & 1))
      return 1;
    return this.factor - 1;
  };
  Iterator.prototype.countLeaves = function() {
    return (this.count() + 1) / 2;
  };
  Iterator.prototype.sibling = function() {
    return this.isLeft() ? this.next() : this.prev();
  };
  Iterator.prototype.parent = function() {
    if (this.offset & 1) {
      this.index -= this.factor / 2;
      this.offset = (this.offset - 1) / 2;
    } else {
      this.index += this.factor / 2;
      this.offset /= 2;
    }
    this.factor *= 2;
    return this.index;
  };
  Iterator.prototype.leftSpan = function() {
    this.index = this.index - this.factor / 2 + 1;
    this.offset = this.index / 2;
    this.factor = 2;
    return this.index;
  };
  Iterator.prototype.rightSpan = function() {
    this.index = this.index + this.factor / 2 - 1;
    this.offset = this.index / 2;
    this.factor = 2;
    return this.index;
  };
  Iterator.prototype.leftChild = function() {
    if (this.factor === 2)
      return this.index;
    this.factor /= 2;
    this.index -= this.factor / 2;
    this.offset *= 2;
    return this.index;
  };
  Iterator.prototype.rightChild = function() {
    if (this.factor === 2)
      return this.index;
    this.factor /= 2;
    this.index += this.factor / 2;
    this.offset = 2 * this.offset + 1;
    return this.index;
  };
  Iterator.prototype.nextTree = function() {
    this.index = this.index + this.factor / 2 + 1;
    this.offset = this.index / 2;
    this.factor = 2;
    return this.index;
  };
  Iterator.prototype.prevTree = function() {
    if (!this.offset) {
      this.index = 0;
      this.factor = 2;
    } else {
      this.index = this.index - this.factor / 2 - 1;
      this.offset = this.index / 2;
      this.factor = 2;
    }
    return this.index;
  };
  Iterator.prototype.fullRoot = function(index) {
    if (index <= this.index || (this.index & 1) > 0)
      return false;
    while (index > this.index + this.factor + this.factor / 2) {
      this.index += this.factor / 2;
      this.factor *= 2;
      this.offset /= 2;
    }
    return true;
  };
});

// node_modules/hypercore-storage/lib/tx.js
var require_tx = __commonJS((exports, module) => {
  var schema = require_hyperschema2();
  var { store, core } = require_keys();
  var View = require_view();
  var b4a = require_b4a();
  var flat = require_flat_tree();
  var CORESTORE_HEAD = schema.getEncoding("@corestore/head");
  var CORESTORE_CORE = schema.getEncoding("@corestore/core");
  var CORE_AUTH = schema.getEncoding("@core/auth");
  var CORE_SESSIONS = schema.getEncoding("@core/sessions");
  var CORE_HEAD = schema.getEncoding("@core/head");
  var CORE_TREE_NODE = schema.getEncoding("@core/tree-node");
  var CORE_DEPENDENCY = schema.getEncoding("@core/dependency");
  var CORE_HINTS = schema.getEncoding("@core/hints");

  class CoreTX {
    constructor(core2, db, view, changes) {
      if (db.snapshotted)
        throw new Error("Cannot open core tx on snapshot");
      this.core = core2;
      this.db = db;
      this.view = view;
      this.changes = changes;
    }
    setAuth(auth) {
      this.changes.push([core.auth(this.core.corePointer), encode(CORE_AUTH, auth), null]);
    }
    setSessions(sessions) {
      this.changes.push([core.sessions(this.core.corePointer), encode(CORE_SESSIONS, sessions), null]);
    }
    setHead(head) {
      this.changes.push([core.head(this.core.dataPointer), encode(CORE_HEAD, head), null]);
    }
    deleteHead() {
      this.changes.push([core.head(this.core.dataPointer), null, null]);
    }
    setDependency(dep) {
      this.changes.push([core.dependency(this.core.dataPointer), encode(CORE_DEPENDENCY, dep), null]);
    }
    setHints(hints) {
      this.changes.push([core.hints(this.core.dataPointer), encode(CORE_HINTS, hints), null]);
    }
    putBlock(index, data) {
      this.changes.push([core.block(this.core.dataPointer, index), data, null]);
    }
    deleteBlock(index) {
      this.changes.push([core.block(this.core.dataPointer, index), null, null]);
    }
    deleteBlockRange(start, end) {
      this.changes.push([
        core.block(this.core.dataPointer, start),
        null,
        core.block(this.core.dataPointer, end === -1 ? Infinity : end)
      ]);
    }
    putBitfieldPage(index, data) {
      this.changes.push([core.bitfield(this.core.dataPointer, index, 0), data, null]);
    }
    deleteBitfieldPage(index) {
      this.changes.push([core.bitfield(this.core.dataPointer, index, 0), null, null]);
    }
    deleteBitfieldPageRange(start, end) {
      this.changes.push([
        core.bitfield(this.core.dataPointer, start, 0),
        null,
        core.bitfield(this.core.dataPointer, end === -1 ? Infinity : end, 0)
      ]);
    }
    putTreeNode(node) {
      this.changes.push([core.tree(this.core.dataPointer, node.index), encode(CORE_TREE_NODE, node), null]);
    }
    deleteTreeNode(index) {
      this.changes.push([core.tree(this.core.dataPointer, index), null, null]);
    }
    deleteTreeNodeRange(start, end) {
      this.changes.push([
        core.tree(this.core.dataPointer, start),
        null,
        core.tree(this.core.dataPointer, end === -1 ? Infinity : end)
      ]);
    }
    putUserData(key, value) {
      const buffer = typeof value === "string" ? b4a.from(value) : value;
      this.changes.push([core.userData(this.core.dataPointer, key), buffer, null]);
    }
    deleteUserData(key) {
      this.changes.push([core.userData(this.core.dataPointer, key), null, null]);
    }
    putLocal(key, value) {
      this.changes.push([core.local(this.core.dataPointer, key), value, null]);
    }
    deleteLocal(key) {
      this.changes.push([core.local(this.core.dataPointer, key), null, null]);
    }
    deleteLocalRange(start, end) {
      this.changes.push([
        core.local(this.core.dataPointer, start),
        null,
        end === null ? core.localEnd(this.core.dataPointer) : core.local(this.core.dataPointer, end)
      ]);
    }
    flush() {
      const changes = this.changes;
      if (changes === null)
        return Promise.resolve(!this.view);
      this.changes = null;
      if (this.view) {
        this.view.apply(changes);
        return Promise.resolve(false);
      }
      return View.flush(changes, this.db);
    }
  }

  class CoreRX {
    constructor(core2, db, view) {
      this.core = core2;
      this.read = db.read({ autoDestroy: true });
      this.view = view;
      view.readStart();
    }
    async getAuth() {
      return await decode(CORE_AUTH, await this.view.get(this.read, core.auth(this.core.corePointer)));
    }
    async getSessions() {
      return await decode(CORE_SESSIONS, await this.view.get(this.read, core.sessions(this.core.corePointer)));
    }
    async getHead() {
      return await decode(CORE_HEAD, await this.view.get(this.read, core.head(this.core.dataPointer)));
    }
    async getDependency() {
      return await decode(CORE_DEPENDENCY, await this.view.get(this.read, core.dependency(this.core.dataPointer)));
    }
    async getHints() {
      return await decode(CORE_HINTS, await this.view.get(this.read, core.hints(this.core.dataPointer)));
    }
    getBlock(index) {
      const dep = findBlockDependency(this.core.dependencies, index);
      const data = dep === null ? this.core.dataPointer : dep.dataPointer;
      return this.view.get(this.read, core.block(data, index));
    }
    getBitfieldPage(index) {
      return this.view.get(this.read, core.bitfield(this.core.dataPointer, index, 0));
    }
    async getTreeNode(index) {
      const dep = findTreeDependency(this.core.dependencies, index);
      const data = dep === null ? this.core.dataPointer : dep.dataPointer;
      return decode(CORE_TREE_NODE, await this.view.get(this.read, core.tree(data, index)));
    }
    async hasTreeNode(index) {
      return await this.getTreeNode(index) !== null;
    }
    getUserData(key) {
      return this.view.get(this.read, core.userData(this.core.dataPointer, key));
    }
    getLocal(key) {
      return this.view.get(this.read, core.local(this.core.dataPointer, key));
    }
    tryFlush() {
      this.read.tryFlush();
      this._free();
    }
    destroy() {
      this.read.destroy();
      this._free();
    }
    _free() {
      if (this.view === null)
        return;
      this.view.readStop();
      this.view = null;
    }
  }

  class CorestoreTX {
    constructor(view) {
      this.view = view;
      this.changes = [];
    }
    setHead(head) {
      this.changes.push([store.head(), encode(CORESTORE_HEAD, head), null]);
    }
    putCore(discoveryKey, ptr) {
      this.changes.push([store.core(discoveryKey), encode(CORESTORE_CORE, ptr), null]);
    }
    putCoreByAlias(alias, discoveryKey) {
      this.changes.push([store.coreByAlias(alias), discoveryKey, null]);
    }
    clear() {
      const [start, end] = store.clear();
      this.changes.push([start, null, end]);
    }
    apply() {
      if (this.changes === null)
        return;
      this.view.apply(this.changes);
      this.changes = null;
    }
  }

  class CorestoreRX {
    constructor(db, view) {
      this.read = db.read({ autoDestroy: true });
      this.view = view;
      view.readStart();
    }
    async getHead() {
      return decode(CORESTORE_HEAD, await this.view.get(this.read, store.head()));
    }
    async getCore(discoveryKey) {
      return decode(CORESTORE_CORE, await this.view.get(this.read, store.core(discoveryKey)));
    }
    getCoreByAlias(alias) {
      return this.view.get(this.read, store.coreByAlias(alias));
    }
    tryFlush() {
      this.read.tryFlush();
      this._free();
    }
    destroy() {
      this.read.destroy();
      this._free();
    }
    _free() {
      if (this.view === null)
        return;
      this.view.readStop();
      this.view = null;
    }
  }
  module.exports = { CorestoreTX, CorestoreRX, CoreTX, CoreRX };
  function findBlockDependency(dependencies, index) {
    for (let i = 0;i < dependencies.length; i++) {
      const dep = dependencies[i];
      if (index < dep.length)
        return dep;
    }
    return null;
  }
  function findTreeDependency(dependencies, index) {
    for (let i = 0;i < dependencies.length; i++) {
      const dep = dependencies[i];
      if (flat.rightSpan(index) <= (dep.length - 1) * 2)
        return dep;
    }
    return null;
  }
  function decode(enc, buffer) {
    if (buffer === null)
      return null;
    return enc.decode({ start: 0, end: buffer.byteLength, buffer });
  }
  function encode(enc, m) {
    const state = { start: 0, end: 0, buffer: null };
    enc.preencode(state, m);
    state.buffer = b4a.allocUnsafe(state.end);
    enc.encode(state, m);
    return state.buffer;
  }
});

// node_modules/hypercore-storage/lib/block-dependency-stream.js
var require_block_dependency_stream = __commonJS((exports, module) => {
  var { Readable, getStreamError } = require_streamx();
  var { core } = require_keys();
  module.exports = class BlockStream extends Readable {
    constructor(core2, db, updates, start, end, reverse) {
      super();
      this.core = core2;
      this.db = db;
      this.updates = updates;
      this.start = start;
      this.end = end;
      this.reverse = reverse === true;
      this._drained = true;
      this._consumed = 0;
      this._stream = null;
      this._oncloseBound = this._onclose.bind(this);
      this._maybeDrainBound = this._maybeDrain.bind(this);
      this._update();
    }
    _update() {
      if (this._consumed > this.core.dependencies.length)
        return;
      const deps = this.core.dependencies;
      const index = this._findDependencyIndex(deps);
      const curr = index < deps.length ? deps[index] : null;
      const prev = index > 0 && index - 1 < deps.length ? deps[index - 1] : null;
      const start = prev && prev.length > this.start ? prev.length : this.start;
      const end = curr && (this.end === -1 || curr.length < this.end) ? curr.length : this.end;
      const ptr = curr ? curr.dataPointer : this.core.dataPointer;
      this._makeStream(core.block(ptr, start), core.block(ptr, end));
    }
    _findDependencyIndex(deps) {
      if (!this.reverse)
        return this._consumed++;
      let i = deps.length - this._consumed++;
      while (i > 0) {
        if (deps[i - 1].length <= this.end)
          return i;
        i--;
        this._consumed++;
      }
      return 0;
    }
    _predestroy() {
      if (this._stream !== null)
        this._stream.destroy();
    }
    _read(cb) {
      this._drained = this._onreadable();
      cb(null);
    }
    _maybeDrain() {
      if (this._drained === true)
        return;
      this._drained = this._onreadable();
    }
    _onreadable() {
      if (this._stream === null) {
        this.push(null);
        return true;
      }
      let data = this._stream.read();
      if (data === null)
        return false;
      do {
        this.push(data);
        data = this._stream.read();
      } while (data !== null);
      return true;
    }
    _onclose() {
      if (this.destroying)
        return;
      const err = getStreamError(this._stream);
      if (err !== null) {
        this.destroy(err);
        return;
      }
      if (this._onreadable() === true)
        this._drained = true;
      this._stream = null;
      this._update();
      this._maybeDrain();
    }
    _makeStream(start, end) {
      this._stream = this.updates.iterator(this.db, start, end, this.reverse);
      this._stream.on("readable", this._maybeDrainBound);
      this._stream.on("error", noop);
      this._stream.on("close", this._oncloseBound);
    }
  };
  function noop() {}
});

// node_modules/hypercore-storage/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var BlockDependencyStream = require_block_dependency_stream();
  var { core, store } = require_keys();
  var schema = require_hyperschema2();
  var CORESTORE_CORE = schema.getEncoding("@corestore/core");
  var CORE_TREE_NODE = schema.getEncoding("@core/tree-node");
  var EMPTY = b4a.alloc(0);
  module.exports = {
    createBlockStream,
    createBitfieldStream,
    createUserDataStream,
    createCoreStream,
    createAliasStream,
    createDiscoveryKeyStream,
    createTreeNodeStream,
    createLocalStream
  };
  function createCoreStream(db, view) {
    const start = store.coreStart();
    const end = store.coreEnd();
    const ite = view.iterator(db, start, end, false);
    ite._readableState.map = mapCore;
    return ite;
  }
  function createDiscoveryKeyStream(db, view, namespace) {
    const start = namespace ? store.coreByAliasStart(namespace) : store.coreStart();
    const end = namespace ? store.coreByAliasEnd(namespace) : store.coreEnd();
    const ite = view.iterator(db, start, end, false);
    ite._readableState.map = namespace ? mapNamespaceDiscoveryKeys : mapAllDiscoveryKeys;
    return ite;
  }
  function createAliasStream(db, view, namespace) {
    const start = store.coreByAliasStart(namespace);
    const end = store.coreByAliasEnd(namespace);
    const ite = view.iterator(db, start, end, false);
    ite._readableState.map = mapAlias;
    return ite;
  }
  function createBlockIterator(ptr, db, view, start, end, reverse) {
    if (ptr.dependencies.length > 0) {
      return new BlockDependencyStream(ptr, db, view, start, end, reverse);
    }
    const s = core.block(ptr.dataPointer, start);
    const e = core.block(ptr.dataPointer, end === -1 ? Infinity : end);
    return view.iterator(db, s, e, reverse);
  }
  function createBlockStream(ptr, db, view, { gt = -1, gte = gt + 1, lte = -1, lt = lte === -1 ? -1 : lte + 1, reverse = false } = {}) {
    const ite = createBlockIterator(ptr, db, view, gte, lt, reverse);
    ite._readableState.map = mapBlock;
    return ite;
  }
  function createBitfieldStream(ptr, db, view, { gt = -1, gte = gt + 1, lte = -1, lt = lte === -1 ? -1 : lte + 1, reverse = false } = {}) {
    const s = core.bitfield(ptr.dataPointer, gte, 0);
    const e = core.bitfield(ptr.dataPointer, lt === -1 ? Infinity : lt, 0);
    const ite = view.iterator(db, s, e, false);
    ite._readableState.map = mapBitfield;
    return ite;
  }
  function createTreeNodeStream(ptr, db, view, { gt = -1, gte = gt + 1, lte = -1, lt = lte === -1 ? -1 : lte + 1, reverse = false } = {}) {
    const s = core.tree(ptr.dataPointer, gte, 0);
    const e = core.tree(ptr.dataPointer, lt === -1 ? Infinity : lt, 0);
    const ite = view.iterator(db, s, e, false);
    ite._readableState.map = mapTreeNode;
    return ite;
  }
  function createUserDataStream(ptr, db, view, { gt = null, gte = "", lte = null, lt = null, reverse = false } = {}) {
    if (gt !== null || lte !== null)
      throw new Error("gt and lte not yet supported for user data streams");
    const s = core.userData(ptr.dataPointer, gte);
    const e = lt === null ? core.userDataEnd(ptr.dataPointer) : core.userData(ptr.dataPointer, lt);
    const ite = view.iterator(db, s, e, false);
    ite._readableState.map = mapUserData;
    return ite;
  }
  function createLocalStream(ptr, db, view, { gt = null, gte = EMPTY, lte = null, lt = null, reverse = false } = {}) {
    if (gt !== null || lte !== null)
      throw new Error("gt and lte not yet supported for local streams");
    const s = core.local(ptr.dataPointer, gte);
    const e = lt === null ? core.localEnd(ptr.dataPointer) : core.local(ptr.dataPointer, lt);
    const ite = view.iterator(db, s, e, false);
    ite._readableState.map = mapLocal;
    return ite;
  }
  function mapBitfield(data) {
    const [index, type] = core.bitfieldIndexAndType(data.key);
    if (type !== 0)
      return null;
    return { index, page: data.value };
  }
  function mapLocal(data) {
    const key = core.localKey(data.key);
    return { key, value: data.value };
  }
  function mapUserData(data) {
    const key = core.userDataKey(data.key);
    return { key, value: data.value };
  }
  function mapCore(data) {
    const discoveryKey = store.discoveryKey(data.key);
    const core2 = CORESTORE_CORE.decode({ start: 0, end: data.value.byteLength, buffer: data.value });
    return { discoveryKey, core: core2 };
  }
  function mapAllDiscoveryKeys(data) {
    return store.discoveryKey(data.key);
  }
  function mapNamespaceDiscoveryKeys(data) {
    return data.value;
  }
  function mapAlias(data) {
    const alias = store.alias(data.key);
    return { alias, discoveryKey: data.value };
  }
  function mapBlock(data) {
    return { index: core.blockIndex(data.key), value: data.value };
  }
  function mapTreeNode(data) {
    return CORE_TREE_NODE.decode({ start: 0, end: data.value.byteLength, buffer: data.value });
  }
});

// node_modules/hypercore-storage/migrations/0/messages.js
var require_messages = __commonJS((exports) => {
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var EMPTY = b4a.alloc(0);
  var DEFAULT_NAMESPACE = b4a.from("4144eea531e483d54e0c14f4ca68e0644f355343ff6fcb0f005200e12cd747cb", "hex");
  var hashes = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      if (m === "blake2b") {
        c.uint.encode(state, 0);
        return;
      }
      throw new Error("Unknown hash: " + m);
    },
    decode(state) {
      const n = c.uint.decode(state);
      if (n === 0)
        return "blake2b";
      throw new Error("Unknown hash id: " + n);
    }
  };
  var signatures = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      if (m === "ed25519") {
        c.uint.encode(state, 0);
        return;
      }
      throw new Error("Unknown signature: " + m);
    },
    decode(state) {
      const n = c.uint.decode(state);
      if (n === 0)
        return "ed25519";
      throw new Error("Unknown signature id: " + n);
    }
  };
  var signer = {
    preencode(state, m) {
      signatures.preencode(state, m.signature);
      c.fixed32.preencode(state, m.namespace);
      c.fixed32.preencode(state, m.publicKey);
    },
    encode(state, m) {
      signatures.encode(state, m.signature);
      c.fixed32.encode(state, m.namespace);
      c.fixed32.encode(state, m.publicKey);
    },
    decode(state) {
      return {
        signature: signatures.decode(state),
        namespace: c.fixed32.decode(state),
        publicKey: c.fixed32.decode(state)
      };
    }
  };
  var signerArray = c.array(signer);
  var prologue = {
    preencode(state, p) {
      c.fixed32.preencode(state, p.hash);
      c.uint.preencode(state, p.length);
    },
    encode(state, p) {
      c.fixed32.encode(state, p.hash);
      c.uint.encode(state, p.length);
    },
    decode(state) {
      return {
        hash: c.fixed32.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var manifestv0 = {
    preencode(state, m) {
      hashes.preencode(state, m.hash);
      state.end++;
      if (m.prologue && m.signers.length === 0) {
        c.fixed32.preencode(state, m.prologue.hash);
        return;
      }
      if (m.quorum === 1 && m.signers.length === 1 && !m.allowPatch) {
        signer.preencode(state, m.signers[0]);
      } else {
        state.end++;
        c.uint.preencode(state, m.quorum);
        signerArray.preencode(state, m.signers);
      }
    },
    encode(state, m) {
      hashes.encode(state, m.hash);
      if (m.prologue && m.signers.length === 0) {
        c.uint.encode(state, 0);
        c.fixed32.encode(state, m.prologue.hash);
        return;
      }
      if (m.quorum === 1 && m.signers.length === 1 && !m.allowPatch) {
        c.uint.encode(state, 1);
        signer.encode(state, m.signers[0]);
      } else {
        c.uint.encode(state, 2);
        c.uint.encode(state, m.allowPatch ? 1 : 0);
        c.uint.encode(state, m.quorum);
        signerArray.encode(state, m.signers);
      }
    },
    decode(state) {
      const hash = hashes.decode(state);
      const type = c.uint.decode(state);
      if (type > 2)
        throw new Error("Unknown type: " + type);
      if (type === 0) {
        return {
          version: 0,
          hash,
          allowPatch: false,
          quorum: 0,
          signers: [],
          prologue: {
            hash: c.fixed32.decode(state),
            length: 0
          }
        };
      }
      if (type === 1) {
        return {
          version: 0,
          hash,
          allowPatch: false,
          quorum: 1,
          signers: [signer.decode(state)],
          prologue: null
        };
      }
      const flags = c.uint.decode(state);
      return {
        version: 0,
        hash,
        allowPatch: (flags & 1) !== 0,
        quorum: c.uint.decode(state),
        signers: signerArray.decode(state),
        prologue: null
      };
    }
  };
  var manifest = exports.manifest = {
    preencode(state, m) {
      state.end++;
      if (m.version === 0)
        return manifestv0.preencode(state, m);
      state.end++;
      hashes.preencode(state, m.hash);
      c.uint.preencode(state, m.quorum);
      signerArray.preencode(state, m.signers);
      if (m.prologue)
        prologue.preencode(state, m.prologue);
    },
    encode(state, m) {
      c.uint.encode(state, m.version);
      if (m.version === 0)
        return manifestv0.encode(state, m);
      c.uint.encode(state, (m.allowPatch ? 1 : 0) | (m.prologue ? 2 : 0) | (m.unencrypted ? 4 : 0));
      hashes.encode(state, m.hash);
      c.uint.encode(state, m.quorum);
      signerArray.encode(state, m.signers);
      if (m.prologue)
        prologue.encode(state, m.prologue);
    },
    decode(state) {
      const v = c.uint.decode(state);
      if (v === 0)
        return manifestv0.decode(state);
      if (v !== 1)
        throw new Error("Unknown version: " + v);
      const flags = c.uint.decode(state);
      const hash = hashes.decode(state);
      const quorum = c.uint.decode(state);
      const signers = signerArray.decode(state);
      const unencrypted = (flags & 4) !== 0;
      return {
        version: 1,
        hash,
        allowPatch: (flags & 1) !== 0,
        quorum,
        signers,
        prologue: (flags & 2) === 0 ? null : prologue.decode(state),
        unencrypted
      };
    }
  };
  var node = {
    preencode(state, n) {
      c.uint.preencode(state, n.index);
      c.uint.preencode(state, n.size);
      c.fixed32.preencode(state, n.hash);
    },
    encode(state, n) {
      c.uint.encode(state, n.index);
      c.uint.encode(state, n.size);
      c.fixed32.encode(state, n.hash);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        size: c.uint.decode(state),
        hash: c.fixed32.decode(state)
      };
    }
  };
  var nodeArray = c.array(node);
  var wire = exports.wire = {};
  wire.handshake = {
    preencode(state, m) {
      c.uint.preencode(state, 1);
      c.fixed32.preencode(state, m.capability);
    },
    encode(state, m) {
      c.uint.encode(state, m.seeks ? 1 : 0);
      c.fixed32.encode(state, m.capability);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        seeks: (flags & 1) !== 0,
        capability: c.fixed32.decode(state)
      };
    }
  };
  var requestBlock = {
    preencode(state, b) {
      c.uint.preencode(state, b.index);
      c.uint.preencode(state, b.nodes);
    },
    encode(state, b) {
      c.uint.encode(state, b.index);
      c.uint.encode(state, b.nodes);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        nodes: c.uint.decode(state)
      };
    }
  };
  var requestSeek = {
    preencode(state, s) {
      c.uint.preencode(state, s.bytes);
      c.uint.preencode(state, s.padding);
    },
    encode(state, s) {
      c.uint.encode(state, s.bytes);
      c.uint.encode(state, s.padding);
    },
    decode(state) {
      return {
        bytes: c.uint.decode(state),
        padding: c.uint.decode(state)
      };
    }
  };
  var requestUpgrade = {
    preencode(state, u) {
      c.uint.preencode(state, u.start);
      c.uint.preencode(state, u.length);
    },
    encode(state, u) {
      c.uint.encode(state, u.start);
      c.uint.encode(state, u.length);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  wire.request = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.id);
      c.uint.preencode(state, m.fork);
      if (m.block)
        requestBlock.preencode(state, m.block);
      if (m.hash)
        requestBlock.preencode(state, m.hash);
      if (m.seek)
        requestSeek.preencode(state, m.seek);
      if (m.upgrade)
        requestUpgrade.preencode(state, m.upgrade);
      if (m.priority)
        c.uint.preencode(state, m.priority);
    },
    encode(state, m) {
      const flags = (m.block ? 1 : 0) | (m.hash ? 2 : 0) | (m.seek ? 4 : 0) | (m.upgrade ? 8 : 0) | (m.manifest ? 16 : 0) | (m.priority ? 32 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.id);
      c.uint.encode(state, m.fork);
      if (m.block)
        requestBlock.encode(state, m.block);
      if (m.hash)
        requestBlock.encode(state, m.hash);
      if (m.seek)
        requestSeek.encode(state, m.seek);
      if (m.upgrade)
        requestUpgrade.encode(state, m.upgrade);
      if (m.priority)
        c.uint.encode(state, m.priority);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        id: c.uint.decode(state),
        fork: c.uint.decode(state),
        block: flags & 1 ? requestBlock.decode(state) : null,
        hash: flags & 2 ? requestBlock.decode(state) : null,
        seek: flags & 4 ? requestSeek.decode(state) : null,
        upgrade: flags & 8 ? requestUpgrade.decode(state) : null,
        manifest: (flags & 16) !== 0,
        priority: flags & 32 ? c.uint.decode(state) : 0
      };
    }
  };
  wire.cancel = {
    preencode(state, m) {
      c.uint.preencode(state, m.request);
    },
    encode(state, m) {
      c.uint.encode(state, m.request);
    },
    decode(state, m) {
      return {
        request: c.uint.decode(state)
      };
    }
  };
  var dataUpgrade = {
    preencode(state, u) {
      c.uint.preencode(state, u.start);
      c.uint.preencode(state, u.length);
      nodeArray.preencode(state, u.nodes);
      nodeArray.preencode(state, u.additionalNodes);
      c.buffer.preencode(state, u.signature);
    },
    encode(state, u) {
      c.uint.encode(state, u.start);
      c.uint.encode(state, u.length);
      nodeArray.encode(state, u.nodes);
      nodeArray.encode(state, u.additionalNodes);
      c.buffer.encode(state, u.signature);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state),
        nodes: nodeArray.decode(state),
        additionalNodes: nodeArray.decode(state),
        signature: c.buffer.decode(state)
      };
    }
  };
  var dataSeek = {
    preencode(state, s) {
      c.uint.preencode(state, s.bytes);
      nodeArray.preencode(state, s.nodes);
    },
    encode(state, s) {
      c.uint.encode(state, s.bytes);
      nodeArray.encode(state, s.nodes);
    },
    decode(state) {
      return {
        bytes: c.uint.decode(state),
        nodes: nodeArray.decode(state)
      };
    }
  };
  var dataBlock = {
    preencode(state, b) {
      c.uint.preencode(state, b.index);
      c.buffer.preencode(state, b.value);
      nodeArray.preencode(state, b.nodes);
    },
    encode(state, b) {
      c.uint.encode(state, b.index);
      c.buffer.encode(state, b.value);
      nodeArray.encode(state, b.nodes);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        value: c.buffer.decode(state) || EMPTY,
        nodes: nodeArray.decode(state)
      };
    }
  };
  var dataHash = {
    preencode(state, b) {
      c.uint.preencode(state, b.index);
      nodeArray.preencode(state, b.nodes);
    },
    encode(state, b) {
      c.uint.encode(state, b.index);
      nodeArray.encode(state, b.nodes);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        nodes: nodeArray.decode(state)
      };
    }
  };
  wire.data = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.request);
      c.uint.preencode(state, m.fork);
      if (m.block)
        dataBlock.preencode(state, m.block);
      if (m.hash)
        dataHash.preencode(state, m.hash);
      if (m.seek)
        dataSeek.preencode(state, m.seek);
      if (m.upgrade)
        dataUpgrade.preencode(state, m.upgrade);
      if (m.manifest)
        manifest.preencode(state, m.manifest);
    },
    encode(state, m) {
      const flags = (m.block ? 1 : 0) | (m.hash ? 2 : 0) | (m.seek ? 4 : 0) | (m.upgrade ? 8 : 0) | (m.manifest ? 16 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.request);
      c.uint.encode(state, m.fork);
      if (m.block)
        dataBlock.encode(state, m.block);
      if (m.hash)
        dataHash.encode(state, m.hash);
      if (m.seek)
        dataSeek.encode(state, m.seek);
      if (m.upgrade)
        dataUpgrade.encode(state, m.upgrade);
      if (m.manifest)
        manifest.encode(state, m.manifest);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        request: c.uint.decode(state),
        fork: c.uint.decode(state),
        block: flags & 1 ? dataBlock.decode(state) : null,
        hash: flags & 2 ? dataHash.decode(state) : null,
        seek: flags & 4 ? dataSeek.decode(state) : null,
        upgrade: flags & 8 ? dataUpgrade.decode(state) : null,
        manifest: flags & 16 ? manifest.decode(state) : null
      };
    }
  };
  wire.noData = {
    preencode(state, m) {
      c.uint.preencode(state, m.request);
    },
    encode(state, m) {
      c.uint.encode(state, m.request);
    },
    decode(state, m) {
      return {
        request: c.uint.decode(state)
      };
    }
  };
  wire.want = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  wire.unwant = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint.encode(state, m.length);
    },
    decode(state, m) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  wire.range = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.start);
      if (m.length !== 1)
        c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, (m.drop ? 1 : 0) | (m.length === 1 ? 2 : 0));
      c.uint.encode(state, m.start);
      if (m.length !== 1)
        c.uint.encode(state, m.length);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        drop: (flags & 1) !== 0,
        start: c.uint.decode(state),
        length: (flags & 2) !== 0 ? 1 : c.uint.decode(state)
      };
    }
  };
  wire.bitfield = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint32array.preencode(state, m.bitfield);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint32array.encode(state, m.bitfield);
    },
    decode(state, m) {
      return {
        start: c.uint.decode(state),
        bitfield: c.uint32array.decode(state)
      };
    }
  };
  wire.sync = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.fork);
      c.uint.preencode(state, m.length);
      c.uint.preencode(state, m.remoteLength);
    },
    encode(state, m) {
      c.uint.encode(state, (m.canUpgrade ? 1 : 0) | (m.uploading ? 2 : 0) | (m.downloading ? 4 : 0) | (m.hasManifest ? 8 : 0));
      c.uint.encode(state, m.fork);
      c.uint.encode(state, m.length);
      c.uint.encode(state, m.remoteLength);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        fork: c.uint.decode(state),
        length: c.uint.decode(state),
        remoteLength: c.uint.decode(state),
        canUpgrade: (flags & 1) !== 0,
        uploading: (flags & 2) !== 0,
        downloading: (flags & 4) !== 0,
        hasManifest: (flags & 8) !== 0
      };
    }
  };
  wire.reorgHint = {
    preencode(state, m) {
      c.uint.preencode(state, m.from);
      c.uint.preencode(state, m.to);
      c.uint.preencode(state, m.ancestors);
    },
    encode(state, m) {
      c.uint.encode(state, m.from);
      c.uint.encode(state, m.to);
      c.uint.encode(state, m.ancestors);
    },
    decode(state) {
      return {
        from: c.uint.encode(state),
        to: c.uint.encode(state),
        ancestors: c.uint.encode(state)
      };
    }
  };
  wire.extension = {
    preencode(state, m) {
      c.string.preencode(state, m.name);
      c.raw.preencode(state, m.message);
    },
    encode(state, m) {
      c.string.encode(state, m.name);
      c.raw.encode(state, m.message);
    },
    decode(state) {
      return {
        name: c.string.decode(state),
        message: c.raw.decode(state)
      };
    }
  };
  var keyValue = {
    preencode(state, p) {
      c.string.preencode(state, p.key);
      c.buffer.preencode(state, p.value);
    },
    encode(state, p) {
      c.string.encode(state, p.key);
      c.buffer.encode(state, p.value);
    },
    decode(state) {
      return {
        key: c.string.decode(state),
        value: c.buffer.decode(state)
      };
    }
  };
  var treeUpgrade = {
    preencode(state, u) {
      c.uint.preencode(state, u.fork);
      c.uint.preencode(state, u.ancestors);
      c.uint.preencode(state, u.length);
      c.buffer.preencode(state, u.signature);
    },
    encode(state, u) {
      c.uint.encode(state, u.fork);
      c.uint.encode(state, u.ancestors);
      c.uint.encode(state, u.length);
      c.buffer.encode(state, u.signature);
    },
    decode(state) {
      return {
        fork: c.uint.decode(state),
        ancestors: c.uint.decode(state),
        length: c.uint.decode(state),
        signature: c.buffer.decode(state)
      };
    }
  };
  var bitfieldUpdate = {
    preencode(state, b) {
      state.end++;
      c.uint.preencode(state, b.start);
      c.uint.preencode(state, b.length);
    },
    encode(state, b) {
      state.buffer[state.start++] = b.drop ? 1 : 0;
      c.uint.encode(state, b.start);
      c.uint.encode(state, b.length);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        drop: (flags & 1) !== 0,
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var oplog = exports.oplog = {};
  oplog.entry = {
    preencode(state, m) {
      state.end++;
      if (m.userData)
        keyValue.preencode(state, m.userData);
      if (m.treeNodes)
        nodeArray.preencode(state, m.treeNodes);
      if (m.treeUpgrade)
        treeUpgrade.preencode(state, m.treeUpgrade);
      if (m.bitfield)
        bitfieldUpdate.preencode(state, m.bitfield);
    },
    encode(state, m) {
      const s = state.start++;
      let flags = 0;
      if (m.userData) {
        flags |= 1;
        keyValue.encode(state, m.userData);
      }
      if (m.treeNodes) {
        flags |= 2;
        nodeArray.encode(state, m.treeNodes);
      }
      if (m.treeUpgrade) {
        flags |= 4;
        treeUpgrade.encode(state, m.treeUpgrade);
      }
      if (m.bitfield) {
        flags |= 8;
        bitfieldUpdate.encode(state, m.bitfield);
      }
      state.buffer[s] = flags;
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        userData: (flags & 1) !== 0 ? keyValue.decode(state) : null,
        treeNodes: (flags & 2) !== 0 ? nodeArray.decode(state) : null,
        treeUpgrade: (flags & 4) !== 0 ? treeUpgrade.decode(state) : null,
        bitfield: (flags & 8) !== 0 ? bitfieldUpdate.decode(state) : null
      };
    }
  };
  var keyPair = {
    preencode(state, kp) {
      c.buffer.preencode(state, kp.publicKey);
      c.buffer.preencode(state, kp.secretKey);
    },
    encode(state, kp) {
      c.buffer.encode(state, kp.publicKey);
      c.buffer.encode(state, kp.secretKey);
    },
    decode(state) {
      return {
        publicKey: c.buffer.decode(state),
        secretKey: c.buffer.decode(state)
      };
    }
  };
  var reorgHint = {
    preencode(state, r) {
      c.uint.preencode(state, r.from);
      c.uint.preencode(state, r.to);
      c.uint.preencode(state, r.ancestors);
    },
    encode(state, r) {
      c.uint.encode(state, r.from);
      c.uint.encode(state, r.to);
      c.uint.encode(state, r.ancestors);
    },
    decode(state) {
      return {
        from: c.uint.decode(state),
        to: c.uint.decode(state),
        ancestors: c.uint.decode(state)
      };
    }
  };
  var reorgHintArray = c.array(reorgHint);
  var hints = {
    preencode(state, h) {
      reorgHintArray.preencode(state, h.reorgs);
      c.uint.preencode(state, h.contiguousLength);
    },
    encode(state, h) {
      reorgHintArray.encode(state, h.reorgs);
      c.uint.encode(state, h.contiguousLength);
    },
    decode(state) {
      return {
        reorgs: reorgHintArray.decode(state),
        contiguousLength: state.start < state.end ? c.uint.decode(state) : 0
      };
    }
  };
  var treeHeader = {
    preencode(state, t) {
      c.uint.preencode(state, t.fork);
      c.uint.preencode(state, t.length);
      c.buffer.preencode(state, t.rootHash);
      c.buffer.preencode(state, t.signature);
    },
    encode(state, t) {
      c.uint.encode(state, t.fork);
      c.uint.encode(state, t.length);
      c.buffer.encode(state, t.rootHash);
      c.buffer.encode(state, t.signature);
    },
    decode(state) {
      return {
        fork: c.uint.decode(state),
        length: c.uint.decode(state),
        rootHash: c.buffer.decode(state),
        signature: c.buffer.decode(state)
      };
    }
  };
  var types = {
    preencode(state, t) {
      c.string.preencode(state, t.tree);
      c.string.preencode(state, t.bitfield);
      c.string.preencode(state, t.signer);
    },
    encode(state, t) {
      c.string.encode(state, t.tree);
      c.string.encode(state, t.bitfield);
      c.string.encode(state, t.signer);
    },
    decode(state) {
      return {
        tree: c.string.decode(state),
        bitfield: c.string.decode(state),
        signer: c.string.decode(state)
      };
    }
  };
  var externalHeader = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var keyValueArray = c.array(keyValue);
  oplog.header = {
    preencode(state, h) {
      state.end += 2;
      if (h.external) {
        externalHeader.preencode(state, h.external);
        return;
      }
      c.fixed32.preencode(state, h.key);
      if (h.manifest)
        manifest.preencode(state, h.manifest);
      if (h.keyPair)
        keyPair.preencode(state, h.keyPair);
      keyValueArray.preencode(state, h.userData);
      treeHeader.preencode(state, h.tree);
      hints.preencode(state, h.hints);
    },
    encode(state, h) {
      c.uint.encode(state, 1);
      if (h.external) {
        c.uint.encode(state, 1);
        externalHeader.encode(state, h.external);
        return;
      }
      c.uint.encode(state, (h.manifest ? 2 : 0) | (h.keyPair ? 4 : 0));
      c.fixed32.encode(state, h.key);
      if (h.manifest)
        manifest.encode(state, h.manifest);
      if (h.keyPair)
        keyPair.encode(state, h.keyPair);
      keyValueArray.encode(state, h.userData);
      treeHeader.encode(state, h.tree);
      hints.encode(state, h.hints);
    },
    decode(state) {
      const version = c.uint.decode(state);
      if (version > 1) {
        throw new Error("Invalid header version. Expected <= 1, got " + version);
      }
      if (version === 0) {
        const old = {
          types: types.decode(state),
          userData: keyValueArray.decode(state),
          tree: treeHeader.decode(state),
          signer: keyPair.decode(state),
          hints: hints.decode(state)
        };
        return {
          external: null,
          key: old.signer.publicKey,
          manifest: {
            version: 0,
            hash: old.types.tree,
            allowPatch: false,
            quorum: 1,
            signers: [{
              signature: old.types.signer,
              namespace: DEFAULT_NAMESPACE,
              publicKey: old.signer.publicKey
            }],
            prologue: null
          },
          keyPair: old.signer.secretKey ? old.signer : null,
          userData: old.userData,
          tree: old.tree,
          hints: old.hints
        };
      }
      const flags = c.uint.decode(state);
      if (flags & 1) {
        return {
          external: externalHeader.decode(state),
          key: null,
          manifest: null,
          keyPair: null,
          userData: null,
          tree: null,
          hints: null
        };
      }
      return {
        external: null,
        key: c.fixed32.decode(state),
        manifest: (flags & 2) !== 0 ? manifest.decode(state) : null,
        keyPair: (flags & 4) !== 0 ? keyPair.decode(state) : null,
        userData: keyValueArray.decode(state),
        tree: treeHeader.decode(state),
        hints: hints.decode(state)
      };
    }
  };
  var uintArray = c.array(c.uint);
  var multisigInput = {
    preencode(state, inp) {
      c.uint.preencode(state, inp.signer);
      c.fixed64.preencode(state, inp.signature);
      c.uint.preencode(state, inp.patch);
    },
    encode(state, inp) {
      c.uint.encode(state, inp.signer);
      c.fixed64.encode(state, inp.signature);
      c.uint.encode(state, inp.patch);
    },
    decode(state) {
      return {
        signer: c.uint.decode(state),
        signature: c.fixed64.decode(state),
        patch: c.uint.decode(state)
      };
    }
  };
  var patchEncodingv0 = {
    preencode(state, n) {
      c.uint.preencode(state, n.start);
      c.uint.preencode(state, n.length);
      uintArray.preencode(state, n.nodes);
    },
    encode(state, n) {
      c.uint.encode(state, n.start);
      c.uint.encode(state, n.length);
      uintArray.encode(state, n.nodes);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state),
        nodes: uintArray.decode(state)
      };
    }
  };
  var multisigInputv0 = {
    preencode(state, n) {
      state.end++;
      c.uint.preencode(state, n.signer);
      c.fixed64.preencode(state, n.signature);
      if (n.patch)
        patchEncodingv0.preencode(state, n.patch);
    },
    encode(state, n) {
      c.uint.encode(state, n.patch ? 1 : 0);
      c.uint.encode(state, n.signer);
      c.fixed64.encode(state, n.signature);
      if (n.patch)
        patchEncodingv0.encode(state, n.patch);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        signer: c.uint.decode(state),
        signature: c.fixed64.decode(state),
        patch: flags & 1 ? patchEncodingv0.decode(state) : null
      };
    }
  };
  var multisigInputArrayv0 = c.array(multisigInputv0);
  var multisigInputArray = c.array(multisigInput);
  var compactNode = {
    preencode(state, n) {
      c.uint.preencode(state, n.index);
      c.uint.preencode(state, n.size);
      c.fixed32.preencode(state, n.hash);
    },
    encode(state, n) {
      c.uint.encode(state, n.index);
      c.uint.encode(state, n.size);
      c.fixed32.encode(state, n.hash);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        size: c.uint.decode(state),
        hash: c.fixed32.decode(state)
      };
    }
  };
  var compactNodeArray = c.array(compactNode);
  exports.multiSignaturev0 = {
    preencode(state, s) {
      multisigInputArrayv0.preencode(state, s.proofs);
      compactNodeArray.preencode(state, s.patch);
    },
    encode(state, s) {
      multisigInputArrayv0.encode(state, s.proofs);
      compactNodeArray.encode(state, s.patch);
    },
    decode(state) {
      return {
        proofs: multisigInputArrayv0.decode(state),
        patch: compactNodeArray.decode(state)
      };
    }
  };
  exports.multiSignature = {
    preencode(state, s) {
      multisigInputArray.preencode(state, s.proofs);
      compactNodeArray.preencode(state, s.patch);
    },
    encode(state, s) {
      multisigInputArray.encode(state, s.proofs);
      compactNodeArray.encode(state, s.patch);
    },
    decode(state) {
      return {
        proofs: multisigInputArray.decode(state),
        patch: compactNodeArray.decode(state)
      };
    }
  };
});

// node_modules/hypercore-storage/migrations/0/index.js
var require_0 = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var { Readable } = require_streamx();
  var b4a = require_b4a();
  var flat = require_flat_tree();
  var crypto = require_hypercore_crypto();
  var c = require_compact_encoding();
  var m = require_messages();
  var View = require_view();
  var { CorestoreTX, CoreTX, CorestoreRX } = require_tx();
  var EMPTY_NODE = b4a.alloc(40);
  var EMPTY_PAGE = b4a.alloc(4096);
  var TREE_01_SKIP = null;
  var TREE_04_SKIP = null;
  var TREE_16_SKIP = null;

  class CoreListStream extends Readable {
    constructor(storage) {
      super();
      this.storage = storage;
      this.stack = [];
    }
    async _open(cb) {
      for (const a of await readdir(path.join(this.storage, "cores"))) {
        for (const b of await readdir(path.join(this.storage, "cores", a))) {
          for (const dkey of await readdir(path.join(this.storage, "cores", a, b))) {
            this.stack.push(path.join(this.storage, "cores", a, b, dkey));
          }
        }
      }
      cb(null);
    }
    async _read(cb) {
      while (true) {
        const next = this.stack.pop();
        if (!next) {
          this.push(null);
          break;
        }
        const oplog = path.join(next, "oplog");
        const result = await readOplog(oplog);
        if (!result)
          continue;
        this.push(result);
        break;
      }
      cb(null);
    }
  }
  function decodeOplogHeader(state) {
    c.uint32.decode(state);
    const l = c.uint32.decode(state);
    const length = l >> 2;
    const headerBit = l & 1;
    const partialBit = l & 2;
    if (state.end - state.start < length)
      return null;
    const end = state.start + length;
    const result = { header: headerBit, partial: partialBit !== 0, byteLength: length + 8, message: null };
    try {
      result.message = m.oplog.header.decode({ start: state.start, end, buffer: state.buffer });
    } catch {
      return null;
    }
    state.start = end;
    return result;
  }
  function decodeOplogEntry(state) {
    if (state.end - state.start < 8)
      return null;
    c.uint32.decode(state);
    const l = c.uint32.decode(state);
    const length = l >>> 2;
    const headerBit = l & 1;
    const partialBit = l & 2;
    if (state.end - state.start < length)
      return null;
    const end = state.start + length;
    const result = { header: headerBit, partial: partialBit !== 0, byteLength: length + 8, message: null };
    try {
      result.message = m.oplog.entry.decode({ start: state.start, end, buffer: state.buffer });
    } catch {
      return null;
    }
    state.start = end;
    return result;
  }
  module.exports = { store, core };
  async function store(storage, { version, dryRun = true, gc = true }) {
    const stream = new CoreListStream(storage.path);
    const view = new View;
    const tx = new CorestoreTX(view);
    const head = await storage._getHead(view);
    const primaryKeyFile = path.join(storage.path, "primary-key");
    const primaryKey = await readFile(primaryKeyFile);
    if (!head.seed)
      head.seed = primaryKey;
    for await (const data of stream) {
      const key = data.header.key;
      const discoveryKey = crypto.discoveryKey(data.header.key);
      const files = getFiles(data.path);
      if (head.defaultDiscoveryKey === null)
        head.defaultDiscoveryKey = discoveryKey;
      const core2 = {
        version: 0,
        corePointer: head.allocated.cores++,
        dataPointer: head.allocated.datas++,
        alias: null
      };
      const ptr = { version: 0, corePointer: core2.corePointer, dataPointer: core2.dataPointer, dependencies: [] };
      const ctx = new CoreTX(ptr, storage.db, view, []);
      const userData = new Map;
      const treeNodes = new Map;
      const auth = {
        key,
        discoveryKey,
        manifest: data.header.manifest,
        keyPair: data.header.keyPair,
        encryptionKey: null
      };
      const tree = {
        length: 0,
        fork: 0,
        rootHash: null,
        signature: null
      };
      if (data.header.tree && data.header.tree.length) {
        tree.length = data.header.tree.length;
        tree.fork = data.header.tree.fork;
        tree.rootHash = data.header.tree.rootHash;
        tree.signature = data.header.tree.signature;
      }
      for (const { key: key2, value } of data.header.userData) {
        userData.set(key2, value);
      }
      for (const e of data.entries) {
        if (e.userData)
          userData.set(e.userData.key, e.userData.value);
        if (e.treeNodes) {
          for (const node of e.treeNodes) {
            treeNodes.set(node.index, node);
            ctx.putTreeNode(node);
          }
        }
        if (e.treeUpgrade) {
          if (e.treeUpgrade.ancestors !== tree.length) {
            throw new Error("Unflushed truncations not migrate-able atm");
          }
          tree.length = e.treeUpgrade.length;
          tree.fork = e.treeUpgrade.fork;
          tree.rootHash = null;
          tree.signature = e.treeUpgrade.signature;
        }
      }
      if (userData.has("corestore/name") && userData.has("corestore/namespace")) {
        core2.alias = {
          name: b4a.toString(userData.get("corestore/name")),
          namespace: userData.get("corestore/namespace")
        };
        userData.delete("corestore/name");
        userData.delete("corestore/namespace");
      }
      for (const [key2, value] of userData) {
        ctx.putUserData(key2, value);
      }
      ctx.setAuth(auth);
      const getTreeNode = (index) => treeNodes.get(index) || getTreeNodeFromFile(files.tree, index);
      if (tree.length) {
        if (tree.rootHash === null)
          tree.rootHash = crypto.tree(await getRoots(tree.length, getTreeNode));
        ctx.setHead(tree);
      }
      tx.putCore(discoveryKey, core2);
      if (core2.alias)
        tx.putCoreByAlias(core2.alias, discoveryKey);
      await ctx.flush();
    }
    head.version = version;
    tx.setHead(head);
    tx.apply();
    if (dryRun)
      return;
    await View.flush(view.changes, storage.db);
    if (gc)
      await rm(primaryKeyFile);
  }

  class BlockSlicer {
    constructor(filename) {
      this.stream = fs.createReadStream(filename);
      this.closed = new Promise((resolve) => this.stream.once("close", resolve));
      this.offset = 0;
      this.overflow = null;
    }
    async take(offset, size) {
      let buffer = null;
      if (offset < this.offset)
        throw new Error("overread");
      while (true) {
        let data = null;
        if (this.overflow) {
          data = this.overflow;
          this.overflow = null;
        } else {
          data = this.stream.read();
          if (!data) {
            await new Promise((resolve) => this.stream.once("readable", resolve));
            continue;
          }
        }
        let chunk = null;
        if (this.offset === offset || buffer) {
          chunk = data;
        } else if (this.offset + data.byteLength > offset) {
          chunk = data.subarray(offset - this.offset);
        }
        this.offset += data.byteLength;
        if (!chunk)
          continue;
        if (buffer)
          buffer = b4a.concat([buffer, chunk]);
        else
          buffer = chunk;
        if (buffer.byteLength < size)
          continue;
        const result = buffer.subarray(0, size);
        this.overflow = size === buffer.byteLength ? null : buffer.subarray(result.byteLength);
        this.offset -= this.overflow ? this.overflow.byteLength : 0;
        return result;
      }
    }
    close() {
      this.stream.on("error", noop);
      this.stream.destroy();
      return this.closed;
    }
  }

  class TreeSlicer {
    constructor() {
      this.buffer = null;
      this.offset = 0;
    }
    get size() {
      return this.buffer === null ? 0 : this.buffer.byteLength;
    }
    push(data) {
      if (this.buffer === null)
        this.buffer = data;
      else
        this.buffer = b4a.concat([this.buffer, data]);
      this.offset += data.byteLength;
    }
    skip() {
      let skipped = 0;
      if (TREE_01_SKIP === null) {
        TREE_16_SKIP = b4a.alloc(16 * 40 * 100);
        TREE_04_SKIP = TREE_16_SKIP.subarray(0, 4 * 40 * 100);
        TREE_01_SKIP = TREE_16_SKIP.subarray(0, 1 * 40 * 100);
      }
      while (true) {
        if (this.buffer.byteLength >= TREE_16_SKIP.byteLength) {
          if (b4a.equals(this.buffer.subarray(0, TREE_16_SKIP.byteLength), TREE_16_SKIP)) {
            this.buffer = this.buffer.subarray(TREE_16_SKIP.byteLength);
            skipped += 1600;
            continue;
          }
        }
        if (this.buffer.byteLength >= TREE_04_SKIP.byteLength) {
          if (b4a.equals(this.buffer.subarray(0, TREE_04_SKIP.byteLength), TREE_04_SKIP)) {
            this.buffer = this.buffer.subarray(TREE_04_SKIP.byteLength);
            skipped += 400;
            continue;
          }
        }
        if (this.buffer.byteLength >= TREE_01_SKIP.byteLength) {
          if (b4a.equals(this.buffer.subarray(0, TREE_01_SKIP.byteLength), TREE_01_SKIP)) {
            this.buffer = this.buffer.subarray(TREE_01_SKIP.byteLength);
            skipped += 100;
            continue;
          }
        }
        break;
      }
      return skipped;
    }
    take() {
      const len = 40;
      if (len <= this.size) {
        const chunk = this.buffer.subarray(0, len);
        this.buffer = this.buffer.subarray(len);
        return chunk;
      }
      return null;
    }
  }
  async function core(core2, { version, dryRun = true, gc = true }) {
    if (dryRun)
      return;
    const rx = core2.read();
    const promises = [rx.getAuth(), rx.getHead()];
    rx.tryFlush();
    const [auth, head] = await Promise.all(promises);
    if (!auth)
      return;
    const dk = b4a.toString(auth.discoveryKey, "hex");
    const files = getFiles(path.join(core2.store.path, "cores", dk.slice(0, 2), dk.slice(2, 4), dk));
    if (head === null || head.length === 0) {
      await commitCoreMigration(auth, core2, version);
      if (gc)
        await runGC();
      return;
    }
    const oplog = await readOplog(files.oplog);
    if (!oplog) {
      const writable = !!auth.keyPair;
      if (writable) {
        throw new Error("No oplog available writable core for " + files.oplog + ", length = " + (head ? head.length : 0));
      }
      const w2 = core2.write();
      w2.deleteBlockRange(0, -1);
      w2.deleteTreeNodeRange(0, -1);
      w2.deleteBitfieldPageRange(0, -1);
      w2.deleteHead();
      await w2.flush();
      await commitCoreMigration(auth, core2, version);
      if (gc)
        await runGC();
      return;
    }
    const treeData = new TreeSlicer;
    let treeIndex = 0;
    if (await exists(files.tree)) {
      for await (const data of fs.createReadStream(files.tree)) {
        treeData.push(data);
        let write = null;
        while (true) {
          const skip = treeData.skip();
          treeIndex += skip;
          const buf2 = treeData.take();
          if (buf2 === null)
            break;
          const index = treeIndex++;
          if (b4a.equals(buf2, EMPTY_NODE))
            continue;
          if (write === null)
            write = core2.write();
          write.putTreeNode(decodeTreeNode(index, buf2));
        }
        if (write !== null)
          await write.flush();
      }
    }
    const buf = [];
    if (await exists(files.bitfield)) {
      for await (const data of fs.createReadStream(files.bitfield)) {
        buf.push(data);
      }
    }
    let bitfield = b4a.concat(buf);
    if (bitfield.byteLength & 4095)
      bitfield = b4a.concat([bitfield, b4a.alloc(4096 - (bitfield.byteLength & 4095))]);
    const pages = new Map;
    const headerBits = new Map;
    const roots = await getRootsFromStorage(core2, head.length);
    for (const e of oplog.entries) {
      if (!e.bitfield)
        continue;
      for (let i = 0;i < e.bitfield.length; i++) {
        headerBits.set(i + e.bitfield.start, !e.bitfield.drop);
      }
    }
    let batch = [];
    const cache = new Map;
    const blocks = new BlockSlicer(files.data);
    for (const index of allBits(bitfield)) {
      if (headerBits.get(index) === false)
        continue;
      if (index >= head.length)
        continue;
      setBitInPage(index);
      batch.push(index);
      if (batch.length < 1024)
        continue;
      await writeBlocksBatch();
      continue;
    }
    if (batch.length)
      await writeBlocksBatch();
    await blocks.close();
    const w = core2.write();
    for (const [index, bit] of headerBits) {
      if (!bit)
        continue;
      if (index >= head.length)
        continue;
      setBitInPage(index);
      const blk = await getBlockFromFile(files.data, core2, index, roots, cache);
      w.putBlock(index, blk);
    }
    for (const [index, page] of pages) {
      w.putBitfieldPage(index, b4a.from(page.buffer, page.byteOffset, page.byteLength));
    }
    await w.flush();
    let contiguousLength = 0;
    for await (const data of core2.createBlockStream()) {
      if (data.index === contiguousLength)
        contiguousLength++;
      else
        break;
    }
    if (contiguousLength) {
      const w2 = core2.write();
      w2.setHints({ contiguousLength });
      await w2.flush();
    }
    await commitCoreMigration(auth, core2, version);
    if (gc)
      await runGC();
    async function runGC() {
      await rm(files.path);
      await rmdir(path.join(files.path, ".."));
      await rmdir(path.join(files.path, "../.."));
      await rmdir(path.join(core2.store.path, "cores"));
    }
    function setBitInPage(index) {
      const n = index & 32767;
      const p = (index - n) / 32768;
      let page = pages.get(p);
      if (!page) {
        page = new Uint32Array(1024);
        pages.set(p, page);
      }
      const o = n & 31;
      const b = (n - o) / 32;
      const v = 1 << o;
      page[b] |= v;
    }
    async function writeBlocksBatch() {
      const read = core2.read();
      const promises2 = [];
      for (const index of batch)
        promises2.push(getByteRangeFromStorage(read, 2 * index, roots, cache));
      read.tryFlush();
      const r = await Promise.all(promises2);
      const tx = core2.write();
      for (let i = 0;i < r.length; i++) {
        const index = batch[i];
        const [offset, size] = r[i];
        const blk = await blocks.take(offset, size);
        tx.putBlock(index, blk);
      }
      batch = [];
      if (cache.size > 16384)
        cache.clear();
      await tx.flush();
    }
  }
  async function commitCoreMigration(auth, core2, version) {
    const view = new View;
    const rx = new CorestoreRX(core2.db, view);
    const storeCorePromise = rx.getCore(auth.discoveryKey);
    rx.tryFlush();
    const storeCore = await storeCorePromise;
    storeCore.version = version;
    const tx = new CorestoreTX(view);
    tx.putCore(auth.discoveryKey, storeCore);
    tx.apply();
    await View.flush(view.changes, core2.db);
  }
  async function getBlockFromFile(file, core2, index, roots, cache) {
    const rx = core2.read();
    const promise = getByteRangeFromStorage(rx, 2 * index, roots, cache);
    rx.tryFlush();
    const [offset, size] = await promise;
    return new Promise(function(resolve) {
      readAll(file, size, offset, function(err, buf) {
        if (err)
          return resolve(null);
        resolve(buf);
      });
    });
  }
  function getFiles(dir) {
    return {
      path: dir,
      oplog: path.join(dir, "oplog"),
      data: path.join(dir, "data"),
      tree: path.join(dir, "tree"),
      bitfield: path.join(dir, "bitfield")
    };
  }
  async function getRootsFromStorage(core2, length) {
    const all = [];
    const rx = core2.read();
    for (const index of flat.fullRoots(2 * length)) {
      all.push(rx.getTreeNode(index));
    }
    rx.tryFlush();
    return Promise.all(all);
  }
  async function getRoots(length, getTreeNode) {
    const all = [];
    for (const index of flat.fullRoots(2 * length)) {
      all.push(await getTreeNode(index));
    }
    return all;
  }
  function getCached(read, cache, index) {
    if (cache.has(index))
      return cache.get(index);
    const p = read.getTreeNode(index);
    cache.set(index, p);
    return p;
  }
  async function getByteRangeFromStorage(read, index, roots, cache) {
    const promises = [getCached(read, cache, index), getByteOffsetFromStorage(read, index, roots, cache)];
    const [node, offset] = await Promise.all(promises);
    return [offset, node.size];
  }
  async function getByteOffsetFromStorage(rx, index, roots, cache) {
    if (index === 0)
      return 0;
    if ((index & 1) === 1)
      index = flat.leftSpan(index);
    let head = 0;
    let offset = 0;
    for (const node of roots) {
      head += 2 * (node.index - head + 1);
      if (index >= head) {
        offset += node.size;
        continue;
      }
      const ite = flat.iterator(node.index);
      const promises = [];
      while (ite.index !== index) {
        if (index < ite.index) {
          ite.leftChild();
        } else {
          promises.push(getCached(rx, cache, ite.leftChild()));
          ite.sibling();
        }
      }
      const nodes = await Promise.all(promises);
      for (const node2 of nodes)
        offset += node2.size;
      return offset;
    }
    throw new Error("Failed to find offset");
  }
  function decodeTreeNode(index, buf) {
    return { index, size: c.decode(c.uint64, buf), hash: buf.subarray(8) };
  }
  async function getTreeNodeFromFile(file, index) {
    return new Promise(function(resolve) {
      readAll(file, 40, index * 40, function(err, buf) {
        if (err)
          return resolve(null);
        resolve(decodeTreeNode(index, buf));
      });
    });
  }
  function readAll(filename, length, pos, cb) {
    const buf = b4a.alloc(length);
    fs.open(filename, "r", function(err, fd) {
      if (err)
        return cb(err);
      let offset = 0;
      fs.read(fd, buf, offset, buf.byteLength, pos, function loop(err2, read) {
        if (err2)
          return done(err2);
        if (read === 0)
          return done(new Error("Partial read"));
        offset += read;
        if (offset === buf.byteLength)
          return done(null, buf);
        fs.read(fd, offset, buf.byteLength - offset, buf, pos + offset, loop);
      });
      function done(err2, value) {
        fs.close(fd, () => cb(err2, value));
      }
    });
  }
  async function readdir(dir) {
    try {
      return await fs.promises.readdir(dir);
    } catch {
      return [];
    }
  }
  async function exists(file) {
    try {
      await fs.promises.stat(file);
      return true;
    } catch {
      return false;
    }
  }
  async function readFile(file) {
    try {
      return await fs.promises.readFile(file);
    } catch {
      return null;
    }
  }
  async function rm(dir) {
    try {
      await fs.promises.rm(dir, { recursive: true });
    } catch {}
  }
  async function rmdir(dir) {
    try {
      await fs.promises.rmdir(dir);
    } catch {}
  }
  function* allBits(buffer) {
    for (let i = 0;i < buffer.byteLength; i += EMPTY_PAGE.byteLength) {
      const page = buffer.subarray(i, i + EMPTY_NODE.byteLength);
      if (b4a.equals(page, EMPTY_PAGE))
        continue;
      const view = new Uint32Array(page.buffer, page.byteOffset, EMPTY_PAGE.byteLength / 4);
      for (let j = 0;j < view.length; j++) {
        const n = view[j];
        if (n === 0)
          continue;
        for (let k = 0;k < 32; k++) {
          const m2 = 1 << k;
          if (n & m2)
            yield i * 8 + j * 32 + k;
        }
      }
    }
  }
  function readOplog(oplog) {
    return new Promise(function(resolve) {
      fs.readFile(oplog, function(err, buffer) {
        if (err)
          return resolve(null);
        const state = { start: 0, end: buffer.byteLength, buffer };
        const headers = [1, 0];
        const h1 = decodeOplogHeader(state);
        state.start = 4096;
        const h2 = decodeOplogHeader(state);
        state.start = 4096 * 2;
        if (!h1 && !h2)
          return resolve(null);
        if (h1 && !h2) {
          headers[0] = h1.header;
          headers[1] = h1.header;
        } else if (!h1 && h2) {
          headers[0] = h2.header + 1 & 1;
          headers[1] = h2.header;
        } else {
          headers[0] = h1.header;
          headers[1] = h2.header;
        }
        const header = headers[0] + headers[1] & 1;
        const result = { path: path.dirname(oplog), header: null, entries: [] };
        const decoded = [];
        result.header = header ? h2.message : h1.message;
        if (result.header.external) {
          fs.readFile(path.join(oplog, "../header"), function(err2, buffer2) {
            if (err2)
              return resolve(null);
            const start = result.header.external.start;
            const end = start + result.header.external.length;
            result.header = m.oplog.header.decode({ buffer: buffer2, start, end });
            finish();
          });
          return;
        }
        finish();
        function finish() {
          while (true) {
            const entry = decodeOplogEntry(state);
            if (!entry)
              break;
            if (entry.header !== header)
              break;
            decoded.push(entry);
          }
          while (decoded.length > 0 && decoded[decoded.length - 1].partial)
            decoded.pop();
          for (const e of decoded) {
            result.entries.push(e.message);
          }
          resolve(result);
        }
      });
    });
  }
  function noop() {}
});

// node_modules/hypercore-storage/index.js
var require_hypercore_storage = __commonJS((exports, module) => {
  var RocksDB = require_rocksdb_native();
  var rrp = require_resolve_reject_promise();
  var ScopeLock = require_scope_lock();
  var DeviceFile = require_device_file();
  var path = __require("path");
  var fs = __require("fs");
  var View = require_view();
  var VERSION = 1;
  var COLUMN_FAMILY = "corestore";
  var { store, core } = require_keys();
  var {
    CorestoreRX,
    CorestoreTX,
    CoreTX,
    CoreRX
  } = require_tx();
  var {
    createCoreStream,
    createAliasStream,
    createDiscoveryKeyStream,
    createBlockStream,
    createBitfieldStream,
    createUserDataStream,
    createTreeNodeStream,
    createLocalStream
  } = require_streams();
  var EMPTY = new View;

  class Atom {
    constructor(db) {
      this.db = db;
      this.view = new View;
      this.flushedPromise = null;
      this.flushing = false;
      this.flushes = [];
    }
    onflush(fn) {
      this.flushes.push(fn);
    }
    flushed() {
      if (!this.flushing)
        return Promise.resolve();
      if (this.flushedPromise !== null)
        return this.flushedPromise.promise;
      this.flushedPromise = rrp();
      return this.flushedPromise.promise;
    }
    _resolve() {
      const f = this.flushedPromise;
      this.flushedPromise = null;
      f.resolve();
    }
    async flush() {
      if (this.flushing)
        throw new Error("Atom already flushing");
      this.flushing = true;
      try {
        await View.flush(this.view.changes, this.db);
        this.view.reset();
        const promises = [];
        const len = this.flushes.length;
        for (let i = 0;i < len; i++)
          promises.push(this.flushes[i]());
        await Promise.all(promises);
      } finally {
        this.flushing = false;
        if (this.flushedPromise !== null)
          this._resolve();
      }
    }
  }

  class HypercoreStorage {
    constructor(store2, db, core2, view, atom) {
      this.store = store2;
      this.db = db;
      this.core = core2;
      this.view = view;
      this.atom = atom;
      this.view.readStart();
    }
    get dependencies() {
      return this.core.dependencies;
    }
    getDependencyLength() {
      return this.core.dependencies.length ? this.core.dependencies[this.core.dependencies.length - 1].length : -1;
    }
    getDependency(length) {
      for (let i = this.core.dependencies.length - 1;i >= 0; i--) {
        const dep = this.core.dependencies[i];
        if (dep.length < length)
          return dep;
      }
      return null;
    }
    setDependencyHead(dep) {
      const deps = this.core.dependencies;
      for (let i = deps.length - 1;i >= 0; i--) {
        const d = deps[i];
        if (d.dataPointer !== dep.dataPointer)
          continue;
        if (d.length === dep.length && i === deps.length - 1)
          return;
        this.core = {
          corePointer: this.core.corePointer,
          dataPointer: this.core.dataPointer,
          dependencies: deps.slice(0, i + 1)
        };
        this.core.dependencies[i] = {
          dataPointer: dep.dataPointer,
          length: dep.length
        };
      }
      this.core.dependencies = [{
        dataPointer: dep.dataPointer,
        length: dep.length
      }];
    }
    updateDependencyLength(length, truncated) {
      const deps = this.core.dependencies;
      const i = this.findDependencyIndex(length, truncated);
      if (i === -1)
        throw new Error("Dependency not found");
      this.core = {
        corePointer: this.core.corePointer,
        dataPointer: this.core.dataPointer,
        dependencies: deps.slice(0, i + 1)
      };
      if (this.core.dependencies[i].length !== length) {
        this.core.dependencies[i] = {
          dataPointer: deps[i].dataPointer,
          length
        };
      }
    }
    findDependencyIndex(length, truncated) {
      const deps = this.core.dependencies;
      if (truncated) {
        for (let i = 0;i < deps.length; i++) {
          if (deps[i].length >= length)
            return i;
        }
        return -1;
      }
      for (let i = deps.length - 1;i >= 0; i--) {
        if (deps[i].length <= length)
          return i;
      }
      return -1;
    }
    get snapshotted() {
      return this.db._snapshot !== null;
    }
    snapshot() {
      return new HypercoreStorage(this.store, this.db.snapshot(), this.core, this.view.snapshot(), this.atom);
    }
    atomize(atom) {
      if (this.atom && this.atom !== atom)
        throw new Error("Cannot atomize and atomized session with a new atom");
      return new HypercoreStorage(this.store, this.db.session(), this.core, atom.view, atom);
    }
    createAtom() {
      return this.store.createAtom();
    }
    createBlockStream(opts) {
      return createBlockStream(this.core, this.db, this.view, opts);
    }
    createTreeNodeStream(opts) {
      return createTreeNodeStream(this.core, this.db, this.view, opts);
    }
    createBitfieldStream(opts) {
      return createBitfieldStream(this.core, this.db, this.view, opts);
    }
    createUserDataStream(opts) {
      return createUserDataStream(this.core, this.db, this.view, opts);
    }
    createLocalStream(opts) {
      return createLocalStream(this.core, this.db, this.view, opts);
    }
    async resumeSession(name) {
      const rx = this.read();
      const existingSessionsPromise = rx.getSessions();
      rx.tryFlush();
      const existingSessions = await existingSessionsPromise;
      const sessions = existingSessions || [];
      const session = getBatch(sessions, name, false);
      if (session === null)
        return null;
      const core2 = {
        corePointer: this.core.corePointer,
        dataPointer: session.dataPointer,
        dependencies: []
      };
      const coreRx = new CoreRX(core2, this.db, this.view);
      const dependencyPromise = coreRx.getDependency();
      coreRx.tryFlush();
      const dependency = await dependencyPromise;
      if (dependency)
        core2.dependencies = this._addDependency(dependency);
      return new HypercoreStorage(this.store, this.db.session(), core2, this.atom ? this.view : new View, this.atom);
    }
    async createSession(name, head) {
      const rx = this.read();
      const existingSessionsPromise = rx.getSessions();
      const existingHeadPromise = rx.getHead();
      rx.tryFlush();
      const [existingSessions, existingHead] = await Promise.all([existingSessionsPromise, existingHeadPromise]);
      if (head === null)
        head = existingHead;
      if (existingHead !== null && head.length > existingHead.length) {
        throw new Error("Invalid head passed, ahead of core");
      }
      const sessions = existingSessions || [];
      const session = getBatch(sessions, name, true);
      const fresh = session.dataPointer === -1;
      if (fresh) {
        session.dataPointer = await this.store._allocData();
      }
      const tx = this.write();
      tx.setSessions(sessions);
      const length = head === null ? 0 : head.length;
      const core2 = {
        corePointer: this.core.corePointer,
        dataPointer: session.dataPointer,
        dependencies: this._addDependency({ dataPointer: this.core.dataPointer, length })
      };
      const coreTx = new CoreTX(core2, this.db, tx.view, tx.changes);
      if (length > 0)
        coreTx.setHead(head);
      coreTx.setDependency(core2.dependencies[core2.dependencies.length - 1]);
      if (!fresh) {
        coreTx.deleteBlockRange(0, -1);
        coreTx.deleteTreeNodeRange(0, -1);
        coreTx.deleteBitfieldPageRange(0, -1);
      }
      await tx.flush();
      return new HypercoreStorage(this.store, this.db.session(), core2, this.atom ? this.view : new View, this.atom);
    }
    async createAtomicSession(atom, head) {
      const length = head === null ? 0 : head.length;
      const core2 = {
        corePointer: this.core.corePointer,
        dataPointer: this.core.dataPointer,
        dependencies: this._addDependency(null)
      };
      const coreTx = new CoreTX(core2, this.db, atom.view, []);
      if (length > 0)
        coreTx.setHead(head);
      await coreTx.flush();
      return this.atomize(atom);
    }
    _addDependency(dep) {
      const deps = [];
      for (let i = 0;i < this.core.dependencies.length; i++) {
        const d = this.core.dependencies[i];
        if (dep !== null && d.length > dep.length) {
          if (d.dataPointer !== dep.dataPointer) {
            deps.push({ dataPointer: d.dataPointer, length: dep.length });
          }
          return deps;
        }
        deps.push(d);
      }
      if (dep !== null && (deps.length === 0 || deps[deps.length - 1].dataPointer !== dep.dataPointer)) {
        deps.push(dep);
      }
      return deps;
    }
    read() {
      return new CoreRX(this.core, this.db, this.view);
    }
    write() {
      return new CoreTX(this.core, this.db, this.atom ? this.view : null, []);
    }
    close() {
      if (this.view !== null) {
        this.view.readStop();
        this.view = null;
      }
      return this.db.close();
    }
  }

  class CorestoreStorage {
    constructor(db, opts = {}) {
      const storage = typeof db === "string" ? db : null;
      this.bootstrap = storage !== null;
      this.path = storage !== null ? storage : path.join(db.path, "..");
      this.readOnly = !!opts.readOnly;
      this.allowBackup = !!opts.allowBackup;
      if (this.bootstrap && !this.readOnly)
        tmpFixStorage(this.path);
      this.rocks = storage === null ? db : new RocksDB(path.join(this.path, "db"), opts);
      this.db = createColumnFamily(this.rocks, opts);
      this.id = opts.id || null;
      this.view = null;
      this.enters = 0;
      this.lock = new ScopeLock;
      this.flushing = null;
      this.version = 0;
      this.migrating = null;
    }
    get opened() {
      return this.db.opened;
    }
    get closed() {
      return this.db.closed;
    }
    async ready() {
      if (this.version === 0)
        await this._migrateStore();
      return this.db.ready();
    }
    async audit() {
      for await (const { core: core2 } of this.createCoreStream()) {
        const coreRx = new CoreRX(core2, this.db, EMPTY);
        const authPromise = coreRx.getAuth();
        coreRx.tryFlush();
        const auth = await authPromise;
        if (!auth.manifest || auth.manifest.version > 0)
          continue;
        if (auth.manifest.linked === null)
          continue;
        auth.manifest.linked = null;
        const coreTx = new CoreTX(core2, this.db, null, []);
        coreTx.setAuth(auth);
        await coreTx.flush();
      }
    }
    async deleteCore(ptr) {
      const rx = new CoreRX(ptr, this.db, EMPTY);
      const authPromise = rx.getAuth();
      const sessionsPromise = rx.getSessions();
      rx.tryFlush();
      const auth = await authPromise;
      const sessions = await sessionsPromise;
      if (!auth)
        return;
      const tx = this.db.write({ autoDestroy: true });
      tx.tryDelete(store.core(auth.discoveryKey));
      const start = core.core(ptr.corePointer);
      const end = core.core(ptr.corePointer + 1);
      tx.tryDeleteRange(start, end);
      if (sessions) {
        for (const { dataPointer } of sessions) {
          const start2 = core.data(dataPointer);
          const end2 = core.data(dataPointer + 1);
          tx.tryDeleteRange(start2, end2);
        }
      }
      return tx.flush();
    }
    static isCoreStorage(db) {
      return isCorestoreStorage(db);
    }
    static from(db) {
      if (isCorestoreStorage(db))
        return db;
      return new this(db);
    }
    async _flush() {
      while (this.enters > 0) {
        await this.lock.lock();
        await this.lock.unlock();
      }
    }
    async _migrateStore() {
      const view = await this._enter();
      try {
        if (this.version === VERSION)
          return;
        await this.db.ready();
        if (this.bootstrap && !this.readOnly && !this.allowBackup) {
          const corestoreFile = path.join(this.path, "CORESTORE");
          if (!await DeviceFile.resume(corestoreFile, { id: this.id })) {
            await DeviceFile.create(corestoreFile, { id: this.id });
          }
        }
        const rx = new CorestoreRX(this.db, view);
        const headPromise = rx.getHead();
        rx.tryFlush();
        const head = await headPromise;
        const version = head === null ? 0 : head.version;
        if (version === VERSION) {
          this.version = VERSION;
          return;
        }
        const target = { version: VERSION, dryRun: false };
        switch (version) {
          case 0: {
            await require_0().store(this, target);
            break;
          }
          default: {
            throw new Error("Unsupported version: " + version + " - you should probably upgrade your dependencies");
          }
        }
        this.version = VERSION;
      } finally {
        await this._exit();
      }
    }
    async _migrateCore(core2, discoveryKey, version, locked) {
      const view = locked ? this.view : await this._enter();
      try {
        if (version === VERSION)
          return;
        const target = { version: VERSION, dryRun: false };
        switch (version) {
          case 0: {
            await require_0().core(core2, target);
            break;
          }
          default: {
            throw new Error("Unsupported version: " + version + " - you should probably upgrade your dependencies");
          }
        }
        if (locked === false)
          return;
        const rx = new CorestoreRX(this.db, EMPTY);
        const tx = new CorestoreTX(view);
        const corePromise = rx.getCore(discoveryKey);
        rx.tryFlush();
        tx.putCore(discoveryKey, await corePromise);
        tx.apply();
      } finally {
        if (!locked)
          await this._exit();
      }
    }
    async _enter() {
      this.enters++;
      await this.lock.lock();
      if (this.view === null)
        this.view = new View;
      return this.view;
    }
    async _exit() {
      this.enters--;
      if (this.flushing === null)
        this.flushing = rrp();
      const flushed = this.flushing.promise;
      if (this.enters === 0 || this.view.size() > 128) {
        try {
          await View.flush(this.view.changes, this.db);
          this.flushing.resolve();
        } catch (err) {
          this.flushing.reject(err);
        } finally {
          this.flushing = null;
          this.view = null;
        }
      }
      this.lock.unlock();
      return flushed;
    }
    async _allocData() {
      let dataPointer = 0;
      const view = await this._enter();
      const tx = new CorestoreTX(view);
      try {
        const head = await this._getHead(view);
        dataPointer = head.allocated.datas++;
        tx.setHead(head);
        tx.apply();
      } finally {
        await this._exit();
      }
      return dataPointer;
    }
    async _getHead(view) {
      const rx = new CorestoreRX(this.db, view);
      const headPromise = rx.getHead();
      rx.tryFlush();
      const head = await headPromise;
      return head === null ? initStoreHead() : head;
    }
    createAtom() {
      return new Atom(this.db);
    }
    async flush() {
      await this.rocks.flush();
    }
    async close() {
      if (this.db.closed)
        return;
      await this._flush();
      await this.db.close();
      await this.rocks.close();
    }
    async clear() {
      if (this.version === 0)
        await this._migrateStore();
      const view = await this._enter();
      const tx = new CorestoreTX(view);
      tx.clear();
      tx.apply();
      await this._exit();
    }
    createCoreStream() {
      return createCoreStream(this.db, EMPTY);
    }
    createAliasStream(namespace) {
      return createAliasStream(this.db, EMPTY, namespace);
    }
    createDiscoveryKeyStream(namespace) {
      return createDiscoveryKeyStream(this.db, EMPTY, namespace);
    }
    async getAlias(alias) {
      if (this.version === 0)
        await this._migrateStore();
      const rx = new CorestoreRX(this.db, EMPTY);
      const discoveryKeyPromise = rx.getCoreByAlias(alias);
      rx.tryFlush();
      return discoveryKeyPromise;
    }
    async getSeed() {
      if (this.version === 0)
        await this._migrateStore();
      const rx = new CorestoreRX(this.db, EMPTY);
      const headPromise = rx.getHead();
      rx.tryFlush();
      const head = await headPromise;
      return head === null ? null : head.seed;
    }
    async setSeed(seed, { overwrite = true } = {}) {
      if (this.version === 0)
        await this._migrateStore();
      const view = await this._enter();
      const tx = new CorestoreTX(view);
      try {
        const rx = new CorestoreRX(this.db, view);
        const headPromise = rx.getHead();
        rx.tryFlush();
        const head = await headPromise || initStoreHead();
        if (head.seed === null || overwrite)
          head.seed = seed;
        tx.setHead(head);
        tx.apply();
        return head.seed;
      } finally {
        await this._exit();
      }
    }
    async getDefaultDiscoveryKey() {
      if (this.version === 0)
        await this._migrateStore();
      const rx = new CorestoreRX(this.db, EMPTY);
      const headPromise = rx.getHead();
      rx.tryFlush();
      const head = await headPromise;
      return head === null ? null : head.defaultDiscoveryKey;
    }
    async setDefaultDiscoveryKey(discoveryKey, { overwrite = true } = {}) {
      if (this.version === 0)
        await this._migrateStore();
      const view = await this._enter();
      const tx = new CorestoreTX(view);
      try {
        const rx = new CorestoreRX(this.db, view);
        const headPromise = rx.getHead();
        rx.tryFlush();
        const head = await headPromise || initStoreHead();
        if (head.defaultDiscoveryKey === null || overwrite)
          head.defaultDiscoveryKey = discoveryKey;
        tx.setHead(head);
        tx.apply();
        return head.defaultDiscoveryKey;
      } finally {
        await this._exit();
      }
    }
    async has(discoveryKey, { ifMigrated = false } = {}) {
      if (this.version === 0)
        await this._migrateStore();
      const rx = new CorestoreRX(this.db, EMPTY);
      const promise = rx.getCore(discoveryKey);
      rx.tryFlush();
      const core2 = await promise;
      if (core2 === null)
        return false;
      if (core2.version !== VERSION && ifMigrated)
        return false;
      return true;
    }
    async getAuth(discoveryKey) {
      if (this.version === 0)
        await this._migrateStore();
      const rx = new CorestoreRX(this.db, EMPTY);
      const corePromise = rx.getCore(discoveryKey);
      rx.tryFlush();
      const core2 = await corePromise;
      if (core2 === null)
        return null;
      const coreRx = new CoreRX(core2, this.db, EMPTY);
      const authPromise = coreRx.getAuth();
      coreRx.tryFlush();
      return authPromise;
    }
    async resume(discoveryKey) {
      if (this.version === 0)
        await this._migrateStore();
      if (!discoveryKey) {
        discoveryKey = await this.getDefaultDiscoveryKey();
        if (!discoveryKey)
          return null;
      }
      const rx = new CorestoreRX(this.db, EMPTY);
      const corePromise = rx.getCore(discoveryKey);
      rx.tryFlush();
      const core2 = await corePromise;
      if (core2 === null)
        return null;
      return this._resumeFromPointers(EMPTY, discoveryKey, false, core2);
    }
    async _resumeFromPointers(view, discoveryKey, create, { version, corePointer, dataPointer }) {
      const core2 = { corePointer, dataPointer, dependencies: [] };
      while (true) {
        const rx = new CoreRX({ dataPointer, corePointer: 0, dependencies: [] }, this.db, view);
        const dependencyPromise = rx.getDependency();
        rx.tryFlush();
        const dependency = await dependencyPromise;
        if (!dependency)
          break;
        core2.dependencies.push(dependency);
        dataPointer = dependency.dataPointer;
      }
      const result = new HypercoreStorage(this, this.db.session(), core2, EMPTY, null);
      if (version < VERSION)
        await this._migrateCore(result, discoveryKey, version, create);
      return result;
    }
    async _create(view, { key, manifest, keyPair, encryptionKey, discoveryKey, alias, userData }) {
      const rx = new CorestoreRX(this.db, view);
      const tx = new CorestoreTX(view);
      const corePromise = rx.getCore(discoveryKey);
      const headPromise = rx.getHead();
      rx.tryFlush();
      let [core2, head] = await Promise.all([corePromise, headPromise]);
      if (core2)
        return this._resumeFromPointers(view, discoveryKey, true, core2);
      if (head === null)
        head = initStoreHead();
      if (head.defaultDiscoveryKey === null)
        head.defaultDiscoveryKey = discoveryKey;
      const corePointer = head.allocated.cores++;
      const dataPointer = head.allocated.datas++;
      core2 = { version: VERSION, corePointer, dataPointer, alias };
      tx.setHead(head);
      tx.putCore(discoveryKey, core2);
      if (alias)
        tx.putCoreByAlias(alias, discoveryKey);
      const ptr = { corePointer, dataPointer, dependencies: [] };
      const ctx = new CoreTX(ptr, this.db, view, tx.changes);
      ctx.setAuth({
        key,
        discoveryKey,
        manifest,
        keyPair,
        encryptionKey
      });
      if (userData) {
        for (const { key: key2, value } of userData) {
          ctx.putUserData(key2, value);
        }
      }
      tx.apply();
      return new HypercoreStorage(this, this.db.session(), ptr, EMPTY, null);
    }
    async create(data) {
      if (this.version === 0)
        await this._migrateStore();
      const view = await this._enter();
      try {
        return await this._create(view, data);
      } finally {
        await this._exit();
      }
    }
  }
  module.exports = CorestoreStorage;
  function initStoreHead() {
    return {
      version: 0,
      allocated: {
        datas: 0,
        cores: 0
      },
      seed: null,
      defaultDiscoveryKey: null
    };
  }
  function getBatch(sessions, name, alloc) {
    for (let i = 0;i < sessions.length; i++) {
      if (sessions[i].name === name)
        return sessions[i];
    }
    if (!alloc)
      return null;
    const result = { name, dataPointer: -1 };
    sessions.push(result);
    return result;
  }
  function isCorestoreStorage(s) {
    return typeof s === "object" && !!s && typeof s.setDefaultDiscoveryKey === "function";
  }
  function createColumnFamily(db, opts = {}) {
    const {
      tableCacheIndexAndFilterBlocks = true,
      blockCache = true,
      optimizeFiltersForMemory = false
    } = opts;
    const col = new RocksDB.ColumnFamily(COLUMN_FAMILY, {
      enableBlobFiles: true,
      minBlobSize: 4096,
      blobFileSize: 256 * 1024 * 1024,
      enableBlobGarbageCollection: true,
      tableBlockSize: 8192,
      tableCacheIndexAndFilterBlocks,
      tableFormatVersion: 6,
      optimizeFiltersForMemory,
      blockCache
    });
    return db.columnFamily(col);
  }
  function tmpFixStorage(p) {
    if (fs.existsSync(path.join(p, "CORESTORE")))
      return;
    let files = [];
    try {
      files = fs.readdirSync(p);
    } catch {}
    const notRocks = new Set(["CORESTORE", "primary-key", "cores", "app-preferences", "cache", "preferences.json", "db", "clone", "core", "notifications"]);
    for (const f of files) {
      if (notRocks.has(f))
        continue;
      try {
        fs.mkdirSync(path.join(p, "db"));
      } catch {}
      fs.renameSync(path.join(p, f), path.join(p, "db", f));
    }
  }
});

// node_modules/sodium-secretstream/index.js
var require_sodium_secretstream = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var b4a = require_b4a();
  var ABYTES = sodium.crypto_secretstream_xchacha20poly1305_ABYTES;
  var TAG_MESSAGE = sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;
  var TAG_FINAL = sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL;
  var STATEBYTES = sodium.crypto_secretstream_xchacha20poly1305_STATEBYTES;
  var HEADERBYTES = sodium.crypto_secretstream_xchacha20poly1305_HEADERBYTES;
  var KEYBYTES = sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES;
  var TAG_FINAL_BYTE = b4a.isBuffer(TAG_FINAL) ? TAG_FINAL[0] : TAG_FINAL;
  var EMPTY = b4a.alloc(0);
  var TAG = b4a.alloc(1);

  class Push {
    constructor(key, state = b4a.allocUnsafeSlow(STATEBYTES), header = b4a.allocUnsafeSlow(HEADERBYTES)) {
      if (!TAG_FINAL)
        throw new Error("JavaScript sodium version needs to support crypto_secretstream_xchacha20poly");
      this.key = key;
      this.state = state;
      this.header = header;
      sodium.crypto_secretstream_xchacha20poly1305_init_push(this.state, this.header, this.key);
    }
    next(message, cipher = b4a.allocUnsafe(message.byteLength + ABYTES)) {
      sodium.crypto_secretstream_xchacha20poly1305_push(this.state, cipher, message, null, TAG_MESSAGE);
      return cipher;
    }
    final(message = EMPTY, cipher = b4a.allocUnsafe(ABYTES)) {
      sodium.crypto_secretstream_xchacha20poly1305_push(this.state, cipher, message, null, TAG_FINAL);
      return cipher;
    }
  }

  class Pull {
    constructor(key, state = b4a.allocUnsafeSlow(STATEBYTES)) {
      if (!TAG_FINAL)
        throw new Error("JavaScript sodium version needs to support crypto_secretstream_xchacha20poly");
      this.key = key;
      this.state = state;
      this.final = false;
    }
    init(header) {
      sodium.crypto_secretstream_xchacha20poly1305_init_pull(this.state, header, this.key);
    }
    next(cipher, message = b4a.allocUnsafe(cipher.byteLength - ABYTES)) {
      sodium.crypto_secretstream_xchacha20poly1305_pull(this.state, message, TAG, cipher, null);
      this.final = TAG[0] === TAG_FINAL_BYTE;
      return message;
    }
  }
  function keygen(buf = b4a.alloc(KEYBYTES)) {
    sodium.crypto_secretstream_xchacha20poly1305_keygen(buf);
    return buf;
  }
  module.exports = {
    keygen,
    KEYBYTES,
    ABYTES,
    STATEBYTES,
    HEADERBYTES,
    Push,
    Pull
  };
});

// node_modules/timeout-refresh/node.js
var require_node2 = __commonJS((exports, module) => {
  module.exports = class Timer {
    constructor(ms, fn, ctx = null, interval = false) {
      this.ms = ms;
      this.ontimeout = fn;
      this.context = ctx;
      this.interval = interval;
      this.done = false;
      this._timer = interval ? setInterval(callInterval, ms, this) : setTimeout(callTimeout, ms, this);
    }
    unref() {
      this._timer.unref();
    }
    ref() {
      this._timer.ref();
    }
    refresh() {
      if (this.done !== true)
        this._timer.refresh();
    }
    destroy() {
      this.done = true;
      this.ontimeout = null;
      if (this.interval)
        clearInterval(this._timer);
      else
        clearTimeout(this._timer);
    }
    static once(ms, fn, ctx) {
      return new this(ms, fn, ctx, false);
    }
    static on(ms, fn, ctx) {
      return new this(ms, fn, ctx, true);
    }
  };
  function callTimeout(self) {
    self.done = true;
    self.ontimeout.call(self.context);
  }
  function callInterval(self) {
    self.ontimeout.call(self.context);
  }
});

// node_modules/timeout-refresh/browser.js
var require_browser = __commonJS((exports, module) => {
  module.exports = class TimerBrowser {
    constructor(ms, fn, ctx = null, interval = false) {
      this.ms = ms;
      this.ontimeout = fn;
      this.context = ctx || null;
      this.interval = interval;
      this.done = false;
      this._timer = interval ? setInterval(callInterval, ms, this) : setTimeout(callTimeout, ms, this);
    }
    unref() {}
    ref() {}
    refresh() {
      if (this.done)
        return;
      if (this.interval) {
        clearInterval(this._timer);
        this._timer = setInterval(callInterval, this.ms, this);
      } else {
        clearTimeout(this._timer);
        this._timer = setTimeout(callTimeout, this.ms, this);
      }
    }
    destroy() {
      this.done = true;
      this.ontimeout = null;
      if (this.interval)
        clearInterval(this._timer);
      else
        clearTimeout(this._timer);
    }
    static once(ms, fn, ctx) {
      return new this(ms, fn, ctx, false);
    }
    static on(ms, fn, ctx) {
      return new this(ms, fn, ctx, true);
    }
  };
  function callTimeout(self) {
    self.done = true;
    self.ontimeout.call(self.context);
  }
  function callInterval(self) {
    self.ontimeout.call(self.context);
  }
});

// node_modules/timeout-refresh/index.js
var require_timeout_refresh = __commonJS((exports, module) => {
  module.exports = isNode() ? require_node2() : require_browser();
  function isNode() {
    const to = setTimeout(function() {}, 1000);
    clearTimeout(to);
    return !!to.refresh;
  }
});

// node_modules/@hyperswarm/secret-stream/lib/bridge.js
var require_bridge = __commonJS((exports, module) => {
  var { Duplex, Writable } = require_streamx();

  class ReversePassThrough extends Duplex {
    constructor(s) {
      super();
      this._stream = s;
      this._ondrain = null;
    }
    _write(data, cb) {
      if (this._stream.push(data) === false) {
        this._stream._ondrain = cb;
      } else {
        cb(null);
      }
    }
    _final(cb) {
      this._stream.push(null);
      cb(null);
    }
    _read(cb) {
      const ondrain = this._ondrain;
      this._ondrain = null;
      if (ondrain)
        ondrain();
      cb(null);
    }
  }
  module.exports = class Bridge extends Duplex {
    constructor(noiseStream) {
      super();
      this.noiseStream = noiseStream;
      this._ondrain = null;
      this.reverse = new ReversePassThrough(this);
    }
    get publicKey() {
      return this.noiseStream.publicKey;
    }
    get remotePublicKey() {
      return this.noiseStream.remotePublicKey;
    }
    get handshakeHash() {
      return this.noiseStream.handshakeHash;
    }
    flush() {
      return Writable.drained(this);
    }
    _read(cb) {
      const ondrain = this._ondrain;
      this._ondrain = null;
      if (ondrain)
        ondrain();
      cb(null);
    }
    _write(data, cb) {
      if (this.reverse.push(data) === false) {
        this.reverse._ondrain = cb;
      } else {
        cb(null);
      }
    }
    _final(cb) {
      this.reverse.push(null);
      cb(null);
    }
  };
});

// node_modules/noise-curve-ed/index.js
var require_noise_curve_ed = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var assert = require_nanoassert();
  var b4a = require_b4a();
  var DHLEN = sodium.crypto_scalarmult_ed25519_BYTES;
  var PKLEN = sodium.crypto_scalarmult_ed25519_BYTES;
  var SCALARLEN = sodium.crypto_scalarmult_ed25519_BYTES;
  var SKLEN = sodium.crypto_sign_SECRETKEYBYTES;
  var ALG = "Ed25519";
  module.exports = {
    DHLEN,
    PKLEN,
    SCALARLEN,
    SKLEN,
    ALG,
    name: ALG,
    generateKeyPair,
    dh
  };
  function generateKeyPair(privKey) {
    if (privKey)
      return generateSeedKeyPair(privKey.subarray(0, 32));
    const keyPair = {};
    keyPair.secretKey = b4a.alloc(SKLEN);
    keyPair.publicKey = b4a.alloc(PKLEN);
    sodium.crypto_sign_keypair(keyPair.publicKey, keyPair.secretKey);
    return keyPair;
  }
  function generateSeedKeyPair(seed) {
    const keyPair = {};
    keyPair.secretKey = b4a.alloc(SKLEN);
    keyPair.publicKey = b4a.alloc(PKLEN);
    sodium.crypto_sign_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed);
    return keyPair;
  }
  function dh(publicKey, { scalar, secretKey }) {
    if (!scalar) {
      assert(secretKey.byteLength === SKLEN);
      const sk = b4a.alloc(64);
      sodium.crypto_hash_sha512(sk, secretKey.subarray(0, 32));
      sk[0] &= 248;
      sk[31] &= 127;
      sk[31] |= 64;
      scalar = sk.subarray(0, 32);
    }
    assert(scalar.byteLength === SCALARLEN);
    assert(publicKey.byteLength === PKLEN);
    const output = b4a.alloc(DHLEN);
    sodium.crypto_scalarmult_ed25519_noclamp(output, scalar, publicKey);
    return output;
  }
});

// node_modules/noise-handshake/cipher.js
var require_cipher = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var b4a = require_b4a();
  module.exports = class CipherState {
    constructor(key) {
      this.key = key || null;
      this.nonce = 0;
      this.CIPHER_ALG = "ChaChaPoly";
    }
    initialiseKey(key) {
      this.key = key;
      this.nonce = 0;
    }
    setNonce(nonce) {
      this.nonce = nonce;
    }
    encrypt(plaintext, ad) {
      if (!this.hasKey)
        return plaintext;
      if (!ad)
        ad = b4a.alloc(0);
      const ciphertext = encryptWithAD(this.key, this.nonce, ad, plaintext);
      if (ciphertext.length > 65535)
        throw new Error(`ciphertext length of ${ciphertext.length} exceeds maximum Noise message length of 65535`);
      this.nonce++;
      return ciphertext;
    }
    decrypt(ciphertext, ad) {
      if (!this.hasKey)
        return ciphertext;
      if (!ad)
        ad = b4a.alloc(0);
      if (ciphertext.length > 65535)
        throw new Error(`ciphertext length of ${ciphertext.length} exceeds maximum Noise message length of 65535`);
      const plaintext = decryptWithAD(this.key, this.nonce, ad, ciphertext);
      this.nonce++;
      return plaintext;
    }
    get hasKey() {
      return this.key !== null;
    }
    _clear() {
      sodium.sodium_memzero(this.key);
      this.key = null;
      this.nonce = null;
    }
    static get MACBYTES() {
      return 16;
    }
    static get NONCEBYTES() {
      return 8;
    }
    static get KEYBYTES() {
      return 32;
    }
  };
  function encryptWithAD(key, counter, additionalData, plaintext) {
    if (!b4a.isBuffer(additionalData))
      additionalData = b4a.from(additionalData, "hex");
    if (!b4a.isBuffer(plaintext))
      plaintext = b4a.from(plaintext, "hex");
    const nonce = b4a.alloc(sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES);
    const view = new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength);
    view.setUint32(4, counter, true);
    const ciphertext = b4a.alloc(plaintext.byteLength + sodium.crypto_aead_chacha20poly1305_ietf_ABYTES);
    sodium.crypto_aead_chacha20poly1305_ietf_encrypt(ciphertext, plaintext, additionalData, null, nonce, key);
    return ciphertext;
  }
  function decryptWithAD(key, counter, additionalData, ciphertext) {
    if (!b4a.isBuffer(additionalData))
      additionalData = b4a.from(additionalData, "hex");
    if (!b4a.isBuffer(ciphertext))
      ciphertext = b4a.from(ciphertext, "hex");
    const nonce = b4a.alloc(sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES);
    const view = new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength);
    view.setUint32(4, counter, true);
    const plaintext = b4a.alloc(ciphertext.byteLength - sodium.crypto_aead_chacha20poly1305_ietf_ABYTES);
    sodium.crypto_aead_chacha20poly1305_ietf_decrypt(plaintext, null, ciphertext, additionalData, nonce, key);
    return plaintext;
  }
});

// node_modules/noise-handshake/dh.js
var require_dh = __commonJS((exports, module) => {
  var {
    crypto_kx_SEEDBYTES,
    crypto_kx_keypair,
    crypto_kx_seed_keypair,
    crypto_scalarmult_BYTES,
    crypto_scalarmult_SCALARBYTES,
    crypto_scalarmult,
    crypto_scalarmult_base
  } = require_sodium_native();
  var assert = require_nanoassert();
  var b4a = require_b4a();
  var DHLEN = crypto_scalarmult_BYTES;
  var PKLEN = crypto_scalarmult_BYTES;
  var SKLEN = crypto_scalarmult_SCALARBYTES;
  var SEEDLEN = crypto_kx_SEEDBYTES;
  var ALG = "25519";
  module.exports = {
    DHLEN,
    PKLEN,
    SKLEN,
    SEEDLEN,
    ALG,
    generateKeyPair,
    generateSeedKeyPair,
    dh
  };
  function generateKeyPair(privKey) {
    const keyPair = {};
    keyPair.secretKey = privKey || b4a.alloc(SKLEN);
    keyPair.publicKey = b4a.alloc(PKLEN);
    if (privKey) {
      crypto_scalarmult_base(keyPair.publicKey, keyPair.secretKey);
    } else {
      crypto_kx_keypair(keyPair.publicKey, keyPair.secretKey);
    }
    return keyPair;
  }
  function generateSeedKeyPair(seed) {
    assert(seed.byteLength === SKLEN);
    const keyPair = {};
    keyPair.secretKey = b4a.alloc(SKLEN);
    keyPair.publicKey = b4a.alloc(PKLEN);
    crypto_kx_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed);
    return keyPair;
  }
  function dh(publicKey, { secretKey }) {
    assert(secretKey.byteLength === SKLEN);
    assert(publicKey.byteLength === PKLEN);
    const output = b4a.alloc(DHLEN);
    crypto_scalarmult(output, secretKey, publicKey);
    return output;
  }
});

// node_modules/noise-handshake/hmac.js
var require_hmac = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var { sodium_memzero, crypto_generichash, crypto_generichash_batch } = require_sodium_native();
  var HASHLEN = 64;
  var BLOCKLEN = 128;
  var scratch = b4a.alloc(BLOCKLEN * 3);
  var HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1);
  var OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2);
  var InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3);
  module.exports = function hmac(out, batch, key) {
    if (key.byteLength > BLOCKLEN) {
      crypto_generichash(HMACKey.subarray(0, HASHLEN), key);
      sodium_memzero(HMACKey.subarray(HASHLEN));
    } else {
      HMACKey.set(key);
      sodium_memzero(HMACKey.subarray(key.byteLength));
    }
    for (let i = 0;i < HMACKey.byteLength; i++) {
      OuterKeyPad[i] = 92 ^ HMACKey[i];
      InnerKeyPad[i] = 54 ^ HMACKey[i];
    }
    sodium_memzero(HMACKey);
    crypto_generichash_batch(out, [InnerKeyPad].concat(batch));
    sodium_memzero(InnerKeyPad);
    crypto_generichash_batch(out, [OuterKeyPad, out]);
    sodium_memzero(OuterKeyPad);
  };
  module.exports.BYTES = HASHLEN;
  module.exports.KEYBYTES = BLOCKLEN;
});

// node_modules/noise-handshake/hkdf.js
var require_hkdf = __commonJS((exports, module) => {
  var hmacBlake2b = require_hmac();
  var b4a = require_b4a();
  var HASHLEN = 64;
  module.exports = {
    hkdf,
    HASHLEN
  };
  function hkdf(salt, inputKeyMaterial, info = "", length = 2 * HASHLEN) {
    const pseudoRandomKey = hkdfExtract(salt, inputKeyMaterial);
    return hkdfExpand(pseudoRandomKey, info, length);
  }
  function hkdfExtract(salt, inputKeyMaterial) {
    const hmac = b4a.alloc(HASHLEN);
    return hmacDigest(hmac, salt, inputKeyMaterial);
  }
  function hkdfExpand(key, info, length) {
    const buffer = b4a.allocUnsafeSlow(length);
    const infoBuf = b4a.from(info);
    let prev = infoBuf;
    const result = [];
    for (let i = 0;i < length; i += HASHLEN) {
      const pos = b4a.from([i / HASHLEN + 1]);
      const out = buffer.subarray(i, i + HASHLEN);
      result.push(out);
      prev = hmacDigest(out, key, [prev, infoBuf, pos]);
    }
    return result;
  }
  function hmacDigest(out, key, input) {
    hmacBlake2b(out, input, key);
    return out;
  }
});

// node_modules/noise-handshake/symmetric-state.js
var require_symmetric_state = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var assert = require_nanoassert();
  var b4a = require_b4a();
  var CipherState = require_cipher();
  var curve = require_dh();
  var { HASHLEN, hkdf } = require_hkdf();
  module.exports = class SymmetricState extends CipherState {
    constructor(opts = {}) {
      super();
      this.curve = opts.curve || curve;
      this.digest = b4a.alloc(HASHLEN);
      this.chainingKey = null;
      this.offset = 0;
      this.DH_ALG = this.curve.ALG;
    }
    mixHash(data) {
      accumulateDigest(this.digest, data);
    }
    mixKeyAndHash(key) {
      const [ck, tempH, tempK] = hkdf(this.chainingKey, key, "", 3 * HASHLEN);
      this.chainingKey = ck;
      this.mixHash(tempH);
      this.initialiseKey(tempK.subarray(0, 32));
    }
    mixKeyNormal(key) {
      const [ck, tempK] = hkdf(this.chainingKey, key);
      this.chainingKey = ck;
      this.initialiseKey(tempK.subarray(0, 32));
    }
    mixKey(remoteKey, localKey) {
      const dh = this.curve.dh(remoteKey, localKey);
      const hkdfResult = hkdf(this.chainingKey, dh);
      this.chainingKey = hkdfResult[0];
      this.initialiseKey(hkdfResult[1].subarray(0, 32));
    }
    encryptAndHash(plaintext) {
      const ciphertext = this.encrypt(plaintext, this.digest);
      accumulateDigest(this.digest, ciphertext);
      return ciphertext;
    }
    decryptAndHash(ciphertext) {
      const plaintext = this.decrypt(ciphertext, this.digest);
      accumulateDigest(this.digest, ciphertext);
      return plaintext;
    }
    getHandshakeHash(out) {
      if (!out)
        return this.getHandshakeHash(b4a.alloc(HASHLEN));
      assert(out.byteLength === HASHLEN, `output must be ${HASHLEN} bytes`);
      out.set(this.digest);
      return out;
    }
    split() {
      const res = hkdf(this.chainingKey, b4a.alloc(0));
      return res.map((k) => k.subarray(0, 32));
    }
    _clear() {
      super._clear();
      sodium.sodium_memzero(this.digest);
      sodium.sodium_memzero(this.chainingKey);
      this.digest = null;
      this.chainingKey = null;
      this.offset = null;
      this.curve = null;
    }
    static get alg() {
      return CipherState.alg + "_BLAKE2b";
    }
  };
  function accumulateDigest(digest, input) {
    const toHash = b4a.concat([digest, input]);
    sodium.crypto_generichash(digest, toHash);
  }
});

// node_modules/noise-handshake/noise.js
var require_noise = __commonJS((exports, module) => {
  var assert = require_nanoassert();
  var b4a = require_b4a();
  var SymmetricState = require_symmetric_state();
  var { HASHLEN } = require_hkdf();
  var PRESHARE_IS = Symbol("initiator static key preshared");
  var PRESHARE_RS = Symbol("responder static key preshared");
  var TOK_PSK = Symbol("psk");
  var TOK_S = Symbol("s");
  var TOK_E = Symbol("e");
  var TOK_ES = Symbol("es");
  var TOK_SE = Symbol("se");
  var TOK_EE = Symbol("ee");
  var TOK_SS = Symbol("ss");
  var HANDSHAKES = Object.freeze({
    NN: [
      [TOK_E],
      [TOK_E, TOK_EE]
    ],
    NNpsk0: [
      [TOK_PSK, TOK_E],
      [TOK_E, TOK_EE]
    ],
    XX: [
      [TOK_E],
      [TOK_E, TOK_EE, TOK_S, TOK_ES],
      [TOK_S, TOK_SE]
    ],
    XXpsk0: [
      [TOK_PSK, TOK_E],
      [TOK_E, TOK_EE, TOK_S, TOK_ES],
      [TOK_S, TOK_SE]
    ],
    IK: [
      PRESHARE_RS,
      [TOK_E, TOK_ES, TOK_S, TOK_SS],
      [TOK_E, TOK_EE, TOK_SE]
    ]
  });

  class Writer {
    constructor() {
      this.size = 0;
      this.buffers = [];
    }
    push(b) {
      this.size += b.byteLength;
      this.buffers.push(b);
    }
    end() {
      const all = b4a.alloc(this.size);
      let offset = 0;
      for (const b of this.buffers) {
        all.set(b, offset);
        offset += b.byteLength;
      }
      return all;
    }
  }

  class Reader {
    constructor(buf) {
      this.offset = 0;
      this.buffer = buf;
    }
    shift(n) {
      const start = this.offset;
      const end = this.offset += n;
      if (end > this.buffer.byteLength)
        throw new Error("Insufficient bytes");
      return this.buffer.subarray(start, end);
    }
    end() {
      return this.shift(this.buffer.byteLength - this.offset);
    }
  }
  module.exports = class NoiseState extends SymmetricState {
    constructor(pattern, initiator, staticKeypair, opts = {}) {
      super(opts);
      this.s = staticKeypair || this.curve.generateKeyPair();
      this.e = null;
      this.psk = null;
      if (opts && opts.psk)
        this.psk = opts.psk;
      this.re = null;
      this.rs = null;
      this.pattern = pattern;
      this.handshake = HANDSHAKES[this.pattern].slice();
      this.isPskHandshake = !!this.psk && hasPskToken(this.handshake);
      this.protocol = b4a.from([
        "Noise",
        this.pattern,
        this.DH_ALG,
        this.CIPHER_ALG,
        "BLAKE2b"
      ].join("_"));
      this.initiator = initiator;
      this.complete = false;
      this.rx = null;
      this.tx = null;
      this.hash = null;
    }
    initialise(prologue, remoteStatic) {
      if (this.protocol.byteLength <= HASHLEN)
        this.digest.set(this.protocol);
      else
        this.mixHash(this.protocol);
      this.chainingKey = b4a.from(this.digest);
      this.mixHash(prologue);
      while (!Array.isArray(this.handshake[0])) {
        const message = this.handshake.shift();
        assert(message === PRESHARE_RS || message === PRESHARE_IS, "Unexpected pattern");
        const takeRemoteKey = this.initiator ? message === PRESHARE_RS : message === PRESHARE_IS;
        if (takeRemoteKey)
          this.rs = remoteStatic;
        const key = takeRemoteKey ? this.rs : this.s.publicKey;
        assert(key != null, "Remote pubkey required");
        this.mixHash(key);
      }
    }
    final() {
      const [k1, k2] = this.split();
      this.tx = this.initiator ? k1 : k2;
      this.rx = this.initiator ? k2 : k1;
      this.complete = true;
      this.hash = this.getHandshakeHash();
      this._clear();
    }
    recv(buf) {
      const r = new Reader(buf);
      for (const pattern of this.handshake.shift()) {
        switch (pattern) {
          case TOK_PSK:
            this.mixKeyAndHash(this.psk);
            break;
          case TOK_E:
            this.re = r.shift(this.curve.PKLEN);
            this.mixHash(this.re);
            if (this.isPskHandshake)
              this.mixKeyNormal(this.re);
            break;
          case TOK_S: {
            const klen = this.hasKey ? this.curve.PKLEN + 16 : this.curve.PKLEN;
            this.rs = this.decryptAndHash(r.shift(klen));
            break;
          }
          case TOK_EE:
          case TOK_ES:
          case TOK_SE:
          case TOK_SS: {
            const useStatic = keyPattern(pattern, this.initiator);
            const localKey = useStatic.local ? this.s : this.e;
            const remoteKey = useStatic.remote ? this.rs : this.re;
            this.mixKey(remoteKey, localKey);
            break;
          }
          default:
            throw new Error("Unexpected message");
        }
      }
      const payload = this.decryptAndHash(r.end());
      if (!this.handshake.length)
        this.final();
      return payload;
    }
    send(payload = b4a.alloc(0)) {
      const w = new Writer;
      for (const pattern of this.handshake.shift()) {
        switch (pattern) {
          case TOK_PSK:
            this.mixKeyAndHash(this.psk);
            break;
          case TOK_E:
            if (this.e === null)
              this.e = this.curve.generateKeyPair();
            this.mixHash(this.e.publicKey);
            if (this.isPskHandshake)
              this.mixKeyNormal(this.e.publicKey);
            w.push(this.e.publicKey);
            break;
          case TOK_S:
            w.push(this.encryptAndHash(this.s.publicKey));
            break;
          case TOK_ES:
          case TOK_SE:
          case TOK_EE:
          case TOK_SS: {
            const useStatic = keyPattern(pattern, this.initiator);
            const localKey = useStatic.local ? this.s : this.e;
            const remoteKey = useStatic.remote ? this.rs : this.re;
            this.mixKey(remoteKey, localKey);
            break;
          }
          default:
            throw new Error("Unexpected message");
        }
      }
      w.push(this.encryptAndHash(payload));
      const response = w.end();
      if (!this.handshake.length)
        this.final();
      return response;
    }
    _clear() {
      super._clear();
      this.e.secretKey.fill(0);
      this.e.publicKey.fill(0);
      this.re.fill(0);
      this.e = null;
      this.re = null;
    }
  };
  function keyPattern(pattern, initiator) {
    const ret = {
      local: false,
      remote: false
    };
    switch (pattern) {
      case TOK_EE:
        return ret;
      case TOK_ES:
        ret.local ^= !initiator;
        ret.remote ^= initiator;
        return ret;
      case TOK_SE:
        ret.local ^= initiator;
        ret.remote ^= !initiator;
        return ret;
      case TOK_SS:
        ret.local ^= 1;
        ret.remote ^= 1;
        return ret;
    }
  }
  function hasPskToken(handshake) {
    return handshake.some((x) => {
      return Array.isArray(x) && x.indexOf(TOK_PSK) !== -1;
    });
  }
});

// node_modules/@hyperswarm/secret-stream/lib/handshake.js
var require_handshake = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var curve = require_noise_curve_ed();
  var Noise = require_noise();
  var b4a = require_b4a();
  var EMPTY = b4a.alloc(0);
  module.exports = class Handshake {
    constructor(isInitiator, keyPair, remotePublicKey, pattern) {
      this.isInitiator = isInitiator;
      this.keyPair = keyPair;
      this.noise = new Noise(pattern, isInitiator, keyPair, { curve });
      this.noise.initialise(EMPTY, remotePublicKey);
      this.destroyed = false;
    }
    static keyPair(seed) {
      const publicKey = b4a.alloc(32);
      const secretKey = b4a.alloc(64);
      if (seed)
        sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);
      else
        sodium.crypto_sign_keypair(publicKey, secretKey);
      return { publicKey, secretKey };
    }
    recv(data) {
      try {
        this.noise.recv(data);
        if (this.noise.complete)
          return this._return(null);
        return this.send();
      } catch {
        this.destroy();
        return null;
      }
    }
    send() {
      try {
        const data = this.noise.send();
        const wrap = b4a.allocUnsafe(data.byteLength + 3);
        writeUint24le(data.byteLength, wrap);
        wrap.set(data, 3);
        return this._return(wrap);
      } catch {
        this.destroy();
        return null;
      }
    }
    destroy() {
      if (this.destroyed)
        return;
      this.destroyed = true;
    }
    _return(data) {
      const tx = this.noise.complete ? b4a.toBuffer(this.noise.tx) : null;
      const rx = this.noise.complete ? b4a.toBuffer(this.noise.rx) : null;
      const hash = this.noise.complete ? b4a.toBuffer(this.noise.hash) : null;
      const remotePublicKey = this.noise.complete ? b4a.toBuffer(this.noise.rs) : null;
      return {
        data,
        remotePublicKey,
        hash,
        tx,
        rx
      };
    }
  };
  function writeUint24le(n, buf) {
    buf[0] = n & 255;
    buf[1] = n >>> 8 & 255;
    buf[2] = n >>> 16 & 255;
  }
});

// node_modules/@hyperswarm/secret-stream/index.js
var require_secret_stream = __commonJS((exports, module) => {
  var { Pull, Push, HEADERBYTES, KEYBYTES, ABYTES } = require_sodium_secretstream();
  var sodium = require_sodium_native();
  var crypto = require_hypercore_crypto();
  var { Duplex, Writable, getStreamError } = require_streamx();
  var b4a = require_b4a();
  var Timeout = require_timeout_refresh();
  var unslab = require_unslab();
  var Bridge = require_bridge();
  var Handshake = require_handshake();
  var IDHEADERBYTES = HEADERBYTES + 32;
  var [NS_INITIATOR, NS_RESPONDER, NS_SEND] = crypto.namespace("hyperswarm/secret-stream", 3);
  var MAX_ATOMIC_WRITE = 256 * 256 * 256 - 1;
  module.exports = class NoiseSecretStream extends Duplex {
    constructor(isInitiator, rawStream, opts = {}) {
      super({ mapWritable: toBuffer });
      if (typeof isInitiator !== "boolean") {
        throw new Error("isInitiator should be a boolean");
      }
      this.noiseStream = this;
      this.isInitiator = isInitiator;
      this.rawStream = null;
      this.publicKey = opts.publicKey || null;
      this.remotePublicKey = opts.remotePublicKey || null;
      this.handshakeHash = null;
      this.connected = false;
      this.keepAlive = opts.keepAlive || 0;
      this.timeout = 0;
      this.enableSend = opts.enableSend !== false;
      this.userData = null;
      let openedDone = null;
      this.opened = new Promise((resolve) => {
        openedDone = resolve;
      });
      this.rawBytesWritten = 0;
      this.rawBytesRead = 0;
      this.relay = null;
      this.puncher = null;
      this._rawStream = null;
      this._handshake = null;
      this._handshakePattern = opts.pattern || null;
      this._handshakeDone = null;
      this._state = 0;
      this._len = 0;
      this._tmp = 1;
      this._message = null;
      this._openedDone = openedDone;
      this._startDone = null;
      this._drainDone = null;
      this._outgoingPlain = null;
      this._outgoingWrapped = null;
      this._utp = null;
      this._setup = true;
      this._ended = 2;
      this._encrypt = null;
      this._decrypt = null;
      this._timeoutTimer = null;
      this._keepAliveTimer = null;
      this._sendState = null;
      if (opts.autoStart !== false)
        this.start(rawStream, opts);
      this.resume();
      this.pause();
    }
    static keyPair(seed) {
      return Handshake.keyPair(seed);
    }
    static id(handshakeHash, isInitiator, id) {
      return streamId(handshakeHash, isInitiator, id);
    }
    setTimeout(ms) {
      if (!ms)
        ms = 0;
      this._clearTimeout();
      this.timeout = ms;
      if (!ms || this.rawStream === null)
        return;
      this._timeoutTimer = Timeout.once(ms, destroyTimeout, this);
      this._timeoutTimer.unref();
    }
    setKeepAlive(ms) {
      if (!ms)
        ms = 0;
      this._clearKeepAlive();
      this.keepAlive = ms;
      if (!ms || this.rawStream === null)
        return;
      this._keepAliveTimer = Timeout.on(ms, sendKeepAlive, this);
      this._keepAliveTimer.unref();
    }
    sendKeepAlive() {
      const empty = this.alloc(0);
      this.write(empty);
    }
    start(rawStream, opts = {}) {
      if (rawStream) {
        this.rawStream = rawStream;
        this._rawStream = rawStream;
        if (typeof this.rawStream.setContentSize === "function") {
          this._utp = rawStream;
        }
      } else {
        this.rawStream = new Bridge(this);
        this._rawStream = this.rawStream.reverse;
      }
      this.rawStream.on("error", this._onrawerror.bind(this));
      this.rawStream.on("close", this._onrawclose.bind(this));
      this._startHandshake(opts.handshake, opts.keyPair || null);
      this._continueOpen(null);
      if (this.destroying)
        return;
      if (opts.data)
        this._onrawdata(opts.data);
      if (opts.ended)
        this._onrawend();
      if (this.keepAlive > 0 && this._keepAliveTimer === null) {
        this.setKeepAlive(this.keepAlive);
      }
      if (this.timeout > 0 && this._timeoutTimer === null) {
        this.setTimeout(this.timeout);
      }
    }
    async flush() {
      if (await this.opened === false)
        return false;
      if (await Writable.drained(this) === false)
        return false;
      if (this.destroying)
        return false;
      if (this.rawStream !== null && this.rawStream.flush) {
        return await this.rawStream.flush();
      }
      return true;
    }
    _continueOpen(err) {
      if (err)
        this.destroy(err);
      if (this._startDone === null)
        return;
      const done = this._startDone;
      this._startDone = null;
      this._open(done);
    }
    _onkeypairpromise(p) {
      const self = this;
      const cont = this._continueOpen.bind(this);
      p.then(onkeypair, cont);
      function onkeypair(kp) {
        self._onkeypair(kp);
        cont(null);
      }
    }
    _onkeypair(keyPair) {
      const pattern = this._handshakePattern || "XX";
      const remotePublicKey = this.remotePublicKey;
      this._handshake = new Handshake(this.isInitiator, keyPair, remotePublicKey, pattern);
      this.publicKey = this._handshake.keyPair.publicKey;
    }
    _startHandshake(handshake, keyPair) {
      if (handshake) {
        const { tx, rx, hash, publicKey, remotePublicKey } = handshake;
        this._setupSecretStream(tx, rx, hash, publicKey, remotePublicKey);
        return;
      }
      if (!keyPair)
        keyPair = Handshake.keyPair();
      if (typeof keyPair.then === "function") {
        this._onkeypairpromise(keyPair);
      } else {
        this._onkeypair(keyPair);
      }
    }
    _onrawerror(err) {
      this.destroy(err);
    }
    _onrawclose() {
      if (this._ended !== 0)
        this.destroy();
    }
    _onrawdata(data) {
      let offset = 0;
      if (this._timeoutTimer !== null) {
        this._timeoutTimer.refresh();
      }
      do {
        switch (this._state) {
          case 0: {
            while (this._tmp !== 16777216 && offset < data.byteLength) {
              const v = data[offset++];
              this._len += this._tmp * v;
              this._tmp *= 256;
            }
            if (this._tmp === 16777216) {
              this._tmp = 0;
              this._state = 1;
              const unprocessed = data.byteLength - offset;
              if (unprocessed < this._len && this._utp !== null)
                this._utp.setContentSize(this._len - unprocessed);
            }
            break;
          }
          case 1: {
            const missing = this._len - this._tmp;
            const end = missing + offset;
            if (this._message === null && end <= data.byteLength) {
              this._message = data.subarray(offset, end);
              offset += missing;
              this._incoming();
              break;
            }
            const unprocessed = data.byteLength - offset;
            if (this._message === null) {
              this._message = b4a.allocUnsafe(this._len);
            }
            b4a.copy(data, this._message, this._tmp, offset);
            this._tmp += unprocessed;
            if (end <= data.byteLength) {
              offset += missing;
              this._incoming();
            } else {
              offset += unprocessed;
            }
            break;
          }
        }
      } while (offset < data.byteLength && !this.destroying);
    }
    _onrawend() {
      this._ended--;
      this.push(null);
    }
    _onrawdrain() {
      const drain = this._drainDone;
      if (drain === null)
        return;
      this._drainDone = null;
      drain();
    }
    _read(cb) {
      this.rawStream.resume();
      cb(null);
    }
    _incoming() {
      const message = this._message;
      this._state = 0;
      this._len = 0;
      this._tmp = 1;
      this._message = null;
      if (this._setup === true) {
        if (this._handshake) {
          this._onhandshakert(this._handshake.recv(message));
        } else {
          if (message.byteLength !== IDHEADERBYTES) {
            this.destroy(new Error("Invalid header message received"));
            return;
          }
          const remoteId = message.subarray(0, 32);
          const expectedId = streamId(this.handshakeHash, !this.isInitiator);
          const header = message.subarray(32);
          if (!b4a.equals(expectedId, remoteId)) {
            this.destroy(new Error("Invalid header received"));
            return;
          }
          this._decrypt.init(header);
          this._setup = false;
        }
        return;
      }
      if (message.byteLength < ABYTES) {
        this.destroy(new Error("Invalid message received"));
        return;
      }
      this.rawBytesRead += message.byteLength;
      const plain = message.subarray(1, message.byteLength - ABYTES + 1);
      try {
        this._decrypt.next(message, plain);
      } catch (err) {
        this.destroy(err);
        return;
      }
      if (plain.byteLength === 0 && this.keepAlive !== 0)
        return;
      if (this.push(plain) === false) {
        this.rawStream.pause();
      }
    }
    _onhandshakert(h) {
      if (this._handshakeDone === null)
        return;
      if (h !== null) {
        if (h.data)
          this._rawStream.write(h.data);
        if (!h.tx)
          return;
      }
      const done = this._handshakeDone;
      const publicKey = this._handshake.keyPair.publicKey;
      this._handshakeDone = null;
      this._handshake = null;
      if (h === null)
        return done(new Error("Noise handshake failed"));
      this._setupSecretStream(h.tx, h.rx, h.hash, publicKey, h.remotePublicKey);
      this._resolveOpened(true);
      done(null);
    }
    _setupSecretStream(tx, rx, handshakeHash, publicKey, remotePublicKey) {
      const buf = b4a.allocUnsafeSlow(3 + IDHEADERBYTES);
      writeUint24le(IDHEADERBYTES, buf);
      this._encrypt = new Push(unslab(tx.subarray(0, KEYBYTES)), undefined, buf.subarray(3 + 32));
      this._decrypt = new Pull(unslab(rx.subarray(0, KEYBYTES)));
      this.publicKey = publicKey;
      this.remotePublicKey = remotePublicKey;
      this.handshakeHash = handshakeHash;
      const id = buf.subarray(3, 3 + 32);
      streamId(handshakeHash, this.isInitiator, id);
      this._setupSecretSend(handshakeHash);
      this.emit("handshake");
      if (this.rawStream !== this._rawStream)
        this.rawStream.emit("handshake");
      if (this.destroying)
        return;
      this._rawStream.write(buf);
    }
    _setupSecretSend(handshakeHash) {
      this._sendState = b4a.allocUnsafeSlow(32 + 32 + 8 + 8);
      const encrypt = this._sendState.subarray(0, 32);
      const decrypt = this._sendState.subarray(32, 64);
      const counter = this._sendState.subarray(64, 72);
      const initial = this._sendState.subarray(72);
      const inputs = this.isInitiator ? [[NS_INITIATOR, NS_SEND], [NS_RESPONDER, NS_SEND]] : [[NS_RESPONDER, NS_SEND], [NS_INITIATOR, NS_SEND]];
      sodium.crypto_generichash_batch(encrypt, inputs[0], handshakeHash);
      sodium.crypto_generichash_batch(decrypt, inputs[1], handshakeHash);
      sodium.randombytes_buf(initial);
      counter.set(initial);
    }
    _open(cb) {
      if (this._rawStream === null || this._handshake === null && this._encrypt === null) {
        this._startDone = cb;
        return;
      }
      this._rawStream.on("data", this._onrawdata.bind(this));
      this._rawStream.on("end", this._onrawend.bind(this));
      this._rawStream.on("drain", this._onrawdrain.bind(this));
      if (this.enableSend)
        this._rawStream.on("message", this._onmessage.bind(this));
      if (this._encrypt !== null) {
        this._resolveOpened(true);
        return cb(null);
      }
      this._handshakeDone = cb;
      if (this.isInitiator)
        this._onhandshakert(this._handshake.send());
    }
    _predestroy() {
      if (this.rawStream) {
        const error = getStreamError(this);
        this.rawStream.destroy(error);
      }
      if (this._startDone !== null) {
        const done = this._startDone;
        this._startDone = null;
        done(new Error("Stream destroyed"));
      }
      if (this._handshakeDone !== null) {
        const done = this._handshakeDone;
        this._handshakeDone = null;
        done(new Error("Stream destroyed"));
      }
      if (this._drainDone !== null) {
        const done = this._drainDone;
        this._drainDone = null;
        done(new Error("Stream destroyed"));
      }
    }
    _write(data, cb) {
      let wrapped = this._outgoingWrapped;
      if (data !== this._outgoingPlain) {
        wrapped = b4a.allocUnsafe(data.byteLength + 3 + ABYTES);
        wrapped.set(data, 4);
      } else {
        this._outgoingWrapped = this._outgoingPlain = null;
      }
      if (wrapped.byteLength - 3 > MAX_ATOMIC_WRITE) {
        return cb(new Error("Message is too large for an atomic write. Max size is " + MAX_ATOMIC_WRITE + " bytes."));
      }
      this.rawBytesWritten += wrapped.byteLength;
      writeUint24le(wrapped.byteLength - 3, wrapped);
      this._encrypt.next(wrapped.subarray(4, 4 + data.byteLength), wrapped.subarray(3));
      if (this._keepAliveTimer !== null)
        this._keepAliveTimer.refresh();
      if (this._rawStream.write(wrapped) === false) {
        this._drainDone = cb;
      } else {
        cb(null);
      }
    }
    _final(cb) {
      this._clearKeepAlive();
      this._ended--;
      this._rawStream.end();
      cb(null);
    }
    _resolveOpened(val) {
      if (this._openedDone === null)
        return;
      const opened = this._openedDone;
      this._openedDone = null;
      opened(val);
      if (!val)
        return;
      this.connected = true;
      this.emit("connect");
    }
    _clearTimeout() {
      if (this._timeoutTimer === null)
        return;
      this._timeoutTimer.destroy();
      this._timeoutTimer = null;
      this.timeout = 0;
    }
    _clearKeepAlive() {
      if (this._keepAliveTimer === null)
        return;
      this._keepAliveTimer.destroy();
      this._keepAliveTimer = null;
      this.keepAlive = 0;
    }
    _destroy(cb) {
      this._clearKeepAlive();
      this._clearTimeout();
      this._resolveOpened(false);
      cb(null);
    }
    _boxMessage(buffer) {
      const MB = sodium.crypto_secretbox_MACBYTES;
      const NB = sodium.crypto_secretbox_NONCEBYTES;
      const counter = this._sendState.subarray(64, 72);
      sodium.sodium_increment(counter);
      if (b4a.equals(counter, this._sendState.subarray(72))) {
        this.destroy(new Error("udp send nonce exchausted"));
        return;
      }
      const secret = this._sendState.subarray(0, 32);
      const envelope = b4a.allocUnsafe(8 + MB + buffer.byteLength);
      const nonce = envelope.subarray(0, NB);
      const ciphertext = envelope.subarray(8);
      b4a.fill(nonce, 0);
      nonce.set(counter);
      sodium.crypto_secretbox_easy(ciphertext, buffer, nonce, secret);
      return envelope;
    }
    send(buffer) {
      if (!this._sendState)
        return;
      if (!this.rawStream?.send)
        return;
      const message = this._boxMessage(buffer);
      return this.rawStream.send(message);
    }
    trySend(buffer) {
      if (!this._sendState)
        return;
      if (!this.rawStream?.trySend)
        return;
      const message = this._boxMessage(buffer);
      this.rawStream.trySend(message);
    }
    _onmessage(buffer) {
      if (!this._sendState)
        return;
      const MB = sodium.crypto_secretbox_MACBYTES;
      const NB = sodium.crypto_secretbox_NONCEBYTES;
      if (buffer.byteLength < NB)
        return;
      const nonce = b4a.allocUnsafe(NB);
      b4a.fill(nonce, 0);
      nonce.set(buffer.subarray(0, 8));
      const secret = this._sendState.subarray(32, 64);
      const ciphertext = buffer.subarray(8);
      const plain = buffer.subarray(8, buffer.byteLength - MB);
      if (ciphertext.byteLength < MB)
        return;
      const success = sodium.crypto_secretbox_open_easy(plain, ciphertext, nonce, secret);
      if (success)
        this.emit("message", plain);
    }
    alloc(len) {
      const buf = b4a.allocUnsafe(len + 3 + ABYTES);
      this._outgoingWrapped = buf;
      this._outgoingPlain = buf.subarray(4, buf.byteLength - ABYTES + 1);
      return this._outgoingPlain;
    }
    toJSON() {
      return {
        isInitiator: this.isInitiator,
        publicKey: this.publicKey && b4a.toString(this.publicKey, "hex"),
        remotePublicKey: this.remotePublicKey && b4a.toString(this.remotePublicKey, "hex"),
        connected: this.connected,
        destroying: this.destroying,
        destroyed: this.destroyed,
        rawStream: this.rawStream && this.rawStream.toJSON ? this.rawStream.toJSON() : null
      };
    }
  };
  function writeUint24le(n, buf) {
    buf[0] = n & 255;
    buf[1] = n >>> 8 & 255;
    buf[2] = n >>> 16 & 255;
  }
  function streamId(handshakeHash, isInitiator, out = b4a.allocUnsafe(32)) {
    sodium.crypto_generichash(out, isInitiator ? NS_INITIATOR : NS_RESPONDER, handshakeHash);
    return out;
  }
  function toBuffer(data) {
    return typeof data === "string" ? b4a.from(data) : data;
  }
  function destroyTimeout() {
    this.destroy(new Error("Stream timed out"));
  }
  function sendKeepAlive() {
    const empty = this.alloc(0);
    this.write(empty);
  }
});

// node_modules/hypercore/lib/mutex.js
var require_mutex = __commonJS((exports, module) => {
  module.exports = class Mutex {
    constructor() {
      this.locked = false;
      this.destroyed = false;
      this._destroying = null;
      this._destroyError = null;
      this._queue = [];
      this._enqueue = (resolve, reject) => this._queue.push([resolve, reject]);
    }
    idle() {
      return this._queue.length === 0 && this.locked === false;
    }
    lock() {
      if (this.destroyed)
        return Promise.reject(this._destroyError || new Error("Mutex has been destroyed"));
      if (this.locked)
        return new Promise(this._enqueue);
      this.locked = true;
      return Promise.resolve();
    }
    unlock() {
      if (!this._queue.length) {
        this.locked = false;
        return;
      }
      this._queue.shift()[0]();
    }
    destroy(err) {
      if (!this._destroying)
        this._destroying = this.locked ? this.lock().catch(() => {}) : Promise.resolve();
      this.destroyed = true;
      if (err)
        this._destroyError = err;
      if (err) {
        while (this._queue.length)
          this._queue.shift()[1](err);
      }
      return this._destroying;
    }
  };
});

// node_modules/hypercore/lib/caps.js
var require_caps = __commonJS((exports) => {
  var crypto = require_hypercore_crypto();
  var sodium = require_sodium_native();
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var [
    TREE,
    REPLICATE_INITIATOR,
    REPLICATE_RESPONDER,
    MANIFEST,
    DEFAULT_NAMESPACE,
    DEFAULT_ENCRYPTION
  ] = crypto.namespace("hypercore", 6);
  exports.MANIFEST = MANIFEST;
  exports.DEFAULT_NAMESPACE = DEFAULT_NAMESPACE;
  exports.DEFAULT_ENCRYPTION = DEFAULT_ENCRYPTION;
  exports.replicate = function(isInitiator, key, handshakeHash) {
    const out = b4a.allocUnsafe(32);
    sodium.crypto_generichash_batch(out, [isInitiator ? REPLICATE_INITIATOR : REPLICATE_RESPONDER, key], handshakeHash);
    return out;
  };
  exports.treeSignable = function(manifestHash, treeHash, length, fork) {
    const state = { start: 0, end: 112, buffer: b4a.allocUnsafe(112) };
    c.fixed32.encode(state, TREE);
    c.fixed32.encode(state, manifestHash);
    c.fixed32.encode(state, treeHash);
    c.uint64.encode(state, length);
    c.uint64.encode(state, fork);
    return state.buffer;
  };
  exports.treeSignableCompat = function(hash, length, fork, noHeader) {
    const end = noHeader ? 48 : 80;
    const state = { start: 0, end, buffer: b4a.allocUnsafe(end) };
    if (!noHeader)
      c.fixed32.encode(state, TREE);
    c.fixed32.encode(state, hash);
    c.uint64.encode(state, length);
    c.uint64.encode(state, fork);
    return state.buffer;
  };
});

// node_modules/hypercore-errors/index.js
var require_hypercore_errors = __commonJS((exports, module) => {
  module.exports = class HypercoreError extends Error {
    constructor(msg, code, fn = HypercoreError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "HypercoreError";
    }
    static ASSERTION(msg) {
      return new HypercoreError(msg, "ERR_ASSERTION", HypercoreError.ASSERT);
    }
    static BAD_ARGUMENT(msg) {
      return new HypercoreError(msg, "BAD_ARGUMENT", HypercoreError.BAD_ARGUMENT);
    }
    static STORAGE_EMPTY(msg) {
      return new HypercoreError(msg, "STORAGE_EMPTY", HypercoreError.STORAGE_EMPTY);
    }
    static STORAGE_CONFLICT(msg) {
      return new HypercoreError(msg, "STORAGE_CONFLICT", HypercoreError.STORAGE_CONFLICT);
    }
    static INVALID_SIGNATURE(msg) {
      return new HypercoreError(msg, "INVALID_SIGNATURE", HypercoreError.INVALID_SIGNATURE);
    }
    static INVALID_CAPABILITY(msg) {
      return new HypercoreError(msg, "INVALID_CAPABILITY", HypercoreError.INVALID_CAPABILITY);
    }
    static INVALID_CHECKSUM(msg = "Invalid checksum") {
      return new HypercoreError(msg, "INVALID_CHECKSUM", HypercoreError.INVALID_CHECKSUM);
    }
    static INVALID_OPERATION(msg) {
      return new HypercoreError(msg, "INVALID_OPERATION", HypercoreError.INVALID_OPERATION);
    }
    static INVALID_PROOF(msg = "Proof not verifiable") {
      return new HypercoreError(msg, "INVALID_PROOF", HypercoreError.INVALID_PROOF);
    }
    static BLOCK_NOT_AVAILABLE(msg = "Block is not available") {
      return new HypercoreError(msg, "BLOCK_NOT_AVAILABLE", HypercoreError.BLOCK_NOT_AVAILABLE);
    }
    static SNAPSHOT_NOT_AVAILABLE(msg = "Snapshot is not available") {
      return new HypercoreError(msg, "SNAPSHOT_NOT_AVAILABLE", HypercoreError.SNAPSHOT_NOT_AVAILABLE);
    }
    static REQUEST_CANCELLED(msg = "Request was cancelled") {
      return new HypercoreError(msg, "REQUEST_CANCELLED", HypercoreError.REQUEST_CANCELLED);
    }
    static REQUEST_TIMEOUT(msg = "Request timed out") {
      return new HypercoreError(msg, "REQUEST_TIMEOUT", HypercoreError.REQUEST_TIMEOUT);
    }
    static SESSION_NOT_WRITABLE(msg = "Session is not writable") {
      return new HypercoreError(msg, "SESSION_NOT_WRITABLE", HypercoreError.SESSION_NOT_WRITABLE);
    }
    static SESSION_CLOSED(msg = "Session is closed") {
      return new HypercoreError(msg, "SESSION_CLOSED", HypercoreError.SESSION_CLOSED);
    }
    static BATCH_UNFLUSHED(msg = "Batch not yet flushed") {
      return new HypercoreError(msg, "BATCH_UNFLUSHED", HypercoreError.BATCH_UNFLUSHED);
    }
    static BATCH_ALREADY_EXISTS(msg = "Batch already exists") {
      return new HypercoreError(msg, "BATCH_ALREADY_EXISTS", HypercoreError.BATCH_ALREADY_EXISTS);
    }
    static BATCH_ALREADY_FLUSHED(msg = "Batch has already been flushed") {
      return new HypercoreError(msg, "BATCH_ALREADY_FLUSHED", HypercoreError.BATCH_ALREADY_FLUSHED);
    }
    static OPLOG_CORRUPT(msg = "Oplog file appears corrupt or out of date") {
      return new HypercoreError(msg, "OPLOG_CORRUPT", HypercoreError.OPLOG_CORRUPT);
    }
    static OPLOG_HEADER_OVERFLOW(msg = "Oplog header exceeds page size") {
      return new HypercoreError(msg, "OPLOG_HEADER_OVERFLOW", HypercoreError.OPLOG_HEADER_OVERFLOW);
    }
    static INVALID_OPLOG_VERSION(msg = "Invalid header version") {
      return new HypercoreError(msg, "INVALID_OPLOG_VERSION", HypercoreError.INVALID_OPLOG_VERSION);
    }
    static WRITE_FAILED(msg = "Write to storage failed") {
      return new HypercoreError(msg, "WRITE_FAILED", HypercoreError.WRITE_FAILED);
    }
    static DECODING_ERROR(msg = "Decoding error") {
      return new HypercoreError(msg, "DECODING_ERROR", HypercoreError.DECODING_ERROR);
    }
    static SESSION_MOVED(msg = "Session moved") {
      return new HypercoreError(msg, "SESSION_MOVED", HypercoreError.SESSION_MOVED);
    }
  };
});

// node_modules/hypercore/lib/merkle-tree.js
var require_merkle_tree = __commonJS((exports, module) => {
  var flat = require_flat_tree();
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var unslab = require_unslab();
  var caps = require_caps();
  var { INVALID_PROOF, INVALID_CHECKSUM, INVALID_OPERATION, BAD_ARGUMENT, ASSERTION } = require_hypercore_errors();

  class NodeQueue {
    constructor(nodes, extra = null) {
      this.i = 0;
      this.nodes = nodes;
      this.extra = extra;
      this.length = nodes.length + (this.extra === null ? 0 : 1);
    }
    shift(index) {
      if (this.extra !== null && this.extra.index === index) {
        const node2 = this.extra;
        this.extra = null;
        this.length--;
        return node2;
      }
      if (this.i >= this.nodes.length) {
        throw INVALID_OPERATION("Expected node " + index + ", got (nil)");
      }
      const node = this.nodes[this.i++];
      if (node.index !== index) {
        throw INVALID_OPERATION("Expected node " + index + ", got node " + node.index);
      }
      this.length--;
      return node;
    }
  }

  class MerkleTreeBatch {
    constructor(session) {
      this.fork = session.fork;
      this.roots = [...session.roots];
      this.length = session.length;
      this.signature = session.signature;
      this.ancestors = session.length;
      this.byteLength = session.byteLength;
      this.prologue = session.prologue;
      this.hashCached = null;
      this.committed = false;
      this.truncated = false;
      this.treeLength = session.length;
      this.treeFork = session.fork;
      this.storage = session.storage;
      this.session = session;
      this.nodes = [];
      this.upgraded = false;
    }
    checkout(length, additionalRoots) {
      const roots = [];
      let r = 0;
      const head = 2 * length - 2;
      const gaps = new Set;
      const all = new Map;
      if (additionalRoots) {
        for (const node of additionalRoots)
          all.set(node.index, node);
      }
      for (const node of this.nodes)
        all.set(node.index, node);
      for (const index of flat.fullRoots(head + 2)) {
        const left = flat.leftSpan(index);
        if (left !== 0)
          gaps.add(left - 1);
        if (r < this.roots.length && this.roots[r].index === index) {
          roots.push(this.roots[r++]);
          continue;
        }
        const node = all.get(index);
        if (!node)
          throw new BAD_ARGUMENT("root missing for given length");
        roots.push(node);
      }
      this.roots = roots;
      this.length = length;
      this.byteLength = totalSize(roots);
      this.hashCached = null;
      this.signature = null;
      for (let i = 0;i < this.nodes.length; i++) {
        const index = this.nodes[i].index;
        if (index <= head && !gaps.has(index))
          continue;
        const last = this.nodes.pop();
        if (i < this.nodes.length)
          this.nodes[i--] = last;
      }
    }
    prune(length) {
      if (length === 0)
        return;
      const head = 2 * length - 2;
      const gaps = new Set;
      for (const index of flat.fullRoots(head + 2)) {
        const left = flat.leftSpan(index);
        if (left !== 0)
          gaps.add(left - 1);
      }
      for (let i = 0;i < this.nodes.length; i++) {
        const index = this.nodes[i].index;
        if (index > head || gaps.has(index))
          continue;
        const last = this.nodes.pop();
        if (i < this.nodes.length)
          this.nodes[i--] = last;
      }
    }
    clone() {
      const b = new MerkleTreeBatch(this.session);
      b.fork = this.fork;
      b.roots = [...this.roots];
      b.length = this.length;
      b.byteLength = this.byteLength;
      b.signature = this.signature;
      b.treeLength = this.treeLength;
      b.treeFork = this.treeFork;
      b.tree = this.tree;
      b.nodes = [...this.nodes];
      b.upgraded = this.upgraded;
      return b;
    }
    hash() {
      if (this.hashCached === null)
        this.hashCached = unslab(crypto.tree(this.roots));
      return this.hashCached;
    }
    signable(manifestHash) {
      return caps.treeSignable(manifestHash, this.hash(), this.length, this.fork);
    }
    signableCompat(noHeader) {
      return caps.treeSignableCompat(this.hash(), this.length, this.fork, noHeader);
    }
    get(index) {
      if (index >= this.length * 2) {
        return null;
      }
      for (const n of this.nodes) {
        if (n.index === index)
          return n;
      }
      return getTreeNodeFromStorage(this.session.storage, index);
    }
    proof(batch, { block, hash, seek, upgrade }) {
      return generateProof(this.session, batch, block, hash, seek, upgrade);
    }
    verifyUpgrade(proof) {
      const unverified = verifyTree(proof, this.nodes);
      if (!proof.upgrade)
        throw INVALID_OPERATION("Expected upgrade proof");
      return verifyUpgrade(proof, unverified, this);
    }
    addNodesUnsafe(nodes) {
      for (let i = 0;i < nodes.length; i++) {
        this.nodes.push(nodes[i]);
      }
    }
    append(buf) {
      const head = this.length * 2;
      const ite = flat.iterator(head);
      const node = blockNode(head, buf);
      this.appendRoot(node, ite);
    }
    appendRoot(node, ite) {
      node = unslabNode(node);
      this.hashCached = null;
      this.upgraded = true;
      this.length += ite.factor / 2;
      this.byteLength += node.size;
      this.roots.push(node);
      this.nodes.push(node);
      while (this.roots.length > 1) {
        const a = this.roots[this.roots.length - 1];
        const b = this.roots[this.roots.length - 2];
        if (ite.sibling() !== b.index) {
          ite.sibling();
          break;
        }
        const node2 = unslabNode(parentNode(ite.parent(), a, b));
        this.nodes.push(node2);
        this.roots.pop();
        this.roots.pop();
        this.roots.push(node2);
      }
    }
    commitable() {
      return this.treeFork === this.session.fork && (this.upgraded ? this.treeLength === this.session.length : this.treeLength <= this.session.length);
    }
    commit(tx) {
      if (tx === undefined)
        throw INVALID_OPERATION("No database batch was passed");
      if (!this.commitable())
        throw INVALID_OPERATION("Tree was modified during batch, refusing to commit");
      if (this.upgraded)
        this._commitUpgrade(tx);
      for (let i = 0;i < this.nodes.length; i++) {
        const node = this.nodes[i];
        tx.putTreeNode(node);
      }
      this.committed = true;
      return this;
    }
    _commitUpgrade(tx) {
      if (this.ancestors < this.treeLength) {
        tx.deleteTreeNodeRange(this.ancestors * 2, this.treeLength * 2);
        if (this.ancestors > 0) {
          const head = this.ancestors * 2;
          const ite = flat.iterator(head - 2);
          while (true) {
            if (ite.contains(head) && ite.index < head) {
              tx.deleteTreeNode(ite.index);
            }
            if (ite.offset === 0)
              break;
            ite.parent();
          }
          this.truncated = true;
        }
      }
    }
    seek(bytes, padding) {
      return new ByteSeeker(this, this, bytes, padding);
    }
    byteRange(index) {
      const rx = this.storage.read();
      const range = getByteRange(this, index, rx);
      rx.tryFlush();
      return range;
    }
    byteOffset(index) {
      if (index === 2 * this.length)
        return this.byteLength;
      const rx = this.storage.read();
      const offset = getByteOffset(this, index, rx);
      rx.tryFlush();
      return offset;
    }
    async restore(length) {
      if (length === this.length)
        return this;
      const roots = unslabNodes(await MerkleTree.getRootsFromStorage(this.storage, length));
      this.roots = roots;
      this.length = length;
      this.byteLength = totalSize(roots);
      this.ancestors = length;
      for (const node of roots)
        this.byteLength += node.size;
      return this;
    }
  }

  class ReorgBatch extends MerkleTreeBatch {
    constructor(session) {
      super(session);
      this.roots = [];
      this.length = 0;
      this.byteLength = 0;
      this.diff = null;
      this.ancestors = 0;
      this.upgraded = true;
      this.want = {
        nodes: 0,
        start: 0,
        end: 0
      };
    }
    get finished() {
      return this.want === null;
    }
    update(proof) {
      if (this.want === null)
        return true;
      const nodes = [];
      const root = verifyTree(proof, nodes);
      if (root === null || !b4a.equals(root.hash, this.diff.hash))
        return false;
      this.nodes.push(...nodes);
      return this._update(nodes);
    }
    async _update(nodes) {
      const n = new Map;
      for (const node of nodes)
        n.set(node.index, node);
      let diff = null;
      const ite = flat.iterator(this.diff.index);
      const startingDiff = this.diff;
      while ((ite.index & 1) !== 0) {
        const left = n.get(ite.leftChild());
        if (!left)
          break;
        const existing = await getTreeNodeFromStorage(this.session.storage, left.index);
        if (!existing || !b4a.equals(existing.hash, left.hash)) {
          diff = left;
        } else {
          diff = n.get(ite.sibling());
        }
      }
      if ((this.diff.index & 1) === 0)
        return true;
      if (diff === null)
        return false;
      if (startingDiff !== this.diff)
        return false;
      return this._updateDiffRoot(diff);
    }
    _updateDiffRoot(diff) {
      if (this.want === null)
        return true;
      const spans = flat.spans(diff.index);
      const start = spans[0] / 2;
      const end = Math.min(this.treeLength, spans[1] / 2 + 1);
      const len = end - start;
      this.ancestors = start;
      this.diff = diff;
      if ((diff.index & 1) === 0 || this.want.start >= this.treeLength || len <= 0) {
        this.want = null;
        return true;
      }
      this.want.start = start;
      this.want.end = end;
      this.want.nodes = log2(spans[1] - spans[0] + 2) - 1;
      return false;
    }
  }

  class ByteSeeker {
    constructor(session, bytes, padding = 0) {
      this.session = session;
      this.bytes = bytes;
      this.padding = padding;
      const size = session.byteLength - session.length * padding;
      this.start = bytes >= size ? session.length : 0;
      this.end = bytes < size ? session.length : 0;
    }
    async _seek(bytes) {
      if (!bytes)
        return [0, 0];
      for (const node of this.session.roots) {
        const size = getUnpaddedSize(node, this.padding, null);
        if (bytes === size)
          return [flat.rightSpan(node.index) + 2, 0];
        if (bytes > size) {
          bytes -= size;
          continue;
        }
        const ite = flat.iterator(node.index);
        while ((ite.index & 1) !== 0) {
          const l = await getTreeNodeFromStorage(this.session.storage, ite.leftChild());
          if (l) {
            const size2 = getUnpaddedSize(l, this.padding, ite);
            if (size2 === bytes)
              return [ite.rightSpan() + 2, 0];
            if (size2 > bytes)
              continue;
            bytes -= size2;
            ite.sibling();
          } else {
            ite.parent();
            return [ite.index, bytes];
          }
        }
        return [ite.index, bytes];
      }
      return null;
    }
    async update() {
      const res = await this._seek(this.bytes);
      if (!res)
        return null;
      if ((res[0] & 1) === 0)
        return [res[0] / 2, res[1]];
      const span = flat.spans(res[0]);
      this.start = span[0] / 2;
      this.end = span[1] / 2 + 1;
      return null;
    }
  }

  class TreeProof {
    constructor(session, block, hash, seek, upgrade) {
      this.fork = session.fork;
      this.signature = session.signature;
      this.block = block;
      this.hash = hash;
      this.seek = seek;
      this.upgrade = upgrade;
      this.pending = {
        node: null,
        seek: null,
        upgrade: null,
        additionalUpgrade: null
      };
    }
    async settle() {
      const result = { fork: this.fork, block: null, hash: null, seek: null, upgrade: null, manifest: null };
      const [pNode, pSeek, pUpgrade, pAdditional] = await settleProof(this.pending);
      if (this.block) {
        if (pNode === null)
          throw INVALID_OPERATION("Invalid block request");
        result.block = {
          index: this.block.index,
          value: null,
          nodes: pNode
        };
      } else if (this.hash) {
        if (pNode === null)
          throw INVALID_OPERATION("Invalid block request");
        result.hash = {
          index: this.hash.index,
          nodes: pNode
        };
      }
      if (this.seek && pSeek !== null) {
        result.seek = {
          bytes: this.seek.bytes,
          nodes: pSeek
        };
      }
      if (this.upgrade) {
        result.upgrade = {
          start: this.upgrade.start,
          length: this.upgrade.length,
          nodes: pUpgrade,
          additionalNodes: pAdditional || [],
          signature: this.signature
        };
      }
      return result;
    }
  }

  class MerkleTree {
    static hash(s) {
      return unslab(crypto.tree(s.roots));
    }
    static signable(s, namespace) {
      return caps.treeSignable(namespace, MerkleTree.hash(s), s.length, s.fork);
    }
    static size(roots) {
      return totalSize(roots);
    }
    static span(roots) {
      return totalSpan(roots);
    }
    static getRoots(session, length) {
      return MerkleTree.getRootsFromStorage(session.storage, length);
    }
    static getRootsFromStorage(storage, length) {
      const indexes = flat.fullRoots(2 * length);
      const roots = new Array(indexes.length);
      const rx = storage.read();
      for (let i = 0;i < indexes.length; i++) {
        roots[i] = getTreeNodeOrError(rx, indexes[i]);
      }
      rx.tryFlush();
      return Promise.all(roots);
    }
    static async upgradeable(session, length) {
      const indexes = flat.fullRoots(2 * length);
      const roots = new Array(indexes.length);
      const rx = session.storage.read();
      for (let i = 0;i < indexes.length; i++) {
        roots[i] = rx.getTreeNode(indexes[i]);
      }
      rx.tryFlush();
      for (const node of await Promise.all(roots)) {
        if (node === null)
          return false;
      }
      return true;
    }
    static seek(session, bytes, padding) {
      return new ByteSeeker(session, bytes, padding);
    }
    static get(session, index) {
      return getTreeNodeFromStorage(session.storage, index);
    }
    static async truncate(session, length, batch, fork = batch.fork) {
      const head = length * 2;
      const fullRoots = flat.fullRoots(head);
      for (let i = 0;i < fullRoots.length; i++) {
        const root = fullRoots[i];
        if (i < batch.roots.length && batch.roots[i].index === root)
          continue;
        while (batch.roots.length > i)
          batch.roots.pop();
        batch.roots.push(unslabNode(await getTreeNodeFromStorageOrError(session.storage, root)));
      }
      while (batch.roots.length > fullRoots.length) {
        batch.roots.pop();
      }
      batch.fork = fork;
      batch.length = length;
      batch.ancestors = length;
      batch.byteLength = totalSize(batch.roots);
      batch.upgraded = true;
      return batch;
    }
    static async reorg(session, proof, batch) {
      let unverified = null;
      if (proof.block || proof.hash || proof.seek) {
        unverified = verifyTree(proof, batch.nodes);
      }
      if (!verifyUpgrade(proof, unverified, batch)) {
        throw INVALID_PROOF("Fork proof not verifiable");
      }
      for (const root of batch.roots) {
        const existing = await getTreeNodeFromStorage(session.storage, root.index);
        if (existing && b4a.equals(existing.hash, root.hash))
          continue;
        batch._updateDiffRoot(root);
        break;
      }
      if (batch.diff !== null) {
        await batch._update(batch.nodes);
      } else {
        batch.want = null;
        batch.ancestors = batch.length;
      }
      return batch;
    }
    static verifyFullyRemote(session, proof) {
      const batch = new MerkleTreeBatch(session);
      batch.fork = proof.fork;
      batch.roots = [];
      batch.length = 0;
      batch.ancestors = 0;
      batch.byteLength = 0;
      let unverified = verifyTree(proof, batch.nodes);
      if (proof.upgrade) {
        if (verifyUpgrade(proof, unverified, batch)) {
          unverified = null;
        }
      }
      return batch;
    }
    static async verify(session, proof) {
      const batch = new MerkleTreeBatch(session);
      let unverified = verifyTree(proof, batch.nodes);
      if (proof.upgrade) {
        if (verifyUpgrade(proof, unverified, batch)) {
          unverified = null;
        }
      }
      if (unverified) {
        const verified = await getTreeNodeFromStorageOrError(session.storage, unverified.index);
        if (!b4a.equals(verified.hash, unverified.hash)) {
          throw INVALID_CHECKSUM("Invalid checksum at node " + unverified.index);
        }
      }
      return batch;
    }
    static proof(session, rx, { block, hash, seek, upgrade }) {
      return generateProof(session, rx, block, hash, seek, upgrade);
    }
    static async missingNodes(session, index, length) {
      const head = 2 * length;
      const ite = flat.iterator(index);
      const iteRightSpan = ite.index + ite.factor / 2 - 1;
      if (iteRightSpan >= head)
        return 0;
      let cnt = 0;
      while (!ite.contains(head) && !await hasTreeNode(session.storage, ite.index)) {
        cnt++;
        ite.parent();
      }
      return cnt;
    }
    static byteOffset(session, index) {
      return getByteOffsetSession(session, index, null);
    }
    static byteRange(session, index) {
      const rx = session.storage.read();
      const offset = getByteOffsetSession(session, index, rx);
      const size = getNodeSize(index, rx);
      rx.tryFlush();
      return Promise.all([offset, size]);
    }
  }
  module.exports = {
    MerkleTreeBatch,
    ReorgBatch,
    MerkleTree
  };
  async function getNodeSize(index, rx) {
    return (await getTreeNodeOrError(rx, index)).size;
  }
  async function getByteOffsetSession(session, index, rx) {
    if (index === 2 * session.length)
      return session.byteLength;
    const treeNodes = rx === null ? await getByteOffsetBatchFlush(session.roots, index, session.storage.read()) : await getByteOffsetBatch(session.roots, index, rx);
    let offset = 0;
    for (const node of treeNodes)
      offset += node.size;
    return offset;
  }
  async function getByteOffset(tree, index, rx) {
    if (index === 2 * tree.length)
      return tree.byteLength;
    const treeNodes = await getByteOffsetBatch(tree.roots, index, rx);
    let offset = 0;
    for (const node of treeNodes)
      offset += node.size;
    return offset;
  }
  function getByteOffsetBatchFlush(roots, index, rx) {
    const treeNodes = getByteOffsetBatch(roots, index, rx);
    rx.tryFlush();
    return treeNodes;
  }
  function getByteOffsetBatch(roots, index, rx) {
    if ((index & 1) === 1)
      index = flat.leftSpan(index);
    let head = 0;
    const promises = [];
    for (const node of roots) {
      head += 2 * (node.index - head + 1);
      if (index >= head) {
        promises.push(node.size);
        continue;
      }
      const ite = flat.iterator(node.index);
      while (ite.index !== index) {
        if (index < ite.index) {
          ite.leftChild();
        } else {
          promises.push(getTreeNodeOrError(rx, ite.leftChild()));
          ite.sibling();
        }
      }
      return Promise.all(promises);
    }
    throw ASSERTION("Failed to find offset");
  }
  function getByteRange(tree, index, rx) {
    const head = 2 * tree.length;
    if (((index & 1) === 0 ? index : flat.rightSpan(index)) >= head) {
      throw BAD_ARGUMENT("Index is out of bounds");
    }
    const offset = getByteOffset(tree, index, rx);
    const size = getNodeSize(index, rx);
    return Promise.all([offset, size]);
  }
  function verifyTree({ block, hash, seek }, nodes) {
    const untrustedNode = block ? { index: 2 * block.index, value: block.value, nodes: block.nodes } : hash ? { index: hash.index, value: null, nodes: hash.nodes } : null;
    if (untrustedNode === null && (!seek || !seek.nodes.length))
      return null;
    let root = null;
    if (seek && seek.nodes.length) {
      const ite2 = flat.iterator(seek.nodes[0].index);
      const q2 = new NodeQueue(seek.nodes);
      root = q2.shift(ite2.index);
      nodes.push(root);
      while (q2.length > 0) {
        const node = q2.shift(ite2.sibling());
        root = parentNode(ite2.parent(), root, node);
        nodes.push(node);
        nodes.push(root);
      }
    }
    if (untrustedNode === null)
      return root;
    const ite = flat.iterator(untrustedNode.index);
    const blockHash = untrustedNode.value && blockNode(ite.index, untrustedNode.value);
    const q = new NodeQueue(untrustedNode.nodes, root);
    root = blockHash || q.shift(ite.index);
    nodes.push(root);
    while (q.length > 0) {
      const node = q.shift(ite.sibling());
      root = parentNode(ite.parent(), root, node);
      nodes.push(node);
      nodes.push(root);
    }
    return root;
  }
  function verifyUpgrade({ fork, upgrade }, blockRoot, batch) {
    const prologue = batch.prologue;
    if (prologue) {
      const { start, length } = upgrade;
      if (start < prologue.length && (start !== 0 || length < prologue.length)) {
        throw INVALID_PROOF("Upgrade does not satisfy prologue");
      }
    }
    const q = new NodeQueue(upgrade.nodes, blockRoot);
    let grow = batch.roots.length > 0;
    let i = 0;
    const to = 2 * (upgrade.start + upgrade.length);
    const ite = flat.iterator(0);
    for (;ite.fullRoot(to); ite.nextTree()) {
      if (i < batch.roots.length && batch.roots[i].index === ite.index) {
        i++;
        continue;
      }
      if (grow) {
        grow = false;
        const root = ite.index;
        if (i < batch.roots.length) {
          ite.seek(batch.roots[batch.roots.length - 1].index);
          while (ite.index !== root) {
            batch.appendRoot(q.shift(ite.sibling()), ite);
          }
          continue;
        }
      }
      batch.appendRoot(q.shift(ite.index), ite);
    }
    if (prologue && batch.length === prologue.length) {
      if (!b4a.equals(prologue.hash, batch.hash())) {
        throw INVALID_PROOF("Invalid hash");
      }
    }
    const extra = upgrade.additionalNodes;
    ite.seek(batch.roots[batch.roots.length - 1].index);
    i = 0;
    while (i < extra.length && extra[i].index === ite.sibling()) {
      batch.appendRoot(extra[i++], ite);
    }
    while (i < extra.length) {
      const node = extra[i++];
      while (node.index !== ite.index) {
        if (ite.factor === 2)
          throw INVALID_OPERATION("Unexpected node: " + node.index);
        ite.leftChild();
      }
      batch.appendRoot(node, ite);
      ite.sibling();
    }
    batch.signature = unslab(upgrade.signature);
    batch.fork = fork;
    return q.extra === null;
  }
  async function seekFromHead(session, head, bytes, padding) {
    const roots = flat.fullRoots(head);
    for (let i = 0;i < roots.length; i++) {
      const root = roots[i];
      const node = await getTreeNodeFromStorage(session.storage, root);
      const size = getUnpaddedSize(node, padding, null);
      if (bytes === size)
        return root;
      if (bytes > size) {
        bytes -= size;
        continue;
      }
      return seekTrustedTree(session, root, bytes, padding);
    }
    return head;
  }
  async function seekTrustedTree(session, root, bytes, padding) {
    if (!bytes)
      return root;
    const ite = flat.iterator(root);
    while ((ite.index & 1) !== 0) {
      const l = await getTreeNodeFromStorage(session.storage, ite.leftChild());
      if (l) {
        const size = getUnpaddedSize(l, padding, ite);
        if (size === bytes)
          return ite.index;
        if (size > bytes)
          continue;
        bytes -= size;
        ite.sibling();
      } else {
        ite.parent();
        return ite.index;
      }
    }
    return ite.index;
  }
  async function seekUntrustedTree(session, root, bytes, padding) {
    const offset = await getByteOffsetSession(session, root, null) - (padding ? padding * flat.leftSpan(root) / 2 : 0);
    if (offset > bytes)
      throw INVALID_OPERATION("Invalid seek");
    if (offset === bytes)
      return root;
    bytes -= offset;
    const node = await getTreeNodeFromStorageOrError(session.storage, root);
    if (getUnpaddedSize(node, padding, null) <= bytes)
      throw INVALID_OPERATION("Invalid seek");
    return seekTrustedTree(session, root, bytes, padding);
  }
  function seekProof(session, rx, seekRoot, root, p) {
    const ite = flat.iterator(seekRoot);
    p.seek = [];
    p.seek.push(getTreeNodeOrError(rx, ite.index));
    while (ite.index !== root) {
      ite.sibling();
      p.seek.push(getTreeNodeOrError(rx, ite.index));
      ite.parent();
    }
  }
  function blockAndSeekProof(session, rx, node, seek, seekRoot, root, p) {
    if (!node)
      return seekProof(session, rx, seekRoot, root, p);
    const ite = flat.iterator(node.index);
    p.node = [];
    if (!node.value)
      p.node.push(getTreeNodeOrError(rx, ite.index));
    while (ite.index !== root) {
      ite.sibling();
      if (seek && ite.contains(seekRoot) && ite.index !== seekRoot) {
        seekProof(session, rx, seekRoot, ite.index, p);
      } else {
        p.node.push(getTreeNodeOrError(rx, ite.index));
      }
      ite.parent();
    }
  }
  function upgradeProof(session, rx, node, seek, from, to, subTree, p) {
    if (from === 0)
      p.upgrade = [];
    for (const ite = flat.iterator(0);ite.fullRoot(to); ite.nextTree()) {
      if (ite.index + ite.factor / 2 < from)
        continue;
      if (p.upgrade === null && ite.contains(from - 2)) {
        p.upgrade = [];
        const root = ite.index;
        const target = from - 2;
        ite.seek(target);
        while (ite.index !== root) {
          ite.sibling();
          if (ite.index > target) {
            if (p.node === null && p.seek === null && ite.contains(subTree)) {
              blockAndSeekProof(session, rx, node, seek, subTree, ite.index, p);
            } else {
              p.upgrade.push(getTreeNodeOrError(rx, ite.index));
            }
          }
          ite.parent();
        }
        continue;
      }
      if (p.upgrade === null) {
        p.upgrade = [];
      }
      if (p.node === null && p.seek === null && ite.contains(subTree)) {
        blockAndSeekProof(session, rx, node, seek, subTree, ite.index, p);
        continue;
      }
      p.upgrade.push(getTreeNodeOrError(rx, ite.index));
    }
  }
  function additionalUpgradeProof(session, rx, from, to, p) {
    if (from === 0)
      p.additionalUpgrade = [];
    for (const ite = flat.iterator(0);ite.fullRoot(to); ite.nextTree()) {
      if (ite.index + ite.factor / 2 < from)
        continue;
      if (p.additionalUpgrade === null && ite.contains(from - 2)) {
        p.additionalUpgrade = [];
        const root = ite.index;
        const target = from - 2;
        ite.seek(target);
        while (ite.index !== root) {
          ite.sibling();
          if (ite.index > target) {
            p.additionalUpgrade.push(getTreeNodeOrError(rx, ite.index));
          }
          ite.parent();
        }
        continue;
      }
      if (p.additionalUpgrade === null) {
        p.additionalUpgrade = [];
      }
      p.additionalUpgrade.push(getTreeNodeOrError(rx, ite.index));
    }
  }
  function nodesToRoot(index, nodes, head) {
    const ite = flat.iterator(index);
    for (let i = 0;i < nodes; i++) {
      ite.parent();
      if (ite.contains(head))
        throw BAD_ARGUMENT("Nodes is out of bounds");
    }
    return ite.index;
  }
  function totalSize(nodes) {
    let s = 0;
    for (const node of nodes)
      s += node.size;
    return s;
  }
  function totalSpan(nodes) {
    let s = 0;
    for (const node of nodes)
      s += 2 * (node.index - s + 1);
    return s;
  }
  function blockNode(index, value) {
    return { index, size: value.byteLength, hash: crypto.data(value) };
  }
  function parentNode(index, a, b) {
    return { index, size: a.size + b.size, hash: crypto.parent(a, b) };
  }
  function log2(n) {
    let res = 1;
    while (n > 2) {
      n /= 2;
      res++;
    }
    return res;
  }
  function normalizeIndexed(block, hash) {
    if (block)
      return { value: true, index: block.index * 2, nodes: block.nodes, lastIndex: block.index };
    if (hash)
      return { value: false, index: hash.index, nodes: hash.nodes, lastIndex: flat.rightSpan(hash.index) / 2 };
    return null;
  }
  async function getTreeNodeOrError(rx, index) {
    const node = await rx.getTreeNode(index);
    if (node === null)
      throw INVALID_OPERATION("Expected tree node " + index + " from storage, got (nil)");
    return node;
  }
  function getTreeNodeFromStorageOrError(storage, index) {
    const rx = storage.read();
    const p = getTreeNodeOrError(rx, index);
    rx.tryFlush();
    return p;
  }
  function getTreeNodeFromStorage(storage, index) {
    const rx = storage.read();
    const node = rx.getTreeNode(index);
    rx.tryFlush();
    return node;
  }
  function hasTreeNode(storage, index) {
    const rx = storage.read();
    const has = rx.hasTreeNode(index);
    rx.tryFlush();
    return has;
  }
  async function settleProof(p) {
    const result = [
      p.node && Promise.all(p.node),
      p.seek && Promise.all(p.seek),
      p.upgrade && Promise.all(p.upgrade),
      p.additionalUpgrade && Promise.all(p.additionalUpgrade)
    ];
    try {
      return await Promise.all(result);
    } catch (err) {
      if (p.node)
        await Promise.allSettled(p.node);
      if (p.seek)
        await Promise.allSettled(p.seek);
      if (p.upgrade)
        await Promise.allSettled(p.upgrade);
      if (p.additionalUpgrade)
        await Promise.allSettled(p.additionalUpgrade);
      throw err;
    }
  }
  async function generateProof(session, rx, block, hash, seek, upgrade) {
    if (session.prologue && upgrade) {
      upgrade.start = upgrade.start < session.prologue.length ? 0 : upgrade.start;
      upgrade.length = upgrade.start < session.prologue.length ? session.prologue.length : upgrade.length;
    }
    const head = 2 * session.length;
    const from = upgrade ? upgrade.start * 2 : 0;
    const to = upgrade ? from + upgrade.length * 2 : head;
    const node = normalizeIndexed(block, hash);
    if (head === 0)
      return new TreeProof(session, null, null, null, null);
    if (from >= to || to > head) {
      throw INVALID_OPERATION("Invalid upgrade");
    }
    if (seek && upgrade && node !== null && node.index >= from) {
      throw INVALID_OPERATION("Cannot both do a seek and block/hash request when upgrading");
    }
    let subTree = head;
    const p = new TreeProof(session, block, hash, seek, upgrade);
    if (node !== null && (!upgrade || node.lastIndex < upgrade.start)) {
      subTree = nodesToRoot(node.index, node.nodes, to);
      const seekRoot = seek ? await seekUntrustedTree(session, subTree, seek.bytes, seek.padding) : head;
      blockAndSeekProof(session, rx, node, seek, seekRoot, subTree, p.pending);
    } else if ((node || seek) && upgrade) {
      subTree = seek ? await seekFromHead(session, to, seek.bytes, seek.padding) : node.index;
    }
    if (upgrade) {
      upgradeProof(session, rx, node, seek, from, to, subTree, p.pending);
      if (head > to)
        additionalUpgradeProof(session, rx, to, head, p.pending);
    }
    return p;
  }
  function getUnpaddedSize(node, padding, ite) {
    return padding === 0 ? node.size : node.size - padding * (ite ? ite.countLeaves() : flat.countLeaves(node.index));
  }
  function unslabNodes(nodes) {
    for (const node of nodes)
      unslabNode(node);
    return nodes;
  }
  function unslabNode(node) {
    if (node === null)
      return node;
    node.hash = unslab(node.hash);
    return node;
  }
});

// node_modules/simdle-native/binding.js
var require_binding4 = __commonJS((exports, module) => {
  var __filename = "/Users/odinsson/Dev/pear/easybase/node_modules/simdle-native/binding.js";
  __require.addon = require_require_addon();
  module.exports = __require.addon(".", __filename);
});

// node_modules/simdle-native/index.js
var require_simdle_native = __commonJS((exports) => {
  var binding = require_binding4();
  var b4a = require_b4a();
  function unary(u8, u16, u32) {
    return function unary(buf, result = b4a.allocUnsafe(buf.byteLength)) {
      if (buf.byteLength % 16 !== 0) {
        throw new Error("Buffer length must be a multiple of 16");
      }
      if (buf.byteLength !== result.byteLength) {
        throw new Error("Length of result buffer is insufficient");
      }
      const n = buf.BYTES_PER_ELEMENT;
      if (n === 1)
        u8(buf, result);
      else if (n === 2)
        u16(buf, result);
      else
        u32(buf, result);
      return result;
    };
  }
  function binary(u8, u16, u32) {
    return function binary(a, b, result = b4a.allocUnsafe(a.byteLength)) {
      if (a.byteLength % 16 !== 0) {
        throw new Error("Buffer length must be a multiple of 16");
      }
      if (a.byteLength !== b.byteLength || a.byteLength !== result.byteLength) {
        throw new Error("Buffers must be the same length");
      }
      const n = a.BYTES_PER_ELEMENT;
      if (n === 1)
        u8(a, b, result);
      else if (n === 2)
        u16(a, b, result);
      else
        u32(a, b, result);
      return result;
    };
  }
  function reduce(u8, u16, u32) {
    return function reduce(buf) {
      if (buf.byteLength % 16 !== 0) {
        throw new Error("Buffer length must be a multiple of 16");
      }
      const n = buf.BYTES_PER_ELEMENT;
      if (n === 1)
        return u8(buf);
      if (n === 2)
        return u16(buf);
      return u32(buf);
    };
  }
  exports.allo = function allo(buf) {
    if (buf.byteLength % 16 !== 0) {
      throw new Error("Buffer length must be a multiple of 16");
    }
    return binding.simdle_napi_allo_v128(buf) !== 0;
  };
  exports.allz = function allz(buf) {
    if (buf.byteLength % 16 !== 0) {
      throw new Error("Buffer length must be a multiple of 16");
    }
    return binding.simdle_napi_allz_v128(buf) !== 0;
  };
  exports.and = binary(binding.simdle_napi_and_v128_u8, binding.simdle_napi_and_v128_u16, binding.simdle_napi_and_v128_u32);
  exports.clear = binary(binding.simdle_napi_clear_v128_u8, binding.simdle_napi_clear_v128_u16, binding.simdle_napi_clear_v128_u32);
  exports.clo = unary(binding.simdle_napi_clo_v128_u8, binding.simdle_napi_clo_v128_u16, binding.simdle_napi_clo_v128_u32);
  exports.clz = unary(binding.simdle_napi_clz_v128_u8, binding.simdle_napi_clz_v128_u16, binding.simdle_napi_clz_v128_u32);
  exports.cnt = unary(binding.simdle_napi_cnt_v128_u8, binding.simdle_napi_cnt_v128_u16, binding.simdle_napi_cnt_v128_u32);
  exports.cto = unary(binding.simdle_napi_cto_v128_u8, binding.simdle_napi_cto_v128_u16, binding.simdle_napi_cto_v128_u32);
  exports.ctz = unary(binding.simdle_napi_ctz_v128_u8, binding.simdle_napi_ctz_v128_u16, binding.simdle_napi_ctz_v128_u32);
  exports.not = unary(binding.simdle_napi_not_v128_u8, binding.simdle_napi_not_v128_u16, binding.simdle_napi_not_v128_u32);
  exports.or = binary(binding.simdle_napi_or_v128_u8, binding.simdle_napi_or_v128_u16, binding.simdle_napi_or_v128_u32);
  exports.sum = reduce(binding.simdle_napi_sum_v128_u8, binding.simdle_napi_sum_v128_u16, binding.simdle_napi_sum_v128_u32);
  exports.xor = binary(binding.simdle_napi_xor_v128_u8, binding.simdle_napi_xor_v128_u16, binding.simdle_napi_xor_v128_u32);
});

// node_modules/simdle-universal/scalar.js
var require_scalar = __commonJS((exports) => {
  var clz = exports.clz = function clz(n) {
    return Math.clz32(n);
  };
  exports.clo = function clo(n) {
    return clz(~n);
  };
  var ctz = exports.ctz = function ctz(n) {
    return 32 - (n === 0 ? 0 : clz(n & -n) + 1);
  };
  exports.cto = function cto(n) {
    return ctz(~n);
  };
  exports.cnt = function cnt(n) {
    n = n - (n >>> 1 & 1431655765);
    n = (n & 858993459) + (n >>> 2 & 858993459);
    n = n + (n >>> 4) & 252645135;
    n = n * 16843009 >>> 24;
    return n;
  };
});

// node_modules/simdle-universal/fallback.js
var require_fallback = __commonJS((exports) => {
  var b4a = require_b4a();
  var scalar = require_scalar();
  function view(buf, n) {
    if (n === buf.BYTES_PER_ELEMENT)
      return buf;
    let TypedArray;
    if (n === 1)
      TypedArray = Uint8Array;
    else if (n === 2)
      TypedArray = Uint16Array;
    else
      TypedArray = Uint32Array;
    return new TypedArray(buf.buffer, buf.byteOffset, buf.byteLength / n);
  }
  function unary(u8, u16 = u8, u32 = u16) {
    return function unary(buf, result = b4a.allocUnsafe(buf.byteLength)) {
      if (buf.byteLength % 16 !== 0) {
        throw new Error("Buffer length must be a multiple of 16");
      }
      if (buf.byteLength !== result.byteLength) {
        throw new Error("Length of result buffer is insufficient");
      }
      const n = buf.BYTES_PER_ELEMENT;
      if (n === 1)
        u8(buf, view(result, n));
      else if (n === 2)
        u16(buf, view(result, n));
      else
        u32(buf, view(result, n));
      return result;
    };
  }
  function binary(u8, u16 = u8, u32 = u16) {
    return function binary(a, b, result = b4a.allocUnsafe(a.byteLength)) {
      if (a.byteLength % 16 !== 0) {
        throw new Error("Buffer length must be a multiple of 16");
      }
      if (a.byteLength !== b.byteLength || a.byteLength !== result.byteLength) {
        throw new Error("Buffers must be the same length");
      }
      const n = a.BYTES_PER_ELEMENT;
      if (n === 1)
        u8(a, b, view(result, n));
      else if (n === 2)
        u16(a, b, view(result, n));
      else
        u32(a, b, view(result, n));
      return result;
    };
  }
  function reduce(u8, u16 = u8, u32 = u16) {
    return function reduce(buf) {
      if (buf.byteLength % 16 !== 0) {
        throw new Error("Buffer length must be a multiple of 16");
      }
      const n = buf.BYTES_PER_ELEMENT;
      if (n === 1)
        return u8(buf);
      if (n === 2)
        return u16(buf);
      return u32(buf);
    };
  }
  exports.allo = function allo(buf) {
    if (buf.byteLength % 16 !== 0) {
      throw new Error("Buffer length must be a multiple of 16");
    }
    const m = 2 ** (buf.BYTES_PER_ELEMENT * 8) - 1;
    for (let i = 0, n = buf.length;i < n; i++) {
      if (buf[i] !== m)
        return false;
    }
    return true;
  };
  exports.allz = function allz(buf) {
    if (buf.byteLength % 16 !== 0) {
      throw new Error("Buffer length must be a multiple of 16");
    }
    for (let i = 0, n = buf.length;i < n; i++) {
      if (buf[i] !== 0)
        return false;
    }
    return true;
  };
  exports.and = binary((a, b, result) => {
    for (let i = 0, n = result.length;i < n; i++) {
      result[i] = a[i] & b[i];
    }
  });
  exports.clear = binary((a, b, result) => {
    for (let i = 0, n = result.length;i < n; i++) {
      result[i] = a[i] & ~b[i];
    }
  });
  exports.clo = unary((buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = 24 - scalar.clo(buf[i]);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = 16 - scalar.clo(buf[i]);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.clo(buf[i]);
    }
  });
  exports.clz = unary((buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = 24 - scalar.clz(buf[i]);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = 16 - scalar.clz(buf[i]);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.clz(buf[i]);
    }
  });
  exports.cnt = unary((buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.cnt(buf[i]) & 255;
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.cnt(buf[i]) & 65535;
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.cnt(buf[i]);
    }
  });
  exports.cto = unary((buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = Math.min(scalar.cto(buf[i]), 8);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = Math.min(scalar.cto(buf[i]), 16);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.cto(buf[i]);
    }
  });
  exports.ctz = unary((buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = Math.min(scalar.ctz(buf[i]), 8);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = Math.min(scalar.ctz(buf[i]), 16);
    }
  }, (buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = scalar.ctz(buf[i]);
    }
  });
  exports.not = unary((buf, result) => {
    for (let i = 0, n = buf.length;i < n; i++) {
      result[i] = ~buf[i];
    }
  });
  exports.or = binary((a, b, result) => {
    for (let i = 0, n = result.length;i < n; i++) {
      result[i] = a[i] | b[i];
    }
  });
  exports.sum = reduce((buf) => {
    let result = 0n;
    for (let i = 0, n = buf.length;i < n; i++) {
      result += BigInt(buf[i]);
    }
    return result;
  });
  exports.xor = binary((a, b, result) => {
    for (let i = 0, n = result.length;i < n; i++) {
      result[i] = a[i] ^ b[i];
    }
  });
});

// node_modules/simdle-universal/index.js
var require_simdle_universal = __commonJS((exports, module) => {
  try {
    module.exports = require_simdle_native();
  } catch {
    module.exports = require_fallback();
  }
});

// node_modules/quickbit-universal/fallback.js
var require_fallback2 = __commonJS((exports) => {
  var simdle = require_simdle_universal();
  var INDEX_LEN = (16 + 128 * 16) * 2;
  var get = exports.get = function get(field, bit) {
    const n = field.byteLength * 8;
    if (bit < 0)
      bit += n;
    if (bit < 0 || bit >= n)
      return false;
    const m = field.BYTES_PER_ELEMENT * 8;
    const offset = bit & m - 1;
    const i = (bit - offset) / m;
    return (field[i] & 1 << offset) !== 0;
  };
  var set = exports.set = function set(field, bit, value = true) {
    const n = field.byteLength * 8;
    if (bit < 0)
      bit += n;
    if (bit < 0 || bit >= n)
      return false;
    const m = field.BYTES_PER_ELEMENT * 8;
    const offset = bit & m - 1;
    const i = (bit - offset) / m;
    const mask = 1 << offset;
    if (value) {
      if ((field[i] & mask) !== 0)
        return false;
    } else {
      if ((field[i] & mask) === 0)
        return false;
    }
    field[i] ^= mask;
    return true;
  };
  exports.fill = function fill(field, value, start = 0, end = field.byteLength * 8) {
    const n = field.byteLength * 8;
    if (start < 0)
      start += n;
    if (end < 0)
      end += n;
    if (start < 0 || start >= field.byteLength * 8 || start >= end)
      return field;
    const m = field.BYTES_PER_ELEMENT * 8;
    let i, j;
    {
      const offset = start & m - 1;
      i = (start - offset) / m;
      if (offset !== 0) {
        let shift = m - offset;
        if (end - start < shift)
          shift = end - start;
        const mask = (1 << shift) - 1 << offset;
        if (value)
          field[i] |= mask;
        else
          field[i] &= ~mask;
        i++;
      }
    }
    {
      const offset = end & m - 1;
      j = (end - offset) / m;
      if (offset !== 0 && j >= i) {
        const mask = (1 << offset) - 1;
        if (value)
          field[j] |= mask;
        else
          field[j] &= ~mask;
      }
    }
    if (i < j)
      field.fill(value ? 2 ** m - 1 : 0, i, j);
    return field;
  };
  exports.clear = function clear(field, ...chunks) {
    const n = field.byteLength;
    for (const chunk of chunks) {
      if (chunk.offset >= n)
        continue;
      const m = chunk.field.byteLength;
      let i = chunk.offset;
      let j = 0;
      while (((i & 15) !== 0 || (j & 15) !== 0) && i < n && j < m) {
        field[i] = field[i] & ~chunk.field[j];
        i++;
        j++;
      }
      if (i + 15 < n && j + 15 < m) {
        const len = Math.min(n - (n & 15) - i, m - (m & 15) - j);
        simdle.clear(field.subarray(i, i + len), chunk.field.subarray(j, j + len), field.subarray(i, i + len));
      }
      while (i < n && j < m) {
        field[i] = field[i] & ~chunk.field[j];
        i++;
        j++;
      }
    }
  };
  function bitOffset(bit, offset) {
    return !bit ? offset : INDEX_LEN * 8 / 2 + offset;
  }
  function byteOffset(bit, offset) {
    return !bit ? offset : INDEX_LEN / 2 + offset;
  }
  exports.findFirst = function findFirst(field, value, position = 0) {
    const n = field.byteLength * 8;
    if (position < 0)
      position += n;
    if (position < 0)
      position = 0;
    if (position >= n)
      return -1;
    value = !!value;
    for (let i = position;i < n; i++) {
      if (get(field, i) === value)
        return i;
    }
    return -1;
  };
  exports.findLast = function findLast(field, value, position = field.byteLength * 8 - 1) {
    const n = field.byteLength * 8;
    if (position < 0)
      position += n;
    if (position < 0)
      return -1;
    if (position >= n)
      position = n - 1;
    value = !!value;
    for (let i = position;i >= 0; i--) {
      if (get(field, i) === value)
        return i;
    }
    return -1;
  };
  var Index = exports.Index = class Index2 {
    static from(fieldOrChunks, byteLength = -1) {
      if (Array.isArray(fieldOrChunks)) {
        return new SparseIndex(fieldOrChunks, byteLength);
      } else {
        return new DenseIndex(fieldOrChunks, byteLength);
      }
    }
    constructor(byteLength) {
      this._byteLength = byteLength;
      this.handle = new Uint32Array(INDEX_LEN / 4);
    }
    get byteLength() {
      return this._byteLength;
    }
    skipFirst(value, position = 0) {
      const n = this.byteLength * 8;
      if (position < 0)
        position += n;
      if (position < 0)
        position = 0;
      if (position >= n)
        return n - 1;
      let i = Math.floor(position / 16384);
      if (i > 127)
        return position;
      while (i <= 127 && get(this.handle, bitOffset(value, i))) {
        i++;
      }
      if (i === 128)
        return n - 1;
      let k = i * 16384;
      let j = 0;
      if (position > k)
        j = Math.floor((position - k) / 128);
      while (j <= 127 && get(this.handle, bitOffset(value, i * 128 + j + 128))) {
        j++;
        k += 128;
      }
      if (j === 128 && i !== 127)
        return this.skipFirst(value, (i + 1) * 16384);
      if (k > position)
        position = k;
      return position < n ? position : n - 1;
    }
    skipLast(value, position = this.byteLength * 8 - 1) {
      const n = this.byteLength * 8;
      if (position < 0)
        position += n;
      if (position < 0)
        return 0;
      if (position >= n)
        position = n - 1;
      let i = Math.floor(position / 16384);
      if (i > 127)
        return position;
      while (i >= 0 && get(this.handle, bitOffset(value, i))) {
        i--;
      }
      if (i === -1)
        return 0;
      let k = (i + 1) * 16384 - 1;
      let j = 127;
      if (position < k)
        j = 128 - Math.ceil((k - position) / 128);
      while (j >= 0 && get(this.handle, bitOffset(value, i * 128 + j + 128))) {
        j--;
        k -= 128;
      }
      if (j === -1 && i !== 0)
        return this.skipLast(value, i * 16384 - 1);
      if (k < position)
        position = k;
      return position;
    }
  };

  class DenseIndex extends Index {
    constructor(field, byteLength) {
      super(byteLength);
      this.field = field;
      const m = field.BYTES_PER_ELEMENT;
      for (let i = 0;i < 128; i++) {
        for (let j = 0;j < 128; j++) {
          const offset = (i * 128 + j) * 16;
          let allz = true;
          let allo = false;
          if (offset + 16 <= this.field.byteLength) {
            const vec = this.field.subarray(offset / m, (offset + 16) / m);
            allz = simdle.allz(vec);
            allo = simdle.allo(vec);
          }
          const k = i * 128 + 128 + j;
          set(this.handle, bitOffset(false, k), allz);
          set(this.handle, bitOffset(true, k), allo);
        }
        {
          const offset = byteOffset(false, i * 16 + 16) / 4;
          const allo = simdle.allo(this.handle.subarray(offset, offset + 4));
          set(this.handle, bitOffset(false, i), allo);
        }
        {
          const offset = byteOffset(true, i * 16 + 16) / 4;
          const allo = simdle.allo(this.handle.subarray(offset, offset + 4));
          set(this.handle, bitOffset(true, i), allo);
        }
      }
    }
    get byteLength() {
      if (this._byteLength !== -1)
        return this._byteLength;
      return this.field.byteLength;
    }
    update(bit) {
      const n = this.byteLength * 8;
      if (bit < 0)
        bit += n;
      if (bit < 0 || bit >= n)
        return false;
      const m = this.field.BYTES_PER_ELEMENT;
      const i = Math.floor(bit / 16384);
      const j = Math.floor(bit / 128);
      const offset = j * 16 / m;
      const vec = this.field.subarray(offset, offset + 16 / m);
      const allz = simdle.allz(vec);
      const allo = simdle.allo(vec);
      let changed = false;
      if (set(this.handle, bitOffset(false, 128 + j), allz)) {
        changed = true;
        const offset2 = byteOffset(false, i * 16 + 16) / 4;
        const allo2 = simdle.allo(this.handle.subarray(offset2, offset2 + 4));
        set(this.handle, bitOffset(false, i), allo2);
      }
      if (set(this.handle, bitOffset(true, 128 + j), allo)) {
        changed = true;
        const offset2 = byteOffset(true, i * 16 + 16) / 4;
        const allo2 = simdle.allo(this.handle.subarray(offset2, offset2 + 4));
        set(this.handle, bitOffset(true, i), allo2);
      }
      return changed;
    }
  }
  function selectChunk(chunks, offset) {
    for (let i = 0;i < chunks.length; i++) {
      const next = chunks[i];
      const start = next.offset;
      const end = next.offset + next.field.byteLength;
      if (offset >= start && offset + 16 <= end) {
        return next;
      }
    }
    return null;
  }

  class SparseIndex extends Index {
    constructor(chunks, byteLength) {
      super(byteLength);
      this.chunks = chunks;
      for (let i = 0;i < 128; i++) {
        for (let j = 0;j < 128; j++) {
          const offset = (i * 128 + j) * 16;
          let allz = true;
          let allo = false;
          const chunk = selectChunk(this.chunks, offset);
          if (chunk !== null) {
            const m = chunk.field.BYTES_PER_ELEMENT;
            const vec = chunk.field.subarray((offset - chunk.offset) / m, (offset - chunk.offset + 16) / m);
            allz = simdle.allz(vec);
            allo = simdle.allo(vec);
          }
          const k = i * 128 + 128 + j;
          set(this.handle, bitOffset(false, k), allz);
          set(this.handle, bitOffset(true, k), allo);
        }
        {
          const offset = byteOffset(false, i * 16 + 16) / 4;
          const allo = simdle.allo(this.handle.subarray(offset, offset + 4));
          set(this.handle, bitOffset(false, i), allo);
        }
        {
          const offset = byteOffset(true, i * 16 + 16) / 4;
          const allo = simdle.allo(this.handle.subarray(offset, offset + 4));
          set(this.handle, bitOffset(true, i), allo);
        }
      }
    }
    get byteLength() {
      if (this._byteLength !== -1)
        return this._byteLength;
      const last = this.chunks[this.chunks.length - 1];
      return last ? last.offset + last.field.byteLength : 0;
    }
    update(bit) {
      const n = this.byteLength * 8;
      if (bit < 0)
        bit += n;
      if (bit < 0 || bit >= n)
        return false;
      const i = Math.floor(bit / 16384);
      const j = Math.floor(bit / 128);
      const offset = j * 16;
      const chunk = selectChunk(this.chunks, offset);
      if (chunk === null)
        return false;
      const m = chunk.field.BYTES_PER_ELEMENT;
      const vec = chunk.field.subarray((offset - chunk.offset) / m, (offset - chunk.offset + 16) / m);
      const allz = simdle.allz(vec);
      const allo = simdle.allo(vec);
      let changed = false;
      if (set(this.handle, bitOffset(false, 128 + j), allz)) {
        changed = true;
        const offset2 = byteOffset(false, i * 16 + 16) / 4;
        const allo2 = simdle.allo(this.handle.subarray(offset2, offset2 + 4));
        set(this.handle, bitOffset(false, i), allo2);
      }
      if (set(this.handle, bitOffset(true, 128 + j), allo)) {
        changed = true;
        const offset2 = byteOffset(true, i * 16 + 16) / 4;
        const allo2 = simdle.allo(this.handle.subarray(offset2, offset2 + 4));
        set(this.handle, bitOffset(true, i), allo2);
      }
      return changed;
    }
  }
});

// node_modules/quickbit-native/binding.js
var require_binding5 = __commonJS((exports, module) => {
  var __filename = "/Users/odinsson/Dev/pear/easybase/node_modules/quickbit-native/binding.js";
  __require.addon = require_require_addon();
  module.exports = __require.addon(".", __filename);
});

// node_modules/quickbit-native/index.js
var require_quickbit_native = __commonJS((exports) => {
  var binding = require_binding5();
  exports.get = function get(field, bit) {
    const n = field.byteLength * 8;
    if (bit < 0)
      bit += n;
    if (bit < 0 || bit >= n)
      return false;
    return binding.quickbit_napi_get(toBuffer(field), bit) !== 0;
  };
  exports.set = function set(field, bit, value = true) {
    const n = field.byteLength * 8;
    if (bit < 0)
      bit += n;
    if (bit < 0 || bit >= n)
      return false;
    return binding.quickbit_napi_set(toBuffer(field), bit, value ? 1 : 0) !== 0;
  };
  exports.fill = function fill(field, value, start = 0, end = field.byteLength * 8) {
    const n = field.byteLength * 8;
    if (start < 0)
      start += n;
    if (end < 0)
      end += n;
    if (start < 0 || start >= field.byteLength * 8 || start >= end)
      return field;
    binding.quickbit_napi_fill(toBuffer(field), value ? 1 : 0, start, end);
    return field;
  };
  exports.clear = function clear(field, ...chunks) {
    binding.quickbit_napi_clear(toBuffer(field), chunks.map(toBufferChunk));
  };
  exports.findFirst = function findFirst(field, value, position = 0) {
    const n = field.byteLength * 8;
    if (position < 0)
      position += n;
    if (position < 0)
      position = 0;
    if (position >= n)
      return -1;
    return binding.quickbit_napi_find_first(toBuffer(field), value ? 1 : 0, position);
  };
  exports.findLast = function findLast(field, value, position = field.byteLength * 8 - 1) {
    const n = field.byteLength * 8;
    if (position < 0)
      position += n;
    if (position < 0)
      return -1;
    if (position >= n)
      position = n - 1;
    return binding.quickbit_napi_find_last(toBuffer(field), value ? 1 : 0, position);
  };
  function toBuffer(field) {
    if (field.BYTES_PER_ELEMENT === 1)
      return field;
    return new Uint8Array(field.buffer, field.byteOffset, field.byteLength);
  }
  function toBufferChunk(chunk) {
    return { field: toBuffer(chunk.field), offset: chunk.offset };
  }

  class Index {
    static from(fieldOrChunks, byteLength = -1) {
      if (Array.isArray(fieldOrChunks)) {
        return new SparseIndex(fieldOrChunks, byteLength);
      } else {
        return new DenseIndex(fieldOrChunks, byteLength);
      }
    }
    constructor(byteLength) {
      this._byteLength = byteLength;
      this.handle = Buffer.allocUnsafe(binding.sizeof_quickbit_index_t);
    }
    get byteLength() {
      return this._byteLength;
    }
    skipFirst(value, position = 0) {
      const n = this.byteLength * 8;
      if (position < 0)
        position += n;
      if (position < 0)
        position = 0;
      if (position >= n)
        return n - 1;
      return binding.quickbit_napi_skip_first(this.handle, this.byteLength, value ? 1 : 0, position);
    }
    skipLast(value, position = this.byteLength * 8 - 1) {
      const n = this.byteLength * 8;
      if (position < 0)
        position += n;
      if (position < 0)
        return 0;
      if (position >= n)
        position = n - 1;
      return binding.quickbit_napi_skip_last(this.handle, this.byteLength, value ? 1 : 0, position);
    }
  }
  exports.Index = Index;

  class DenseIndex extends Index {
    constructor(field, byteLength) {
      super(byteLength);
      this.field = field;
      binding.quickbit_napi_index_init(this.handle, toBuffer(this.field));
    }
    get byteLength() {
      if (this._byteLength !== -1)
        return this._byteLength;
      return this.field.byteLength;
    }
    update(bit) {
      const n = this.byteLength * 8;
      if (bit < 0)
        bit += n;
      if (bit < 0 || bit >= n)
        return false;
      return binding.quickbit_napi_index_update(this.handle, toBuffer(this.field), bit) !== 0;
    }
  }
  function selectChunk(chunks, offset) {
    for (let i = 0;i < chunks.length; i++) {
      const next = chunks[i];
      const start = next.offset;
      const end = next.offset + next.field.byteLength;
      if (offset >= start && offset + 16 <= end) {
        return next;
      }
    }
    return null;
  }

  class SparseIndex extends Index {
    constructor(chunks, byteLength) {
      super(byteLength);
      this.chunks = chunks;
      binding.quickbit_napi_index_init_sparse(this.handle, this.chunks.map(toBufferChunk));
    }
    get byteLength() {
      if (this._byteLength !== -1)
        return this._byteLength;
      const last = this.chunks[this.chunks.length - 1];
      return last ? last.offset + last.field.byteLength : 0;
    }
    update(bit) {
      const n = this.byteLength * 8;
      if (bit < 0)
        bit += n;
      if (bit < 0 || bit >= n)
        return false;
      const j = Math.floor(bit / 128);
      const offset = j * 16;
      const chunk = selectChunk(this.chunks, offset);
      if (chunk === null)
        return false;
      return binding.quickbit_napi_index_update_sparse(this.handle, toBuffer(chunk.field), chunk.offset, bit) !== 0;
    }
  }
});

// node_modules/quickbit-universal/index.js
var require_quickbit_universal = __commonJS((exports, module) => {
  var fallback = require_fallback2();
  try {
    const native = require_quickbit_native();
    exports.get = fallback.get;
    exports.set = fallback.set;
    exports.fill = fallback.fill;
    exports.clear = native.clear;
    exports.findFirst = native.findFirst;
    exports.findLast = native.findLast;
    exports.Index = native.Index;
  } catch {
    module.exports = fallback;
  }
});

// node_modules/hypercore/lib/compat.js
var require_compat = __commonJS((exports) => {
  var quickbit = require_quickbit_universal();
  if (typeof quickbit.findFirst !== "function" || typeof quickbit.findLast !== "function" || typeof quickbit.clear !== "function") {
    quickbit = require_fallback2();
  }
  exports.quickbit = quickbit;
});

// node_modules/hypercore/lib/bit-interlude.js
var require_bit_interlude = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var quickbit = require_compat().quickbit;
  module.exports = class BitInterlude {
    constructor() {
      this.ranges = [];
    }
    contiguousLength(from) {
      for (const r of this.ranges) {
        if (r.start > from)
          break;
        if (!r.value && r.start <= from)
          return r.start;
      }
      while (this.get(from) === true)
        from++;
      return from;
    }
    get(index) {
      let start = 0;
      let end = this.ranges.length;
      while (start < end) {
        const mid = start + end >> 1;
        const r = this.ranges[mid];
        if (index < r.start) {
          end = mid;
          continue;
        }
        if (index >= r.end) {
          if (mid === start)
            break;
          start = mid;
          continue;
        }
        return r.value;
      }
      return false;
    }
    setRange(start, end, value) {
      if (start === end)
        return;
      let r = null;
      for (let i = 0;i < this.ranges.length; i++) {
        r = this.ranges[i];
        if (r.start <= start && end <= r.end) {
          if (value === r.value)
            return;
          const ranges = mergeRanges(r, { start, end, value });
          this.ranges.splice(i, 1, ...ranges);
          return;
        }
        if (start > r.end) {
          continue;
        }
        if (end >= r.start && end <= r.end) {
          r.start = r.value === value ? start : end;
          if (r.value !== value)
            this.ranges.splice(i, 0, { start, end, value });
          return;
        }
        if (start >= r.start && start <= r.end) {
          if (r.value !== value) {
            this.ranges.splice(++i, 0, { start, end, value });
            r.end = start;
            return;
          }
          start = r.start;
        }
        let remove = 0;
        for (let j = i;j < this.ranges.length; j++) {
          const n = this.ranges[j];
          if (n.start > end || n.value !== value)
            break;
          if (n.start <= end && n.end > end)
            end = n.end;
          remove++;
        }
        this.ranges.splice(i, remove, { start, end, value });
        return;
      }
      if (r !== null) {
        if (start <= r.end && end > r.end) {
          r.end = end;
          return;
        }
        if (r.end > start)
          return;
      }
      this.ranges.push({ start, end, value });
    }
    flush(tx, bitfield) {
      if (!this.ranges.length)
        return [];
      let index = this.ranges[0].start;
      const final = this.ranges[this.ranges.length - 1].end;
      let i = 0;
      while (index < final) {
        const page = bitfield.getBitfield(index);
        const pageIndex = page ? page.index : bitfield.getPageIndex(index);
        const buf = b4a.allocUnsafe(bitfield.getPageByteLength());
        if (page) {
          const src = page.bitfield;
          buf.set(b4a.from(src.buffer, src.byteOffset, src.byteLength), 0);
        } else {
          b4a.fill(buf, 0);
        }
        const last = (pageIndex + 1) * (buf.byteLength << 3);
        const offset = pageIndex * (buf.byteLength << 3);
        let hasValue = false;
        while (i < this.ranges.length) {
          const { start, end, value } = this.ranges[i];
          if (!hasValue && value)
            hasValue = true;
          const from = start < index ? index : start;
          const to = end < last ? end : last;
          quickbit.fill(buf, value, from - offset, to - offset);
          index = to;
          if (to === last)
            break;
          i++;
        }
        if (page || hasValue)
          tx.putBitfieldPage(pageIndex, buf);
      }
      return this.ranges;
    }
  };
  function mergeRanges(a, b) {
    const ranges = [];
    if (a.start < b.start)
      ranges.push({ start: a.start, end: b.start, value: a.value });
    ranges.push({ start: b.start, end: b.end, value: b.value });
    if (b.end < a.end)
      ranges.push({ start: b.end, end: a.end, value: a.value });
    return ranges;
  }
});

// node_modules/big-sparse-array/index.js
var require_big_sparse_array = __commonJS((exports, module) => {
  var FACTOR = new Uint16Array(8);
  function factor4096(i, n) {
    while (n > 0) {
      const f = i & 4095;
      FACTOR[--n] = f;
      i = (i - f) / 4096;
    }
    return FACTOR;
  }
  module.exports = class BigSparseArray {
    constructor() {
      this.tiny = new TinyArray;
      this.maxLength = 4096;
      this.factor = 1;
    }
    set(index, val) {
      if (val !== undefined) {
        while (index >= this.maxLength) {
          this.maxLength *= 4096;
          this.factor++;
          if (!this.tiny.isEmptyish()) {
            const t = new TinyArray;
            t.set(0, this.tiny);
            this.tiny = t;
          }
        }
      }
      const f = factor4096(index, this.factor);
      const last = this.factor - 1;
      let tiny = this.tiny;
      for (let i = 0;i < last; i++) {
        const next = tiny.get(f[i]);
        if (next === undefined) {
          if (val === undefined)
            return;
          tiny = tiny.set(f[i], new TinyArray);
        } else {
          tiny = next;
        }
      }
      return tiny.set(f[last], val);
    }
    get(index) {
      if (index >= this.maxLength)
        return;
      const f = factor4096(index, this.factor);
      const last = this.factor - 1;
      let tiny = this.tiny;
      for (let i = 0;i < last; i++) {
        tiny = tiny.get(f[i]);
        if (tiny === undefined)
          return;
      }
      return tiny.get(f[last]);
    }
  };

  class TinyArray {
    constructor() {
      this.s = 0;
      this.b = new Array(1);
      this.f = new Uint16Array(1);
    }
    isEmptyish() {
      return this.b.length === 1 && this.b[0] === undefined;
    }
    get(i) {
      if (this.s === 12)
        return this.b[i];
      const f = i >>> this.s;
      const r = i & this.b.length - 1;
      return this.f[r] === f ? this.b[r] : undefined;
    }
    set(i, v) {
      while (this.s !== 12) {
        const f = i >>> this.s;
        const r = i & this.b.length - 1;
        const o = this.b[r];
        if (o === undefined || f === this.f[r]) {
          this.b[r] = v;
          this.f[r] = f;
          return v;
        }
        this.grow();
      }
      this.b[i] = v;
      return v;
    }
    grow() {
      const os = this.s;
      const ob = this.b;
      const of = this.f;
      this.s += 4;
      this.b = new Array(this.b.length << 4);
      this.f = this.s === 12 ? null : new Uint8Array(this.b.length);
      const m = this.b.length - 1;
      for (let or = 0;or < ob.length; or++) {
        if (ob[or] === undefined)
          continue;
        const i = of[or] << os | or;
        const f = i >>> this.s;
        const r = i & m;
        this.b[r] = ob[or];
        if (this.s !== 12)
          this.f[r] = f;
      }
    }
  }
});

// node_modules/hypercore/lib/bitfield.js
var require_bitfield = __commonJS((exports, module) => {
  var BigSparseArray = require_big_sparse_array();
  var b4a = require_b4a();
  var quickbit = require_compat().quickbit;
  var BITS_PER_PAGE = 32768;
  var BYTES_PER_PAGE = BITS_PER_PAGE / 8;
  var WORDS_PER_PAGE = BYTES_PER_PAGE / 4;
  var BITS_PER_SEGMENT = 2097152;
  var BYTES_PER_SEGMENT = BITS_PER_SEGMENT / 8;
  var WORDS_PER_SEGMENT = BYTES_PER_SEGMENT / 4;
  var INITIAL_WORDS_PER_SEGMENT = 1024;
  var PAGES_PER_SEGMENT = BITS_PER_SEGMENT / BITS_PER_PAGE;
  var SEGMENT_GROWTH_FACTOR = 4;

  class BitfieldPage {
    constructor(index, segment) {
      this.index = index;
      this.offset = index * BYTES_PER_PAGE - segment.offset;
      this.bitfield = null;
      this.segment = segment;
      segment.add(this);
    }
    get tree() {
      return this.segment.tree;
    }
    get(index, dirty) {
      return quickbit.get(this.bitfield, index);
    }
    set(index, val) {
      if (quickbit.set(this.bitfield, index, val)) {
        this.tree.update(this.offset * 8 + index);
      }
    }
    setRange(start, end, val) {
      quickbit.fill(this.bitfield, val, start, end);
      let i = Math.floor(start / 128);
      const n = i + Math.ceil((end - start) / 128);
      while (i <= n)
        this.tree.update(this.offset * 8 + i++ * 128);
    }
    findFirst(val, position) {
      return quickbit.findFirst(this.bitfield, val, position);
    }
    findLast(val, position) {
      return quickbit.findLast(this.bitfield, val, position);
    }
    count(start, length, val) {
      const end = start + length;
      let i = start;
      let c = 0;
      while (length > 0) {
        const l = this.findFirst(val, i);
        if (l === -1 || l >= end)
          return c;
        const h = this.findFirst(!val, l + 1);
        if (h === -1 || h >= end)
          return c + end - l;
        c += h - l;
        length -= h - i;
        i = h;
      }
      return c;
    }
  }

  class BitfieldSegment {
    constructor(index, bitfield) {
      this.index = index;
      this.offset = index * BYTES_PER_SEGMENT;
      this.tree = quickbit.Index.from(bitfield, BYTES_PER_SEGMENT);
      this.pages = new Array(PAGES_PER_SEGMENT);
    }
    get bitfield() {
      return this.tree.field;
    }
    add(page) {
      const i = page.index - this.index * PAGES_PER_SEGMENT;
      this.pages[i] = page;
      const start = i * WORDS_PER_PAGE;
      const end = start + WORDS_PER_PAGE;
      if (end >= this.bitfield.length)
        this.reallocate(end);
      page.bitfield = this.bitfield.subarray(start, end);
    }
    reallocate(length) {
      let target = this.bitfield.length;
      while (target < length)
        target *= SEGMENT_GROWTH_FACTOR;
      const bitfield = new Uint32Array(target);
      bitfield.set(this.bitfield);
      this.tree = quickbit.Index.from(bitfield, BYTES_PER_SEGMENT);
      for (let i = 0;i < this.pages.length; i++) {
        const page = this.pages[i];
        if (!page)
          continue;
        const start = i * WORDS_PER_PAGE;
        const end = start + WORDS_PER_PAGE;
        page.bitfield = bitfield.subarray(start, end);
      }
    }
    findFirst(val, position) {
      position = this.tree.skipFirst(!val, position);
      let j = position & BITS_PER_PAGE - 1;
      let i = (position - j) / BITS_PER_PAGE;
      if (i >= PAGES_PER_SEGMENT)
        return -1;
      while (i < this.pages.length) {
        const p = this.pages[i];
        let index = -1;
        if (p)
          index = p.findFirst(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_PAGE + index;
        j = 0;
        i++;
      }
      return -1;
    }
    findLast(val, position) {
      position = this.tree.skipLast(!val, position);
      let j = position & BITS_PER_PAGE - 1;
      let i = (position - j) / BITS_PER_PAGE;
      if (i >= PAGES_PER_SEGMENT)
        return -1;
      while (i >= 0) {
        const p = this.pages[i];
        let index = -1;
        if (p)
          index = p.findLast(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_PAGE + index;
        j = BITS_PER_PAGE - 1;
        i--;
      }
      return -1;
    }
  }
  module.exports = class Bitfield {
    static BITS_PER_PAGE = BITS_PER_PAGE;
    static BYTES_PER_PAGE = BYTES_PER_PAGE;
    constructor(buffer) {
      this.resumed = !!(buffer && buffer.byteLength >= 0);
      this._pages = new BigSparseArray;
      this._segments = new BigSparseArray;
      const view = this.resumed ? new Uint32Array(buffer.buffer, buffer.byteOffset, Math.floor(buffer.byteLength / 4)) : new Uint32Array(INITIAL_WORDS_PER_SEGMENT);
      for (let i = 0;i < view.length; i += WORDS_PER_SEGMENT) {
        let bitfield = view.subarray(i, i + WORDS_PER_SEGMENT);
        let length = WORDS_PER_SEGMENT;
        if (i === 0) {
          length = INITIAL_WORDS_PER_SEGMENT;
          while (length < bitfield.length)
            length *= SEGMENT_GROWTH_FACTOR;
        }
        if (bitfield.length !== length) {
          const copy = new Uint32Array(length);
          copy.set(bitfield, 0);
          bitfield = copy;
        }
        const segment = new BitfieldSegment(i / WORDS_PER_SEGMENT, bitfield);
        this._segments.set(segment.index, segment);
        for (let j = 0;j < bitfield.length; j += WORDS_PER_PAGE) {
          const page = new BitfieldPage((i + j) / WORDS_PER_PAGE, segment);
          this._pages.set(page.index, page);
        }
      }
    }
    static from(bitfield) {
      return new Bitfield(bitfield.toBuffer(bitfield._pages.maxLength * BITS_PER_PAGE));
    }
    toBuffer(length) {
      const pages = Math.ceil(length / BITS_PER_PAGE);
      const buffer = b4a.allocUnsafe(pages * BYTES_PER_PAGE);
      for (let i = 0;i < pages; i++) {
        const page = this._pages.get(i);
        const offset = i * BYTES_PER_PAGE;
        if (page) {
          const buf = b4a.from(page.bitfield.buffer, page.bitfield.byteOffset, page.bitfield.byteLength);
          buffer.set(buf, offset);
        } else {
          buffer.fill(0, offset, offset + BYTES_PER_PAGE);
        }
      }
      return buffer;
    }
    getBitfield(index) {
      const i = this.getPageIndex(index);
      const p = this._pages.get(i);
      return p || null;
    }
    merge(bitfield, length) {
      let i = 0;
      while (i < length) {
        const start = bitfield.firstSet(i);
        if (start === -1)
          break;
        i = bitfield.firstUnset(start);
        if (i === -1 || i > length)
          i = length;
        this.setRange(start, i, true);
        if (i >= length)
          break;
      }
    }
    get(index) {
      const j = index & BITS_PER_PAGE - 1;
      const i = (index - j) / BITS_PER_PAGE;
      const p = this._pages.get(i);
      return p ? p.get(j) : false;
    }
    getPageByteLength() {
      return BYTES_PER_PAGE;
    }
    getPageIndex(index) {
      const j = index & BITS_PER_PAGE - 1;
      return (index - j) / BITS_PER_PAGE;
    }
    getPage(index, create) {
      const i = this.getPageIndex(index);
      let p = this._pages.get(i);
      if (p)
        return p;
      if (!create)
        return null;
      const k = Math.floor(i / PAGES_PER_SEGMENT);
      const s = this._segments.get(k) || this._segments.set(k, new BitfieldSegment(k, new Uint32Array(k === 0 ? INITIAL_WORDS_PER_SEGMENT : WORDS_PER_SEGMENT)));
      p = this._pages.set(i, new BitfieldPage(i, s));
      return p;
    }
    set(index, val) {
      const j = index & BITS_PER_PAGE - 1;
      const i = (index - j) / BITS_PER_PAGE;
      let p = this._pages.get(i);
      if (!p && val) {
        const k = Math.floor(i / PAGES_PER_SEGMENT);
        const s = this._segments.get(k) || this._segments.set(k, new BitfieldSegment(k, new Uint32Array(k === 0 ? INITIAL_WORDS_PER_SEGMENT : WORDS_PER_SEGMENT)));
        p = this._pages.set(i, new BitfieldPage(i, s));
      }
      if (p)
        p.set(j, val);
    }
    setRange(start, end, val) {
      let j = start & BITS_PER_PAGE - 1;
      let i = (start - j) / BITS_PER_PAGE;
      while (start < end) {
        let p = this._pages.get(i);
        if (!p && val) {
          const k = Math.floor(i / PAGES_PER_SEGMENT);
          const s = this._segments.get(k) || this._segments.set(k, new BitfieldSegment(k, new Uint32Array(k === 0 ? INITIAL_WORDS_PER_SEGMENT : WORDS_PER_SEGMENT)));
          p = this._pages.set(i, new BitfieldPage(i, s));
        }
        const offset = p.index * BITS_PER_PAGE;
        const last = Math.min(end - offset, BITS_PER_PAGE);
        const range = last - j;
        if (p)
          p.setRange(j, last, val);
        j = 0;
        i++;
        start += range;
      }
    }
    findFirst(val, position) {
      let j = position & BITS_PER_SEGMENT - 1;
      let i = (position - j) / BITS_PER_SEGMENT;
      while (i < this._segments.maxLength) {
        const s = this._segments.get(i);
        let index = -1;
        if (s)
          index = s.findFirst(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_SEGMENT + index;
        j = 0;
        i++;
      }
      return val ? -1 : this._segments.maxLength * BITS_PER_SEGMENT;
    }
    firstSet(position) {
      return this.findFirst(true, position);
    }
    firstUnset(position) {
      return this.findFirst(false, position);
    }
    findLast(val, position) {
      let j = position & BITS_PER_SEGMENT - 1;
      let i = (position - j) / BITS_PER_SEGMENT;
      while (i >= 0) {
        const s = this._segments.get(i);
        let index = -1;
        if (s)
          index = s.findLast(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_SEGMENT + index;
        j = BITS_PER_SEGMENT - 1;
        i--;
      }
      return -1;
    }
    lastSet(position) {
      return this.findLast(true, position);
    }
    lastUnset(position) {
      return this.findLast(false, position);
    }
    count(start, length, val) {
      let j = start & BITS_PER_PAGE - 1;
      let i = (start - j) / BITS_PER_PAGE;
      let c = 0;
      while (length > 0) {
        const p = this._pages.get(i);
        const end = Math.min(j + length, BITS_PER_PAGE);
        const range = end - j;
        if (p)
          c += p.count(j, range, val);
        else if (!val)
          c += range;
        j = 0;
        i++;
        length -= range;
      }
      return c;
    }
    countSet(start, length) {
      return this.count(start, length, true);
    }
    countUnset(start, length) {
      return this.count(start, length, false);
    }
    *want(start, length) {
      const j = start & BITS_PER_SEGMENT - 1;
      let i = (start - j) / BITS_PER_SEGMENT;
      while (length > 0) {
        const s = this._segments.get(i);
        if (s) {
          const end = ceilTo(clamp(length / 8, 4096, BYTES_PER_SEGMENT), 4096);
          yield {
            start: i * BITS_PER_SEGMENT,
            bitfield: s.bitfield.subarray(0, end / 4)
          };
        }
        i++;
        length -= BITS_PER_SEGMENT;
      }
    }
    clear(tx) {
      return tx.deleteBitfieldPageRange(0, -1);
    }
    onupdate(ranges) {
      for (const { start, end, value } of ranges) {
        this.setRange(start, end, value);
      }
    }
    static async open(storage, length) {
      if (length === 0)
        return new Bitfield(storage, null);
      const pages = Math.ceil(length / BITS_PER_PAGE);
      const buffer = b4a.alloc(pages * BYTES_PER_PAGE);
      const stream = storage.createBitfieldStream();
      for await (const { index, page } of stream) {
        buffer.set(page, index * BYTES_PER_PAGE);
      }
      return new Bitfield(buffer);
    }
  };
  function clamp(n, min, max) {
    return Math.min(Math.max(n, min), max);
  }
  function ceilTo(n, multiple = 1) {
    const remainder = n % multiple;
    if (remainder === 0)
      return n;
    return n + multiple - remainder;
  }
});

// node_modules/hypercore/lib/remote-bitfield.js
var require_remote_bitfield = __commonJS((exports, module) => {
  var BigSparseArray = require_big_sparse_array();
  var quickbit = require_compat().quickbit;
  var BITS_PER_PAGE = 32768;
  var BYTES_PER_PAGE = BITS_PER_PAGE / 8;
  var WORDS_PER_PAGE = BYTES_PER_PAGE / 4;
  var BITS_PER_SEGMENT = 2097152;
  var BYTES_PER_SEGMENT = BITS_PER_SEGMENT / 8;
  var PAGES_PER_SEGMENT = BITS_PER_SEGMENT / BITS_PER_PAGE;

  class RemoteBitfieldPage {
    constructor(index, bitfield, segment) {
      this.index = index;
      this.offset = index * BYTES_PER_PAGE - segment.offset;
      this.bitfield = bitfield;
      this.segment = segment;
      segment.add(this);
    }
    get tree() {
      return this.segment.tree;
    }
    get(index) {
      return quickbit.get(this.bitfield, index);
    }
    set(index, val) {
      if (quickbit.set(this.bitfield, index, val)) {
        this.tree.update(this.offset * 8 + index);
      }
    }
    setRange(start, end, val) {
      quickbit.fill(this.bitfield, val, start, end);
      let i = Math.floor(start / 128);
      const n = i + Math.ceil((end - start) / 128);
      while (i <= n)
        this.tree.update(this.offset * 8 + i++ * 128);
    }
    findFirst(val, position) {
      return quickbit.findFirst(this.bitfield, val, position);
    }
    findLast(val, position) {
      return quickbit.findLast(this.bitfield, val, position);
    }
    insert(start, bitfield) {
      this.bitfield.set(bitfield, start / 32);
      this.segment.refresh();
    }
    clear(start, bitfield) {
      quickbit.clear(this.bitfield, { field: bitfield, offset: start });
    }
  }

  class RemoteBitfieldSegment {
    constructor(index) {
      this.index = index;
      this.offset = index * BYTES_PER_SEGMENT;
      this.tree = quickbit.Index.from([], BYTES_PER_SEGMENT);
      this.pages = new Array(PAGES_PER_SEGMENT);
      this.pagesLength = 0;
    }
    get chunks() {
      return this.tree.chunks;
    }
    refresh() {
      this.tree = quickbit.Index.from(this.tree.chunks, BYTES_PER_SEGMENT);
    }
    add(page) {
      const pageIndex = page.index - this.index * PAGES_PER_SEGMENT;
      if (pageIndex >= this.pagesLength)
        this.pagesLength = pageIndex + 1;
      this.pages[pageIndex] = page;
      const chunk = { field: page.bitfield, offset: page.offset };
      this.chunks.push(chunk);
      for (let i = this.chunks.length - 2;i >= 0; i--) {
        const prev = this.chunks[i];
        if (prev.offset <= chunk.offset)
          break;
        this.chunks[i] = chunk;
        this.chunks[i + 1] = prev;
      }
    }
    findFirst(val, position) {
      position = this.tree.skipFirst(!val, position);
      let j = position & BITS_PER_PAGE - 1;
      let i = (position - j) / BITS_PER_PAGE;
      if (i >= PAGES_PER_SEGMENT)
        return -1;
      while (i < this.pagesLength) {
        const p = this.pages[i];
        let index = -1;
        if (p)
          index = p.findFirst(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_PAGE + index;
        j = 0;
        i++;
      }
      return val || this.pagesLength === PAGES_PER_SEGMENT ? -1 : this.pagesLength * BITS_PER_PAGE;
    }
    findLast(val, position) {
      position = this.tree.skipLast(!val, position);
      let j = position & BITS_PER_PAGE - 1;
      let i = (position - j) / BITS_PER_PAGE;
      if (i >= PAGES_PER_SEGMENT)
        return -1;
      while (i >= 0) {
        const p = this.pages[i];
        let index = -1;
        if (p)
          index = p.findLast(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_PAGE + index;
        j = BITS_PER_PAGE - 1;
        i--;
      }
      return -1;
    }
  }
  module.exports = class RemoteBitfield {
    static BITS_PER_PAGE = BITS_PER_PAGE;
    constructor() {
      this._pages = new BigSparseArray;
      this._segments = new BigSparseArray;
      this._maxSegments = 0;
    }
    getBitfield(index) {
      const j = index & BITS_PER_PAGE - 1;
      const i = (index - j) / BITS_PER_PAGE;
      const p = this._pages.get(i);
      return p || null;
    }
    get(index) {
      const j = index & BITS_PER_PAGE - 1;
      const i = (index - j) / BITS_PER_PAGE;
      const p = this._pages.get(i);
      return p ? p.get(j) : false;
    }
    set(index, val) {
      const j = index & BITS_PER_PAGE - 1;
      const i = (index - j) / BITS_PER_PAGE;
      let p = this._pages.get(i);
      if (!p && val) {
        const k = Math.floor(i / PAGES_PER_SEGMENT);
        const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k));
        if (this._maxSegments <= k)
          this._maxSegments = k + 1;
        p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s));
      }
      if (p)
        p.set(j, val);
    }
    setRange(start, end, val) {
      let j = start & BITS_PER_PAGE - 1;
      let i = (start - j) / BITS_PER_PAGE;
      while (start < end) {
        let p = this._pages.get(i);
        if (!p && val) {
          const k = Math.floor(i / PAGES_PER_SEGMENT);
          const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k));
          if (this._maxSegments <= k)
            this._maxSegments = k + 1;
          p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s));
        }
        const offset = i * BITS_PER_PAGE;
        const last = Math.min(end - offset, BITS_PER_PAGE);
        const range = last - j;
        if (p)
          p.setRange(j, last, val);
        j = 0;
        i++;
        start += range;
      }
    }
    findFirst(val, position) {
      let j = position & BITS_PER_SEGMENT - 1;
      let i = (position - j) / BITS_PER_SEGMENT;
      while (i < this._maxSegments) {
        const s = this._segments.get(i);
        let index = -1;
        if (s)
          index = s.findFirst(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_SEGMENT + index;
        j = 0;
        i++;
      }
      return val ? -1 : Math.max(position, this._maxSegments * BITS_PER_SEGMENT);
    }
    firstSet(position) {
      return this.findFirst(true, position);
    }
    firstUnset(position) {
      return this.findFirst(false, position);
    }
    findLast(val, position) {
      let j = position & BITS_PER_SEGMENT - 1;
      let i = (position - j) / BITS_PER_SEGMENT;
      while (i >= 0) {
        const s = this._segments.get(i);
        let index = -1;
        if (s)
          index = s.findLast(val, j);
        else if (!val)
          index = j;
        if (index !== -1)
          return i * BITS_PER_SEGMENT + index;
        j = BITS_PER_SEGMENT - 1;
        i--;
      }
      return -1;
    }
    lastSet(position) {
      return this.findLast(true, position);
    }
    lastUnset(position) {
      return this.findLast(false, position);
    }
    insert(start, bitfield) {
      if (start % 32 !== 0)
        return false;
      let length = bitfield.byteLength * 8;
      let j = start & BITS_PER_PAGE - 1;
      let i = (start - j) / BITS_PER_PAGE;
      while (length > 0) {
        let p = this._pages.get(i);
        if (!p) {
          const k = Math.floor(i / PAGES_PER_SEGMENT);
          const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k));
          if (this._maxSegments <= k)
            this._maxSegments = k + 1;
          p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s));
        }
        const end = Math.min(j + length, BITS_PER_PAGE);
        const range = end - j;
        p.insert(j, bitfield.subarray(0, range / 32));
        bitfield = bitfield.subarray(range / 32);
        j = 0;
        i++;
        length -= range;
      }
      return true;
    }
    clear(start, bitfield) {
      if (start % 32 !== 0)
        return false;
      let length = bitfield.byteLength * 8;
      let j = start & BITS_PER_PAGE - 1;
      let i = (start - j) / BITS_PER_PAGE;
      while (length > 0) {
        let p = this._pages.get(i);
        if (!p) {
          const k = Math.floor(i / PAGES_PER_SEGMENT);
          const s = this._segments.get(k) || this._segments.set(k, new RemoteBitfieldSegment(k));
          if (this._maxSegments <= k)
            this._maxSegments = k + 1;
          p = this._pages.set(i, new RemoteBitfieldPage(i, new Uint32Array(WORDS_PER_PAGE), s));
        }
        const end = Math.min(j + length, BITS_PER_PAGE);
        const range = end - j;
        p.clear(j, bitfield.subarray(0, range / 32));
        bitfield = bitfield.subarray(range / 32);
        j = 0;
        i++;
        length -= range;
      }
      return true;
    }
  };
});

// node_modules/hypercore/lib/messages.js
var require_messages2 = __commonJS((exports) => {
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var { DEFAULT_NAMESPACE } = require_caps();
  var { INVALID_OPLOG_VERSION } = require_hypercore_errors();
  var unslab = require_unslab();
  var EMPTY = b4a.alloc(0);
  var MANIFEST_PATCH = 1;
  var MANIFEST_PROLOGUE = 2;
  var MANIFEST_LINKED = 4;
  var MANIFEST_USER_DATA = 8;
  var hashes = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      if (m === "blake2b") {
        c.uint.encode(state, 0);
        return;
      }
      throw new Error("Unknown hash: " + m);
    },
    decode(state) {
      const n = c.uint.decode(state);
      if (n === 0)
        return "blake2b";
      throw new Error("Unknown hash id: " + n);
    }
  };
  var signatures = {
    preencode(state, m) {
      state.end++;
    },
    encode(state, m) {
      if (m === "ed25519") {
        c.uint.encode(state, 0);
        return;
      }
      throw new Error("Unknown signature: " + m);
    },
    decode(state) {
      const n = c.uint.decode(state);
      if (n === 0)
        return "ed25519";
      throw new Error("Unknown signature id: " + n);
    }
  };
  var signer = {
    preencode(state, m) {
      signatures.preencode(state, m.signature);
      c.fixed32.preencode(state, m.namespace);
      c.fixed32.preencode(state, m.publicKey);
    },
    encode(state, m) {
      signatures.encode(state, m.signature);
      c.fixed32.encode(state, m.namespace);
      c.fixed32.encode(state, m.publicKey);
    },
    decode(state) {
      return {
        signature: signatures.decode(state),
        namespace: c.fixed32.decode(state),
        publicKey: c.fixed32.decode(state)
      };
    }
  };
  var signerArray = c.array(signer);
  var prologue = {
    preencode(state, p) {
      c.fixed32.preencode(state, p.hash);
      c.uint.preencode(state, p.length);
    },
    encode(state, p) {
      c.fixed32.encode(state, p.hash);
      c.uint.encode(state, p.length);
    },
    decode(state) {
      return {
        hash: c.fixed32.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var manifestv0 = {
    preencode(state, m) {
      hashes.preencode(state, m.hash);
      state.end++;
      if (m.prologue && m.signers.length === 0) {
        c.fixed32.preencode(state, m.prologue.hash);
        return;
      }
      if (m.quorum === 1 && m.signers.length === 1 && !m.allowPatch) {
        signer.preencode(state, m.signers[0]);
      } else {
        state.end++;
        c.uint.preencode(state, m.quorum);
        signerArray.preencode(state, m.signers);
      }
    },
    encode(state, m) {
      hashes.encode(state, m.hash);
      if (m.prologue && m.signers.length === 0) {
        c.uint.encode(state, 0);
        c.fixed32.encode(state, m.prologue.hash);
        return;
      }
      if (m.quorum === 1 && m.signers.length === 1 && !m.allowPatch) {
        c.uint.encode(state, 1);
        signer.encode(state, m.signers[0]);
      } else {
        c.uint.encode(state, 2);
        c.uint.encode(state, m.allowPatch ? 1 : 0);
        c.uint.encode(state, m.quorum);
        signerArray.encode(state, m.signers);
      }
    },
    decode(state) {
      const hash = hashes.decode(state);
      const type = c.uint.decode(state);
      if (type > 2)
        throw new Error("Unknown type: " + type);
      if (type === 0) {
        return {
          version: 0,
          hash,
          allowPatch: false,
          quorum: 0,
          signers: [],
          prologue: {
            hash: c.fixed32.decode(state),
            length: 0
          },
          linked: null,
          userData: null
        };
      }
      if (type === 1) {
        return {
          version: 0,
          hash,
          allowPatch: false,
          quorum: 1,
          signers: [signer.decode(state)],
          prologue: null,
          linked: null,
          userData: null
        };
      }
      const flags = c.uint.decode(state);
      return {
        version: 0,
        hash,
        allowPatch: (flags & 1) !== 0,
        quorum: c.uint.decode(state),
        signers: signerArray.decode(state),
        prologue: null,
        linked: null,
        userData: null
      };
    }
  };
  var fixed32Array = c.array(c.fixed32);
  var manifest = exports.manifest = {
    preencode(state, m) {
      state.end++;
      if (m.version === 0)
        return manifestv0.preencode(state, m);
      state.end++;
      hashes.preencode(state, m.hash);
      c.uint.preencode(state, m.quorum);
      signerArray.preencode(state, m.signers);
      if (m.prologue)
        prologue.preencode(state, m.prologue);
      if (m.linked)
        fixed32Array.preencode(state, m.linked);
      if (m.userData)
        c.buffer.preencode(state, m.userData);
    },
    encode(state, m) {
      c.uint.encode(state, m.version);
      if (m.version === 0)
        return manifestv0.encode(state, m);
      let flags = 0;
      if (m.allowPatch)
        flags |= MANIFEST_PATCH;
      if (m.prologue)
        flags |= MANIFEST_PROLOGUE;
      if (m.linked)
        flags |= MANIFEST_LINKED;
      if (m.userData)
        flags |= MANIFEST_USER_DATA;
      c.uint.encode(state, flags);
      hashes.encode(state, m.hash);
      c.uint.encode(state, m.quorum);
      signerArray.encode(state, m.signers);
      if (m.prologue)
        prologue.encode(state, m.prologue);
      if (m.linked)
        fixed32Array.encode(state, m.linked);
      if (m.userData)
        c.buffer.encode(state, m.userData);
    },
    decode(state) {
      const version = c.uint.decode(state);
      if (version === 0)
        return manifestv0.decode(state);
      if (version > 2)
        throw new Error("Unknown version: " + version);
      const flags = c.uint.decode(state);
      const hash = hashes.decode(state);
      const quorum = c.uint.decode(state);
      const signers = signerArray.decode(state);
      const hasPatch = (flags & MANIFEST_PATCH) !== 0;
      const hasPrologue = (flags & MANIFEST_PROLOGUE) !== 0;
      const hasLinked = (flags & MANIFEST_LINKED) !== 0;
      const hasUserData = (flags & MANIFEST_USER_DATA) !== 0;
      return {
        version,
        hash,
        allowPatch: hasPatch,
        quorum,
        signers,
        prologue: hasPrologue ? prologue.decode(state) : null,
        linked: hasLinked ? fixed32Array.decode(state) : null,
        userData: hasUserData ? c.buffer.decode(state) : null
      };
    }
  };
  var node = {
    preencode(state, n) {
      c.uint.preencode(state, n.index);
      c.uint.preencode(state, n.size);
      c.fixed32.preencode(state, n.hash);
    },
    encode(state, n) {
      c.uint.encode(state, n.index);
      c.uint.encode(state, n.size);
      c.fixed32.encode(state, n.hash);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        size: c.uint.decode(state),
        hash: c.fixed32.decode(state)
      };
    }
  };
  var nodeArray = c.array(node);
  var wire = exports.wire = {};
  wire.handshake = {
    preencode(state, m) {
      c.uint.preencode(state, 1);
      c.fixed32.preencode(state, m.capability);
    },
    encode(state, m) {
      c.uint.encode(state, m.seeks ? 1 : 0);
      c.fixed32.encode(state, m.capability);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        seeks: (flags & 1) !== 0,
        capability: unslab(c.fixed32.decode(state))
      };
    }
  };
  var requestBlock = {
    preencode(state, b) {
      c.uint.preencode(state, b.index);
      c.uint.preencode(state, b.nodes);
    },
    encode(state, b) {
      c.uint.encode(state, b.index);
      c.uint.encode(state, b.nodes);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        nodes: c.uint.decode(state)
      };
    }
  };
  var requestSeek = {
    preencode(state, s) {
      c.uint.preencode(state, s.bytes);
      c.uint.preencode(state, s.padding);
    },
    encode(state, s) {
      c.uint.encode(state, s.bytes);
      c.uint.encode(state, s.padding);
    },
    decode(state) {
      return {
        bytes: c.uint.decode(state),
        padding: c.uint.decode(state)
      };
    }
  };
  var requestUpgrade = {
    preencode(state, u) {
      c.uint.preencode(state, u.start);
      c.uint.preencode(state, u.length);
    },
    encode(state, u) {
      c.uint.encode(state, u.start);
      c.uint.encode(state, u.length);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  wire.request = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.id);
      c.uint.preencode(state, m.fork);
      if (m.block)
        requestBlock.preencode(state, m.block);
      if (m.hash)
        requestBlock.preencode(state, m.hash);
      if (m.seek)
        requestSeek.preencode(state, m.seek);
      if (m.upgrade)
        requestUpgrade.preencode(state, m.upgrade);
      if (m.priority)
        c.uint.preencode(state, m.priority);
    },
    encode(state, m) {
      const flags = (m.block ? 1 : 0) | (m.hash ? 2 : 0) | (m.seek ? 4 : 0) | (m.upgrade ? 8 : 0) | (m.manifest ? 16 : 0) | (m.priority ? 32 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.id);
      c.uint.encode(state, m.fork);
      if (m.block)
        requestBlock.encode(state, m.block);
      if (m.hash)
        requestBlock.encode(state, m.hash);
      if (m.seek)
        requestSeek.encode(state, m.seek);
      if (m.upgrade)
        requestUpgrade.encode(state, m.upgrade);
      if (m.priority)
        c.uint.encode(state, m.priority);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        id: c.uint.decode(state),
        fork: c.uint.decode(state),
        block: flags & 1 ? requestBlock.decode(state) : null,
        hash: flags & 2 ? requestBlock.decode(state) : null,
        seek: flags & 4 ? requestSeek.decode(state) : null,
        upgrade: flags & 8 ? requestUpgrade.decode(state) : null,
        manifest: (flags & 16) !== 0,
        priority: flags & 32 ? c.uint.decode(state) : 0
      };
    }
  };
  wire.cancel = {
    preencode(state, m) {
      c.uint.preencode(state, m.request);
    },
    encode(state, m) {
      c.uint.encode(state, m.request);
    },
    decode(state, m) {
      return {
        request: c.uint.decode(state)
      };
    }
  };
  var dataUpgrade = {
    preencode(state, u) {
      c.uint.preencode(state, u.start);
      c.uint.preencode(state, u.length);
      nodeArray.preencode(state, u.nodes);
      nodeArray.preencode(state, u.additionalNodes);
      c.buffer.preencode(state, u.signature);
    },
    encode(state, u) {
      c.uint.encode(state, u.start);
      c.uint.encode(state, u.length);
      nodeArray.encode(state, u.nodes);
      nodeArray.encode(state, u.additionalNodes);
      c.buffer.encode(state, u.signature);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state),
        nodes: nodeArray.decode(state),
        additionalNodes: nodeArray.decode(state),
        signature: c.buffer.decode(state)
      };
    }
  };
  var dataSeek = {
    preencode(state, s) {
      c.uint.preencode(state, s.bytes);
      nodeArray.preencode(state, s.nodes);
    },
    encode(state, s) {
      c.uint.encode(state, s.bytes);
      nodeArray.encode(state, s.nodes);
    },
    decode(state) {
      return {
        bytes: c.uint.decode(state),
        nodes: nodeArray.decode(state)
      };
    }
  };
  var dataBlock = {
    preencode(state, b) {
      c.uint.preencode(state, b.index);
      c.buffer.preencode(state, b.value);
      nodeArray.preencode(state, b.nodes);
    },
    encode(state, b) {
      c.uint.encode(state, b.index);
      c.buffer.encode(state, b.value);
      nodeArray.encode(state, b.nodes);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        value: c.buffer.decode(state) || EMPTY,
        nodes: nodeArray.decode(state)
      };
    }
  };
  var dataHash = {
    preencode(state, b) {
      c.uint.preencode(state, b.index);
      nodeArray.preencode(state, b.nodes);
    },
    encode(state, b) {
      c.uint.encode(state, b.index);
      nodeArray.encode(state, b.nodes);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        nodes: nodeArray.decode(state)
      };
    }
  };
  wire.data = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.request);
      c.uint.preencode(state, m.fork);
      if (m.block)
        dataBlock.preencode(state, m.block);
      if (m.hash)
        dataHash.preencode(state, m.hash);
      if (m.seek)
        dataSeek.preencode(state, m.seek);
      if (m.upgrade)
        dataUpgrade.preencode(state, m.upgrade);
      if (m.manifest)
        manifest.preencode(state, m.manifest);
    },
    encode(state, m) {
      const flags = (m.block ? 1 : 0) | (m.hash ? 2 : 0) | (m.seek ? 4 : 0) | (m.upgrade ? 8 : 0) | (m.manifest ? 16 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.request);
      c.uint.encode(state, m.fork);
      if (m.block)
        dataBlock.encode(state, m.block);
      if (m.hash)
        dataHash.encode(state, m.hash);
      if (m.seek)
        dataSeek.encode(state, m.seek);
      if (m.upgrade)
        dataUpgrade.encode(state, m.upgrade);
      if (m.manifest)
        manifest.encode(state, m.manifest);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        request: c.uint.decode(state),
        fork: c.uint.decode(state),
        block: flags & 1 ? dataBlock.decode(state) : null,
        hash: flags & 2 ? dataHash.decode(state) : null,
        seek: flags & 4 ? dataSeek.decode(state) : null,
        upgrade: flags & 8 ? dataUpgrade.decode(state) : null,
        manifest: flags & 16 ? manifest.decode(state) : null
      };
    }
  };
  wire.noData = {
    preencode(state, m) {
      c.uint.preencode(state, m.request);
    },
    encode(state, m) {
      c.uint.encode(state, m.request);
    },
    decode(state, m) {
      return {
        request: c.uint.decode(state)
      };
    }
  };
  wire.want = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  wire.unwant = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint.encode(state, m.length);
    },
    decode(state, m) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  wire.range = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.start);
      if (m.length !== 1)
        c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, (m.drop ? 1 : 0) | (m.length === 1 ? 2 : 0));
      c.uint.encode(state, m.start);
      if (m.length !== 1)
        c.uint.encode(state, m.length);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        drop: (flags & 1) !== 0,
        start: c.uint.decode(state),
        length: (flags & 2) !== 0 ? 1 : c.uint.decode(state)
      };
    }
  };
  wire.bitfield = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint32array.preencode(state, m.bitfield);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint32array.encode(state, m.bitfield);
    },
    decode(state, m) {
      return {
        start: c.uint.decode(state),
        bitfield: c.uint32array.decode(state)
      };
    }
  };
  wire.sync = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.fork);
      c.uint.preencode(state, m.length);
      c.uint.preencode(state, m.remoteLength);
    },
    encode(state, m) {
      c.uint.encode(state, (m.canUpgrade ? 1 : 0) | (m.uploading ? 2 : 0) | (m.downloading ? 4 : 0) | (m.hasManifest ? 8 : 0));
      c.uint.encode(state, m.fork);
      c.uint.encode(state, m.length);
      c.uint.encode(state, m.remoteLength);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        fork: c.uint.decode(state),
        length: c.uint.decode(state),
        remoteLength: c.uint.decode(state),
        canUpgrade: (flags & 1) !== 0,
        uploading: (flags & 2) !== 0,
        downloading: (flags & 4) !== 0,
        hasManifest: (flags & 8) !== 0
      };
    }
  };
  wire.reorgHint = {
    preencode(state, m) {
      c.uint.preencode(state, m.from);
      c.uint.preencode(state, m.to);
      c.uint.preencode(state, m.ancestors);
    },
    encode(state, m) {
      c.uint.encode(state, m.from);
      c.uint.encode(state, m.to);
      c.uint.encode(state, m.ancestors);
    },
    decode(state) {
      return {
        from: c.uint.encode(state),
        to: c.uint.encode(state),
        ancestors: c.uint.encode(state)
      };
    }
  };
  wire.extension = {
    preencode(state, m) {
      c.string.preencode(state, m.name);
      c.raw.preencode(state, m.message);
    },
    encode(state, m) {
      c.string.encode(state, m.name);
      c.raw.encode(state, m.message);
    },
    decode(state) {
      return {
        name: c.string.decode(state),
        message: c.raw.decode(state)
      };
    }
  };
  var keyValue = {
    preencode(state, p) {
      c.string.preencode(state, p.key);
      c.buffer.preencode(state, p.value);
    },
    encode(state, p) {
      c.string.encode(state, p.key);
      c.buffer.encode(state, p.value);
    },
    decode(state) {
      return {
        key: c.string.decode(state),
        value: c.buffer.decode(state)
      };
    }
  };
  var treeUpgrade = {
    preencode(state, u) {
      c.uint.preencode(state, u.fork);
      c.uint.preencode(state, u.ancestors);
      c.uint.preencode(state, u.length);
      c.buffer.preencode(state, u.signature);
    },
    encode(state, u) {
      c.uint.encode(state, u.fork);
      c.uint.encode(state, u.ancestors);
      c.uint.encode(state, u.length);
      c.buffer.encode(state, u.signature);
    },
    decode(state) {
      return {
        fork: c.uint.decode(state),
        ancestors: c.uint.decode(state),
        length: c.uint.decode(state),
        signature: c.buffer.decode(state)
      };
    }
  };
  var bitfieldUpdate = {
    preencode(state, b) {
      state.end++;
      c.uint.preencode(state, b.start);
      c.uint.preencode(state, b.length);
    },
    encode(state, b) {
      state.buffer[state.start++] = b.drop ? 1 : 0;
      c.uint.encode(state, b.start);
      c.uint.encode(state, b.length);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        drop: (flags & 1) !== 0,
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var oplog = exports.oplog = {};
  oplog.entry = {
    preencode(state, m) {
      state.end++;
      if (m.userData)
        keyValue.preencode(state, m.userData);
      if (m.treeNodes)
        nodeArray.preencode(state, m.treeNodes);
      if (m.treeUpgrade)
        treeUpgrade.preencode(state, m.treeUpgrade);
      if (m.bitfield)
        bitfieldUpdate.preencode(state, m.bitfield);
    },
    encode(state, m) {
      const s = state.start++;
      let flags = 0;
      if (m.userData) {
        flags |= 1;
        keyValue.encode(state, m.userData);
      }
      if (m.treeNodes) {
        flags |= 2;
        nodeArray.encode(state, m.treeNodes);
      }
      if (m.treeUpgrade) {
        flags |= 4;
        treeUpgrade.encode(state, m.treeUpgrade);
      }
      if (m.bitfield) {
        flags |= 8;
        bitfieldUpdate.encode(state, m.bitfield);
      }
      state.buffer[s] = flags;
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        userData: (flags & 1) !== 0 ? keyValue.decode(state) : null,
        treeNodes: (flags & 2) !== 0 ? nodeArray.decode(state) : null,
        treeUpgrade: (flags & 4) !== 0 ? treeUpgrade.decode(state) : null,
        bitfield: (flags & 8) !== 0 ? bitfieldUpdate.decode(state) : null
      };
    }
  };
  var keyPair = {
    preencode(state, kp) {
      c.buffer.preencode(state, kp.publicKey);
      c.buffer.preencode(state, kp.secretKey);
    },
    encode(state, kp) {
      c.buffer.encode(state, kp.publicKey);
      c.buffer.encode(state, kp.secretKey);
    },
    decode(state) {
      return {
        publicKey: c.buffer.decode(state),
        secretKey: c.buffer.decode(state)
      };
    }
  };
  var reorgHint = {
    preencode(state, r) {
      c.uint.preencode(state, r.from);
      c.uint.preencode(state, r.to);
      c.uint.preencode(state, r.ancestors);
    },
    encode(state, r) {
      c.uint.encode(state, r.from);
      c.uint.encode(state, r.to);
      c.uint.encode(state, r.ancestors);
    },
    decode(state) {
      return {
        from: c.uint.decode(state),
        to: c.uint.decode(state),
        ancestors: c.uint.decode(state)
      };
    }
  };
  var reorgHintArray = c.array(reorgHint);
  var hints = {
    preencode(state, h) {
      reorgHintArray.preencode(state, h.reorgs);
      c.uint.preencode(state, h.contiguousLength);
    },
    encode(state, h) {
      reorgHintArray.encode(state, h.reorgs);
      c.uint.encode(state, h.contiguousLength);
    },
    decode(state) {
      return {
        reorgs: reorgHintArray.decode(state),
        contiguousLength: state.start < state.end ? c.uint.decode(state) : 0
      };
    }
  };
  var treeHeader = {
    preencode(state, t) {
      c.uint.preencode(state, t.fork);
      c.uint.preencode(state, t.length);
      c.buffer.preencode(state, t.rootHash);
      c.buffer.preencode(state, t.signature);
    },
    encode(state, t) {
      c.uint.encode(state, t.fork);
      c.uint.encode(state, t.length);
      c.buffer.encode(state, t.rootHash);
      c.buffer.encode(state, t.signature);
    },
    decode(state) {
      return {
        fork: c.uint.decode(state),
        length: c.uint.decode(state),
        rootHash: c.buffer.decode(state),
        signature: c.buffer.decode(state)
      };
    }
  };
  var types = {
    preencode(state, t) {
      c.string.preencode(state, t.tree);
      c.string.preencode(state, t.bitfield);
      c.string.preencode(state, t.signer);
    },
    encode(state, t) {
      c.string.encode(state, t.tree);
      c.string.encode(state, t.bitfield);
      c.string.encode(state, t.signer);
    },
    decode(state) {
      return {
        tree: c.string.decode(state),
        bitfield: c.string.decode(state),
        signer: c.string.decode(state)
      };
    }
  };
  var externalHeader = {
    preencode(state, m) {
      c.uint.preencode(state, m.start);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.uint.encode(state, m.start);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var keyValueArray = c.array(keyValue);
  oplog.header = {
    preencode(state, h) {
      state.end += 2;
      if (h.external) {
        externalHeader.preencode(state, h.external);
        return;
      }
      c.fixed32.preencode(state, h.key);
      if (h.manifest)
        manifest.preencode(state, h.manifest);
      if (h.keyPair)
        keyPair.preencode(state, h.keyPair);
      keyValueArray.preencode(state, h.userData);
      treeHeader.preencode(state, h.tree);
      hints.preencode(state, h.hints);
    },
    encode(state, h) {
      c.uint.encode(state, 1);
      if (h.external) {
        c.uint.encode(state, 1);
        externalHeader.encode(state, h.external);
        return;
      }
      c.uint.encode(state, (h.manifest ? 2 : 0) | (h.keyPair ? 4 : 0));
      c.fixed32.encode(state, h.key);
      if (h.manifest)
        manifest.encode(state, h.manifest);
      if (h.keyPair)
        keyPair.encode(state, h.keyPair);
      keyValueArray.encode(state, h.userData);
      treeHeader.encode(state, h.tree);
      hints.encode(state, h.hints);
    },
    decode(state) {
      const version = c.uint.decode(state);
      if (version > 1) {
        throw INVALID_OPLOG_VERSION("Invalid header version. Expected <= 1, got " + version);
      }
      if (version === 0) {
        const old = {
          types: types.decode(state),
          userData: keyValueArray.decode(state),
          tree: treeHeader.decode(state),
          signer: keyPair.decode(state),
          hints: hints.decode(state)
        };
        return {
          external: null,
          key: old.signer.publicKey,
          manifest: {
            version: 0,
            hash: old.types.tree,
            allowPatch: false,
            quorum: 1,
            signers: [{
              signature: old.types.signer,
              namespace: DEFAULT_NAMESPACE,
              publicKey: old.signer.publicKey
            }],
            prologue: null,
            linked: null,
            userData: null
          },
          keyPair: old.signer.secretKey ? old.signer : null,
          userData: old.userData,
          tree: old.tree,
          hints: old.hints
        };
      }
      const flags = c.uint.decode(state);
      if (flags & 1) {
        return {
          external: externalHeader.decode(state),
          key: null,
          manifest: null,
          keyPair: null,
          userData: null,
          tree: null,
          hints: null
        };
      }
      return {
        external: null,
        key: c.fixed32.decode(state),
        manifest: (flags & 2) !== 0 ? manifest.decode(state) : null,
        keyPair: (flags & 4) !== 0 ? keyPair.decode(state) : null,
        userData: keyValueArray.decode(state),
        tree: treeHeader.decode(state),
        hints: hints.decode(state)
      };
    }
  };
  var uintArray = c.array(c.uint);
  var multisigInput = {
    preencode(state, inp) {
      c.uint.preencode(state, inp.signer);
      c.fixed64.preencode(state, inp.signature);
      c.uint.preencode(state, inp.patch);
    },
    encode(state, inp) {
      c.uint.encode(state, inp.signer);
      c.fixed64.encode(state, inp.signature);
      c.uint.encode(state, inp.patch);
    },
    decode(state) {
      return {
        signer: c.uint.decode(state),
        signature: c.fixed64.decode(state),
        patch: c.uint.decode(state)
      };
    }
  };
  var patchEncodingv0 = {
    preencode(state, n) {
      c.uint.preencode(state, n.start);
      c.uint.preencode(state, n.length);
      uintArray.preencode(state, n.nodes);
    },
    encode(state, n) {
      c.uint.encode(state, n.start);
      c.uint.encode(state, n.length);
      uintArray.encode(state, n.nodes);
    },
    decode(state) {
      return {
        start: c.uint.decode(state),
        length: c.uint.decode(state),
        nodes: uintArray.decode(state)
      };
    }
  };
  var multisigInputv0 = {
    preencode(state, n) {
      state.end++;
      c.uint.preencode(state, n.signer);
      c.fixed64.preencode(state, n.signature);
      if (n.patch)
        patchEncodingv0.preencode(state, n.patch);
    },
    encode(state, n) {
      c.uint.encode(state, n.patch ? 1 : 0);
      c.uint.encode(state, n.signer);
      c.fixed64.encode(state, n.signature);
      if (n.patch)
        patchEncodingv0.encode(state, n.patch);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        signer: c.uint.decode(state),
        signature: c.fixed64.decode(state),
        patch: flags & 1 ? patchEncodingv0.decode(state) : null
      };
    }
  };
  var multisigInputArrayv0 = c.array(multisigInputv0);
  var multisigInputArray = c.array(multisigInput);
  var compactNode = {
    preencode(state, n) {
      c.uint.preencode(state, n.index);
      c.uint.preencode(state, n.size);
      c.fixed32.preencode(state, n.hash);
    },
    encode(state, n) {
      c.uint.encode(state, n.index);
      c.uint.encode(state, n.size);
      c.fixed32.encode(state, n.hash);
    },
    decode(state) {
      return {
        index: c.uint.decode(state),
        size: c.uint.decode(state),
        hash: c.fixed32.decode(state)
      };
    }
  };
  var compactNodeArray = c.array(compactNode);
  exports.multiSignaturev0 = {
    preencode(state, s) {
      multisigInputArrayv0.preencode(state, s.proofs);
      compactNodeArray.preencode(state, s.patch);
    },
    encode(state, s) {
      multisigInputArrayv0.encode(state, s.proofs);
      compactNodeArray.encode(state, s.patch);
    },
    decode(state) {
      return {
        proofs: multisigInputArrayv0.decode(state),
        patch: compactNodeArray.decode(state)
      };
    }
  };
  exports.multiSignature = {
    preencode(state, s) {
      multisigInputArray.preencode(state, s.proofs);
      compactNodeArray.preencode(state, s.patch);
    },
    encode(state, s) {
      multisigInputArray.encode(state, s.proofs);
      compactNodeArray.encode(state, s.patch);
    },
    decode(state) {
      return {
        proofs: multisigInputArray.decode(state),
        patch: compactNodeArray.decode(state)
      };
    }
  };
});

// node_modules/hypercore/lib/multisig.js
var require_multisig = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var flat = require_flat_tree();
  var { MerkleTree } = require_merkle_tree();
  var { multiSignature, multiSignaturev0 } = require_messages2();
  module.exports = {
    assemblev0,
    assemble,
    inflatev0,
    inflate,
    partialSignature,
    signableLength
  };
  function inflatev0(data) {
    return c.decode(multiSignaturev0, data);
  }
  function inflate(data) {
    return c.decode(multiSignature, data);
  }
  async function partialSignature(core, signer, from, to = core.state.length, signature = core.state.signature) {
    if (from > core.state.length)
      return null;
    const nodes = to <= from ? null : await upgradeNodes(core, from, to);
    if (signature.byteLength !== 64)
      signature = c.decode(multiSignature, signature).proofs[0].signature;
    return {
      signer,
      signature,
      patch: nodes ? to - from : 0,
      nodes
    };
  }
  async function upgradeNodes(core, from, to) {
    const rx = core.state.storage.read();
    const p = await MerkleTree.proof(core.state, rx, { upgrade: { start: from, length: to - from } });
    rx.tryFlush();
    return (await p.settle()).upgrade.nodes;
  }
  function signableLength(lengths, quorum) {
    if (quorum <= 0)
      quorum = 1;
    if (quorum > lengths.length)
      return 0;
    return lengths.sort(cmp)[quorum - 1];
  }
  function cmp(a, b) {
    return b - a;
  }
  function assemblev0(inputs) {
    const proofs = [];
    const patch = [];
    for (const u of inputs) {
      proofs.push(compressProof(u, patch));
    }
    return c.encode(multiSignaturev0, { proofs, patch });
  }
  function assemble(inputs) {
    const proofs = [];
    const patch = [];
    const seen = new Set;
    for (const u of inputs) {
      if (u.nodes) {
        for (const node of u.nodes) {
          if (seen.has(node.index))
            continue;
          seen.add(node.index);
          patch.push(node);
        }
      }
      proofs.push({
        signer: u.signer,
        signature: u.signature,
        patch: u.patch
      });
    }
    return c.encode(multiSignature, { proofs, patch });
  }
  function compareNode(a, b) {
    if (a.index !== b.index)
      return false;
    if (a.size !== b.size)
      return false;
    return b4a.equals(a.hash, b.hash);
  }
  function compressProof(proof, nodes) {
    return {
      signer: proof.signer,
      signature: proof.signature,
      patch: proof.patch ? compressUpgrade(proof, nodes) : null
    };
  }
  function compressUpgrade(p, nodes) {
    const u = {
      start: flat.rightSpan(p.nodes[p.nodes.length - 1].index) / 2 + 1,
      length: p.patch,
      nodes: []
    };
    for (const node of p.nodes) {
      let present = false;
      for (let i = 0;i < nodes.length; i++) {
        if (!compareNode(nodes[i], node))
          continue;
        u.nodes.push(i);
        present = true;
        break;
      }
      if (present)
        continue;
      u.nodes.push(nodes.push(node) - 1);
    }
    return u;
  }
});

// node_modules/hypercore/lib/verifier.js
var require_verifier = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var flat = require_flat_tree();
  var { BAD_ARGUMENT } = require_hypercore_errors();
  var unslab = require_unslab();
  var m = require_messages2();
  var multisig = require_multisig();
  var caps = require_caps();

  class Signer {
    constructor(manifestHash2, version, index, { signature = "ed25519", publicKey, namespace = caps.DEFAULT_NAMESPACE } = {}) {
      if (!publicKey)
        throw BAD_ARGUMENT("public key is required for a signer");
      if (signature !== "ed25519")
        throw BAD_ARGUMENT("Only Ed25519 signatures are supported");
      this.manifestHash = manifestHash2;
      this.version = version;
      this.signer = index;
      this.signature = signature;
      this.publicKey = publicKey;
      this.namespace = namespace;
    }
    _ctx() {
      return this.version === 0 ? this.namespace : this.manifestHash;
    }
    verify(batch, signature) {
      return crypto.verify(batch.signable(this._ctx()), signature, this.publicKey);
    }
    sign(batch, keyPair) {
      return crypto.sign(batch.signable(this._ctx()), keyPair.secretKey);
    }
  }

  class CompatSigner extends Signer {
    constructor(index, signer, legacy) {
      super(null, 0, index, signer);
      this.legacy = legacy;
    }
    verify(batch, signature) {
      return crypto.verify(batch.signableCompat(this.legacy), signature, this.publicKey);
    }
    sign(batch, keyPair) {
      return crypto.sign(batch.signableCompat(this.legacy), keyPair.secretKey);
    }
  }
  module.exports = class Verifier {
    constructor(manifestHash2, manifest, { compat = isCompat(manifestHash2, manifest), legacy = false } = {}) {
      const self = this;
      this.manifestHash = manifestHash2;
      this.compat = compat || manifest === null;
      this.version = this.compat ? 0 : typeof manifest.version === "number" ? manifest.version : 1;
      this.hash = manifest.hash || "blake2b";
      this.allowPatch = !this.compat && !!manifest.allowPatch;
      this.quorum = this.compat ? 1 : defaultQuorum(manifest);
      this.signers = manifest.signers ? manifest.signers.map(createSigner) : [];
      this.prologue = this.compat ? null : manifest.prologue || null;
      function createSigner(signer, index) {
        return self.compat ? new CompatSigner(index, signer, legacy) : new Signer(manifestHash2, self.version, index, signer);
      }
    }
    _verifyCompat(batch, signature) {
      if (!signature)
        return false;
      if (this.compat || !this.allowPatch && this.signers.length === 1) {
        return !!signature && this.signers[0].verify(batch, signature);
      }
      return this._verifyMulti(batch, signature);
    }
    _inflate(signature) {
      if (this.version >= 1)
        return multisig.inflate(signature);
      const { proofs, patch } = multisig.inflatev0(signature);
      return {
        proofs: proofs.map(proofToVersion1),
        patch
      };
    }
    _verifyMulti(batch, signature) {
      if (!signature || this.quorum === 0)
        return false;
      const { proofs, patch } = this._inflate(signature);
      if (proofs.length < this.quorum)
        return false;
      const tried = new Uint8Array(this.signers.length);
      const nodes = this.allowPatch && patch.length ? toMap(patch) : null;
      for (let i = 0;i < this.quorum; i++) {
        const inp = proofs[i];
        let tree = batch;
        if (inp.patch && this.allowPatch) {
          tree = batch.clone();
          const upgrade = generateUpgrade(nodes, batch.length, inp.patch);
          const proof = { fork: tree.fork, block: null, hash: null, seek: null, upgrade, manifest: null };
          try {
            if (!tree.verifyUpgrade(proof))
              return false;
          } catch {
            return false;
          }
        }
        if (inp.signer >= this.signers.length || tried[inp.signer])
          return false;
        tried[inp.signer] = 1;
        const s = this.signers[inp.signer];
        if (!s.verify(tree, inp.signature))
          return false;
      }
      return true;
    }
    verify(batch, signature) {
      if (this.version === 0) {
        return this._verifyCompat(batch, signature);
      }
      if (this.prologue !== null && batch.length <= this.prologue.length) {
        return batch.length === this.prologue.length && b4a.equals(batch.hash(), this.prologue.hash);
      }
      return this._verifyMulti(batch, signature);
    }
    sign(batch, keyPair) {
      if (!keyPair || !keyPair.secretKey)
        throw BAD_ARGUMENT("No key pair was passed");
      for (const s of this.signers) {
        if (b4a.equals(s.publicKey, keyPair.publicKey)) {
          const signature = s.sign(batch, keyPair);
          if (this.signers.length !== 1 || this.version === 0)
            return signature;
          return this.assemble([{ signer: 0, signature, patch: 0, nodes: null }]);
        }
      }
      throw BAD_ARGUMENT("Public key is not a declared signer");
    }
    assemble(inputs) {
      return this.version === 0 ? multisig.assemblev0(inputs) : multisig.assemble(inputs);
    }
    static manifestHash(manifest) {
      return manifestHash(manifest);
    }
    static encodeManifest(manifest) {
      return c.encode(m.manifest, manifest);
    }
    static decodeManifest(manifest) {
      return c.decode(m.manifest, manifest);
    }
    static defaultSignerManifest(publicKey) {
      return {
        version: 1,
        hash: "blake2b",
        allowPatch: false,
        quorum: 1,
        signers: [{
          signature: "ed25519",
          namespace: caps.DEFAULT_NAMESPACE,
          publicKey
        }],
        prologue: null,
        linked: null,
        userData: null
      };
    }
    static fromManifest(manifest, opts) {
      const m2 = this.createManifest(manifest);
      return new this(manifestHash(m2), m2, opts);
    }
    static createManifest(inp) {
      if (!inp)
        return null;
      const manifest = {
        version: getManifestVersion(inp),
        hash: "blake2b",
        allowPatch: !!inp.allowPatch,
        quorum: defaultQuorum(inp),
        signers: inp.signers ? inp.signers.map(parseSigner) : [],
        prologue: null,
        linked: null,
        userData: inp.userData || null
      };
      if (inp.hash && inp.hash !== "blake2b")
        throw BAD_ARGUMENT("Only Blake2b hashes are supported");
      if (inp.prologue) {
        if (!(b4a.isBuffer(inp.prologue.hash) && inp.prologue.hash.byteLength === 32) || !(inp.prologue.length >= 0)) {
          throw BAD_ARGUMENT("Invalid prologue");
        }
        manifest.prologue = inp.prologue;
        manifest.prologue.hash = unslab(manifest.prologue.hash);
      }
      if (manifest.userData !== null && manifest.version < 2) {
        throw BAD_ARGUMENT("Invalid field: userData");
      }
      if (inp.linked && inp.linked.length) {
        if (manifest.version < 2)
          throw BAD_ARGUMENT("Invalid field: linked");
        for (const key of inp.linked) {
          if (!(b4a.isBuffer(key) && key.byteLength === 32)) {
            throw BAD_ARGUMENT("Invalid key");
          }
        }
        manifest.linked = inp.linked;
      }
      return manifest;
    }
    static isValidManifest(key, manifest) {
      return b4a.equals(key, manifestHash(manifest));
    }
    static isCompat(key, manifest) {
      return isCompat(key, manifest);
    }
    static sign(manifest, batch, keyPair, opts) {
      return Verifier.fromManifest(manifest, opts).sign(batch, keyPair);
    }
  };
  function toMap(nodes) {
    const m2 = new Map;
    for (const node of nodes)
      m2.set(node.index, node);
    return m2;
  }
  function isCompat(key, manifest) {
    return !!(manifest && manifest.signers.length === 1 && b4a.equals(key, manifest.signers[0].publicKey));
  }
  function defaultQuorum(man) {
    if (typeof man.quorum === "number")
      return man.quorum;
    if (!man.signers || !man.signers.length)
      return 0;
    return (man.signers.length >> 1) + 1;
  }
  function generateUpgrade(patch, start, length) {
    const upgrade = { start, length, nodes: null, additionalNodes: [], signature: null };
    const from = start * 2;
    const to = from + length * 2;
    for (const ite = flat.iterator(0);ite.fullRoot(to); ite.nextTree()) {
      if (ite.index + ite.factor / 2 < from)
        continue;
      if (upgrade.nodes === null && ite.contains(from - 2)) {
        upgrade.nodes = [];
        const root = ite.index;
        const target = from - 2;
        ite.seek(target);
        while (ite.index !== root) {
          ite.sibling();
          if (ite.index > target)
            upgrade.nodes.push(patch.get(ite.index));
          ite.parent();
        }
        continue;
      }
      if (upgrade.nodes === null)
        upgrade.nodes = [];
      upgrade.nodes.push(patch.get(ite.index));
    }
    if (upgrade.nodes === null)
      upgrade.nodes = [];
    return upgrade;
  }
  function parseSigner(signer) {
    validateSigner(signer);
    return {
      signature: "ed25519",
      namespace: unslab(signer.namespace || caps.DEFAULT_NAMESPACE),
      publicKey: unslab(signer.publicKey)
    };
  }
  function validateSigner(signer) {
    if (!signer || !signer.publicKey)
      throw BAD_ARGUMENT("Signer missing public key");
    if (signer.signature && signer.signature !== "ed25519")
      throw BAD_ARGUMENT("Only Ed25519 signatures are supported");
  }
  function manifestHash(manifest) {
    const state = { start: 0, end: 32, buffer: null };
    m.manifest.preencode(state, manifest);
    state.buffer = b4a.allocUnsafe(state.end);
    c.raw.encode(state, caps.MANIFEST);
    m.manifest.encode(state, manifest);
    return crypto.hash(state.buffer);
  }
  function proofToVersion1(proof) {
    return {
      signer: proof.signer,
      signature: proof.signature,
      patch: proof.patch ? proof.patch.length : 0
    };
  }
  function getManifestVersion(inp) {
    if (typeof inp.version === "number")
      return inp.version;
    if (inp.linked && inp.linked.length)
      return 2;
    if (inp.userData)
      return 2;
    return 1;
  }
});

// node_modules/hypercore/lib/audit.js
var require_audit = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var flat = require_flat_tree();
  var b4a = require_b4a();
  var { MerkleTree } = require_merkle_tree();
  module.exports = async function auditCore(core, { tree = true, blocks = true, bitfield = true, dryRun = false } = {}) {
    const length = core.state.length;
    const stats = { treeNodes: 0, blocks: 0, bits: 0, droppedTreeNodes: 0, droppedBlocks: 0, droppedBits: 0, corrupt: false };
    if (tree) {
      let tx = null;
      const roots = await MerkleTree.getRootsFromStorage(core.state.storage, length);
      const stack = [];
      for (const r of roots) {
        if (r === null) {
          if (!dryRun) {
            const storage = core.state.storage;
            await storage.store.deleteCore(storage.core);
            return null;
          }
          stats.corrupt = true;
        }
        stack.push(r);
      }
      stats.treeNodes += roots.length;
      while (stack.length > 0) {
        const node = stack.pop();
        if ((node.index & 1) === 0)
          continue;
        const [left, right] = flat.children(node.index);
        const rx = core.state.storage.read();
        const leftNodePromise = rx.getTreeNode(left);
        const rightNodePromise = rx.getTreeNode(right);
        rx.tryFlush();
        const [leftNode, rightNode] = await Promise.all([leftNodePromise, rightNodePromise]);
        if (isBadTree(node, leftNode, rightNode)) {
          if (!tx && !stats.corrupt)
            tx = core.state.storage.write();
          const [l, r] = flat.spans(node.index);
          tx.deleteTreeNodeRange(l, r + 1);
          stats.droppedTreeNodes++;
          continue;
        }
        if (!leftNode)
          continue;
        stats.treeNodes += 2;
        stack.push(leftNode, rightNode);
      }
      if (tx && !dryRun)
        await tx.flush();
    }
    if (blocks) {
      let tx = null;
      for await (const block of core.state.storage.createBlockStream()) {
        if (!core.bitfield.get(block.index)) {
          if (!tx && !stats.corrupt)
            tx = core.state.storage.write();
          tx.deleteBlock(block.index);
          stats.droppedBlocks++;
        }
        const rx = core.state.storage.read();
        const treeNodePromise = rx.getTreeNode(2 * block.index);
        rx.tryFlush();
        const treeNode = await treeNodePromise;
        if (isBadBlock(treeNode, block.value)) {
          if (!tx && !stats.corrupt)
            tx = core.state.storage.write();
          tx.deleteBlock(block.index);
          stats.droppedBlocks++;
          continue;
        }
        stats.blocks++;
      }
      if (tx && !dryRun)
        await tx.flush();
    }
    if (bitfield) {
      let tx = null;
      for (const index of allBits(core.bitfield)) {
        const rx = core.state.storage.read();
        const blockPromise = rx.getBlock(index);
        rx.tryFlush();
        const block = await blockPromise;
        if (!block) {
          stats.droppedBits++;
          if (dryRun)
            continue;
          if (!tx && !stats.corrupt)
            tx = core.state.storage.write();
          core.bitfield.set(index, false);
          const page = core.bitfield.getBitfield(index);
          if (page.bitfield)
            tx.setBitfieldPage(page.index, page.bitfield);
          else
            tx.deleteBitfieldPage(page.idnex);
          continue;
        }
        stats.bits++;
      }
      if (tx && !dryRun)
        await tx.flush();
    }
    return stats;
  };
  function isBadBlock(node, block) {
    if (!node)
      return true;
    const hash = crypto.data(block);
    return !b4a.equals(hash, node.hash) || node.size !== block.byteLength;
  }
  function isBadTree(parent, left, right) {
    if (!left && !right)
      return false;
    if (!left || !right)
      return true;
    const hash = crypto.parent(left, right);
    return !b4a.equals(hash, parent.hash) || parent.size !== left.size + right.size;
  }
  function* allBits(bitfield) {
    let i = 0;
    if (bitfield.get(0))
      yield 0;
    while (true) {
      i = bitfield.findFirst(true, i + 1);
      if (i === -1)
        break;
      yield i;
    }
  }
});

// node_modules/hypercore/lib/copy-prologue.js
var require_copy_prologue = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var flat = require_flat_tree();
  var b4a = require_b4a();
  var quickbit = require_quickbit_universal();
  var Bitfield = require_bitfield();
  var MAX_BATCH_USED = 4 * 1024 * 1024;
  var MIN_BATCH_USED = 512 * 1024;
  module.exports = copyPrologue;
  async function copyPrologue(src, dst) {
    const prologue = dst.header.manifest.prologue;
    if (src.length < prologue.length || prologue.length === 0)
      return;
    const stack = [];
    const roots = flat.fullRoots(prologue.length * 2);
    const batch = { roots, first: true, last: false, contig: 0, used: 0, tree: [], blocks: [] };
    for (let i = 0;i < roots.length; i++) {
      const node = roots[i];
      batch.tree.push(node);
      stack.push(node);
    }
    let lastPage = -1;
    let lastBlock = -1;
    for await (const data of src.storage.createBlockStream({ gte: 0, lt: prologue.length, reverse: true })) {
      if (walkTree(stack, data.index * 2, batch) === false) {
        throw new Error("Missing block or tree node for " + data.index);
      }
      batch.contig = data.index + 1 === lastBlock ? batch.contig + 1 : 1;
      lastBlock = data.index;
      const page = getBitfieldPage(data.index);
      batch.blocks.push(data);
      if (lastPage !== page)
        batch.used += 4096;
      batch.used += Math.max(data.value.byteLength, 128);
      if (batch.used >= MIN_BATCH_USED && page !== lastPage || batch.used >= MAX_BATCH_USED) {
        await flushBatch(prologue, src, dst, batch);
      }
      lastPage = page;
    }
    if (lastBlock !== 0)
      batch.contig = 0;
    batch.last = true;
    await flushBatch(prologue, src, dst, batch);
  }
  async function flushBatch(prologue, src, dst, batch) {
    const nodePromises = [];
    const srcReader = src.storage.read();
    for (const index of batch.tree) {
      nodePromises.push(srcReader.getTreeNode(index));
    }
    srcReader.tryFlush();
    const nodes = await Promise.all(nodePromises);
    const pagePromises = [];
    const dstReader = dst.storage.read();
    const headPromise = batch.first ? dstReader.getHead() : null;
    if (headPromise)
      headPromise.catch(noop);
    let lastPage = -1;
    for (const { index } of batch.blocks) {
      const page = getBitfieldPage(index);
      if (page === lastPage)
        continue;
      lastPage = page;
      pagePromises.push(dstReader.getBitfieldPage(page));
    }
    dstReader.tryFlush();
    const pages = await Promise.all(pagePromises);
    const head = headPromise === null ? null : await headPromise;
    const userData = [];
    if (batch.first) {
      const roots = nodes.slice(0, batch.roots.length);
      for (const node of roots) {
        if (!node)
          throw new Error("Missing nodes for prologue hash");
      }
      const treeHash = crypto.tree(roots);
      if (!b4a.equals(treeHash, prologue.hash))
        throw new Error("Prologue does not match source");
    }
    if (batch.first) {
      for await (const data of src.storage.createUserDataStream())
        userData.push(data);
    }
    for (let i = 0;i < pages.length; i++) {
      if (!pages[i])
        pages[i] = b4a.alloc(4096);
    }
    const tx = dst.storage.write();
    for (const node of nodes)
      tx.putTreeNode(node);
    lastPage = -1;
    let pageIndex = -1;
    for (const { index, value } of batch.blocks) {
      const page = getBitfieldPage(index);
      if (page !== lastPage) {
        lastPage = page;
        pageIndex++;
        tx.putBitfieldPage(pageIndex, pages[pageIndex]);
      }
      const pageBuffer = pages[pageIndex];
      quickbit.set(pageBuffer, getBitfieldOffset(index), true);
      tx.putBlock(index, value);
    }
    for (const { key, value } of userData) {
      tx.putUserData(key, value);
    }
    let upgraded = batch.first && !head;
    if (upgraded) {
      tx.setHead(prologueToTree(prologue));
    }
    await tx.flush();
    if (upgraded) {
      const roots = nodes.slice(0, batch.roots.length);
      dst.state.setRoots(roots);
      dst.header.tree = prologueToTree(prologue);
    }
    if (userData.length > 0) {
      dst.header.userData = userData.concat(dst.header.userData);
    }
    if (batch.contig) {
      dst.header.hints.contiguousLength = batch.contig;
    }
    let start = 0;
    let length = 0;
    for (const { index } of batch.blocks) {
      if (start === 0 || start - 1 === index) {
        length++;
      } else {
        if (length > 0)
          signalReplicator(dst, upgraded, start, length);
        upgraded = false;
        length = 1;
      }
      start = index;
      dst.bitfield.set(index, true);
    }
    if (length > 0)
      signalReplicator(dst, upgraded, start, length);
    batch.tree = [];
    batch.blocks = [];
    batch.first = false;
    batch.used = 0;
  }
  function signalReplicator(core, upgraded, start, length) {
    if (upgraded) {
      core.replicator.cork();
      core.replicator.onhave(start, length, false);
      core.replicator.onupgrade();
      core.replicator.uncork();
    } else {
      core.replicator.onhave(start, length, false);
    }
  }
  function prologueToTree(prologue) {
    return {
      fork: 0,
      length: prologue.length,
      rootHash: prologue.hash,
      signature: null
    };
  }
  function getBitfieldPage(index) {
    return Math.floor(index / Bitfield.BITS_PER_PAGE);
  }
  function getBitfieldOffset(index) {
    return index & Bitfield.BITS_PER_PAGE - 1;
  }
  function walkTree(stack, target, batch) {
    while (stack.length > 0) {
      const node = stack.pop();
      if ((node & 1) === 0) {
        if (node === target)
          return true;
        continue;
      }
      const ite = flat.iterator(node);
      if (!ite.contains(target))
        continue;
      while ((ite.index & 1) !== 0) {
        const left = ite.leftChild();
        const right = ite.sibling();
        batch.tree.push(left, right);
        if (ite.contains(target))
          stack.push(left);
        else
          ite.sibling();
      }
      if (ite.index === target)
        return true;
    }
    return false;
  }
  function noop() {}
});

// node_modules/hypercore/lib/session-state.js
var require_session_state = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var assert = require_nanoassert();
  var flat = require_flat_tree();
  var quickbit = require_quickbit_universal();
  var { INVALID_OPERATION, INVALID_SIGNATURE } = require_hypercore_errors();
  var Mutex = require_mutex();
  var Bitfield = require_bitfield();
  var { MerkleTree, MerkleTreeBatch } = require_merkle_tree();
  module.exports = class SessionState {
    constructor(core, parent, storage, treeInfo, name) {
      this.core = core;
      this.index = this.core.sessionStates.push(this) - 1;
      this.storage = storage;
      this.name = name;
      this.sessions = [];
      this.lingers = null;
      this.parent = parent;
      this.atomized = null;
      this.mutex = new Mutex;
      this.roots = treeInfo.roots.length ? treeInfo.roots : [];
      this.fork = treeInfo.fork || 0;
      this.length = MerkleTree.span(this.roots) / 2;
      this.byteLength = MerkleTree.size(this.roots);
      this.prologue = treeInfo.prologue || null;
      this.signature = treeInfo.signature || null;
      this.snapshotCompatLength = this.isSnapshot() ? Math.min(this.length, this.core.state.length) : -1;
      this.lastTruncation = null;
      this.active = 0;
      this._activeTx = null;
      this._pendingBitfield = null;
      this.ref();
    }
    isSnapshot() {
      return this.storage.snapshotted;
    }
    isDefault() {
      return this.core.state === this || this.isAtomicDefault();
    }
    isAtomicDefault() {
      return !!this.storage.atom && !!this.parent && this.parent.isDefault();
    }
    createTreeBatch() {
      return new MerkleTreeBatch(this);
    }
    addSession(s) {
      if (s._stateIndex !== -1)
        return;
      s._stateIndex = this.sessions.push(s) - 1;
      if (s.weak === false)
        this.core.activeSessions++;
    }
    removeSession(s) {
      if (s._stateIndex === -1)
        return;
      const head = this.sessions.pop();
      if (head !== s)
        this.sessions[head._stateIndex = s._stateIndex] = head;
      s._stateIndex = -1;
      if (s.weak === false)
        this.core.activeSessions--;
      this.core.checkIfIdle();
    }
    flushedLength() {
      if (this.isDefault() || this.isSnapshot())
        return this.length;
      const deps = this.storage.dependencies;
      if (deps.length)
        return deps[deps.length - 1].length;
      return 0;
    }
    signedLength() {
      const l = Math.min(this.flushedLength(), this.core.state.length);
      return this.isSnapshot() && l > this.snapshotCompatLength ? this.snapshotCompatLength : l;
    }
    unref() {
      if (--this.active > 0)
        return;
      this.close().catch(noop);
    }
    ref() {
      this.active++;
      return this;
    }
    hash() {
      return MerkleTree.hash(this);
    }
    setRoots(roots) {
      this.roots = roots;
      this.length = MerkleTree.span(roots) / 2;
      this.byteLength = MerkleTree.size(roots);
    }
    get encryptionFork() {
      return this.core.header.tree.fork;
    }
    async updateSnapshotStorage(storage) {
      if (!this.atomized || !this.atomized.flushing)
        return this.treeInfo();
      await this.atomized.flushed();
      let rx = storage.read();
      const headPromise = rx.getHead();
      const authPromise = rx.getAuth();
      const depPromise = rx.getDependency();
      rx.tryFlush();
      const [head, auth, dep] = await Promise.all([headPromise, authPromise, depPromise]);
      storage.setDependencyHead(dep);
      const fork = head ? head.fork : 0;
      const length = head ? head.length : 0;
      rx = storage.read();
      const rootPromises = [];
      for (const r of flat.fullRoots(length * 2)) {
        rootPromises.push(rx.getTreeNode(r));
      }
      rx.tryFlush();
      const roots = await Promise.all(rootPromises);
      for (const root of roots) {
        if (root === null) {
          throw new Error("Bad snapshot from atomized session, id = " + this.core.id + " length = " + length + " fork = " + fork);
        }
      }
      return {
        fork,
        roots,
        length,
        prologue: auth.manifest && auth.manifest.prologue,
        signature: head && head.signature
      };
    }
    treeInfo() {
      return {
        fork: this.fork,
        roots: this.roots.slice(),
        length: this.length,
        prologue: this.prologue,
        signature: this.signature
      };
    }
    async close() {
      if (this.index === -1)
        return;
      this.active = 0;
      this.mutex.destroy(new Error("Closed")).catch(noop);
      if (this.parent && this.parent.atomized)
        this.parent.atomized = null;
      const closing = this.storage.close();
      const head = this.core.sessionStates.pop();
      if (head !== this)
        this.core.sessionStates[head.index = this.index] = head;
      this.index = -1;
      this.core.checkIfIdle();
      if (this.lingers !== null) {
        for (const storage of this.lingers)
          await storage.close();
      }
      return closing;
    }
    async snapshot() {
      const storage = this.storage.snapshot();
      const treeInfo = await this.updateSnapshotStorage(storage);
      const s = new SessionState(this.core, null, storage, treeInfo, this.name);
      return s;
    }
    updateDependency(tx, length) {
      const dependency = updateDependency(this, length, false);
      if (dependency)
        tx.setDependency(dependency);
      return dependency;
    }
    _clearActiveBatch() {
      this._activeTx = null;
    }
    createWriteBatch() {
      assert(!this._activeTx && !this.storage.snapshotted);
      this._activeTx = this.storage.write();
      return this._activeTx;
    }
    _unlock() {
      this._clearActiveBatch();
      this.mutex.unlock();
      this.core.checkIfIdle();
    }
    async flush() {
      const tx = this._activeTx;
      this._activeTx = null;
      try {
        if (!await tx.flush())
          return false;
      } finally {
        this._clearActiveBatch();
      }
      this.lastTruncation = null;
      return true;
    }
    _precommit() {
      this.commiting = true;
    }
    async _commit() {
      await this.mutex.lock();
      try {
        const bitfield = this._pendingBitfield;
        this._pendingBitfield = null;
        this.lastTruncation = null;
        await this.parent._oncommit(this, bitfield);
      } finally {
        this.commiting = false;
        this.mutex.unlock();
      }
    }
    async _oncommit(src, bitfield) {
      await this.mutex.lock();
      try {
        const currLength = this.length;
        const rx = this.storage.read();
        const dependencyPromise = rx.getDependency();
        rx.tryFlush();
        const dependency = await dependencyPromise;
        this.fork = src.fork;
        this.length = src.length;
        this.byteLength = src.byteLength;
        this.roots = src.roots.slice();
        this.signature = src.signature;
        const tree = {
          fork: this.fork,
          length: this.length,
          rootHash: this.hash(),
          signature: this.signature
        };
        if (dependency)
          this.storage.setDependencyHead(dependency);
        const b = bitfield;
        if (b && b.truncated && b.start < currLength) {
          this.ontruncate(tree, b.start, currLength, true);
          if (!b || b.appends === 0)
            return;
        }
        const append = b ? { start: b.start, length: b.appends, drop: false } : null;
        this.onappend(tree, append, true);
      } finally {
        this.mutex.unlock();
        this.core.checkIfIdle();
      }
    }
    async setUserData(key, value) {
      await this.mutex.lock();
      try {
        const tx = this.createWriteBatch();
        tx.putUserData(key, value);
        return await this.flush();
      } finally {
        this._unlock();
      }
    }
    async _verifyBlock(batch, bitfield, value, manifest, from) {
      await this.mutex.lock();
      try {
        if (!batch.commitable())
          return false;
        const tx = this.createWriteBatch();
        this.updating = true;
        if (bitfield) {
          tx.putBlock(bitfield.start, value);
        }
        if (bitfield && this.isDefault()) {
          await storeBitfieldRange(this.storage, tx, bitfield.start, bitfield.start + 1, true);
        }
        if (manifest)
          this.core._setManifest(tx, manifest, null);
        assert(batch.commitable(), "Should still be commitable");
        batch.commit(tx);
        const head = {
          fork: batch.fork,
          length: batch.length,
          rootHash: batch.hash(),
          signature: batch.signature
        };
        if (batch.upgraded)
          tx.setHead(head);
        const flushed = await this.flush();
        if (batch.upgraded) {
          this.roots = batch.roots;
          this.length = batch.length;
          this.byteLength = batch.byteLength;
          this.fork = batch.fork;
          this.signature = batch.signature;
          this.onappend(head, bitfield, flushed);
        }
      } finally {
        this._clearActiveBatch();
        this.updating = false;
        this.mutex.unlock();
      }
      return true;
    }
    async truncate(length, fork, { signature, keyPair } = {}) {
      if (!keyPair && this.isDefault())
        keyPair = this.core.header.keyPair;
      await this.mutex.lock();
      try {
        if (this.prologue && length < this.prologue.length) {
          throw INVALID_OPERATION("Truncation breaks prologue");
        }
        if (length > this.length) {
          throw INVALID_OPERATION("Not a truncation, " + length + " must be less or equal to " + this.length);
        }
        const batch = this.createTreeBatch();
        await MerkleTree.truncate(this, length, batch, fork);
        if (!signature && keyPair && length > 0)
          signature = this.core.verifier.sign(batch, keyPair);
        if (signature)
          batch.signature = signature;
        const tx = this.createWriteBatch();
        if (this.core.verifier === null && keyPair)
          this.core._setManifest(tx, null, keyPair);
        const { dependency, tree, roots } = await this._truncate(tx, batch);
        for (const sessionState of this.core.sessionStates) {
          if (sessionState.isSnapshot() && sessionState.name === this.name && length < sessionState.snapshotCompatLength) {
            sessionState.snapshotCompatLength = length;
          }
        }
        const flushed = await this.flush();
        this.fork = tree.fork;
        this.length = tree.length;
        this.byteLength = MerkleTree.size(roots);
        this.roots = roots;
        this.signature = tree.signature;
        if (dependency)
          this.storage.setDependencyHead(dependency);
        this.ontruncate(tree, tree.length, batch.treeLength, flushed);
      } finally {
        this._unlock();
      }
    }
    async reorg(batch) {
      await this.mutex.lock();
      const storage = this.createWriteBatch();
      try {
        if (!batch.commitable())
          return false;
        const { dependency, tree } = await this._truncate(storage, batch);
        const flushed = await this.flush();
        this.fork = batch.fork;
        this.length = batch.length;
        this.byteLength = batch.byteLength;
        this.roots = batch.roots;
        this.signature = batch.signature;
        if (dependency)
          this.storage.setDependencyHead(dependency);
        this.ontruncate(tree, batch.ancestors, batch.treeLength, flushed);
      } finally {
        this._unlock();
      }
    }
    async _truncate(storage, batch) {
      storage.deleteBlockRange(batch.ancestors, batch.treeLength);
      assert(batch.commitable(), "Batch must be commitable");
      const tree = {
        fork: batch.fork,
        length: batch.length,
        rootHash: batch.hash(),
        signature: batch.signature
      };
      storage.setHead(tree);
      batch.commit(storage);
      const truncated = batch.length < this.flushedLength();
      const dependency = truncated ? updateDependency(this, batch.length, true) : null;
      if (dependency)
        storage.setDependency(dependency);
      if (this.isDefault()) {
        await storeBitfieldRange(this.storage, storage, batch.ancestors, batch.treeLength, false);
        if (batch.ancestors < this.core.header.hints.contiguousLength) {
          storage.setHints({ contiguousLength: batch.ancestors });
        }
      }
      return { dependency, tree, roots: batch.roots };
    }
    async clear(start, end, cleared) {
      await this.mutex.lock();
      try {
        const tx = this.createWriteBatch();
        if (this.isDefault()) {
          await storeBitfieldRange(this.storage, tx, start, end, false);
          if (start < this.core.header.hints.contiguousLength) {
            tx.setHints({ contiguousLength: start });
          }
        }
        tx.deleteBlockRange(start, end);
        const dependency = start < this.flushedLength() ? updateDependency(this, start, true) : null;
        const flushed = await this.flush();
        if (dependency)
          this.storage.setDependencyHead(dependency);
        if (this.isDefault() && flushed) {
          const length = end - start;
          this.core.updateContiguousLength({ start, length, drop: true });
          this.core._setBitfieldRanges(start, end, false);
          this.core.replicator.onhave(start, length, true);
        }
      } finally {
        this._unlock();
      }
    }
    async append(values, { signature, keyPair, preappend, maxLength = -1 } = {}) {
      if (!keyPair && this.isDefault())
        keyPair = this.core.header.keyPair;
      await this.mutex.lock();
      try {
        if (maxLength >= 0 && this.length + values.length > maxLength) {
          return { length: this.length, byteLength: this.byteLength };
        }
        const tx = this.createWriteBatch();
        if (this.core.verifier === null && keyPair)
          this.core._setManifest(tx, null, keyPair);
        if (preappend)
          await preappend(values);
        if (!values.length) {
          await this.flush();
          return { length: this.length, byteLength: this.byteLength };
        }
        const batch = this.createTreeBatch();
        for (const val of values)
          batch.append(val);
        if (this.prologue && batch.length < this.prologue.length) {
          throw INVALID_OPERATION("Append is not consistent with prologue");
        }
        if (!signature && keyPair)
          signature = this.core.verifier.sign(batch, keyPair);
        if (signature)
          batch.signature = signature;
        batch.commit(tx);
        const tree = {
          fork: batch.fork,
          length: batch.length,
          rootHash: batch.hash(),
          signature: batch.signature
        };
        tx.setHead(tree);
        if (this.isDefault()) {
          await storeBitfieldRange(this.storage, tx, batch.ancestors, batch.length, true);
          if (this.length === this.core.header.hints.contiguousLength) {
            tx.setHints({ contiguousLength: this.length + values.length });
          }
        }
        for (let i = 0;i < values.length; i++) {
          tx.putBlock(this.length + i, values[i]);
        }
        const bitfield = {
          drop: false,
          start: batch.ancestors,
          length: values.length
        };
        const flushed = await this.flush();
        this.fork = batch.fork;
        this.roots = batch.roots;
        this.length = batch.length;
        this.byteLength = batch.byteLength;
        this.signature = batch.signature;
        this.onappend(tree, bitfield, flushed);
        return { length: this.length, byteLength: this.byteLength };
      } finally {
        this._unlock();
      }
    }
    onappend(tree, bitfield, flushed) {
      if (!flushed)
        this._updateBitfield(bitfield);
      else if (this.isDefault())
        this.core.onappend(tree, bitfield);
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        this.sessions[i].emit("append");
      }
    }
    ontruncate(tree, to, from, flushed) {
      const bitfield = { start: to, length: from - to, drop: true };
      this.lastTruncation = { from, to };
      if (!flushed)
        this._updateBitfield(bitfield);
      else if (this.isDefault())
        this.core.ontruncate(tree, bitfield);
      for (const sessionState of this.core.sessionStates) {
        if (sessionState.isSnapshot() && sessionState.name === this.name && to < sessionState.snapshotCompatLength) {
          sessionState.snapshotCompatLength = to;
        }
      }
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        this.sessions[i].emit("truncate", to, tree.fork);
      }
    }
    _updateBitfield(bitfield, flushed) {
      if (!bitfield)
        return;
      const p = this._pendingBitfield;
      const b = bitfield;
      if (b.drop) {
        if (p && b.start + b.length !== p.start + p.appends) {
          throw INVALID_OPERATION("Atomic truncations must be contiguous");
        }
        if (p === null || b.start < p.start) {
          this._pendingBitfield = { truncated: true, start: b.start, appends: 0 };
          return;
        }
        p.appends = b.start - p.start;
        if (p.appends === 0)
          this._pendingBitfield = null;
        return;
      }
      if (p === null) {
        this._pendingBitfield = { truncated: false, start: b.start, appends: b.length };
        return;
      }
      if (b.start !== p.start + p.appends) {
        throw INVALID_OPERATION("Atomic operations must be contiguous");
      }
      p.appends += b.length;
    }
    async catchup(length) {
      assert(!this.isDefault(), "Cannot catchup signed state");
      await this.mutex.lock();
      try {
        const origLength = this.length;
        let sharedLength = 0;
        for (let i = this.storage.dependencies.length - 1;i >= 0; i--) {
          const dep2 = this.storage.dependencies[i];
          if (dep2.dataPointer === this.core.state.storage.core.dataPointer) {
            sharedLength = dep2.length;
            break;
          }
        }
        const tx = this.createWriteBatch();
        const rx = this.core.state.storage.read();
        const rootPromises = [];
        for (const root of flat.fullRoots(length * 2)) {
          rootPromises.push(rx.getTreeNode(root));
        }
        rx.tryFlush();
        const roots = await Promise.all(rootPromises);
        const truncating = sharedLength < origLength;
        for (const node of roots) {
          if (node === null)
            throw INVALID_OPERATION("Invalid catchup length, tree nodes not available");
        }
        const fork = truncating ? this.fork + 1 : this.fork;
        tx.deleteBlockRange(0, -1);
        tx.deleteTreeNodeRange(0, -1);
        tx.deleteBitfieldPageRange(0, -1);
        const tree = {
          fork,
          length,
          rootHash: crypto.tree(roots),
          signature: null
        };
        tx.setHead(tree);
        const dep = updateDependency(this, sharedLength, true);
        dep.length = length;
        tx.setDependency(dep);
        const flushed = await this.flush();
        this.storage.setDependencyHead(dep);
        this.fork = tree.fork;
        this.roots = roots;
        this.length = tree.length;
        this.byteLength = MerkleTree.size(roots);
        if (truncating)
          this.ontruncate(tree, sharedLength, origLength, flushed);
        if (sharedLength < length)
          this.onappend(tree, null, flushed);
      } finally {
        this.mutex.unlock();
      }
    }
    async _overwrite(source, fork, length, treeLength, signature) {
      const blockPromises = [];
      const treePromises = [];
      const rootPromises = [];
      const rx = source.storage.read();
      for (const root of flat.fullRoots(length * 2)) {
        rootPromises.push(rx.getTreeNode(root));
      }
      for (const index of flat.patch(treeLength * 2, length * 2)) {
        treePromises.push(rx.getTreeNode(index));
      }
      for (let i = treeLength;i < length; i++) {
        treePromises.push(rx.getTreeNode(i * 2));
        treePromises.push(rx.getTreeNode(i * 2 + 1));
        blockPromises.push(rx.getBlock(i));
      }
      rx.tryFlush();
      const blocks = await Promise.all(blockPromises);
      const nodes = await Promise.all(treePromises);
      const roots = await Promise.all(rootPromises);
      if (this.core.destroyed)
        throw new Error("Core destroyed");
      if (signature) {
        const batch = this.createTreeBatch();
        batch.roots = roots;
        batch.length = length;
        if (!this.core.verifier.verify(batch, signature)) {
          throw INVALID_SIGNATURE("Signature is not valid over committed tree");
        }
      }
      const tx = this.createWriteBatch();
      if (treeLength < this.length) {
        tx.deleteBlockRange(treeLength, this.length);
      }
      for (const root of roots)
        tx.putTreeNode(root);
      for (const node of nodes) {
        if (node !== null)
          tx.putTreeNode(node);
      }
      for (let i = 0;i < blocks.length; i++) {
        assert(blocks[i] !== null, "has block");
        tx.putBlock(i + treeLength, blocks[i]);
      }
      const totalLength = Math.max(length, this.length);
      if (totalLength > treeLength) {
        const firstPage = getBitfieldPage(treeLength);
        const lastPage = getBitfieldPage(totalLength - 1);
        const srx = this.storage.read();
        const bitfieldPagePromise = srx.getBitfieldPage(firstPage);
        srx.tryFlush();
        const bitfieldPage = await bitfieldPagePromise;
        let index = treeLength;
        for (let i = firstPage;i <= lastPage; i++) {
          const page = b4a.alloc(Bitfield.BYTES_PER_PAGE);
          tx.putBitfieldPage(i, page);
          if (i === firstPage && bitfieldPage)
            page.set(bitfieldPage);
          if (index < length) {
            index = fillBitfieldPage(page, index, length, i, true);
            if (index < length)
              continue;
          }
          if (index < this.length) {
            index = fillBitfieldPage(page, index, this.length, i, false);
          }
        }
      }
      const tree = {
        fork,
        length,
        rootHash: crypto.tree(roots),
        signature
      };
      const upgraded = treeLength < this.length || this.length < length || tree.fork !== this.fork;
      if (upgraded)
        tx.setHead(tree);
      const flushed = await this.flush();
      this.fork = tree.fork;
      this.roots = roots;
      this.length = length;
      this.byteLength = MerkleTree.size(roots);
      this.signature = signature;
      return { tree, flushed };
    }
    async commit(state, { signature, keyPair, length = state.length, treeLength = -1, overwrite = false } = {}) {
      assert(this.isDefault() || this.parent && this.parent.isDefault(), "Can only commit into default state");
      let srcLocked = false;
      await this.mutex.lock();
      try {
        await state.mutex.lock();
        srcLocked = true;
        if (treeLength === -1)
          treeLength = state.flushedLength();
        if (!await this.core._validateCommit(state, treeLength))
          return null;
        if (this.length > length)
          return null;
        if (this.length < length && !signature) {
          if (!keyPair)
            keyPair = this.core.header.keyPair;
          const batch = state.createTreeBatch();
          if (length !== batch.length)
            await batch.restore(length);
          signature = this.core.verifier.sign(batch, keyPair);
        }
        const { tree, flushed } = await this._overwrite(state, this.fork, length, treeLength, signature);
        if (treeLength < length) {
          const tx = state.createWriteBatch();
          tx.deleteBlockRange(treeLength, length);
          const dependency = state.updateDependency(tx, length);
          await state.flush(tx);
          if (dependency)
            state.storage.setDependencyHead(dependency);
        }
        const bitfield = { start: treeLength, length: length - treeLength, drop: false };
        this.onappend(tree, bitfield, flushed);
        return {
          length: this.length,
          byteLength: this.byteLength
        };
      } finally {
        this.updating = false;
        this.mutex.unlock();
        if (srcLocked) {
          state.mutex.unlock();
          state._clearActiveBatch();
        }
        this.core.checkIfIdle();
      }
    }
    async _getTreeHeadAt(length) {
      if (length === null)
        return this.treeInfo();
      const head = getDefaultTree();
      head.length = length;
      const roots = await MerkleTree.getRootsFromStorage(this.storage, length);
      const rootHash = crypto.tree(roots);
      head.fork = this.fork;
      head.rootHash = rootHash;
      if (length === this.length)
        head.signature = this.signature;
      return head;
    }
    _moveToCore(core, truncated, appended) {
      const head = this.core.sessionStates.pop();
      if (head !== this)
        this.core.sessionStates[head.index = this.index] = head;
      this.core = core;
      this.index = this.core.sessionStates.push(this) - 1;
      for (let i = this.sessions.length - 1;i >= 0; i--) {
        const s = this.sessions[i];
        const manifest = s.manifest;
        s.transferSession(this.core);
        if (!manifest && s.manifest)
          s.emit("manifest");
        if (truncated)
          s.emit("truncate", truncated.to, truncated.fork);
        if (appended)
          s.emit("append");
      }
    }
    async moveTo(core, length) {
      const state = core.state;
      await this.mutex.lock();
      try {
        const treeLength = this.length;
        let truncated = null;
        let appended = false;
        if (!this.isSnapshot()) {
          if (this.lingers === null)
            this.lingers = [];
          this.lingers.push(this.storage);
          const resumed = await state.storage.resumeSession(this.name);
          const truncation = length < this.length ? await truncateAndFlush(this, length) : null;
          const treeInfo = truncation ? truncation.tree : resumed ? null : await state._getTreeHeadAt(this.length);
          const fork = truncation ? this.fork + 1 : this.fork;
          let storage = null;
          if (resumed) {
            storage = resumed;
          } else {
            treeInfo.fork = fork;
            storage = await state.storage.createSession(this.name, treeInfo);
          }
          const roots = await MerkleTree.getRootsFromStorage(storage, length);
          this.storage = storage;
          this.prologue = state.prologue;
          this.fork = fork;
          this.length = length;
          this.byteLength = MerkleTree.size(roots);
          this.roots = roots;
          if (truncation) {
            const { dependency } = truncation;
            if (dependency)
              this.storage.setDependencyHead(dependency);
            truncated = { to: treeLength, fork };
          }
          if (this.length > treeLength) {
            appended = true;
          }
        }
        for (let i = this.core.sessionStates.length - 1;i >= 0; i--) {
          const state2 = this.core.sessionStates[i];
          if (state2 === this)
            continue;
          if (state2.name === this.name)
            state2._moveToCore(core.core);
        }
        this._moveToCore(core.core, truncated, appended);
      } finally {
        this.mutex.unlock();
      }
    }
    async createSession(name, overwrite, atom) {
      let storage = null;
      let treeInfo = null;
      if (!atom && !overwrite && this.storage) {
        storage = await this.storage.resumeSession(name);
        if (storage !== null)
          treeInfo = await getCoreHead(storage) || getDefaultTree();
      }
      const length = treeInfo ? treeInfo.length : this.length;
      if (storage === null) {
        treeInfo = await this._getTreeHeadAt(length);
        if (atom) {
          storage = await this.storage.createAtomicSession(atom, treeInfo);
        } else {
          storage = await this.storage.createSession(name, treeInfo);
        }
      }
      if (this.atomized && atom) {
        throw new Error("Session already atomized");
      }
      const head = {
        fork: this.fork,
        roots: length === this.length ? this.roots.slice() : await MerkleTree.getRootsFromStorage(storage, length),
        length,
        prologue: this.prologue,
        signature: length === this.length ? this.signature : null
      };
      const state = new SessionState(this.core, atom ? this : null, storage, head, atom ? this.name : name);
      if (atom) {
        this.atomized = atom;
        atom.onflush(state._commit.bind(state));
      }
      return state;
    }
  };
  function noop() {}
  function getBitfieldPage(index) {
    return Math.floor(index / Bitfield.BITS_PER_PAGE);
  }
  function fillBitfieldPage(page, start, end, pageIndex, value) {
    const offset = pageIndex * Bitfield.BITS_PER_PAGE;
    const max = offset + Bitfield.BITS_PER_PAGE;
    const index = max < end ? max : end;
    const from = start - offset;
    const to = index - offset;
    quickbit.fill(page, value, from, to);
    return index;
  }
  async function storeBitfieldRange(storage, tx, from, to, value) {
    if (from >= to)
      return;
    const firstPage = getBitfieldPage(from);
    const lastPage = getBitfieldPage(to - 1);
    let index = from;
    const rx = storage.read();
    const promises = [];
    for (let i = firstPage;i <= lastPage; i++) {
      promises.push(rx.getBitfieldPage(i));
    }
    rx.tryFlush();
    const pages = await Promise.all(promises);
    const cnt = lastPage - firstPage + 1;
    for (let i = 0;i < cnt; i++) {
      const pageIndex = i + firstPage;
      if (!pages[i])
        pages[i] = b4a.alloc(Bitfield.BYTES_PER_PAGE);
      index = fillBitfieldPage(pages[i], index, to, pageIndex, value);
      tx.putBitfieldPage(pageIndex, pages[i]);
    }
  }
  async function truncateAndFlush(s, length) {
    const batch = s.createTreeBatch();
    await MerkleTree.truncate(s, length, batch, s.fork);
    const tx = s.createWriteBatch();
    const info = await s._truncate(tx, batch);
    const flushed = await s.flush();
    return {
      tree: info.tree,
      roots: info.roots,
      dependency: info.dependency,
      flushed
    };
  }
  function updateDependency(state, length, truncated) {
    const i = state.storage.findDependencyIndex(length, truncated);
    if (i === -1)
      return null;
    return {
      dataPointer: state.storage.dependencies[i].dataPointer,
      length
    };
  }
  function getDefaultTree() {
    return {
      fork: 0,
      length: 0,
      rootHash: null,
      signature: null
    };
  }
  function getCoreHead(storage) {
    const b = storage.read();
    const p = b.getHead();
    b.tryFlush();
    return p;
  }
});

// node_modules/random-array-iterator/index.js
var require_random_array_iterator = __commonJS((exports, module) => {
  module.exports = class RandomArrayIterator {
    constructor(values) {
      this.values = values;
      this.start = 0;
      this.length = this.values.length;
    }
    next() {
      if (this.length === 0) {
        if (this.start === 0)
          return { done: true, value: undefined };
        this.length = this.start;
        this.start = 0;
      }
      const i = this.start + (Math.random() * this.length | 0);
      const j = this.start + --this.length;
      const value = this.values[i];
      this.values[i] = this.values[j];
      this.values[j] = value;
      return { done: false, value };
    }
    dequeue() {
      this.values[this.start + this.length] = this.values[this.values.length - 1];
      this.values.pop();
    }
    requeue() {
      const i = this.start + this.length;
      const value = this.values[i];
      this.values[i] = this.values[this.start];
      this.values[this.start++] = value;
    }
    restart() {
      this.start = 0;
      this.length = this.values.length;
      return this;
    }
    [Symbol.iterator]() {
      return this;
    }
  };
});

// node_modules/hypercore/lib/receiver-queue.js
var require_receiver_queue = __commonJS((exports, module) => {
  var FIFO = require_fast_fifo();
  module.exports = class ReceiverQueue {
    constructor() {
      this.queue = new FIFO;
      this.priority = [];
      this.requests = new Map;
      this.length = 0;
    }
    push(req) {
      if (req.priority > 0)
        this.priority.push(req);
      else
        this.queue.push(req);
      this.requests.set(req.id, req);
      this.length++;
    }
    shift() {
      while (this.priority.length > 0) {
        const msg = this.priority.pop();
        const req = this._processRequest(msg);
        if (req !== null)
          return req;
      }
      while (this.queue.length > 0) {
        const msg = this.queue.shift();
        const req = this._processRequest(msg);
        if (req !== null)
          return req;
      }
      return null;
    }
    _processRequest(req) {
      if (req.block || req.hash || req.seek || req.upgrade || req.manifest) {
        this.requests.delete(req.id);
        this.length--;
        return req;
      }
      return null;
    }
    clear() {
      this.queue.clear();
      this.priority = [];
      this.length = 0;
      this.requests.clear();
    }
    delete(id) {
      const req = this.requests.get(id);
      if (!req)
        return;
      req.block = null;
      req.hash = null;
      req.seek = null;
      req.upgrade = null;
      req.manifest = false;
      this.requests.delete(id);
      this.length--;
      if (this.length === 0) {
        this.queue.clear();
        this.priority = [];
      }
    }
  };
});

// node_modules/hypercore/lib/hotswap-queue.js
var require_hotswap_queue = __commonJS((exports, module) => {
  var TICKS = 16;
  module.exports = class HotswapQueue {
    constructor() {
      this.priorities = [[], [], []];
    }
    *pick(peer) {
      for (let i = 0;i < this.priorities.length; i++) {
        let ticks = (this.priorities.length - i) * TICKS;
        const queue = this.priorities[i];
        for (let j = 0;j < queue.length; j++) {
          const r = j + Math.floor(Math.random() * queue.length - j);
          const a = queue[j];
          const b = queue[r];
          if (r !== j) {
            queue[b.hotswap.index = j] = b;
            queue[a.hotswap.index = r] = a;
          }
          if (hasInflight(b, peer))
            continue;
          yield b;
          if (--ticks <= 0)
            break;
        }
      }
    }
    add(block) {
      if (block.hotswap !== null)
        this.remove(block);
      if (block.inflight.length === 0 || block.inflight.length >= 3)
        return;
      const queue = this.priorities[block.inflight.length - 1];
      const index = queue.push(block) - 1;
      block.hotswap = { ref: this, queue, index };
    }
    remove(block) {
      const hotswap = block.hotswap;
      if (hotswap === null)
        return;
      block.hotswap = null;
      const head = hotswap.queue.pop();
      if (head === block)
        return;
      hotswap.queue[head.hotswap.index = hotswap.index] = head;
    }
  };
  function hasInflight(block, peer) {
    for (let j = 0;j < block.inflight.length; j++) {
      if (block.inflight[j].peer === peer)
        return true;
    }
    return false;
  }
});

// node_modules/hypercore/lib/replicator.js
var require_replicator = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var safetyCatch = require_safety_catch();
  var RandomIterator = require_random_array_iterator();
  var flatTree = require_flat_tree();
  var ReceiverQueue = require_receiver_queue();
  var HotswapQueue = require_hotswap_queue();
  var RemoteBitfield = require_remote_bitfield();
  var { MerkleTree } = require_merkle_tree();
  var { REQUEST_CANCELLED, REQUEST_TIMEOUT, INVALID_CAPABILITY, SNAPSHOT_NOT_AVAILABLE } = require_hypercore_errors();
  var m = require_messages2();
  var caps = require_caps();
  var DEFAULT_MAX_INFLIGHT = [16, 512];
  var SCALE_LATENCY = 50;
  var DEFAULT_SEGMENT_SIZE = 256 * 1024 * 8;
  var NOT_DOWNLOADING_SLACK = 20000 + Math.random() * 20000 | 0;
  var MAX_PEERS_UPGRADE = 3;
  var LAST_BLOCKS = 256;
  var MAX_REMOTE_SEGMENTS = 2048;
  var MAX_RANGES = 64;
  var PRIORITY = {
    NORMAL: 0,
    HIGH: 1,
    VERY_HIGH: 2,
    CANCELLED: 255
  };

  class Attachable {
    constructor() {
      this.resolved = false;
      this.processing = false;
      this.refs = [];
    }
    attach(session) {
      const r = {
        context: this,
        session,
        sindex: 0,
        rindex: 0,
        snapshot: true,
        resolve: null,
        reject: null,
        promise: null,
        timeout: null
      };
      r.sindex = session.push(r) - 1;
      r.rindex = this.refs.push(r) - 1;
      r.promise = new Promise((resolve, reject) => {
        r.resolve = resolve;
        r.reject = reject;
      });
      return r;
    }
    detach(r, err = null) {
      if (r.context !== this)
        return false;
      this._detach(r);
      this._cancel(r, err);
      this.gc();
      return true;
    }
    _detach(r) {
      const rh = this.refs.pop();
      const sh = r.session.pop();
      if (r.rindex < this.refs.length)
        this.refs[rh.rindex = r.rindex] = rh;
      if (r.sindex < r.session.length)
        r.session[sh.sindex = r.sindex] = sh;
      destroyRequestTimeout(r);
      r.context = null;
      return r;
    }
    gc() {
      if (this.refs.length === 0 && !this.processing)
        this._unref();
    }
    processed() {
      this.processing = false;
      this.gc();
    }
    _cancel(r, err) {
      r.reject(err || REQUEST_CANCELLED());
    }
    _unref() {}
    resolve(val) {
      this.resolved = true;
      while (this.refs.length > 0) {
        this._detach(this.refs[this.refs.length - 1]).resolve(val);
      }
    }
    reject(err) {
      this.resolved = true;
      while (this.refs.length > 0) {
        this._detach(this.refs[this.refs.length - 1]).reject(err);
      }
    }
    setTimeout(r, ms) {
      destroyRequestTimeout(r);
      r.timeout = setTimeout(onrequesttimeout, ms, r);
    }
  }

  class BlockRequest extends Attachable {
    constructor(tracker, index, priority) {
      super();
      this.index = index;
      this.priority = priority;
      this.inflight = [];
      this.queued = false;
      this.hotswap = null;
      this.tracker = tracker;
    }
    _unref() {
      this.queued = false;
      for (const req of this.inflight) {
        req.peer._cancelRequest(req);
      }
      this.tracker.remove(this.index);
      removeHotswap(this);
    }
  }

  class RangeRequest extends Attachable {
    constructor(ranges, start, end, linear, ifAvailable, blocks) {
      super();
      this.start = start;
      this.end = end;
      this.linear = linear;
      this.ifAvailable = ifAvailable;
      this.blocks = blocks;
      this.ranges = ranges;
      this.userStart = start;
      this.userEnd = end;
    }
    _unref() {
      const i = this.ranges.indexOf(this);
      if (i === -1)
        return;
      const h = this.ranges.pop();
      if (i < this.ranges.length)
        this.ranges[i] = h;
    }
    _cancel(r) {
      r.resolve(false);
    }
  }

  class UpgradeRequest extends Attachable {
    constructor(replicator, fork, length) {
      super();
      this.fork = fork;
      this.length = length;
      this.inflight = [];
      this.replicator = replicator;
    }
    _unref() {
      if (this.replicator.eagerUpgrade === true || this.inflight.length > 0)
        return;
      this.replicator._upgrade = null;
    }
    _cancel(r) {
      r.resolve(false);
    }
  }

  class SeekRequest extends Attachable {
    constructor(seeks, seeker) {
      super();
      this.seeker = seeker;
      this.inflight = [];
      this.seeks = seeks;
    }
    _unref() {
      if (this.inflight.length > 0)
        return;
      const i = this.seeks.indexOf(this);
      if (i === -1)
        return;
      const h = this.seeks.pop();
      if (i < this.seeks.length)
        this.seeks[i] = h;
    }
  }

  class InflightTracker {
    constructor() {
      this._requests = [];
      this._free = [];
    }
    get idle() {
      return this._requests.length === this._free.length;
    }
    *[Symbol.iterator]() {
      for (const req of this._requests) {
        if (req !== null)
          yield req;
      }
    }
    add(req) {
      const id = this._free.length ? this._free.pop() : this._requests.push(null);
      req.id = id;
      this._requests[id - 1] = req;
      return req;
    }
    get(id) {
      return id <= this._requests.length ? this._requests[id - 1] : null;
    }
    remove(id, roundtrip) {
      if (id > this._requests.length)
        return;
      this._requests[id - 1] = null;
      if (roundtrip === true)
        this._free.push(id);
    }
    reusable(id) {
      this._free.push(id);
    }
  }

  class BlockTracker {
    constructor() {
      this._map = new Map;
    }
    [Symbol.iterator]() {
      return this._map.values();
    }
    isEmpty() {
      return this._map.size === 0;
    }
    has(index) {
      return this._map.has(index);
    }
    get(index) {
      return this._map.get(index) || null;
    }
    add(index, priority) {
      let b = this._map.get(index);
      if (b)
        return b;
      b = new BlockRequest(this, index, priority);
      this._map.set(index, b);
      return b;
    }
    remove(index) {
      const b = this.get(index);
      this._map.delete(index);
      return b;
    }
  }

  class RoundtripQueue {
    constructor() {
      this.queue = [];
      this.tick = 0;
    }
    clear() {
      const ids = new Array(this.queue.length);
      for (let i = 0;i < ids.length; i++) {
        ids[i] = this.queue[i][1];
      }
      this.queue = [];
      return ids;
    }
    add(id) {
      this.queue.push([++this.tick, id]);
    }
    flush(tick) {
      let flushed = null;
      for (let i = 0;i < this.queue.length; i++) {
        if (this.queue[i][0] > tick)
          break;
        if (flushed === null)
          flushed = [];
        flushed.push(this.queue[i][1]);
      }
      if (flushed !== null)
        this.queue.splice(0, flushed.length);
      return flushed;
    }
  }

  class ProofRequest {
    constructor(msg, proof, block, manifest) {
      this.msg = msg;
      this.proof = proof;
      this.block = block;
      this.manifest = manifest;
    }
    async fulfill() {
      if (this.proof === null)
        return null;
      const [proof, block] = await Promise.all([this.proof.settle(), this.block]);
      if (this.manifest)
        proof.manifest = this.manifest;
      if (!block && proof.block)
        return null;
      if (block)
        proof.block.value = block;
      return proof;
    }
  }

  class Peer {
    constructor(replicator, protomux, channel, inflightRange) {
      this.core = replicator.core;
      this.replicator = replicator;
      this.stream = protomux.stream;
      this.protomux = protomux;
      this.remotePublicKey = this.stream.remotePublicKey;
      this.remoteSupportsSeeks = false;
      this.inflightRange = inflightRange;
      this.remoteSegmentsWanted = new Set;
      this.paused = false;
      this.removed = false;
      this.channel = channel;
      this.channel.userData = this;
      this.wireSync = this.channel.messages[0];
      this.wireRequest = this.channel.messages[1];
      this.wireCancel = this.channel.messages[2];
      this.wireData = this.channel.messages[3];
      this.wireNoData = this.channel.messages[4];
      this.wireWant = this.channel.messages[5];
      this.wireUnwant = this.channel.messages[6];
      this.wireBitfield = this.channel.messages[7];
      this.wireRange = this.channel.messages[8];
      this.wireExtension = this.channel.messages[9];
      this.stats = {
        wireSync: { tx: 0, rx: 0 },
        wireRequest: { tx: 0, rx: 0 },
        wireCancel: { tx: 0, rx: 0 },
        wireData: { tx: 0, rx: 0 },
        wireWant: { tx: 0, rx: 0 },
        wireBitfield: { tx: 0, rx: 0 },
        wireRange: { tx: 0, rx: 0 },
        wireExtension: { tx: 0, rx: 0 },
        hotswaps: 0
      };
      this.receiverQueue = new ReceiverQueue;
      this.receiverBusy = false;
      this.roundtripQueue = null;
      this.inflight = 0;
      this.dataProcessing = 0;
      this.canUpgrade = true;
      this.needsSync = false;
      this.syncsProcessing = 0;
      this._remoteContiguousLength = 0;
      this.remoteOpened = false;
      this.remoteBitfield = new RemoteBitfield;
      this.missingBlocks = new RemoteBitfield;
      this.remoteFork = 0;
      this.remoteLength = 0;
      this.remoteCanUpgrade = false;
      this.remoteUploading = true;
      this.remoteDownloading = true;
      this.remoteSynced = false;
      this.remoteHasManifest = false;
      this.remoteRequests = new Map;
      this.segmentsWanted = new Set;
      this.broadcastedNonSparse = false;
      this.lengthAcked = 0;
      this.extensions = new Map;
      this.lastExtensionSent = "";
      this.lastExtensionRecv = "";
      replicator._ifAvailable++;
      replicator._active++;
    }
    get remoteContiguousLength() {
      return this.remoteBitfield.findFirst(false, this._remoteContiguousLength);
    }
    getMaxInflight() {
      const stream = this.stream.rawStream;
      if (!stream.udx)
        return Math.min(this.inflightRange[1], this.inflightRange[0] * 3);
      const scale = stream.rtt <= SCALE_LATENCY ? 1 : stream.rtt / SCALE_LATENCY * Math.min(1, 2 / this.replicator.peers.length);
      return Math.max(this.inflightRange[0], Math.round(Math.min(this.inflightRange[1], this.inflightRange[0] * scale)));
    }
    getMaxHotswapInflight() {
      const inf = this.getMaxInflight();
      return Math.max(16, inf / 2);
    }
    signalUpgrade() {
      if (this._shouldUpdateCanUpgrade() === true)
        this._updateCanUpgradeAndSync();
      else
        this.sendSync();
    }
    _markInflight(index) {
      this.missingBlocks.set(index, false);
    }
    broadcastRange(start, length, drop) {
      if (!this.isActive())
        return;
      if (drop)
        this._unclearLocalRange(start, length);
      else
        this._clearLocalRange(start, length);
      const i = Math.floor(start / DEFAULT_SEGMENT_SIZE);
      const contig = this.core.header.hints.contiguousLength === this.core.state.length;
      if (start + LAST_BLOCKS < this.core.state.length && !this.remoteSegmentsWanted.has(i) && !drop && !contig)
        return;
      if (contig && !drop) {
        start = 0;
        length = this.core.state.length;
      }
      if (!drop) {
        if (this._remoteContiguousLength >= start + length)
          return;
        if (length === 1) {
          if (this.remoteBitfield.get(start))
            return;
        } else {
          if (this.remoteBitfield.firstUnset(start) >= start + length)
            return;
        }
      }
      this.wireRange.send({
        drop,
        start,
        length
      });
      incrementTx(this.stats.wireRange, this.replicator.stats.wireRange);
    }
    extension(name, message) {
      this.wireExtension.send({ name: name === this.lastExtensionSent ? "" : name, message });
      incrementTx(this.stats.wireExtension, this.replicator.stats.wireExtension);
      this.lastExtensionSent = name;
    }
    onextension(message) {
      const name = message.name || this.lastExtensionRecv;
      this.lastExtensionRecv = name;
      const ext = this.extensions.get(name);
      if (ext)
        ext._onmessage({ start: 0, end: message.message.byteLength, buffer: message.message }, this);
    }
    sendSync() {
      if (this.syncsProcessing !== 0) {
        this.needsSync = true;
        return;
      }
      if (this.core.state.fork !== this.remoteFork) {
        this.canUpgrade = false;
      }
      this.needsSync = false;
      this.wireSync.send({
        fork: this.core.state.fork,
        length: this.core.state.length,
        remoteLength: this.core.state.fork === this.remoteFork ? this.remoteLength : 0,
        canUpgrade: this.canUpgrade,
        uploading: true,
        downloading: this.replicator.isDownloading(),
        hasManifest: !!this.core.header.manifest && this.core.compat === false
      });
      incrementTx(this.stats.wireSync, this.replicator.stats.wireSync);
    }
    onopen({ seeks, capability }) {
      const expected = caps.replicate(this.stream.isInitiator === false, this.core.key, this.stream.handshakeHash);
      if (b4a.equals(capability, expected) !== true) {
        throw INVALID_CAPABILITY("Remote sent an invalid replication capability");
      }
      if (this.remoteOpened === true)
        return;
      this.remoteOpened = true;
      this.remoteSupportsSeeks = seeks;
      this.protomux.cork();
      this.sendSync();
      const contig = Math.min(this.core.state.length, this.core.header.hints.contiguousLength);
      if (contig > 0) {
        this.broadcastRange(0, contig, false);
        if (contig === this.core.state.length) {
          this.broadcastedNonSparse = true;
        }
      }
      this.replicator._ifAvailable--;
      this.replicator._addPeer(this);
      this.protomux.uncork();
      this.core.checkIfIdle();
    }
    onclose(isRemote) {
      const reopen = isRemote === true && this.remoteOpened === true && this.remoteDownloading === false && this.remoteUploading === true && this.replicator.downloading === true;
      if (this.remoteOpened === false) {
        this.replicator._ifAvailable--;
        this.replicator.updateAll();
        return;
      }
      this.remoteOpened = false;
      this.removed = true;
      this.remoteRequests.clear();
      this.receiverQueue.clear();
      if (this.roundtripQueue !== null) {
        for (const id of this.roundtripQueue.clear())
          this.replicator._inflight.reusable(id);
      }
      this.replicator._removePeer(this);
      if (reopen) {
        this.replicator._makePeer(this.protomux);
      }
    }
    closeIfIdle() {
      if (this.remoteDownloading === false && this.replicator.isDownloading() === false) {
        this.channel.close();
        return true;
      }
      return false;
    }
    async onsync({ fork, length, remoteLength, canUpgrade, uploading, downloading, hasManifest }) {
      const lengthChanged = length !== this.remoteLength;
      const sameFork = fork === this.core.state.fork;
      this.remoteSynced = true;
      this.remoteFork = fork;
      this.remoteLength = length;
      this.remoteCanUpgrade = canUpgrade;
      this.remoteUploading = uploading;
      this.remoteDownloading = downloading;
      this.remoteHasManifest = hasManifest;
      if (this.closeIfIdle())
        return;
      this.lengthAcked = sameFork ? remoteLength : 0;
      this.syncsProcessing++;
      this.replicator._updateFork(this);
      if (this.remoteLength > this.core.state.length && this.lengthAcked === this.core.state.length) {
        if (this.replicator._addUpgradeMaybe() !== null)
          this._update();
      }
      const upgrade = lengthChanged === false || sameFork === false ? this.canUpgrade && sameFork : await this._canUpgrade(length, fork);
      if (length === this.remoteLength && fork === this.core.state.fork) {
        this.canUpgrade = upgrade;
      }
      if (--this.syncsProcessing !== 0)
        return;
      if (this.needsSync === true || this.core.state.fork === this.remoteFork && this.core.state.length > this.remoteLength) {
        this.signalUpgrade();
      }
      this._update();
    }
    _shouldUpdateCanUpgrade() {
      return this.core.state.fork === this.remoteFork && this.core.state.length > this.remoteLength && this.canUpgrade === false && this.syncsProcessing === 0;
    }
    async _updateCanUpgradeAndSync() {
      const { length, fork } = this.core.state;
      const canUpgrade = await this._canUpgrade(this.remoteLength, this.remoteFork);
      if (this.syncsProcessing > 0 || length !== this.core.state.length || fork !== this.core.state.fork) {
        return;
      }
      if (canUpgrade === this.canUpgrade) {
        return;
      }
      this.canUpgrade = canUpgrade;
      this.sendSync();
    }
    async _canUpgrade(remoteLength, remoteFork) {
      if (remoteFork !== this.core.state.fork)
        return false;
      if (remoteLength === 0)
        return true;
      if (remoteLength >= this.core.state.length)
        return false;
      try {
        const canUpgrade = await MerkleTree.upgradeable(this.core.state, remoteLength);
        if (remoteFork !== this.core.state.fork)
          return false;
        return canUpgrade;
      } catch {
        return false;
      }
    }
    async _getProof(batch, msg) {
      let block = null;
      if (msg.block) {
        const index = msg.block.index;
        if (msg.fork !== this.core.state.fork || !this.core.bitfield.get(index)) {
          return new ProofRequest(msg, null, null, null);
        }
        block = batch.getBlock(index);
        block.catch(noop);
      }
      const manifest = msg.manifest && !this.core.compat ? this.core.header.manifest : null;
      try {
        const proof = await MerkleTree.proof(this.core.state, batch, msg);
        return new ProofRequest(msg, proof, block, manifest);
      } catch (err) {
        batch.destroy();
        throw err;
      }
    }
    async onrequest(msg) {
      const size = this.remoteRequests.size;
      this.remoteRequests.set(msg.id, msg);
      if (size === this.remoteRequests.size) {
        this._cancel(msg.id);
        this.remoteRequests.set(msg.id, msg);
      }
      if (!this.protomux.drained || this.receiverQueue.length) {
        this.receiverQueue.push(msg);
        return;
      }
      if (this.replicator.destroyed)
        return;
      await this._handleRequest(msg);
    }
    oncancel(msg) {
      this._cancel(msg.request);
    }
    _cancel(id) {
      this.remoteRequests.delete(id);
      this.receiverQueue.delete(id);
    }
    ondrain() {
      return this._handleRequests();
    }
    async _handleRequests() {
      if (this.receiverBusy || this.replicator.destroyed)
        return;
      this.receiverBusy = true;
      this.protomux.cork();
      while (this.remoteOpened && this.protomux.drained && this.receiverQueue.length > 0 && !this.removed) {
        const msg = this.receiverQueue.shift();
        await this._handleRequest(msg);
      }
      this.protomux.uncork();
      this.receiverBusy = false;
    }
    async _handleRequest(msg) {
      const batch = this.core.storage.read();
      const req = msg.fork === this.core.state.fork ? await this._getProof(batch, msg) : new ProofRequest(msg, null, null, null);
      batch.tryFlush();
      await this._fulfillRequest(req);
    }
    async _fulfillRequest(req) {
      const proof = await req.fulfill();
      if (this.remoteRequests.get(req.msg.id) !== req.msg) {
        return;
      }
      this.remoteRequests.delete(req.msg.id);
      if (!this.isActive() && proof.block !== null) {
        return;
      }
      if (proof === null) {
        if (req.msg.manifest && this.core.header.manifest) {
          const manifest = this.core.header.manifest;
          this.wireData.send({ request: req.msg.id, fork: this.core.state.fork, block: null, hash: null, seek: null, upgrade: null, manifest });
          incrementTx(this.stats.wireData, this.replicator.stats.wireData);
          return;
        }
        this.wireNoData.send({ request: req.msg.id });
        return;
      }
      if (proof.block !== null) {
        this.replicator._onupload(proof.block.index, proof.block.value.byteLength, this);
      }
      this.wireData.send({
        request: req.msg.id,
        fork: req.msg.fork,
        block: proof.block,
        hash: proof.hash,
        seek: proof.seek,
        upgrade: proof.upgrade,
        manifest: proof.manifest
      });
      incrementTx(this.stats.wireData, this.replicator.stats.wireData);
    }
    _cancelRequest(req) {
      if (req.priority === PRIORITY.CANCELLED)
        return;
      req.priority = PRIORITY.CANCELLED;
      this.inflight--;
      this.replicator._requestDone(req.id, false);
      if (isBlockRequest(req))
        this.replicator._unmarkInflight(req.block.index);
      if (isUpgradeRequest(req))
        this.replicator._clearInflightUpgrade(req);
      if (this.roundtripQueue === null)
        this.roundtripQueue = new RoundtripQueue;
      this.roundtripQueue.add(req.id);
      this.wireCancel.send({ request: req.id });
      incrementTx(this.stats.wireCancel, this.replicator.stats.wireCancel);
    }
    _checkIfConflict() {
      this.paused = true;
      const length = Math.min(this.core.state.length, this.remoteLength);
      if (length === 0)
        return;
      this.wireRequest.send({
        id: 0,
        fork: this.remoteFork,
        block: null,
        hash: null,
        seek: null,
        upgrade: {
          start: 0,
          length
        }
      });
      incrementTx(this.stats.wireRequest, this.replicator.stats.wireRequest);
    }
    async ondata(data) {
      if (data.request === 0 && data.upgrade && data.upgrade.start === 0) {
        if (await this.core.checkConflict(data, this))
          return;
        this.paused = false;
      }
      const req = data.request > 0 ? this.replicator._inflight.get(data.request) : null;
      const reorg = data.fork > this.core.state.fork;
      if (req === null && reorg === false)
        return;
      if (req !== null) {
        if (req.peer !== this)
          return;
        this._onrequestroundtrip(req);
      }
      try {
        if (reorg === true)
          return await this.replicator._onreorgdata(this, req, data);
      } catch (err) {
        safetyCatch(err);
        if (isBlockRequest(req))
          this.replicator._unmarkInflight(req.block.index);
        this.paused = true;
        this.replicator._oninvalid(err, req, data, this);
        return;
      }
      this.dataProcessing++;
      if (isBlockRequest(req))
        this.replicator._markProcessing(req.block.index);
      try {
        if (!matchingRequest(req, data) || !await this.core.verify(data, this)) {
          this.replicator._onnodata(this, req);
          return;
        }
      } catch (err) {
        safetyCatch(err);
        if (isBlockRequest(req))
          this.replicator._unmarkInflight(req.block.index);
        if (err.code === "WRITE_FAILED") {
          this.paused = true;
          return;
        }
        if (this.core.closed && !isCriticalError(err))
          return;
        if (err.code !== "INVALID_OPERATION") {
          this._checkIfConflict();
        }
        this.replicator._onnodata(this, req);
        this.replicator._oninvalid(err, req, data, this);
        return;
      } finally {
        if (isBlockRequest(req))
          this.replicator._markProcessed(req.block.index);
        this.dataProcessing--;
      }
      this.replicator._ondata(this, req, data);
      if (this._shouldUpdateCanUpgrade() === true) {
        this._updateCanUpgradeAndSync();
      }
    }
    onnodata({ request }) {
      const req = request > 0 ? this.replicator._inflight.get(request) : null;
      if (req === null || req.peer !== this)
        return;
      this._onrequestroundtrip(req);
      this.replicator._onnodata(this, req);
    }
    _onrequestroundtrip(req) {
      if (req.priority === PRIORITY.CANCELLED)
        return;
      req.priority = PRIORITY.CANCELLED;
      this.inflight--;
      this.replicator._requestDone(req.id, true);
      if (this.roundtripQueue === null)
        return;
      const flushed = this.roundtripQueue.flush(req.rt);
      if (flushed === null)
        return;
      for (const id of flushed)
        this.replicator._inflight.reusable(id);
    }
    onwant({ start, length }) {
      const i = Math.floor(start / DEFAULT_SEGMENT_SIZE);
      if (this.remoteSegmentsWanted.size >= MAX_REMOTE_SEGMENTS)
        this.remoteSegmentsWanted.clear();
      this.remoteSegmentsWanted.add(i);
      this.replicator._onwant(this, start, length);
    }
    onunwant() {}
    onbitfield({ start, bitfield }) {
      if (start < this._remoteContiguousLength)
        this._remoteContiguousLength = start;
      this.remoteBitfield.insert(start, bitfield);
      this.missingBlocks.insert(start, bitfield);
      this._clearLocalRange(start, bitfield.byteLength * 8);
      this._update();
    }
    _clearLocalRange(start, length) {
      const bitfield = this.core.skipBitfield === null ? this.core.bitfield : this.core.skipBitfield;
      if (length === 1) {
        this.missingBlocks.set(start, this._remoteHasBlock(start) && !bitfield.get(start));
        return;
      }
      const contig = Math.min(this.core.state.length, this.core.header.hints.contiguousLength);
      if (start + length < contig) {
        this.missingBlocks.setRange(start, contig, false);
        return;
      }
      const rem = start & 32767;
      if (rem > 0) {
        start -= rem;
        length += rem;
      }
      const end = start + Math.min(length, this.core.state.length);
      while (start < end) {
        const local = bitfield.getBitfield(start);
        if (local && local.bitfield) {
          this.missingBlocks.clear(start, local.bitfield);
        }
        start += 32768;
      }
    }
    _resetMissingBlock(index) {
      const bitfield = this.core.skipBitfield === null ? this.core.bitfield : this.core.skipBitfield;
      this.missingBlocks.set(index, this._remoteHasBlock(index) && !bitfield.get(index));
    }
    _unclearLocalRange(start, length) {
      if (length === 1) {
        this._resetMissingBlock(start);
        return;
      }
      const rem = start & 2097151;
      if (rem > 0) {
        start -= rem;
        length += rem;
      }
      const fixedStart = start;
      const end = start + Math.min(length, this.remoteLength);
      while (start < end) {
        const remote = this.remoteBitfield.getBitfield(start);
        if (remote && remote.bitfield) {
          this.missingBlocks.insert(start, remote.bitfield);
        }
        start += 2097152;
      }
      this._clearLocalRange(fixedStart, length);
    }
    onrange({ drop, start, length }) {
      const has = drop === false;
      if (drop === true && start < this._remoteContiguousLength) {
        this._remoteContiguousLength = start;
      }
      if (start === 0 && drop === false) {
        if (length > this._remoteContiguousLength)
          this._remoteContiguousLength = length;
      } else if (length === 1) {
        const bitfield = this.core.skipBitfield === null ? this.core.bitfield : this.core.skipBitfield;
        this.remoteBitfield.set(start, has);
        this.missingBlocks.set(start, has && !bitfield.get(start));
      } else {
        const rangeStart = this.remoteBitfield.findFirst(!has, start);
        const rangeEnd = length + start;
        if (rangeStart !== -1 && rangeStart < rangeEnd) {
          this.remoteBitfield.setRange(rangeStart, rangeEnd, has);
          this.missingBlocks.setRange(rangeStart, rangeEnd, has);
          if (has)
            this._clearLocalRange(rangeStart, rangeEnd - rangeStart);
        }
      }
      if (drop === false)
        this._update();
    }
    onreorghint() {}
    _update() {
      this.replicator.updatePeer(this);
    }
    async _onconflict() {
      this.protomux.cork();
      if (this.remoteLength > 0 && this.core.state.fork === this.remoteFork) {
        await this.onrequest({
          id: 0,
          fork: this.core.state.fork,
          block: null,
          hash: null,
          seek: null,
          upgrade: {
            start: 0,
            length: Math.min(this.core.state.length, this.remoteLength)
          }
        });
      }
      this.channel.close();
      this.protomux.uncork();
    }
    _makeRequest(needsUpgrade, priority, minLength) {
      if (needsUpgrade === true && this.replicator._shouldUpgrade(this) === false) {
        return null;
      }
      if (this.remoteLength < minLength) {
        return null;
      }
      if (needsUpgrade === false && this.replicator._autoUpgrade(this) === true) {
        needsUpgrade = true;
      }
      return {
        peer: this,
        rt: this.roundtripQueue === null ? 0 : this.roundtripQueue.tick,
        id: 0,
        fork: this.remoteFork,
        block: null,
        hash: null,
        seek: null,
        upgrade: needsUpgrade === false ? null : { start: this.core.state.length, length: this.remoteLength - this.core.state.length },
        manifest: this.core.header.manifest === null && this.remoteHasManifest === true,
        priority,
        timestamp: Date.now(),
        elapsed: 0
      };
    }
    _requestManifest() {
      const req = this._makeRequest(false, 0, 0);
      this._send(req);
    }
    _requestUpgrade(u) {
      const req = this._makeRequest(true, 0, 0);
      if (req === null)
        return false;
      this._send(req);
      return true;
    }
    _requestSeek(s) {
      if (this.replicator._updatesPending > 0)
        return false;
      const { length, fork } = this.core.state;
      if (fork !== this.remoteFork)
        return false;
      if (s.seeker.start >= length) {
        const req = this._makeRequest(true, 0, 0);
        if (req === null)
          return false;
        req.seek = this.remoteSupportsSeeks ? { bytes: s.seeker.bytes, padding: s.seeker.padding } : null;
        s.inflight.push(req);
        this._send(req);
        return true;
      }
      const len = s.seeker.end - s.seeker.start;
      const off = s.seeker.start + Math.floor(Math.random() * len);
      for (let i = 0;i < len; i++) {
        let index = off + i;
        if (index > s.seeker.end)
          index -= len;
        if (this._remoteHasBlock(index) === false)
          continue;
        if (this.core.bitfield.get(index) === true)
          continue;
        if (!this._hasTreeParent(index))
          continue;
        const b = this.replicator._blocks.get(index);
        if (b !== null && b.inflight.length > 0)
          continue;
        const h = this.replicator._hashes.add(index, PRIORITY.NORMAL);
        if (h.inflight.length > 0)
          continue;
        const req = this._makeRequest(false, h.priority, index + 1);
        if (req === null)
          continue;
        const nodes = flatTree.depth(s.seeker.start + s.seeker.end - 1);
        req.hash = { index: 2 * index, nodes };
        req.seek = this.remoteSupportsSeeks ? { bytes: s.seeker.bytes, padding: s.seeker.padding } : null;
        s.inflight.push(req);
        h.inflight.push(req);
        this._send(req);
        return true;
      }
      this._maybeWant(s.seeker.start, len);
      return false;
    }
    _hasTreeParent(index) {
      if (this.remoteLength >= this.core.state.length)
        return true;
      const ite = flatTree.iterator(index * 2);
      let span = 2;
      let length = 0;
      while (true) {
        ite.parent();
        const left = (ite.index - ite.factor / 2 + 1) / 2;
        length = left + span;
        if (length > this.core.state.length) {
          if (length > this.remoteLength)
            return true;
          break;
        }
        if (length > this.remoteLength)
          break;
        span *= 2;
        const first = this.core.bitfield.findFirst(true, left);
        if (first > -1 && first < length)
          return true;
      }
      return false;
    }
    _remoteHasBlock(index) {
      return index < this._remoteContiguousLength || this.remoteBitfield.get(index) === true;
    }
    _sendBlockRequest(req, b) {
      req.block = { index: b.index, nodes: 0 };
      this.replicator._markInflight(b.index);
      b.inflight.push(req);
      this.replicator.hotswaps.add(b);
      this._send(req);
    }
    _requestBlock(b) {
      const { length, fork } = this.core.state;
      if (this._remoteHasBlock(b.index) === false || fork !== this.remoteFork) {
        this._maybeWant(b.index);
        return false;
      }
      if (!this._hasTreeParent(b.index)) {
        return false;
      }
      const req = this._makeRequest(b.index >= length, b.priority, b.index + 1);
      if (req === null)
        return false;
      this._sendBlockRequest(req, b);
      return true;
    }
    _requestRangeBlock(index, length) {
      if (this.core.bitfield.get(index) === true || !this._hasTreeParent(index))
        return false;
      const b = this.replicator._blocks.add(index, PRIORITY.NORMAL);
      if (b.inflight.length > 0) {
        this.missingBlocks.set(index, false);
        return false;
      }
      const req = this._makeRequest(index >= length, b.priority, index + 1);
      if (req === null) {
        b.gc();
        return false;
      }
      this._sendBlockRequest(req, b);
      if (b.queued)
        b.queued = false;
      return true;
    }
    _findNext(i) {
      if (i < this._remoteContiguousLength) {
        if (this.core.skipBitfield === null)
          this.replicator._openSkipBitfield();
        i = this.core.skipBitfield.findFirst(false, i);
        if (i < this._remoteContiguousLength && i > -1)
          return i;
        i = this._remoteContiguousLength;
      }
      return this.missingBlocks.findFirst(true, i);
    }
    _requestRange(r) {
      const { length, fork } = this.core.state;
      if (r.blocks) {
        let min = -1;
        let max = -1;
        for (let i2 = r.start;i2 < r.end; i2++) {
          const index = r.blocks[i2];
          if (min === -1 || index < min)
            min = index;
          if (max === -1 || index > max)
            max = index;
          const has = index < this._remoteContiguousLength || this.missingBlocks.get(index) === true;
          if (has === true && this._requestRangeBlock(index, length))
            return true;
        }
        if (min > -1)
          this._maybeWant(min, max - min);
        return false;
      }
      const end = Math.min(this.core.state.length, Math.min(r.end === -1 ? this.remoteLength : r.end, this.remoteLength));
      if (end <= r.start || fork !== this.remoteFork)
        return false;
      const len = end - r.start;
      const off = r.start + (r.linear ? 0 : Math.floor(Math.random() * len));
      let i = off;
      while (true) {
        i = this._findNext(i);
        if (i === -1 || i >= end)
          break;
        if (this._requestRangeBlock(i, length))
          return true;
        i++;
      }
      i = r.start;
      while (true) {
        i = this._findNext(i);
        if (i === -1 || i >= off)
          break;
        if (this._requestRangeBlock(i, length))
          return true;
        i++;
      }
      this._maybeWant(r.start, len);
      return false;
    }
    _requestForkProof(f) {
      if (!this.remoteLength)
        return;
      const req = this._makeRequest(false, 0, 0);
      req.upgrade = { start: 0, length: this.remoteLength };
      req.manifest = !this.core.header.manifest;
      f.inflight.push(req);
      this._send(req);
    }
    _requestForkRange(f) {
      if (f.fork !== this.remoteFork || f.batch.want === null)
        return false;
      const end = Math.min(f.batch.want.end, this.remoteLength);
      if (end < f.batch.want.start)
        return false;
      const len = end - f.batch.want.start;
      const off = f.batch.want.start + Math.floor(Math.random() * len);
      for (let i = 0;i < len; i++) {
        let index = off + i;
        if (index >= end)
          index -= len;
        if (this._remoteHasBlock(index) === false)
          continue;
        const req = this._makeRequest(false, 0, 0);
        req.hash = { index: 2 * index, nodes: f.batch.want.nodes };
        f.inflight.push(req);
        this._send(req);
        return true;
      }
      this._maybeWant(f.batch.want.start, len);
      return false;
    }
    _maybeWant(start, length = 1) {
      if (start + length <= this.remoteContiguousLength)
        return;
      let i = Math.floor(start / DEFAULT_SEGMENT_SIZE);
      const n = Math.ceil((start + length) / DEFAULT_SEGMENT_SIZE);
      for (;i < n; i++) {
        if (this.segmentsWanted.has(i))
          continue;
        this.segmentsWanted.add(i);
        this.wireWant.send({
          start: i * DEFAULT_SEGMENT_SIZE,
          length: DEFAULT_SEGMENT_SIZE
        });
        incrementTx(this.stats.wireWant, this.replicator.stats.wireWant);
      }
    }
    isActive() {
      if (this.paused || this.removed || this.core.header.frozen)
        return false;
      return true;
    }
    async _send(req) {
      const fork = this.core.state.fork;
      this.inflight++;
      this.replicator._inflight.add(req);
      if (req.upgrade !== null && req.fork === fork) {
        const u = this.replicator._addUpgrade();
        u.inflight.push(req);
      }
      try {
        if (req.block !== null && req.fork === fork) {
          req.block.nodes = await MerkleTree.missingNodes(this.core.state, 2 * req.block.index, this.core.state.length);
          if (req.priority === PRIORITY.CANCELLED)
            return;
        }
        if (req.hash !== null && req.fork === fork && req.hash.nodes === 0) {
          req.hash.nodes = await MerkleTree.missingNodes(this.core.state, req.hash.index, this.core.state.length);
          if (req.priority === PRIORITY.CANCELLED)
            return;
          if (req.hash.nodes === 0 && (req.hash.index & 1) === 0) {
            this.inflight--;
            this.replicator._resolveHashLocally(this, req);
            return;
          }
        }
      } catch (err) {
        this.stream.destroy(err);
        return;
      }
      this.wireRequest.send(req);
      incrementTx(this.stats.wireRequest, this.replicator.stats.wireRequest);
    }
  }
  module.exports = class Replicator {
    static Peer = Peer;
    constructor(core, {
      notDownloadingLinger = NOT_DOWNLOADING_SLACK,
      eagerUpgrade = true,
      allowFork = true,
      inflightRange = null
    } = {}) {
      this.core = core;
      this.eagerUpgrade = eagerUpgrade;
      this.allowFork = allowFork;
      this.ondownloading = null;
      this.peers = [];
      this.findingPeers = 0;
      this.destroyed = false;
      this.downloading = false;
      this.activeSessions = 0;
      this.hotswaps = new HotswapQueue;
      this.inflightRange = inflightRange || DEFAULT_MAX_INFLIGHT;
      this.stats = {
        wireSync: { tx: 0, rx: 0 },
        wireRequest: { tx: 0, rx: 0 },
        wireCancel: { tx: 0, rx: 0 },
        wireData: { tx: 0, rx: 0 },
        wireWant: { tx: 0, rx: 0 },
        wireBitfield: { tx: 0, rx: 0 },
        wireRange: { tx: 0, rx: 0 },
        wireExtension: { tx: 0, rx: 0 },
        hotswaps: 0
      };
      this._attached = new Set;
      this._inflight = new InflightTracker;
      this._blocks = new BlockTracker;
      this._hashes = new BlockTracker;
      this._queued = [];
      this._seeks = [];
      this._upgrade = null;
      this._reorgs = [];
      this._ranges = [];
      this._hadPeers = false;
      this._active = 0;
      this._ifAvailable = 0;
      this._updatesPending = 0;
      this._applyingReorg = null;
      this._manifestPeer = null;
      this._notDownloadingLinger = notDownloadingLinger;
      this._downloadingTimer = null;
      const self = this;
      this._onstreamclose = onstreamclose;
      function onstreamclose() {
        self.detachFrom(this.userData);
      }
    }
    updateActivity(inc, session) {
      this.activeSessions += inc;
      this.setDownloading(this.activeSessions !== 0, session);
    }
    isDownloading() {
      return this.downloading || !this._inflight.idle;
    }
    setDownloading(downloading) {
      clearTimeout(this._downloadingTimer);
      if (this.destroyed)
        return;
      if (downloading || this._notDownloadingLinger === 0) {
        this.setDownloadingNow(downloading);
        return;
      }
      this._downloadingTimer = setTimeout(setDownloadingLater, this._notDownloadingLinger, this, downloading);
      if (this._downloadingTimer.unref)
        this._downloadingTimer.unref();
    }
    setDownloadingNow(downloading) {
      this._downloadingTimer = null;
      if (this.downloading === downloading)
        return;
      this.downloading = downloading;
      if (!downloading && this.isDownloading())
        return;
      for (const peer of this.peers)
        peer.signalUpgrade();
      if (downloading) {
        for (const protomux of this._attached) {
          if (!protomux.stream.handshakeHash)
            continue;
          if (protomux.opened({ protocol: "hypercore/alpha", id: this.core.discoveryKey }))
            continue;
          this._makePeer(protomux, true);
        }
      } else {
        for (const peer of this.peers)
          peer.closeIfIdle();
      }
      if (this.ondownloading !== null && downloading)
        this.ondownloading();
    }
    cork() {
      for (const peer of this.peers)
        peer.protomux.cork();
    }
    uncork() {
      for (const peer of this.peers)
        peer.protomux.uncork();
    }
    onhave(start, length, drop = false) {
      for (const peer of this.peers)
        peer.broadcastRange(start, length, drop);
    }
    ontruncate(newLength, truncated) {
      const notify = [];
      for (const blk of this._blocks) {
        if (blk.index < newLength)
          continue;
        notify.push(blk);
      }
      for (const blk of notify) {
        for (const r of blk.refs) {
          if (r.snapshot === false)
            continue;
          blk.detach(r, SNAPSHOT_NOT_AVAILABLE());
        }
      }
      for (const peer of this.peers)
        peer._unclearLocalRange(newLength, truncated);
    }
    onupgrade() {
      for (const peer of this.peers)
        peer.signalUpgrade();
      if (this._blocks.isEmpty() === false)
        this._resolveBlocksLocally();
      if (this._upgrade !== null)
        this._resolveUpgradeRequest(null);
      if (!this._blocks.isEmpty() || this._ranges.length !== 0 || this._seeks.length !== 0) {
        this._updateNonPrimary(true);
      }
    }
    async onconflict() {
      const all = [];
      for (const peer of this.peers) {
        all.push(peer._onconflict());
      }
      await Promise.allSettled(all);
    }
    async applyPendingReorg() {
      if (this._applyingReorg !== null) {
        await this._applyingReorg;
        return true;
      }
      for (let i = this._reorgs.length - 1;i >= 0; i--) {
        const f = this._reorgs[i];
        if (f.batch !== null && f.batch.finished) {
          await this._applyReorg(f);
          return true;
        }
      }
      return false;
    }
    addUpgrade(session) {
      if (this._upgrade !== null) {
        const ref2 = this._upgrade.attach(session);
        this._checkUpgradeIfAvailable();
        return ref2;
      }
      const ref = this._addUpgrade().attach(session);
      this.updateAll();
      return ref;
    }
    addBlock(session, index) {
      const b = this._blocks.add(index, PRIORITY.HIGH);
      const ref = b.attach(session);
      this._queueBlock(b);
      this.updateAll();
      return ref;
    }
    addSeek(session, seeker) {
      const s = new SeekRequest(this._seeks, seeker);
      const ref = s.attach(session);
      this._seeks.push(s);
      this.updateAll();
      return ref;
    }
    addRange(session, { start = 0, end = -1, length = toLength(start, end), blocks = null, linear = false, ifAvailable = false } = {}) {
      if (blocks !== null) {
        start = 0;
        end = length = blocks.length;
      }
      const r = new RangeRequest(this._ranges, start, length === -1 ? -1 : start + length, linear, ifAvailable, blocks);
      const ref = r.attach(session);
      clampRange(this.core, r);
      this._ranges.push(r);
      if (r.end !== -1 && r.start >= r.end) {
        this._resolveRangeRequest(r, this._ranges.length - 1);
        return ref;
      }
      this.updateAll();
      return ref;
    }
    cancel(ref) {
      ref.context.detach(ref, null);
    }
    clearRequests(session, err = null) {
      let cleared = false;
      while (session.length > 0) {
        const ref = session[session.length - 1];
        ref.context.detach(ref, err);
        cleared = true;
      }
      if (cleared)
        this.updateAll();
    }
    _addUpgradeMaybe() {
      return this.eagerUpgrade === true ? this._addUpgrade() : this._upgrade;
    }
    _checkUpgradeIfAvailable() {
      if (this._ifAvailable > 0 && this.peers.length < MAX_PEERS_UPGRADE)
        return;
      if (this._upgrade === null || this._upgrade.refs.length === 0)
        return;
      if (this._hadPeers === false && this.findingPeers > 0)
        return;
      const maxPeers = Math.min(this.peers.length, MAX_PEERS_UPGRADE);
      for (let i = 0;i < maxPeers; i++) {
        const peer = this.peers[i];
        if (peer.remoteSynced === false)
          return;
        if (this.core.state.length === 0 && peer.remoteLength > 0)
          return;
        if (peer.remoteLength <= this._upgrade.length || peer.remoteFork !== this._upgrade.fork)
          continue;
        if (peer.syncsProcessing > 0)
          return;
        if (peer.lengthAcked !== this.core.state.length && peer.remoteFork === this.core.state.fork)
          return;
        if (peer.remoteCanUpgrade === true)
          return;
      }
      if (this._applyingReorg !== null)
        return;
      for (let i = 0;i < this._reorgs.length; i++) {
        const r = this._reorgs[i];
        if (r.inflight.length > 0)
          return;
      }
      if (this._upgrade.inflight.length > 0)
        return;
      const u = this._upgrade;
      this._upgrade = null;
      u.resolve(false);
    }
    _addUpgrade() {
      if (this._upgrade !== null)
        return this._upgrade;
      this._upgrade = new UpgradeRequest(this, this.core.state.fork, this.core.state.length);
      return this._upgrade;
    }
    _addReorg(fork, peer) {
      if (this.allowFork === false)
        return null;
      for (const f2 of this._reorgs) {
        if (f2.fork > fork && f2.batch !== null)
          return null;
        if (f2.fork === fork)
          return f2;
      }
      const f = {
        fork,
        inflight: [],
        batch: null
      };
      this._reorgs.push(f);
      let i = this._reorgs.length - 1;
      while (i > 0 && this._reorgs[i - 1].fork > fork) {
        this._reorgs[i] = this._reorgs[i - 1];
        this._reorgs[--i] = f;
      }
      return f;
    }
    _shouldUpgrade(peer) {
      if (this._upgrade !== null && this._upgrade.inflight.length > 0)
        return false;
      return peer.remoteCanUpgrade === true && peer.remoteLength > this.core.state.length && peer.lengthAcked === this.core.state.length;
    }
    _autoUpgrade(peer) {
      return this._upgrade !== null && peer.remoteFork === this.core.state.fork && this._shouldUpgrade(peer);
    }
    _addPeer(peer) {
      this._hadPeers = true;
      this.peers.push(peer);
      this.updatePeer(peer);
      this._onpeerupdate(true, peer);
    }
    _requestDone(id, roundtrip) {
      this._inflight.remove(id, roundtrip);
      if (this.isDownloading() === true)
        return;
      for (const peer of this.peers)
        peer.signalUpgrade();
    }
    _removePeer(peer) {
      this.peers.splice(this.peers.indexOf(peer), 1);
      if (this._manifestPeer === peer)
        this._manifestPeer = null;
      for (const req of this._inflight) {
        if (req.peer !== peer)
          continue;
        this._inflight.remove(req.id, true);
        this._clearRequest(peer, req);
      }
      this._onpeerupdate(false, peer);
      this.updateAll();
    }
    _queueBlock(b) {
      if (b.inflight.length > 0 || b.queued === true)
        return;
      b.queued = true;
      this._queued.push(b);
    }
    _resolveHashLocally(peer, req) {
      this._requestDone(req.id, false);
      this._resolveBlockRequest(this._hashes, req.hash.index / 2, null, req);
      this.updatePeer(peer);
    }
    async _resolveBlocksLocally() {
      const clear = [];
      const blocks = [];
      const reader = this.core.storage.read();
      for (const b of this._blocks) {
        if (this.core.bitfield.get(b.index) === false)
          continue;
        blocks.push(this._resolveLocalBlock(b, reader, clear));
      }
      reader.tryFlush();
      await Promise.all(blocks);
      if (!clear.length)
        return;
      for (const b of clear) {
        this._blocks.remove(b.index);
        removeHotswap(b);
      }
    }
    async _resolveLocalBlock(b, reader, resolved) {
      try {
        b.resolve(await reader.getBlock(b.index));
      } catch (err) {
        b.reject(err);
        return;
      }
      resolved.push(b);
    }
    _resolveBlockRequest(tracker, index, value, req) {
      const b = tracker.remove(index);
      if (b === null)
        return false;
      removeInflight(b.inflight, req);
      removeHotswap(b);
      b.queued = false;
      b.resolve(value);
      if (b.inflight.length > 0) {
        for (let i = b.inflight.length - 1;i >= 0; i--) {
          const req2 = b.inflight[i];
          req2.peer._cancelRequest(req2);
        }
      }
      return true;
    }
    _resolveUpgradeRequest(req) {
      if (req !== null)
        removeInflight(this._upgrade.inflight, req);
      if (this.core.state.length === this._upgrade.length && this.core.state.fork === this._upgrade.fork)
        return false;
      const u = this._upgrade;
      this._upgrade = null;
      u.resolve(true);
      return true;
    }
    _resolveRangeRequest(req, index) {
      const head = this._ranges.pop();
      if (index < this._ranges.length)
        this._ranges[index] = head;
      req.resolve(true);
    }
    _clearInflightBlock(tracker, req) {
      const isBlock = tracker === this._blocks;
      const index = isBlock === true ? req.block.index : req.hash.index / 2;
      const b = tracker.get(index);
      if (b === null || removeInflight(b.inflight, req) === false)
        return;
      if (removeHotswap(b) === true && b.inflight.length > 0) {
        this.hotswaps.add(b);
      }
      if (b.refs.length > 0 && isBlock === true) {
        this._queueBlock(b);
        return;
      }
      b.gc();
    }
    _clearInflightUpgrade(req) {
      if (removeInflight(this._upgrade.inflight, req) === false)
        return;
      this._upgrade.gc();
    }
    _clearInflightSeeks(req) {
      for (const s of this._seeks) {
        if (removeInflight(s.inflight, req) === false)
          continue;
        s.gc();
      }
    }
    _clearInflightReorgs(req) {
      for (const r of this._reorgs) {
        removeInflight(r.inflight, req);
      }
    }
    _clearOldReorgs(fork) {
      for (let i = 0;i < this._reorgs.length; i++) {
        const f = this._reorgs[i];
        if (f.fork >= fork)
          continue;
        if (i === this._reorgs.length - 1)
          this._reorgs.pop();
        else
          this._reorgs[i] = this._reorgs.pop();
        i--;
      }
    }
    async _updateNonPrimary(updateAll) {
      while (++this._updatesPending === 1) {
        let len = Math.min(MAX_RANGES, this._ranges.length);
        for (let i = 0;i < len; i++) {
          const r = this._ranges[i];
          clampRange(this.core, r);
          if (r.end !== -1 && r.start >= r.end) {
            this._resolveRangeRequest(r, i--);
            if (len > this._ranges.length)
              len--;
            if (this._ranges.length === MAX_RANGES)
              updateAll = true;
          }
        }
        for (let i = 0;i < this._seeks.length; i++) {
          const s = this._seeks[i];
          let err = null;
          let res = null;
          try {
            res = await s.seeker.update();
          } catch (error) {
            err = error;
          }
          if (!res && !err)
            continue;
          if (i < this._seeks.length - 1)
            this._seeks[i] = this._seeks.pop();
          else
            this._seeks.pop();
          i--;
          if (err)
            s.reject(err);
          else
            s.resolve(res);
        }
        if (--this._updatesPending === 0)
          break;
        this._updatesPending = 0;
      }
      if (this._inflight.idle || updateAll)
        this.updateAll();
    }
    _maybeResolveIfAvailableRanges() {
      if (this._ifAvailable > 0 || !this._inflight.idle || !this._ranges.length)
        return;
      for (let i = 0;i < this.peers.length; i++) {
        if (this.peers[i].dataProcessing > 0)
          return;
      }
      for (let i = 0;i < this._ranges.length; i++) {
        const r = this._ranges[i];
        if (r.ifAvailable) {
          this._resolveRangeRequest(r, i--);
        }
      }
    }
    _clearRequest(peer, req) {
      if (req.block !== null) {
        this._clearInflightBlock(this._blocks, req);
        this._unmarkInflight(req.block.index);
      }
      if (req.hash !== null) {
        this._clearInflightBlock(this._hashes, req);
      }
      if (req.upgrade !== null && this._upgrade !== null) {
        this._clearInflightUpgrade(req);
      }
      if (this._seeks.length > 0) {
        this._clearInflightSeeks(req);
      }
      if (this._reorgs.length > 0) {
        this._clearInflightReorgs(req);
      }
    }
    _onnodata(peer, req) {
      this._clearRequest(peer, req);
      this.updateAll();
    }
    _openSkipBitfield() {
      const bitfield = this.core.openSkipBitfield();
      for (const req of this._inflight) {
        if (req.block)
          bitfield.set(req.block.index, true);
      }
    }
    _markProcessing(index) {
      const b = this._blocks.get(index);
      if (b) {
        b.processing = true;
        return;
      }
      const h = this._hashes.get(index);
      if (h)
        h.processing = true;
    }
    _markProcessed(index) {
      const b = this._blocks.get(index);
      if (b)
        return b.processed();
      const h = this._hashes.get(index);
      if (h)
        h.processed();
    }
    _markInflight(index) {
      if (this.core.skipBitfield !== null)
        this.core.skipBitfield.set(index, true);
      for (const peer of this.peers)
        peer._markInflight(index);
    }
    _unmarkInflight(index) {
      if (this.core.skipBitfield !== null)
        this.core.skipBitfield.set(index, this.core.bitfield.get(index));
      for (const peer of this.peers)
        peer._resetMissingBlock(index);
    }
    _ondata(peer, req, data) {
      req.elapsed = Date.now() - req.timestamp;
      if (data.block !== null) {
        this._resolveBlockRequest(this._blocks, data.block.index, data.block.value, req);
        this._ondownload(data.block.index, data.block.value.byteLength, peer, req);
      }
      if (data.hash !== null && (data.hash.index & 1) === 0) {
        this._resolveBlockRequest(this._hashes, data.hash.index / 2, null, req);
      }
      if (this._upgrade !== null) {
        this._resolveUpgradeRequest(req);
      }
      if (this._seeks.length > 0) {
        this._clearInflightSeeks(req);
      }
      if (this._reorgs.length > 0) {
        this._clearInflightReorgs(req);
      }
      if (this._manifestPeer === peer && this.core.header.manifest !== null) {
        this._manifestPeer = null;
      }
      if (this._seeks.length > 0 || this._ranges.length > 0)
        this._updateNonPrimary(this._seeks.length > 0);
      this.updatePeer(peer);
    }
    _onwant(peer, start, length) {
      if (!peer.isActive())
        return;
      const contig = Math.min(this.core.state.length, this.core.header.hints.contiguousLength);
      if (start + length < contig || this.core.state.length === contig) {
        peer.wireRange.send({
          drop: false,
          start: 0,
          length: contig
        });
        incrementTx(peer.stats.wireRange, this.stats.wireRange);
        return;
      }
      length = Math.min(length, this.core.state.length - start);
      peer.protomux.cork();
      for (const msg of this.core.bitfield.want(start, length)) {
        peer.wireBitfield.send(msg);
        incrementTx(peer.stats.wireBitfield, this.stats.wireBitfield);
      }
      peer.protomux.uncork();
    }
    async _onreorgdata(peer, req, data) {
      const newBatch = data.upgrade && await this.core.verifyReorg(data);
      const f = this._addReorg(data.fork, peer);
      if (f === null) {
        this.updateAll();
        return;
      }
      removeInflight(f.inflight, req);
      if (f.batch) {
        await f.batch.update(data);
      } else if (data.upgrade) {
        f.batch = newBatch;
        this._clearOldReorgs(f.fork);
      }
      if (f.batch && f.batch.finished) {
        if (this._addUpgradeMaybe() !== null) {
          await this._applyReorg(f);
        }
      }
      this.updateAll();
    }
    async _applyReorg(f) {
      const u = this._upgrade;
      this._reorgs = [];
      this._applyingReorg = this.core.reorg(f.batch, null);
      try {
        await this._applyingReorg;
      } catch (err) {
        this._upgrade = null;
        u.reject(err);
      }
      this._applyingReorg = null;
      if (this._upgrade !== null) {
        this._resolveUpgradeRequest(null);
      }
      for (const peer of this.peers)
        this._updateFork(peer);
      for (const r of this._ranges) {
        r.start = r.userStart;
        r.end = r.userEnd;
      }
      this.updateAll();
    }
    _maybeUpdate() {
      return this._upgrade !== null && this._upgrade.inflight.length === 0;
    }
    _maybeRequestManifest() {
      return this.core.header.manifest === null && this._manifestPeer === null;
    }
    _updateFork(peer) {
      if (this._applyingReorg !== null || this.allowFork === false || peer.remoteFork <= this.core.state.fork) {
        return false;
      }
      const f = this._addReorg(peer.remoteFork, peer);
      if (f !== null && f.batch === null && f.inflight.length === 0) {
        return peer._requestForkProof(f);
      }
      return false;
    }
    _updateHotswap(peer) {
      const maxHotswaps = peer.getMaxHotswapInflight();
      if (!peer.isActive() || peer.inflight >= maxHotswaps)
        return;
      for (const b of this.hotswaps.pick(peer)) {
        if (peer._requestBlock(b) === false)
          continue;
        peer.stats.hotswaps++;
        peer.replicator.stats.hotswaps++;
        if (peer.inflight >= maxHotswaps)
          break;
      }
    }
    _updatePeer(peer) {
      if (!peer.isActive() || peer.inflight >= peer.getMaxInflight()) {
        return false;
      }
      if (this._maybeRequestManifest() === true && peer.remoteLength === 0 && peer.remoteHasManifest === true) {
        this._manifestPeer = peer;
        peer._requestManifest();
      }
      for (const s of this._seeks) {
        if (s.inflight.length > 0)
          continue;
        if (peer._requestSeek(s) === true) {
          return true;
        }
      }
      const blks = new RandomIterator(this._queued);
      for (const b of blks) {
        if (b.queued === false || peer._requestBlock(b) === true) {
          b.queued = false;
          blks.dequeue();
          return true;
        }
      }
      return false;
    }
    _updatePeerNonPrimary(peer) {
      if (!peer.isActive() || peer.inflight >= peer.getMaxInflight()) {
        return false;
      }
      const ranges = new RandomIterator(this._ranges);
      let tried = 0;
      for (const r of ranges) {
        if (peer._requestRange(r) === true) {
          return true;
        }
        if (++tried >= MAX_RANGES)
          break;
      }
      for (let i = this._reorgs.length - 1;i >= 0; i--) {
        const f = this._reorgs[i];
        if (f.batch !== null && f.inflight.length === 0 && peer._requestForkRange(f) === true) {
          return true;
        }
      }
      if (this._maybeUpdate() === true && peer._requestUpgrade(this._upgrade) === true) {
        return true;
      }
      return false;
    }
    updatePeer(peer) {
      if (this._applyingReorg !== null)
        return;
      while (this._updatePeer(peer) === true)
        ;
      while (this._updatePeerNonPrimary(peer) === true)
        ;
      if (this.peers.length > 1 && this._blocks.isEmpty() === false) {
        this._updateHotswap(peer);
      }
      this._checkUpgradeIfAvailable();
      this._maybeResolveIfAvailableRanges();
    }
    updateAll() {
      if (this._applyingReorg !== null)
        return;
      const peers = new RandomIterator(this.peers);
      for (const peer of peers) {
        if (this._updatePeer(peer) === true) {
          peers.requeue();
        }
      }
      if (this._maybeUpdate() === false && this._ranges.length === 0 && this._reorgs.length === 0) {
        this._checkUpgradeIfAvailable();
        return;
      }
      for (const peer of peers.restart()) {
        if (this._updatePeerNonPrimary(peer) === true) {
          peers.requeue();
        }
      }
      this._checkUpgradeIfAvailable();
      this._maybeResolveIfAvailableRanges();
    }
    onpeerdestroy() {
      if (--this._active === 0)
        this.core.checkIfIdle();
    }
    attached(protomux) {
      return this._attached.has(protomux);
    }
    attachTo(protomux) {
      if (this.core.closed)
        return;
      const makePeer = this._makePeer.bind(this, protomux);
      this._attached.add(protomux);
      protomux.pair({ protocol: "hypercore/alpha", id: this.core.discoveryKey }, makePeer);
      protomux.stream.setMaxListeners(0);
      protomux.stream.on("close", this._onstreamclose);
      this._ifAvailable++;
      this._active++;
      protomux.stream.opened.then((opened) => {
        this._ifAvailable--;
        this._active--;
        if (opened && !this.destroyed)
          makePeer();
        this._checkUpgradeIfAvailable();
        this.core.checkIfIdle();
      });
    }
    detachFrom(protomux) {
      if (this._attached.delete(protomux)) {
        protomux.stream.removeListener("close", this._onstreamclose);
        protomux.unpair({ protocol: "hypercore/alpha", id: this.core.discoveryKey });
      }
    }
    idle() {
      return this.peers.length === 0 && this._active === 0;
    }
    close() {
      const waiting = [];
      for (const peer of this.peers) {
        waiting.push(peer.channel.fullyClosed());
      }
      this.destroy();
      return Promise.all(waiting);
    }
    destroy() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      if (this._downloadingTimer) {
        clearTimeout(this._downloadingTimer);
        this._downloadingTimer = null;
      }
      while (this.peers.length) {
        const peer = this.peers[this.peers.length - 1];
        this.detachFrom(peer.protomux);
        peer.channel.close();
      }
      for (const protomux of this._attached) {
        this.detachFrom(protomux);
      }
    }
    _makePeer(protomux) {
      const replicator = this;
      if (protomux.opened({ protocol: "hypercore/alpha", id: this.core.discoveryKey }))
        return onnochannel();
      const channel = protomux.createChannel({
        userData: null,
        protocol: "hypercore/alpha",
        aliases: ["hypercore"],
        id: this.core.discoveryKey,
        handshake: m.wire.handshake,
        messages: [
          { encoding: m.wire.sync, onmessage: onwiresync },
          { encoding: m.wire.request, onmessage: onwirerequest },
          { encoding: m.wire.cancel, onmessage: onwirecancel },
          { encoding: m.wire.data, onmessage: onwiredata },
          { encoding: m.wire.noData, onmessage: onwirenodata },
          { encoding: m.wire.want, onmessage: onwirewant },
          { encoding: m.wire.unwant, onmessage: onwireunwant },
          { encoding: m.wire.bitfield, onmessage: onwirebitfield },
          { encoding: m.wire.range, onmessage: onwirerange },
          { encoding: m.wire.extension, onmessage: onwireextension }
        ],
        onopen: onwireopen,
        onclose: onwireclose,
        ondrain: onwiredrain,
        ondestroy: onwiredestroy
      });
      if (channel === null)
        return onnochannel();
      const peer = new Peer(replicator, protomux, channel, this.inflightRange);
      const stream = protomux.stream;
      peer.channel.open({
        seeks: true,
        capability: caps.replicate(stream.isInitiator, this.core.key, stream.handshakeHash)
      });
      return true;
      function onnochannel() {
        return false;
      }
    }
    _onpeerupdate(added, peer) {
      const name = added ? "peer-add" : "peer-remove";
      const sessions = this.core.monitors;
      for (let i = sessions.length - 1;i >= 0; i--) {
        sessions[i].emit(name, peer);
        if (added) {
          for (const ext of sessions[i].extensions.values()) {
            peer.extensions.set(ext.name, ext);
          }
        }
      }
    }
    _ondownload(index, byteLength, from, req) {
      const sessions = this.core.monitors;
      for (let i = sessions.length - 1;i >= 0; i--) {
        const s = sessions[i];
        s.emit("download", index, byteLength - s.padding, from, req);
      }
    }
    _onupload(index, byteLength, from) {
      const sessions = this.core.monitors;
      for (let i = sessions.length - 1;i >= 0; i--) {
        const s = sessions[i];
        s.emit("upload", index, byteLength - s.padding, from);
      }
    }
    _oninvalid(err, req, res, from) {
      const sessions = this.core.monitors;
      for (let i = 0;i < sessions.length; i++) {
        sessions[i].emit("verification-error", err, req, res, from);
      }
    }
  };
  function matchingRequest(req, data) {
    if (data.block !== null && (req.block === null || req.block.index !== data.block.index))
      return false;
    if (data.hash !== null && (req.hash === null || req.hash.index !== data.hash.index))
      return false;
    if (data.seek !== null && (req.seek === null || req.seek.bytes !== data.seek.bytes))
      return false;
    if (data.upgrade !== null && req.upgrade === null)
      return false;
    return req.fork === data.fork;
  }
  function removeHotswap(block) {
    if (block.hotswap === null)
      return false;
    block.hotswap.ref.remove(block);
    return true;
  }
  function removeInflight(inf, req) {
    const i = inf.indexOf(req);
    if (i === -1)
      return false;
    if (i < inf.length - 1)
      inf[i] = inf.pop();
    else
      inf.pop();
    return true;
  }
  function toLength(start, end) {
    return end === -1 ? -1 : end < start ? 0 : end - start;
  }
  function clampRange(core, r) {
    if (r.blocks === null) {
      const start = core.bitfield.firstUnset(r.start);
      if (r.end === -1)
        r.start = start === -1 ? core.state.length : start;
      else if (start === -1 || start >= r.end)
        r.start = r.end;
      else {
        r.start = start;
        const end = core.bitfield.lastUnset(r.end - 1);
        if (end === -1 || start >= end + 1)
          r.end = r.start;
        else
          r.end = end + 1;
      }
    } else {
      while (r.start < r.end && core.bitfield.get(r.blocks[r.start]))
        r.start++;
      while (r.start < r.end && core.bitfield.get(r.blocks[r.end - 1]))
        r.end--;
    }
  }
  function onrequesttimeout(req) {
    if (req.context)
      req.context.detach(req, REQUEST_TIMEOUT());
  }
  function destroyRequestTimeout(req) {
    if (req.timeout !== null) {
      clearTimeout(req.timeout);
      req.timeout = null;
    }
  }
  function isCriticalError(err) {
    return err.name === "HypercoreError";
  }
  function onwireopen(m2, c) {
    return c.userData.onopen(m2);
  }
  function onwireclose(isRemote, c) {
    return c.userData.onclose(isRemote);
  }
  function onwiredestroy(c) {
    c.userData.replicator.onpeerdestroy();
  }
  function onwiredrain(c) {
    return c.userData.ondrain();
  }
  function onwiresync(m2, c) {
    incrementRx(c.userData.stats.wireSync, c.userData.replicator.stats.wireSync);
    return c.userData.onsync(m2);
  }
  function onwirerequest(m2, c) {
    incrementRx(c.userData.stats.wireRequest, c.userData.replicator.stats.wireRequest);
    return c.userData.onrequest(m2);
  }
  function onwirecancel(m2, c) {
    incrementRx(c.userData.stats.wireCancel, c.userData.replicator.stats.wireCancel);
    return c.userData.oncancel(m2);
  }
  function onwiredata(m2, c) {
    incrementRx(c.userData.stats.wireData, c.userData.replicator.stats.wireData);
    return c.userData.ondata(m2);
  }
  function onwirenodata(m2, c) {
    return c.userData.onnodata(m2);
  }
  function onwirewant(m2, c) {
    incrementRx(c.userData.stats.wireWant, c.userData.replicator.stats.wireWant);
    return c.userData.onwant(m2);
  }
  function onwireunwant(m2, c) {
    return c.userData.onunwant(m2);
  }
  function onwirebitfield(m2, c) {
    incrementRx(c.userData.stats.wireBitfield, c.userData.replicator.stats.wireBitfield);
    return c.userData.onbitfield(m2);
  }
  function onwirerange(m2, c) {
    incrementRx(c.userData.stats.wireRange, c.userData.replicator.stats.wireRange);
    return c.userData.onrange(m2);
  }
  function onwireextension(m2, c) {
    incrementRx(c.userData.stats.wireExtension, c.userData.replicator.stats.wireExtension);
    return c.userData.onextension(m2);
  }
  function setDownloadingLater(repl, downloading, session) {
    repl.setDownloadingNow(downloading, session);
  }
  function isBlockRequest(req) {
    return req !== null && req.block !== null;
  }
  function isUpgradeRequest(req) {
    return req !== null && req.upgrade !== null;
  }
  function incrementTx(stats1, stats2) {
    stats1.tx++;
    stats2.tx++;
  }
  function incrementRx(stats1, stats2) {
    stats1.rx++;
    stats2.rx++;
  }
  function noop() {}
});

// node_modules/hypercore/lib/core.js
var require_core = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var unslab = require_unslab();
  var z32 = require_z32();
  var Mutex = require_mutex();
  var { MerkleTree, ReorgBatch } = require_merkle_tree();
  var BitInterlude = require_bit_interlude();
  var Bitfield = require_bitfield();
  var RemoteBitfield = require_remote_bitfield();
  var { BAD_ARGUMENT, STORAGE_EMPTY, STORAGE_CONFLICT, INVALID_SIGNATURE, INVALID_CHECKSUM } = require_hypercore_errors();
  var Verifier = require_verifier();
  var audit = require_audit();
  var copyPrologue = require_copy_prologue();
  var SessionState = require_session_state();
  var Replicator = require_replicator();
  module.exports = class Core {
    constructor(db, opts = {}) {
      this.db = db;
      this.storage = null;
      this.replicator = new Replicator(this, opts);
      this.sessionStates = [];
      this.monitors = [];
      this.activeSessions = 0;
      this.gc = 0;
      this.id = opts.key ? z32.encode(opts.key) : null;
      this.key = opts.key || null;
      this.discoveryKey = opts.discoveryKey || opts.key && crypto.discoveryKey(opts.key) || null;
      this.manifest = null;
      this.opening = null;
      this.closing = null;
      this.exclusive = null;
      this.preupdate = null;
      this.header = null;
      this.compat = false;
      this.bitfield = null;
      this.verifier = null;
      this.truncating = 0;
      this.updating = false;
      this.skipBitfield = null;
      this.globalCache = opts.globalCache || null;
      this.autoClose = opts.autoClose !== false;
      this.onidle = noop;
      this.state = null;
      this.opened = false;
      this.destroyed = false;
      this.closed = false;
      this._manifestFlushed = false;
      this._bitfield = null;
      this._verifies = null;
      this._verifiesFlushed = null;
      this._legacy = !!opts.legacy;
      this.opening = this._open(opts);
      this.opening.catch(noop);
    }
    ready() {
      return this.opening;
    }
    addMonitor(s) {
      if (s._monitorIndex >= 0)
        return;
      s._monitorIndex = this.monitors.push(s) - 1;
    }
    removeMonitor(s) {
      if (s._monitorIndex < 0)
        return;
      const head = this.monitors.pop();
      if (head !== s)
        this.monitors[head._monitorIndex = s._monitorIndex] = head;
      s._monitorIndex = -1;
    }
    emitManifest() {
      for (let i = this.monitors.length - 1;i >= 0; i--) {
        this.monitors[i].emit("manifest");
      }
    }
    createUserDataStream(opts, session = this.state) {
      return session.storage.createUserDataStream(opts);
    }
    allSessions() {
      const sessions = [];
      for (const state of this.sessionStates) {
        if (state.sessions.length)
          sessions.push(...state.sessions);
      }
      return sessions;
    }
    hasSession() {
      return this.activeSessions !== 0;
    }
    checkIfIdle() {
      if (!this.opened || this.destroyed === true || this.hasSession() === true)
        return;
      if (this.replicator.idle() === false)
        return;
      if (this.state === null || this.state.mutex.idle() === false)
        return;
      this.onidle();
    }
    async lockExclusive() {
      if (this.exclusive === null)
        this.exclusive = new Mutex;
      await this.exclusive.lock();
    }
    unlockExclusive() {
      if (this.exclusive !== null)
        this.exclusive.unlock();
    }
    async _open(opts) {
      try {
        await this._tryOpen(opts);
      } catch (err) {
        this.onidle();
        throw err;
      }
      this.opened = true;
    }
    async _tryOpen(opts) {
      if (opts.preopen)
        await opts.preopen;
      let storage = await this.db.resume(this.discoveryKey);
      let overwrite = opts.overwrite === true;
      const force = opts.force === true;
      const createIfMissing = opts.createIfMissing !== false;
      const legacy = !!opts.legacy;
      let compat = opts.compat === true || opts.compat !== false && !opts.manifest;
      let header = storage ? parseHeader(await getCoreInfo(storage)) : null;
      if (force && opts.key && header && !b4a.equals(header.key, opts.key)) {
        overwrite = true;
      }
      if (!header && (opts.discoveryKey && !(opts.key || opts.manifest))) {
        throw STORAGE_EMPTY("No Hypercore is stored here");
      }
      if (!header || overwrite) {
        if (!createIfMissing) {
          throw STORAGE_EMPTY("No Hypercore is stored here");
        }
        if (compat) {
          if (opts.key && opts.keyPair && !b4a.equals(opts.key, opts.keyPair.publicKey)) {
            throw BAD_ARGUMENT("Key must match publicKey when in compat mode");
          }
        }
        const keyPair = opts.keyPair || (opts.key ? null : crypto.keyPair());
        const defaultManifest = !opts.manifest && (!!opts.compat || !opts.key || !!(keyPair && b4a.equals(opts.key, keyPair.publicKey)));
        const manifest = defaultManifest ? Verifier.defaultSignerManifest(opts.key || keyPair.publicKey) : Verifier.createManifest(opts.manifest);
        header = {
          key: opts.key || (compat ? manifest.signers[0].publicKey : Verifier.manifestHash(manifest)),
          manifest,
          keyPair: keyPair ? { publicKey: keyPair.publicKey, secretKey: keyPair.secretKey || null } : null,
          frozen: false,
          tree: {
            fork: 0,
            length: 0,
            rootHash: null,
            signature: null
          },
          hints: {
            reorgs: [],
            contiguousLength: 0
          }
        };
        const discoveryKey = opts.discoveryKey || crypto.discoveryKey(header.key);
        storage = await this.db.create({
          key: header.key,
          manifest,
          keyPair,
          frozen: false,
          discoveryKey,
          userData: opts.userData || [],
          alias: opts.alias || null
        });
      }
      header.key = unslab(header.key);
      if (header.tree) {
        header.tree.rootHash = unslab(header.tree.rootHash);
        header.tree.signature = unslab(header.tree.signature);
      }
      if (header.keyPair) {
        header.keyPair.publicKey = unslab(header.keyPair.publicKey);
        header.keyPair.secretKey = unslab(header.keyPair.secretKey);
      }
      if (header.keyPair) {
        header.keyPair.publicKey = unslab(header.keyPair.publicKey);
        header.keyPair.secretKey = unslab(header.keyPair.secretKey);
      }
      if (opts.manifest) {
        if (!opts.key && !Verifier.isValidManifest(header.key, Verifier.createManifest(opts.manifest))) {
          throw STORAGE_CONFLICT("Manifest does not hash to provided key");
        }
        if (!header.manifest)
          header.manifest = opts.manifest;
      }
      if (opts.key && !b4a.equals(header.key, opts.key)) {
        throw STORAGE_CONFLICT("Another Hypercore is stored here");
      }
      if (compat && header.manifest && !Verifier.isCompat(header.key, header.manifest)) {
        compat = false;
      } else if (!compat && header.manifest && Verifier.isCompat(header.key, header.manifest)) {
        compat = true;
      }
      const prologue = header.manifest ? header.manifest.prologue : null;
      const bitfield = await Bitfield.open(storage, header.tree.length);
      const treeInfo = {
        fork: header.tree.fork,
        length: header.tree.length,
        signature: header.tree.signature,
        roots: header.tree.length ? await MerkleTree.getRootsFromStorage(storage, header.tree.length) : [],
        prologue
      };
      if (overwrite) {
        const tx = storage.write();
        tx.deleteTreeNodeRange(0, -1);
        tx.deleteBlockRange(0, -1);
        bitfield.clear(tx);
        await tx.flush();
      }
      const len = bitfield.findFirst(false, header.hints.contiguousLength);
      if (header.hints.contiguousLength !== len) {
        header.hints.contiguousLength = len;
        const tx = storage.write();
        tx.setHints({ contiguousLength: len });
        await tx.flush();
      }
      if (header.manifest) {
        header.manifest = Verifier.createManifest(header.manifest);
      }
      const verifier = header.manifest ? new Verifier(header.key, header.manifest, { crypto, legacy }) : null;
      this.storage = storage;
      this.header = header;
      this.compat = compat;
      this.bitfield = bitfield;
      this.verifier = verifier;
      this.state = new SessionState(this, null, storage, treeInfo, null);
      if (this.key === null)
        this.key = this.header.key;
      if (this.discoveryKey === null)
        this.discoveryKey = crypto.discoveryKey(this.key);
      if (this.id === null)
        this.id = z32.encode(this.key);
      if (this.manifest === null)
        this.manifest = this.header.manifest;
      this._manifestFlushed = !!header.manifest;
    }
    async audit(opts) {
      await this.state.mutex.lock();
      try {
        return await audit(this, opts);
      } finally {
        this.state._unlock();
      }
    }
    async setManifest(manifest) {
      await this.state.mutex.lock();
      try {
        if (manifest && this.header.manifest === null) {
          if (!Verifier.isValidManifest(this.header.key, manifest))
            throw INVALID_CHECKSUM("Manifest hash does not match");
          const tx = this.state.createWriteBatch();
          this._setManifest(tx, Verifier.createManifest(manifest), null);
          await this.state.flush();
        }
      } finally {
        this.state._unlock();
      }
    }
    _setManifest(tx, manifest, keyPair) {
      if (!manifest && b4a.equals(keyPair.publicKey, this.header.key))
        manifest = Verifier.defaultSignerManifest(this.header.key);
      if (!manifest)
        return;
      const verifier = new Verifier(this.header.key, manifest, { legacy: this._legacy });
      if (verifier.prologue)
        this.state.prologue = Object.assign({}, verifier.prologue);
      this.manifest = this.header.manifest = manifest;
      tx.setAuth({
        key: this.header.key,
        discoveryKey: this.discoveryKey,
        manifest,
        keyPair: this.header.keyPair
      });
      this.compat = verifier.compat;
      this.verifier = verifier;
      this._manifestFlushed = false;
      this.replicator.onupgrade();
      this.emitManifest();
    }
    async copyPrologue(src) {
      await this.state.mutex.lock();
      try {
        await src.mutex.lock();
      } catch (err) {
        this.state.mutex.unlock();
        throw err;
      }
      try {
        await copyPrologue(src, this);
      } finally {
        src.mutex.unlock();
        this.state.mutex.unlock();
        this.checkIfIdle();
      }
    }
    flushed() {
      return this.state.flushed();
    }
    async _validateCommit(state, treeLength) {
      if (this.state.length > state.length) {
        return false;
      }
      if (this.state.length > treeLength) {
        for (const root of this.state.roots) {
          const batchRoot = await MerkleTree.get(state, root.index);
          if (batchRoot.size !== root.size || !b4a.equals(batchRoot.hash, root.hash)) {
            return false;
          }
        }
      }
      if (this.verifier === null) {
        return false;
      }
      return true;
    }
    _verifyBatchUpgrade(batch, manifest) {
      if (!this.header.manifest) {
        if (!manifest)
          manifest = Verifier.defaultSignerManifest(this.header.key);
        if (!manifest || !(Verifier.isValidManifest(this.header.key, manifest) || Verifier.isCompat(this.header.key, manifest))) {
          throw INVALID_SIGNATURE("Proof contains an invalid manifest");
        }
      }
      const verifier = this.verifier || new Verifier(this.header.key, Verifier.createManifest(manifest), { legacy: this._legacy });
      if (!verifier.verify(batch, batch.signature)) {
        throw INVALID_SIGNATURE("Proof contains an invalid signature");
      }
      return manifest;
    }
    async _verifyExclusive({ batch, bitfield, value, manifest }) {
      manifest = this._verifyBatchUpgrade(batch, manifest);
      if (!batch.commitable())
        return false;
      if (this.preupdate !== null)
        await this.preupdate(batch, this.header.key);
      if (!await this.state._verifyBlock(batch, bitfield, value, this.header.manifest ? null : manifest)) {
        return false;
      }
      if (!batch.upgraded && bitfield) {
        this.replicator.onhave(bitfield.start, bitfield.length, bitfield.drop);
      }
      return true;
    }
    async _verifyShared() {
      if (!this._verifies.length)
        return false;
      await this.state.mutex.lock();
      const tx = this.state.createWriteBatch();
      const verifies = this._verifies;
      this._verifies = null;
      this._verified = null;
      try {
        for (const { batch, bitfield, value } of verifies) {
          if (!batch.commitable())
            continue;
          if (bitfield) {
            tx.putBlock(bitfield.start, value);
          }
        }
        const bits = new BitInterlude;
        for (let i = 0;i < verifies.length; i++) {
          const { batch, bitfield, manifest } = verifies[i];
          if (!batch.commitable()) {
            verifies[i] = null;
            continue;
          }
          if (bitfield) {
            bits.setRange(bitfield.start, bitfield.start + 1, true);
          }
          if (manifest && this.header.manifest === null) {
            if (!Verifier.isValidManifest(this.header.key, manifest))
              throw INVALID_CHECKSUM("Manifest hash does not match");
            this._setManifest(tx, manifest, null);
          }
          if (batch.commitable())
            batch.commit(tx);
        }
        const ranges = bits.flush(tx, this.bitfield);
        await this.state.flush();
        for (const { start, end, value } of ranges) {
          this._setBitfieldRanges(start, end, value);
        }
        for (let i = 0;i < verifies.length; i++) {
          const bitfield = verifies[i] && verifies[i].bitfield;
          if (bitfield) {
            this.updateContiguousLength(bitfield);
            this.replicator.onhave(bitfield.start, bitfield.length, bitfield.drop);
          }
        }
      } finally {
        this.state._clearActiveBatch();
        this.state.mutex.unlock();
      }
      return verifies[0] !== null;
    }
    async checkConflict(proof, from) {
      if (this.state.length < proof.upgrade.length || proof.fork !== this.state.fork) {
        return false;
      }
      if (!this.header.manifest) {
        return false;
      }
      const batch = MerkleTree.verifyFullyRemote(this.state, proof);
      try {
        this._verifyBatchUpgrade(batch, proof.manifest);
      } catch {
        return true;
      }
      const roots = await MerkleTree.getRootsFromStorage(this.storage, proof.upgrade.length);
      const remoteTreeHash = crypto.tree(proof.upgrade.nodes);
      const localTreeHash = crypto.tree(roots);
      try {
        const rx = this.state.storage.read();
        const treeProofPromise = MerkleTree.proof(this.state, rx, {
          block: null,
          hash: null,
          seek: null,
          upgrade: {
            start: 0,
            length: proof.upgrade.length
          }
        });
        rx.tryFlush();
        const treeProof = await treeProofPromise;
        const verifyBatch = MerkleTree.verifyFullyRemote(this.state, await treeProof.settle());
        this._verifyBatchUpgrade(verifyBatch, this.header.manifest);
      } catch {
        return true;
      }
      if (b4a.equals(localTreeHash, remoteTreeHash))
        return false;
      await this.state.mutex.lock();
      try {
        const tx = this.state.createWriteBatch();
        this.header.frozen = true;
        tx.setAuth({
          key: this.header.key,
          discoveryKey: this.discoveryKey,
          manifest: this.header.manifest,
          keyPair: this.header.keyPair,
          frozen: true
        });
        await this.state.flush();
      } finally {
        this.state.mutex.unlock();
      }
      const id = b4a.toString(this.discoveryKey, "hex");
      console.log("[hypercore] conflict detected in " + id + " (writable=" + !!this.header.keyPair + ",quorum=" + this.header.manifest.quorum + ")");
      await this._onconflict(proof);
      return true;
    }
    async verifyReorg(proof) {
      const batch = new ReorgBatch(this.state);
      await MerkleTree.reorg(this.state, proof, batch);
      const manifest = this._verifyBatchUpgrade(batch, proof.manifest);
      if (manifest && !this.header.manifest) {
        await this.state.mutex.lock();
        try {
          if (manifest && this.header.manifest === null) {
            const tx = this.state.createWriteBatch();
            this._setManifest(tx, Verifier.createManifest(manifest), null);
            await this.state.flush();
          }
        } finally {
          this.state._unlock();
        }
      }
      return batch;
    }
    async verify(proof, from) {
      if (proof.fork !== this.state.fork)
        return false;
      const batch = await MerkleTree.verify(this.state, proof);
      if (!batch.commitable())
        return false;
      const value = proof.block && proof.block.value || null;
      const op = {
        batch,
        bitfield: value && { drop: false, start: proof.block.index, length: 1 },
        value,
        manifest: proof.manifest,
        from
      };
      if (batch.upgraded) {
        return this._verifyExclusive(op);
      }
      if (this._verifies !== null) {
        const verifies = this._verifies;
        const i = verifies.push(op);
        await this._verified;
        return verifies[i] !== null;
      }
      this._verifies = [op];
      this._verified = this._verifyShared();
      return this._verified;
    }
    async reorg(batch) {
      if (!batch.commitable())
        return false;
      this.truncating++;
      try {
        await this.state.reorg(batch);
      } finally {
        this.truncating--;
      }
      return true;
    }
    openSkipBitfield() {
      if (this.skipBitfield !== null)
        return this.skipBitfield;
      this.skipBitfield = new RemoteBitfield;
      const buf = this.bitfield.toBuffer(this.state.length);
      const bitfield = new Uint32Array(buf.buffer, buf.byteOffset, buf.byteLength / 4);
      this.skipBitfield.insert(0, bitfield);
      return this.skipBitfield;
    }
    _setBitfieldRanges(start, end, value) {
      this.bitfield.setRange(start, end, value);
      if (this.skipBitfield !== null)
        this.skipBitfield.setRange(start, end, value);
    }
    close() {
      if (!this.closing)
        this.closing = this._close();
      return this.closing;
    }
    updateContiguousLength(bitfield) {
      const contig = updateContigBatch(this.header.hints.contiguousLength, bitfield, this.bitfield);
      if (contig.length !== -1 && contig.length !== this.header.hints.contiguousLength) {
        this.header.hints.contiguousLength = contig.length;
      }
    }
    onappend(tree, bitfield) {
      this.header.tree = tree;
      if (!bitfield) {
        this.replicator.onupgrade();
        return;
      }
      this.replicator.cork();
      const { start, length, drop } = bitfield;
      this._setBitfieldRanges(start, start + length, true);
      this.updateContiguousLength({ start, length, drop: false });
      this.replicator.onupgrade();
      this.replicator.onhave(start, length, drop);
      this.replicator.uncork();
    }
    ontruncate(tree, { start, length }) {
      if (tree)
        this.header.tree = tree;
      this.replicator.cork();
      this.replicator.ontruncate(start, length);
      this.replicator.onhave(start, length, true);
      this.replicator.onupgrade();
      this.replicator.uncork();
      for (const sessionState of this.sessionStates) {
        if (start < sessionState.snapshotCompatLength)
          sessionState.snapshotCompatLength = start;
      }
      this._setBitfieldRanges(start, start + length, false);
      this.updateContiguousLength({ start, length, drop: true });
    }
    async _onconflict(proof) {
      await this.replicator.onconflict();
      for (let i = this.monitors.length - 1;i >= 0; i--) {
        const s = this.monitors[i];
        s.emit("conflict", proof.upgrade.length, proof.fork, proof);
      }
      const err = new Error("Two conflicting signatures exist for length " + proof.upgrade.length);
      await this.closeAllSessions(err);
    }
    async closeAllSessions(err) {
      const sessions = this.allSessions();
      const all = [];
      for (const s of sessions)
        all.push(s.close({ error: err, force: false }));
      await Promise.allSettled(all);
    }
    async destroy() {
      if (this.destroyed === true)
        return;
      this.destroyed = true;
      if (this.hasSession() === true)
        throw new Error("Cannot destroy while sessions are open");
      const weakSessions = this.allSessions();
      if (this.replicator)
        this.replicator.destroy();
      if (this.state)
        await this.state.close();
      for (const s of weakSessions)
        s.close().catch(noop);
    }
    async _close() {
      if (this.opened === false)
        await this.opening;
      if (this.hasSession() === true)
        throw new Error("Cannot close while sessions are open");
      if (this.replicator)
        await this.replicator.close();
      await this.destroy();
      if (this.autoClose)
        await this.storage.store.close();
      this.closed = true;
    }
  };
  function updateContigBatch(start, upd, bitfield) {
    const end = upd.start + upd.length;
    let c = start;
    if (upd.drop) {
      if (c > upd.start) {
        c = upd.start;
      }
    } else {
      if (c <= end && c >= upd.start) {
        c = end;
        while (bitfield.get(c))
          c++;
      }
    }
    if (c === start) {
      return {
        length: -1
      };
    }
    if (c > start) {
      return {
        length: c
      };
    }
    return {
      length: c
    };
  }
  function getDefaultTree() {
    return {
      fork: 0,
      length: 0,
      rootHash: null,
      signature: null
    };
  }
  function parseHeader(info) {
    if (!info)
      return null;
    return {
      key: info.key,
      manifest: info.manifest,
      external: null,
      keyPair: info.keyPair,
      tree: info.head || getDefaultTree(),
      hints: {
        reorgs: [],
        contiguousLength: info.hints ? info.hints.contiguousLength : 0
      }
    };
  }
  function noop() {}
  async function getCoreInfo(storage) {
    const r = storage.read();
    const auth = r.getAuth();
    const head = r.getHead();
    const hints = r.getHints();
    r.tryFlush();
    return {
      ...await auth,
      head: await head,
      hints: await hints
    };
  }
});

// node_modules/hypercore/lib/info.js
var require_info = __commonJS((exports, module) => {
  module.exports = class Info {
    constructor(opts = {}) {
      this.key = opts.key;
      this.discoveryKey = opts.discoveryKey;
      this.length = opts.length || 0;
      this.contiguousLength = opts.contiguousLength || 0;
      this.byteLength = opts.byteLength || 0;
      this.fork = opts.fork || 0;
      this.padding = opts.padding || 0;
      this.storage = opts.storage || null;
    }
    static async from(session, opts = {}) {
      return new Info({
        key: session.key,
        discoveryKey: session.discoveryKey,
        length: session.length,
        contiguousLength: session.contiguousLength,
        byteLength: session.byteLength,
        fork: session.fork,
        padding: session.padding,
        storage: opts.storage ? await this.storage(session) : null
      });
    }
    static async storage(session) {
      const { oplog, tree, blocks, bitfield } = session.core;
      try {
        return {
          oplog: await Info.bytesUsed(oplog.storage),
          tree: await Info.bytesUsed(tree.storage),
          blocks: await Info.bytesUsed(blocks.storage),
          bitfield: await Info.bytesUsed(bitfield.storage)
        };
      } catch {
        return null;
      }
    }
    static bytesUsed(file) {
      return new Promise((resolve, reject) => {
        file.stat((err, st) => {
          if (err) {
            resolve(0);
          } else if (typeof st.blocks !== "number") {
            reject(new Error("cannot determine bytes used"));
          } else {
            resolve(st.blocks * 512);
          }
        });
      });
    }
  };
});

// node_modules/hypercore/lib/download.js
var require_download = __commonJS((exports, module) => {
  module.exports = class Download {
    constructor(session, range) {
      this.session = session;
      this.range = range;
      this.request = null;
      this.opened = false;
      this.opening = this._open();
      this.opening.catch(noop);
    }
    ready() {
      return this.opening;
    }
    async _open() {
      if (this.session.opened === false)
        await this.session.opening;
      this._download();
      this.opened = true;
    }
    async done() {
      await this.ready();
      try {
        return await this.request.promise;
      } catch (err) {
        if (isSessionMoved(err))
          return this._download();
        throw err;
      }
    }
    _download() {
      const activeRequests = this.range && this.range.activeRequests || this.session.activeRequests;
      this.request = this.session.core.replicator.addRange(activeRequests, this.range);
      this.request.promise.catch(noop);
      return this.request.promise;
    }
    downloaded() {
      return this.done();
    }
    destroy() {
      this._destroyBackground().catch(noop);
    }
    async _destroyBackground() {
      if (this.opened === false)
        await this.ready();
      if (this.request.context)
        this.request.context.detach(this.request);
    }
  };
  function noop() {}
  function isSessionMoved(err) {
    return err.code === "SESSION_MOVED";
  }
});

// node_modules/hypercore/lib/default-encryption.js
var require_default_encryption = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var { DEFAULT_ENCRYPTION } = require_caps();
  var nonce = b4a.alloc(sodium.crypto_stream_NONCEBYTES);
  module.exports = class DefaultEncryption {
    static PADDING = 8;
    constructor(encryptionKey, hypercoreKey, opts = {}) {
      this.key = encryptionKey;
      this.compat = opts.compat === true;
      const keys = DefaultEncryption.deriveKeys(encryptionKey, hypercoreKey, opts);
      this.blockKey = keys.block;
      this.blindingKey = keys.blinding;
    }
    static deriveKeys(encryptionKey, hypercoreKey, { block = false, compat = false } = {}) {
      const subKeys = b4a.alloc(2 * sodium.crypto_stream_KEYBYTES);
      const blockKey = block ? encryptionKey : subKeys.subarray(0, sodium.crypto_stream_KEYBYTES);
      const blindingKey = subKeys.subarray(sodium.crypto_stream_KEYBYTES);
      if (!block) {
        if (compat)
          sodium.crypto_generichash_batch(blockKey, [encryptionKey], hypercoreKey);
        else
          sodium.crypto_generichash_batch(blockKey, [DEFAULT_ENCRYPTION, hypercoreKey, encryptionKey]);
      }
      sodium.crypto_generichash(blindingKey, blockKey);
      return {
        blinding: blindingKey,
        block: blockKey
      };
    }
    static blockEncryptionKey(hypercoreKey, encryptionKey) {
      const blockKey = b4a.alloc(sodium.crypto_stream_KEYBYTES);
      sodium.crypto_generichash_batch(blockKey, [DEFAULT_ENCRYPTION, hypercoreKey, encryptionKey]);
      return blockKey;
    }
    static encrypt(index, block, fork, blockKey, blindingKey) {
      const padding = block.subarray(0, DefaultEncryption.PADDING);
      block = block.subarray(DefaultEncryption.PADDING);
      c.uint64.encode({ start: 0, end: 8, buffer: padding }, fork);
      c.uint64.encode({ start: 0, end: 8, buffer: nonce }, index);
      nonce.fill(0, 8, 8 + padding.byteLength);
      sodium.crypto_stream_xor(padding, padding, nonce, blindingKey);
      nonce.set(padding, 8);
      sodium.crypto_stream_xor(block, block, nonce, blockKey);
    }
    static decrypt(index, block, blockKey) {
      const padding = block.subarray(0, DefaultEncryption.PADDING);
      block = block.subarray(DefaultEncryption.PADDING);
      c.uint64.encode({ start: 0, end: 8, buffer: nonce }, index);
      nonce.set(padding, 8);
      sodium.crypto_stream_xor(block, block, nonce, blockKey);
    }
    encrypt(index, block, fork, core) {
      if (core.compat !== this.compat)
        this._reload(core);
      return DefaultEncryption.encrypt(index, block, fork, this.blockKey, this.blindingKey);
    }
    decrypt(index, block, core) {
      if (core.compat !== this.compat)
        this._reload(core);
      return DefaultEncryption.decrypt(index, block, this.blockKey);
    }
    padding() {
      return DefaultEncryption.PADDING;
    }
    _reload(core) {
      const block = b4a.equals(this.key, this.blockKey);
      const keys = DefaultEncryption.deriveKeys(this.key, core.key, { block, compat: core.compat });
      this.blockKey = keys.blockKey;
      this.blindingKey = keys.blindingKey;
    }
  };
});

// node_modules/hypercore/lib/streams.js
var require_streams2 = __commonJS((exports) => {
  var { Writable, Readable } = require_streamx();

  class ReadStream extends Readable {
    constructor(core, opts = {}) {
      super();
      this.core = core;
      this.start = opts.start || 0;
      this.end = typeof opts.end === "number" ? opts.end : -1;
      this.snapshot = !opts.live && opts.snapshot !== false;
      this.live = this.end === -1 ? !!opts.live : false;
    }
    _open(cb) {
      this._openP().then(cb, cb);
    }
    _read(cb) {
      this._readP().then(cb, cb);
    }
    async _openP() {
      if (this.end === -1)
        await this.core.update();
      else
        await this.core.ready();
      if (this.snapshot && this.end === -1)
        this.end = this.core.length;
    }
    async _readP() {
      const end = this.live ? -1 : this.end === -1 ? this.core.length : this.end;
      if (end >= 0 && this.start >= end) {
        this.push(null);
        return;
      }
      this.push(await this.core.get(this.start++));
    }
  }
  exports.ReadStream = ReadStream;

  class WriteStream extends Writable {
    constructor(core) {
      super();
      this.core = core;
    }
    _writev(batch, cb) {
      this._writevP(batch).then(cb, cb);
    }
    async _writevP(batch) {
      await this.core.append(batch);
    }
  }
  exports.WriteStream = WriteStream;

  class ByteStream extends Readable {
    constructor(core, opts = {}) {
      super();
      this._core = core;
      this._index = 0;
      this._range = null;
      this._byteOffset = opts.byteOffset || 0;
      this._byteLength = typeof opts.byteLength === "number" ? opts.byteLength : -1;
      this._prefetch = typeof opts.prefetch === "number" ? opts.prefetch : 32;
      this._applyOffset = this._byteOffset > 0;
    }
    _open(cb) {
      this._openp().then(cb, cb);
    }
    _read(cb) {
      this._readp().then(cb, cb);
    }
    async _openp() {
      if (this._byteLength === -1) {
        await this._core.update();
        this._byteLength = Math.max(this._core.byteLength - this._byteOffset, 0);
      }
    }
    async _readp() {
      let data = null;
      if (this._byteLength === 0) {
        this.push(null);
        return;
      }
      let relativeOffset = 0;
      if (this._applyOffset) {
        this._applyOffset = false;
        const [block, byteOffset] = await this._core.seek(this._byteOffset);
        this._index = block;
        relativeOffset = byteOffset;
      }
      this._predownload(this._index + 1);
      data = await this._core.get(this._index++, { valueEncoding: "binary" });
      if (relativeOffset > 0)
        data = data.subarray(relativeOffset);
      if (data.byteLength > this._byteLength)
        data = data.subarray(0, this._byteLength);
      this._byteLength -= data.byteLength;
      this.push(data);
      if (this._byteLength === 0)
        this.push(null);
    }
    _predownload(index) {
      if (this._range)
        this._range.destroy();
      this._range = this._core.download({ start: index, end: index + this._prefetch, linear: true });
    }
    _destroy(cb) {
      if (this._range)
        this._range.destroy();
      cb(null);
    }
  }
  exports.ByteStream = ByteStream;
});

// node_modules/hypercore/index.js
var require_hypercore = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var isOptions = require_is_options();
  var crypto = require_hypercore_crypto();
  var CoreStorage = require_hypercore_storage();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var NoiseSecretStream = require_secret_stream();
  var Protomux = require_protomux();
  var id = require_hypercore_id_encoding();
  var safetyCatch = require_safety_catch();
  var unslab = require_unslab();
  var Core = require_core();
  var Info = require_info();
  var Download = require_download();
  var DefaultEncryption = require_default_encryption();
  var caps = require_caps();
  var { manifestHash, createManifest } = require_verifier();
  var { ReadStream, WriteStream, ByteStream } = require_streams2();
  var { MerkleTree } = require_merkle_tree();
  var {
    ASSERTION,
    BAD_ARGUMENT,
    SESSION_CLOSED,
    SESSION_MOVED,
    SESSION_NOT_WRITABLE,
    SNAPSHOT_NOT_AVAILABLE,
    DECODING_ERROR
  } = require_hypercore_errors();
  var inspect = Symbol.for("nodejs.util.inspect.custom");
  var MAX_SUGGESTED_BLOCK_SIZE = 15 * 1024 * 1024;

  class Hypercore extends EventEmitter {
    constructor(storage, key, opts) {
      super();
      if (isOptions(storage) && !storage.db) {
        opts = storage;
        storage = null;
        key = opts.key || null;
      } else if (isOptions(key)) {
        opts = key;
        key = opts.key || null;
      }
      if (key && typeof key === "string")
        key = id.decode(key);
      if (!opts)
        opts = {};
      if (!storage)
        storage = opts.storage;
      this.core = null;
      this.state = null;
      this.encryption = null;
      this.extensions = new Map;
      this.valueEncoding = null;
      this.encodeBatch = null;
      this.activeRequests = [];
      this.sessions = null;
      this.ongc = null;
      this.keyPair = opts.keyPair || null;
      this.readable = true;
      this.writable = false;
      this.exclusive = false;
      this.opened = false;
      this.closed = false;
      this.weak = !!opts.weak;
      this.snapshotted = !!opts.snapshot;
      this.onwait = opts.onwait || null;
      this.wait = opts.wait !== false;
      this.timeout = opts.timeout || 0;
      this.preload = null;
      this.closing = null;
      this.opening = null;
      this._readonly = opts.writable === false;
      this._preappend = preappend.bind(this);
      this._snapshot = null;
      this._findingPeers = 0;
      this._active = opts.weak ? !!opts.active : opts.active !== false;
      this._sessionIndex = -1;
      this._stateIndex = -1;
      this._monitorIndex = -1;
      this.opening = this._open(storage, key, opts);
      this.opening.catch(safetyCatch);
      this.on("newListener", maybeAddMonitor);
    }
    [inspect](depth, opts) {
      let indent = "";
      if (typeof opts.indentationLvl === "number") {
        while (indent.length < opts.indentationLvl)
          indent += " ";
      }
      let peers = "";
      const min = Math.min(this.peers.length, 5);
      for (let i = 0;i < min; i++) {
        const peer = this.peers[i];
        peers += indent + `    Peer(
`;
        peers += indent + "      remotePublicKey: " + opts.stylize(toHex(peer.remotePublicKey), "string") + `
`;
        peers += indent + "      remoteLength: " + opts.stylize(peer.remoteLength, "number") + `
`;
        peers += indent + "      remoteFork: " + opts.stylize(peer.remoteFork, "number") + `
`;
        peers += indent + "      remoteCanUpgrade: " + opts.stylize(peer.remoteCanUpgrade, "boolean") + `
`;
        peers += indent + "    )" + `
`;
      }
      if (this.peers.length > 5) {
        peers += indent + "  ... and " + (this.peers.length - 5) + ` more
`;
      }
      if (peers)
        peers = `[
` + peers + indent + "  ]";
      else
        peers = "[ " + opts.stylize(0, "number") + " ]";
      return this.constructor.name + `(
` + indent + "  id: " + opts.stylize(this.id, "string") + `
` + indent + "  key: " + opts.stylize(toHex(this.key), "string") + `
` + indent + "  discoveryKey: " + opts.stylize(toHex(this.discoveryKey), "string") + `
` + indent + "  opened: " + opts.stylize(this.opened, "boolean") + `
` + indent + "  closed: " + opts.stylize(this.closed, "boolean") + `
` + indent + "  snapshotted: " + opts.stylize(this.snapshotted, "boolean") + `
` + indent + "  writable: " + opts.stylize(this.writable, "boolean") + `
` + indent + "  length: " + opts.stylize(this.length, "number") + `
` + indent + "  fork: " + opts.stylize(this.fork, "number") + `
` + indent + "  sessions: [ " + opts.stylize(this.sessions.length, "number") + ` ]
` + indent + "  activeRequests: [ " + opts.stylize(this.activeRequests.length, "number") + ` ]
` + indent + "  peers: " + peers + `
` + indent + ")";
    }
    static MAX_SUGGESTED_BLOCK_SIZE = MAX_SUGGESTED_BLOCK_SIZE;
    static DefaultEncryption = DefaultEncryption;
    static key(manifest, { compat, version, namespace } = {}) {
      if (b4a.isBuffer(manifest))
        manifest = { version, signers: [{ publicKey: manifest, namespace }] };
      return compat ? manifest.signers[0].publicKey : manifestHash(createManifest(manifest));
    }
    static discoveryKey(key) {
      return crypto.discoveryKey(key);
    }
    static blockEncryptionKey(key, encryptionKey) {
      return DefaultEncryption.blockEncryptionKey(key, encryptionKey);
    }
    static getProtocolMuxer(stream) {
      return stream.noiseStream.userData;
    }
    static createCore(storage, opts) {
      return new Core(Hypercore.defaultStorage(storage), { autoClose: false, ...opts });
    }
    static createProtocolStream(isInitiator, opts = {}) {
      let outerStream = Protomux.isProtomux(isInitiator) ? isInitiator.stream : isStream(isInitiator) ? isInitiator : opts.stream;
      let noiseStream = null;
      if (outerStream) {
        noiseStream = outerStream.noiseStream;
      } else {
        noiseStream = new NoiseSecretStream(isInitiator, null, opts);
        outerStream = noiseStream.rawStream;
      }
      if (!noiseStream)
        throw BAD_ARGUMENT("Invalid stream");
      if (!noiseStream.userData) {
        const protocol = Protomux.from(noiseStream);
        if (opts.keepAlive !== false) {
          noiseStream.setKeepAlive(5000);
        }
        noiseStream.userData = protocol;
      }
      if (opts.ondiscoverykey) {
        noiseStream.userData.pair({ protocol: "hypercore/alpha" }, opts.ondiscoverykey);
      }
      return outerStream;
    }
    static defaultStorage(storage, opts = {}) {
      if (CoreStorage.isCoreStorage(storage))
        return storage;
      const directory = storage;
      return new CoreStorage(directory, opts);
    }
    snapshot(opts) {
      return this.session({ ...opts, snapshot: true });
    }
    session(opts = {}) {
      if (this.closing) {
        throw SESSION_CLOSED("Cannot make sessions on a closing core");
      }
      if (opts.checkout !== undefined && !opts.name && !opts.atom) {
        throw ASSERTION("Checkouts are only supported on atoms or named sessions");
      }
      const wait = opts.wait === false ? false : this.wait;
      const writable = opts.writable === undefined ? !this._readonly : opts.writable === true;
      const onwait = opts.onwait === undefined ? this.onwait : opts.onwait;
      const timeout = opts.timeout === undefined ? this.timeout : opts.timeout;
      const weak = opts.weak === undefined ? this.weak : opts.weak;
      const Clz = opts.class || Hypercore;
      const s = new Clz(null, this.key, {
        ...opts,
        wait,
        onwait,
        timeout,
        writable,
        weak,
        parent: this
      });
      return s;
    }
    async setEncryptionKey(key, opts) {
      if (!this.opened)
        await this.opening;
      const encryption = this._getEncryptionProvider({ key, block: !!(opts && opts.block) });
      return this.setEncryption(encryption, opts);
    }
    async setEncryption(encryption, opts) {
      if (!this.opened)
        await this.opening;
      if (encryption === null) {
        this.encryption = encryption;
        return;
      }
      if (!isEncryptionProvider(encryption)) {
        throw ASSERTION("Provider does not satisfy HypercoreEncryption interface");
      }
      this.encryption = encryption;
    }
    setKeyPair(keyPair) {
      this.keyPair = keyPair;
    }
    setActive(bool) {
      const active = !!bool;
      if (active === this._active || this.closing)
        return;
      this._active = active;
      if (!this.opened)
        return;
      this.core.replicator.updateActivity(this._active ? 1 : -1);
    }
    async _open(storage, key, opts) {
      const preload = opts.preload || opts.parent && opts.parent.preload;
      if (preload) {
        this.sessions = [];
        this.preload = preload;
        opts = { ...opts, ...await this.preload };
        this.preload = null;
      }
      const parent = opts.parent || null;
      const core = opts.core || parent && parent.core;
      const sessions = opts.sessions || parent && parent.sessions;
      const ongc = opts.ongc || parent && parent.ongc;
      if (core)
        this.core = core;
      if (ongc)
        this.ongc = ongc;
      if (sessions)
        this.sessions = sessions;
      if (this.sessions === null)
        this.sessions = [];
      this._sessionIndex = this.sessions.push(this) - 1;
      if (this.core === null)
        initOnce(this, storage, key, opts);
      if (this._monitorIndex === -2)
        this.core.addMonitor(this);
      try {
        await this._openSession(opts);
      } catch (err) {
        if (this.core.autoClose && this.core.hasSession() === false)
          await this.core.close();
        if (this.exclusive)
          this.core.unlockExclusive();
        this.core.removeMonitor(this);
        this._removeSession();
        if (this.state !== null)
          this.state.removeSession(this);
        this.closed = true;
        this.emit("close");
        throw err;
      }
      this.emit("ready");
      if (this.core.closing)
        this.close().catch(safetyCatch);
    }
    _removeSession() {
      if (this._sessionIndex === -1)
        return;
      const head = this.sessions.pop();
      if (head !== this)
        this.sessions[head._sessionIndex = this._sessionIndex] = head;
      this._sessionIndex = -1;
      if (this.ongc !== null)
        this.ongc(this);
    }
    async _openSession(opts) {
      if (this.core.opened === false)
        await this.core.ready();
      if (this.keyPair === null)
        this.keyPair = opts.keyPair || this.core.header.keyPair;
      const parent = opts.parent || null;
      if (parent && parent.encryption)
        this.encryption = parent.encryption;
      const e = getEncryptionOption(opts);
      if (!this.encryption)
        this.encryption = this._getEncryptionProvider(e);
      this.writable = this._isWritable();
      if (opts.valueEncoding) {
        this.valueEncoding = c.from(opts.valueEncoding);
      }
      if (opts.encodeBatch) {
        this.encodeBatch = opts.encodeBatch;
      }
      if (parent) {
        if (parent._stateIndex === -1)
          await parent.ready();
        if (!this.keyPair)
          this.keyPair = parent.keyPair;
        const ps = parent.state;
        if (ps) {
          const shouldSnapshot = this.snapshotted && !ps.isSnapshot();
          this.state = shouldSnapshot ? await ps.snapshot() : ps.ref();
        }
        if (this.snapshotted && this.core && !this._snapshot) {
          this._updateSnapshot();
        }
      }
      if (opts.exclusive && opts.writable !== false) {
        this.exclusive = true;
        await this.core.lockExclusive();
      }
      const parentState = parent ? parent.state : this.core.state;
      const checkout = opts.checkout === undefined ? -1 : opts.checkout;
      const state = this.state;
      if (opts.atom) {
        this.state = await parentState.createSession(null, false, opts.atom);
        if (state)
          state.unref();
      } else if (opts.name) {
        this.state = await parentState.createSession(opts.name, !!opts.overwrite, null);
        if (state)
          state.unref();
      }
      if (this.state && checkout !== -1) {
        if (!opts.name && !opts.atom)
          throw ASSERTION("Checkouts must be named or atomized");
        if (checkout > this.state.length)
          throw ASSERTION("Invalid checkout " + checkout + " for " + opts.name + ", length is " + this.state.length);
        if (this.state.prologue && checkout < this.state.prologue.length) {
          throw ASSERTION("Invalid checkout " + checkout + " for " + opts.name + ", prologue length is " + this.state.prologue.length);
        }
        if (checkout < this.state.length)
          await this.state.truncate(checkout, this.fork);
      }
      if (this.state === null) {
        this.state = this.core.state.ref();
      }
      this.writable = this._isWritable();
      if (this.snapshotted && this.core)
        this._updateSnapshot();
      this.state.addSession(this);
      this.core = this.state.core;
      if (opts.userData) {
        const tx = this.state.storage.write();
        for (const [key, value] of Object.entries(opts.userData)) {
          tx.putUserData(key, value);
        }
        await tx.flush();
      }
      if (opts.manifest && !this.core.header.manifest) {
        await this.core.setManifest(createManifest(opts.manifest));
      }
      this.core.replicator.updateActivity(this._active ? 1 : 0);
      this.opened = true;
    }
    get replicator() {
      return this.core === null ? null : this.core.replicator;
    }
    _getSnapshot() {
      return {
        length: this.state.length,
        byteLength: this.state.byteLength,
        fork: this.state.fork
      };
    }
    _updateSnapshot() {
      const prev = this._snapshot;
      const next = this._snapshot = this._getSnapshot();
      if (!prev)
        return true;
      return prev.length !== next.length || prev.fork !== next.fork;
    }
    _isWritable() {
      if (this._readonly)
        return false;
      if (this.state && !this.state.isDefault())
        return true;
      return !!(this.keyPair && this.keyPair.secretKey);
    }
    close({ error } = {}) {
      if (this.closing)
        return this.closing;
      this.closing = this._close(error || null);
      return this.closing;
    }
    async _close(error) {
      if (this.opened === false) {
        try {
          await this.opening;
        } catch (err) {
          if (!this.closed)
            throw err;
        }
      }
      if (this.closed === true)
        return;
      this.core.removeMonitor(this);
      this.state.removeSession(this);
      this._removeSession();
      this.readable = false;
      this.writable = false;
      this.opened = false;
      const gc = [];
      for (const ext of this.extensions.values()) {
        if (ext.session === this)
          gc.push(ext);
      }
      for (const ext of gc)
        ext.destroy();
      this.core.replicator.findingPeers -= this._findingPeers;
      this.core.replicator.clearRequests(this.activeRequests, error);
      this.core.replicator.updateActivity(this._active ? -1 : 0);
      this._findingPeers = 0;
      this.state.unref();
      if (this.exclusive)
        this.core.unlockExclusive();
      if (this.core.hasSession()) {
        this.closed = true;
        this.emit("close");
        return;
      }
      if (this.core.autoClose)
        await this.core.close();
      this.closed = true;
      this.emit("close");
    }
    async commit(session, opts) {
      await this.ready();
      await session.ready();
      return this.state.commit(session.state, { keyPair: this.keyPair, ...opts });
    }
    replicate(isInitiator, opts = {}) {
      if (Protomux.isProtomux(isInitiator))
        return this._attachToMuxer(isInitiator, opts);
      if (isStream(isInitiator) && this._isAttached(isInitiator))
        return isInitiator;
      const protocolStream = Hypercore.createProtocolStream(isInitiator, opts);
      const noiseStream = protocolStream.noiseStream;
      const protocol = noiseStream.userData;
      this._attachToMuxer(protocol);
      return protocolStream;
    }
    _isAttached(stream) {
      return stream.userData && this.core && this.core.replicator && this.core.replicator.attached(stream.userData);
    }
    _attachToMuxer(mux) {
      if (this.opened) {
        this.core.replicator.attachTo(mux);
      } else {
        this.opening.then(() => this.core.replicator.attachTo(mux), mux.destroy.bind(mux));
      }
      return mux;
    }
    get id() {
      return this.core === null ? null : this.core.id;
    }
    get key() {
      return this.core === null ? null : this.core.key;
    }
    get discoveryKey() {
      return this.core === null ? null : this.core.discoveryKey;
    }
    get manifest() {
      return this.core === null ? null : this.core.manifest;
    }
    get length() {
      if (this._snapshot)
        return this._snapshot.length;
      return this.opened === false ? 0 : this.state.length;
    }
    get signedLength() {
      return this.opened === false ? 0 : this.state.signedLength();
    }
    get byteLength() {
      if (this.opened === false)
        return 0;
      if (this._snapshot)
        return this._snapshot.byteLength;
      return this.state.byteLength - this.state.length * this.padding;
    }
    get contiguousLength() {
      if (this.opened === false)
        return 0;
      return Math.min(this.core.state.length, this.core.header.hints.contiguousLength);
    }
    get contiguousByteLength() {
      return 0;
    }
    get fork() {
      if (this.opened === false)
        return 0;
      return this.state.fork;
    }
    get padding() {
      if (this.encryption && this.key && this.manifest) {
        return this.encryption.padding(this.core, this.length);
      }
      return 0;
    }
    get peers() {
      return this.opened === false ? [] : this.core.replicator.peers;
    }
    get globalCache() {
      return this.opened === false ? null : this.core.globalCache;
    }
    ready() {
      return this.opening;
    }
    async setUserData(key, value) {
      if (this.opened === false)
        await this.opening;
      await this.state.setUserData(key, value);
    }
    async getUserData(key) {
      if (this.opened === false)
        await this.opening;
      const batch = this.state.storage.read();
      const p = batch.getUserData(key);
      batch.tryFlush();
      return p;
    }
    transferSession(core) {
      if (this.weak === false) {
        this.core.activeSessions--;
        core.activeSessions++;
      }
      if (this._monitorIndex >= 0) {
        this.core.removeMonitor(this);
        core.addMonitor(this);
      }
      const old = this.core;
      this.core = core;
      old.replicator.clearRequests(this.activeRequests, SESSION_MOVED());
      this.emit("migrate", this.key);
    }
    findingPeers() {
      this._findingPeers++;
      if (this.core !== null && !this.closing)
        this.core.replicator.findingPeers++;
      let once = true;
      return () => {
        if (this.closing || !once)
          return;
        once = false;
        this._findingPeers--;
        if (this.core !== null && --this.core.replicator.findingPeers === 0) {
          this.core.replicator.updateAll();
        }
      };
    }
    async info(opts) {
      if (this.opened === false)
        await this.opening;
      return Info.from(this, opts);
    }
    async update(opts) {
      if (this.opened === false)
        await this.opening;
      if (this.closing !== null)
        return false;
      if (this.snapshotted)
        return false;
      if (this.writable && (!opts || opts.force !== true))
        return false;
      const remoteWait = this._shouldWait(opts, this.core.replicator.findingPeers > 0);
      let upgraded = false;
      if (await this.core.replicator.applyPendingReorg()) {
        upgraded = true;
      }
      if (!upgraded && remoteWait) {
        const activeRequests = opts && opts.activeRequests || this.activeRequests;
        const req = this.core.replicator.addUpgrade(activeRequests);
        try {
          upgraded = await req.promise;
        } catch (err) {
          if (isSessionMoved(err))
            return this.update(opts);
          throw err;
        }
      }
      if (!upgraded)
        return false;
      return true;
    }
    async seek(bytes, opts) {
      if (this.opened === false)
        await this.opening;
      if (!isValidIndex(bytes))
        throw ASSERTION("seek is invalid");
      const activeRequests = opts && opts.activeRequests || this.activeRequests;
      if (this.encryption && !this.core.manifest) {
        const req2 = this.replicator.addUpgrade(activeRequests);
        try {
          await req2.promise;
        } catch (err) {
          if (isSessionMoved(err))
            return this.seek(bytes, opts);
          throw err;
        }
      }
      const s = MerkleTree.seek(this.state, bytes, this.padding);
      const offset = await s.update();
      if (offset)
        return offset;
      if (this.closing !== null)
        throw SESSION_CLOSED();
      if (!this._shouldWait(opts, this.wait))
        return null;
      const req = this.core.replicator.addSeek(activeRequests, s);
      const timeout = opts && opts.timeout !== undefined ? opts.timeout : this.timeout;
      if (timeout)
        req.context.setTimeout(req, timeout);
      try {
        return await req.promise;
      } catch (err) {
        if (isSessionMoved(err))
          return this.seek(bytes, opts);
        throw err;
      }
    }
    async has(start, end = start + 1) {
      if (this.opened === false)
        await this.opening;
      if (!isValidIndex(start) || !isValidIndex(end))
        throw ASSERTION("has range is invalid");
      if (this.state.isDefault()) {
        if (end === start + 1)
          return this.core.bitfield.get(start);
        const i = this.core.bitfield.firstUnset(start);
        return i === -1 || i >= end;
      }
      if (end === start + 1) {
        const rx = this.state.storage.read();
        const block = rx.getBlock(start);
        rx.tryFlush();
        return await block !== null;
      }
      let count = 0;
      const stream = this.state.storage.createBlockStream({ gte: start, lt: end });
      for await (const block of stream) {
        if (block === null)
          return false;
        count++;
      }
      return count === end - start;
    }
    async get(index, opts) {
      if (this.opened === false)
        await this.opening;
      if (!isValidIndex(index))
        throw ASSERTION("block index is invalid");
      if (this.closing !== null)
        throw SESSION_CLOSED();
      const encoding = opts && opts.valueEncoding && c.from(opts.valueEncoding) || this.valueEncoding;
      const req = this._get(index, opts);
      let block = await req;
      if (!block)
        return null;
      if (opts && opts.raw)
        return block;
      if (this.encryption && (!opts || opts.decrypt !== false)) {
        block = b4a.from(block);
        await this.encryption.decrypt(index, block, this.core);
      }
      return this._decode(encoding, block, index);
    }
    async clear(start, end = start + 1, opts) {
      if (this.opened === false)
        await this.opening;
      if (this.closing !== null)
        throw SESSION_CLOSED();
      if (typeof end === "object") {
        opts = end;
        end = start + 1;
      }
      if (!isValidIndex(start) || !isValidIndex(end))
        throw ASSERTION("clear range is invalid");
      const cleared = opts && opts.diff ? { blocks: 0 } : null;
      if (start >= end)
        return cleared;
      if (start >= this.length)
        return cleared;
      await this.state.clear(start, end, cleared);
      return cleared;
    }
    async purge() {
      await this._closeAllSessions(null);
      await this.core.purge();
    }
    async _get(index, opts) {
      const block = await readBlock(this.state.storage.read(), index);
      if (block !== null)
        return block;
      if (this.closing !== null)
        throw SESSION_CLOSED();
      if (this._snapshot !== null) {
        checkSnapshot(this, index);
        const coreBlock = await readBlock(this.core.state.storage.read(), index);
        checkSnapshot(this, index);
        if (coreBlock !== null)
          return coreBlock;
      }
      if (this.core.bitfield.get(index)) {
        const coreBlock = await readBlock(this.state.storage.read(), index);
        if (coreBlock !== null)
          return coreBlock;
      }
      if (!this._shouldWait(opts, this.wait))
        return null;
      if (opts && opts.onwait)
        opts.onwait(index, this);
      if (this.onwait)
        this.onwait(index, this);
      const activeRequests = opts && opts.activeRequests || this.activeRequests;
      const req = this.core.replicator.addBlock(activeRequests, index);
      req.snapshot = index < this.length;
      const timeout = opts && opts.timeout !== undefined ? opts.timeout : this.timeout;
      if (timeout)
        req.context.setTimeout(req, timeout);
      let replicatedBlock = null;
      try {
        replicatedBlock = await req.promise;
      } catch (err) {
        if (isSessionMoved(err))
          return this._get(index, opts);
        throw err;
      }
      if (this._snapshot !== null)
        checkSnapshot(this, index);
      return maybeUnslab(replicatedBlock);
    }
    _shouldWait(opts, defaultValue) {
      if (opts) {
        if (opts.wait === false)
          return false;
        if (opts.wait === true)
          return true;
      }
      return defaultValue;
    }
    createReadStream(opts) {
      return new ReadStream(this, opts);
    }
    createWriteStream(opts) {
      return new WriteStream(this, opts);
    }
    createByteStream(opts) {
      return new ByteStream(this, opts);
    }
    download(range) {
      return new Download(this, range);
    }
    undownload(range) {
      range.destroy(null);
    }
    cancel(request) {}
    async truncate(newLength = 0, opts = {}) {
      if (this.opened === false)
        await this.opening;
      const {
        fork = this.state.fork + 1,
        keyPair = this.keyPair,
        signature = null
      } = typeof opts === "number" ? { fork: opts } : opts;
      const isDefault = this.state === this.core.state;
      const writable = !this._readonly && !!(signature || keyPair && keyPair.secretKey);
      if (isDefault && writable === false && (newLength > 0 || fork !== this.state.fork))
        throw SESSION_NOT_WRITABLE();
      await this.state.truncate(newLength, fork, { keyPair, signature });
      if (this.state === this.core.state)
        this.core.replicator.updateAll();
    }
    async append(blocks, opts = {}) {
      if (this.opened === false)
        await this.opening;
      const isDefault = this.state === this.core.state;
      const defaultKeyPair = this.state.name === null ? this.keyPair : null;
      const { keyPair = defaultKeyPair, signature = null, maxLength } = opts;
      const writable = !isDefault || !!signature || !!(keyPair && keyPair.secretKey) || opts.writable === true;
      if (this._readonly || writable === false)
        throw SESSION_NOT_WRITABLE();
      blocks = Array.isArray(blocks) ? blocks : [blocks];
      const preappend2 = this.encryption && this._preappend;
      const buffers = this.encodeBatch !== null ? this.encodeBatch(blocks) : new Array(blocks.length);
      if (this.encodeBatch === null) {
        for (let i = 0;i < blocks.length; i++) {
          buffers[i] = this._encode(this.valueEncoding, blocks[i]);
        }
      }
      for (const b of buffers) {
        if (b.byteLength > MAX_SUGGESTED_BLOCK_SIZE) {
          throw BAD_ARGUMENT("Appended block exceeds the maximum suggested block size");
        }
      }
      return this.state.append(buffers, { keyPair, signature, preappend: preappend2, maxLength });
    }
    async signable(length = -1, fork = -1) {
      if (this.opened === false)
        await this.opening;
      if (length === -1)
        length = this.length;
      if (fork === -1)
        fork = this.fork;
      return caps.treeSignable(this.key, await this.treeHash(length), length, fork);
    }
    async treeHash(length = -1) {
      if (this.opened === false)
        await this.opening;
      if (length === -1)
        length = this.length;
      const roots = await MerkleTree.getRoots(this.state, length);
      return crypto.tree(roots);
    }
    async proof(opts) {
      if (this.opened === false)
        await this.opening;
      const rx = this.state.storage.read();
      const promise = MerkleTree.proof(this.state, rx, opts);
      rx.tryFlush();
      return promise;
    }
    async verifyFullyRemote(proof) {
      if (this.opened === false)
        await this.opening;
      const batch = await MerkleTree.verifyFullyRemote(this.state, proof);
      await this.core._verifyBatchUpgrade(batch, proof.manifest);
      return batch;
    }
    registerExtension(name, handlers = {}) {
      if (this.extensions.has(name)) {
        const ext2 = this.extensions.get(name);
        ext2.handlers = handlers;
        ext2.encoding = c.from(handlers.encoding || c.buffer);
        ext2.session = this;
        return ext2;
      }
      const ext = {
        name,
        handlers,
        encoding: c.from(handlers.encoding || c.buffer),
        session: this,
        send(message, peer) {
          const buffer = c.encode(this.encoding, message);
          peer.extension(name, buffer);
        },
        broadcast(message) {
          const buffer = c.encode(this.encoding, message);
          for (const peer of this.session.peers) {
            peer.extension(name, buffer);
          }
        },
        destroy() {
          for (const peer of this.session.peers) {
            if (peer.extensions.get(name) === ext)
              peer.extensions.delete(name);
          }
          this.session.extensions.delete(name);
        },
        _onmessage(state, peer) {
          const m = this.encoding.decode(state);
          if (this.handlers.onmessage)
            this.handlers.onmessage(m, peer);
        }
      };
      this.extensions.set(name, ext);
      if (this.core === null)
        this._monitorIndex = -2;
      else
        this.core.addMonitor(this);
      for (const peer of this.peers) {
        peer.extensions.set(name, ext);
      }
      return ext;
    }
    _encode(enc, val) {
      const state = { start: this.padding, end: this.padding, buffer: null };
      if (b4a.isBuffer(val)) {
        if (state.start === 0)
          return val;
        state.end += val.byteLength;
      } else if (enc) {
        enc.preencode(state, val);
      } else {
        val = b4a.from(val);
        if (state.start === 0)
          return val;
        state.end += val.byteLength;
      }
      state.buffer = b4a.allocUnsafe(state.end);
      if (enc)
        enc.encode(state, val);
      else
        state.buffer.set(val, state.start);
      return state.buffer;
    }
    _decode(enc, block, index) {
      if (this.encryption)
        block = block.subarray(this.encryption.padding(this.core, index));
      try {
        if (enc)
          return c.decode(enc, block);
      } catch {
        throw DECODING_ERROR();
      }
      return block;
    }
    _getEncryptionProvider(e) {
      if (isEncryptionProvider(e))
        return e;
      if (!e || !e.key)
        return null;
      return new DefaultEncryption(e.key, this.key, { block: e.block, compat: this.core.compat });
    }
  }
  module.exports = Hypercore;
  function isStream(s) {
    return typeof s === "object" && s && typeof s.pipe === "function";
  }
  function toHex(buf) {
    return buf && b4a.toString(buf, "hex");
  }
  async function preappend(blocks) {
    const offset = this.state.length;
    const fork = this.state.encryptionFork;
    for (let i = 0;i < blocks.length; i++) {
      await this.encryption.encrypt(offset + i, blocks[i], fork, this.core);
    }
  }
  function isValidIndex(index) {
    return index === 0 || index > 0;
  }
  function maybeUnslab(block) {
    return block !== null && 2 * block.byteLength < block.buffer.byteLength ? unslab(block) : block;
  }
  function checkSnapshot(snapshot, index) {
    if (index >= snapshot.state.snapshotCompatLength)
      throw SNAPSHOT_NOT_AVAILABLE();
  }
  function readBlock(rx, index) {
    const promise = rx.getBlock(index);
    rx.tryFlush();
    return promise;
  }
  function initOnce(session, storage, key, opts) {
    if (storage === null)
      storage = opts.storage || null;
    if (key === null)
      key = opts.key || null;
    session.core = new Core(Hypercore.defaultStorage(storage), {
      preopen: opts.preopen,
      eagerUpgrade: true,
      notDownloadingLinger: opts.notDownloadingLinger,
      allowFork: opts.allowFork !== false,
      inflightRange: opts.inflightRange,
      compat: opts.compat === true,
      force: opts.force,
      createIfMissing: opts.createIfMissing,
      discoveryKey: opts.discoveryKey,
      overwrite: opts.overwrite,
      key,
      keyPair: opts.keyPair,
      legacy: opts.legacy,
      manifest: opts.manifest,
      globalCache: opts.globalCache || null
    });
  }
  function maybeAddMonitor(name) {
    if (name === "append" || name === "truncate")
      return;
    if (this._monitorIndex >= 0 || this.closing)
      return;
    if (this.core === null) {
      this._monitorIndex = -2;
    } else {
      this.core.addMonitor(this);
    }
  }
  function isSessionMoved(err) {
    return err.code === "SESSION_MOVED";
  }
  function getEncryptionOption(opts) {
    if (opts.encryptionKey)
      return { key: opts.encryptionKey, block: !!opts.isBlockKey };
    if (!opts.encryption)
      return null;
    return b4a.isBuffer(opts.encryption) ? { key: opts.encryption } : opts.encryption;
  }
  function isEncryptionProvider(e) {
    return e && isFunction(e.padding) && isFunction(e.encrypt) && isFunction(e.decrypt);
  }
  function isFunction(fn) {
    return !!fn && typeof fn === "function";
  }
});

// node_modules/autobase/encoding/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var IndexEncoder = require_index_encoder();
  var Checkout = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.key);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        key: c.fixed32.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var Clock = c.array(Checkout);
  var IndexCheckpoint = {
    preencode(state, m) {
      c.fixed64.preencode(state, m.signature);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed64.encode(state, m.signature);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        signature: c.fixed64.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  var KeyV0 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.key);
    },
    decode(state) {
      return {
        key: c.fixed32.decode(state),
        length: -1
      };
    }
  };
  var KeysV0 = c.array(KeyV0);
  var WakeupV0 = {
    preencode(state, m) {
      c.uint.preencode(state, 0);
      c.uint.preencode(state, m.type);
      if (m.type === 1) {
        KeysV0.preencode(state, m.writers);
      }
    },
    encode(state, m) {
      c.uint.encode(state, 0);
      c.uint.encode(state, m.type);
      if (m.type === 1) {
        KeysV0.encode(state, m.writers);
      }
    },
    decode(state) {
      const v = c.uint.decode(state);
      if (v !== 0)
        throw new Error("Unsupported version: " + v);
      const type = c.uint.decode(state);
      const m = { version: 0, type, writers: null };
      if (m.type === 1) {
        m.writers = KeysV0.decode(state);
      }
      return m;
    }
  };
  var Wakeup = {
    preencode(state, m) {
      if (m.version === 0)
        return WakeupV0.preencode(state, m);
      c.uint.preencode(state, 1);
      c.uint.preencode(state, m.type);
      if (m.type === 1) {
        Clock.preencode(state, m.writers);
      }
    },
    encode(state, m) {
      if (m.version === 0)
        return WakeupV0.encode(state, m);
      c.uint.encode(state, 1);
      c.uint.encode(state, m.type);
      if (m.type === 1) {
        Clock.encode(state, m.writers);
      }
    },
    decode(state) {
      const start = state.start;
      const v = c.uint.decode(state);
      if (v > 1)
        throw new Error("Unsupported version: " + v);
      if (v === 0) {
        state.start = start;
        return WakeupV0.decode(state);
      }
      const type = c.uint.decode(state);
      const m = { version: 1, type, writers: null };
      if (m.type === 1) {
        m.writers = Clock.decode(state);
      }
      return m;
    }
  };
  var BootRecordV0 = {
    preencode() {
      throw new Error("version 0 records cannot be encoded");
    },
    encode() {
      throw new Error("version 0 records cannot be encoded");
    },
    decode(state) {
      const indexed = Checkout.decode(state);
      const heads = Clock.decode(state);
      return { version: 0, key: indexed.key, indexedLength: indexed.length, indexersUpdated: false, fastForwarding: false, recoveries: 1, migrating: false, heads };
    }
  };
  var Checkpointer = {
    preencode(state, idx) {
      c.uint.preencode(state, idx.checkpointer);
      if (idx.checkpoint !== null)
        IndexCheckpoint.preencode(state, idx.checkpoint);
    },
    encode(state, idx) {
      c.uint.encode(state, idx.checkpointer);
      if (idx.checkpoint !== null)
        IndexCheckpoint.encode(state, idx.checkpoint);
    },
    decode(state) {
      const checkpointer = c.uint.decode(state);
      const checkpoint = checkpointer ? null : IndexCheckpoint.decode(state);
      return {
        checkpointer,
        checkpoint
      };
    }
  };
  var CheckpointerArray = c.array(Checkpointer);
  var Indexer = {
    preencode(state, m) {
      c.uint.preencode(state, m.signature);
      c.fixed32.preencode(state, m.namespace);
      c.fixed32.preencode(state, m.publicKey);
    },
    encode(state, m) {
      c.uint.encode(state, m.signature);
      c.fixed32.encode(state, m.namespace);
      c.fixed32.encode(state, m.publicKey);
    },
    decode(state) {
      return {
        signature: c.uint.decode(state),
        namespace: c.fixed32.decode(state),
        publicKey: c.fixed32.decode(state)
      };
    }
  };
  var Indexers = c.array(Indexer);
  var DigestV0 = {
    preencode(state, m) {
      c.uint.preencode(state, m.pointer);
      if (m.pointer === 0) {
        Indexers.preencode(state, m.indexers);
      }
    },
    encode(state, m) {
      c.uint.encode(state, m.pointer);
      if (m.pointer === 0) {
        Indexers.encode(state, m.indexers);
      }
    },
    decode(state) {
      const pointer = c.uint.decode(state);
      return {
        pointer,
        indexers: pointer === 0 ? Indexers.decode(state) : null
      };
    }
  };
  var Digest = {
    preencode(state, m) {
      c.uint.preencode(state, m.pointer);
      if (m.pointer === 0) {
        c.fixed32.preencode(state, m.key);
      }
    },
    encode(state, m) {
      c.uint.encode(state, m.pointer);
      if (m.pointer === 0) {
        c.fixed32.encode(state, m.key);
      }
    },
    decode(state) {
      const pointer = c.uint.decode(state);
      return {
        pointer,
        key: pointer === 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  var Node = {
    preencode(state, m) {
      Clock.preencode(state, m.heads);
      c.uint.preencode(state, m.batch);
      c.buffer.preencode(state, m.value);
    },
    encode(state, m) {
      Clock.encode(state, m.heads);
      c.uint.encode(state, m.batch);
      c.buffer.encode(state, m.value);
    },
    decode(state, m) {
      return {
        heads: Clock.decode(state),
        batch: c.uint.decode(state),
        value: c.buffer.decode(state)
      };
    }
  };
  var Additional = {
    preencode(state, m) {
      c.uint.preencode(state, m.pointer);
      if (m.pointer === 0) {
        AdditionalData.preencode(state, m.data);
      }
    },
    encode(state, m) {
      c.uint.encode(state, m.pointer);
      if (m.pointer === 0) {
        AdditionalData.encode(state, m.data);
      }
    },
    decode(state) {
      const pointer = c.uint.decode(state);
      return {
        pointer,
        data: pointer === 0 ? AdditionalData.decode(state) : null
      };
    }
  };
  var AdditionalData = {
    preencode(state, m) {
      c.uint.preencode(state, 0);
    },
    encode(state, m) {
      c.uint.encode(state, 0);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        encryptionId: flags & 1 ? c.fixed32.decode(state) : null,
        abi: flags & 2 ? c.uint.decode(state) : 0
      };
    }
  };
  var OplogMessageV1 = {
    preencode(state, m) {
      throw new Error("Encoding not supported");
    },
    encode(state, m) {
      throw new Error("Encoding not supported");
    },
    decode(state) {
      const maxSupportedVersion = c.uint.decode(state);
      const flags = c.uint.decode(state);
      const isCheckpointer = (flags & 1) !== 0;
      const chk = isCheckpointer ? CheckpointerArray.decode(state) : null;
      const digest = isCheckpointer ? Digest.decode(state) : null;
      const node = Node.decode(state);
      return {
        version: 1,
        maxSupportedVersion,
        digest,
        checkpoint: chk ? { system: chk[0], encryption: null, user: chk.slice(1) } : null,
        optimistic: (flags & 2) !== 0,
        node
      };
    }
  };
  var OplogMessageV0 = {
    preencode(state, m) {
      throw new Error("Encoding not supported");
    },
    encode(state, m) {
      throw new Error("Encoding not supported");
    },
    decode(state) {
      const flags = c.uint.decode(state);
      const isCheckpointer = (flags & 1) !== 0;
      if (isCheckpointer)
        DigestV0.decode(state);
      const chk = isCheckpointer ? CheckpointerArray.decode(state) : null;
      const node = Node.decode(state);
      Additional.decode(state);
      const maxSupportedVersion = state.start < state.end ? c.uint.decode(state) : 0;
      return {
        version: 0,
        maxSupportedVersion,
        digest: null,
        checkpoint: chk ? { system: chk[0], encryption: null, user: chk.slice(1) } : null,
        optimistic: null,
        node
      };
    }
  };
  var LINEARIZER_PREFIX = 1;
  var LinearizerKey = {
    preencode(state, seq) {
      IndexEncoder.UINT.preencode(state, LINEARIZER_PREFIX);
      IndexEncoder.UINT.preencode(state, seq);
    },
    encode(state, seq) {
      IndexEncoder.UINT.encode(state, LINEARIZER_PREFIX);
      IndexEncoder.UINT.encode(state, seq);
    },
    decode(state) {
      IndexEncoder.UINT.decode(state);
      return IndexEncoder.UINT.decode(state);
    }
  };
  function infoLegacyMap(info) {
    return {
      version: info.version,
      members: info.members,
      pendingIndexers: info.pendingIndexers,
      indexers: info.indexers,
      heads: info.heads,
      views: info.views,
      encryptionLength: 0,
      entropy: null
    };
  }
  module.exports = {
    Wakeup,
    BootRecordV0,
    OplogMessageV0,
    OplogMessageV1,
    LinearizerKey,
    infoLegacyMap
  };
});

// node_modules/autobase/encoding/spec/autobase/index.js
var require_autobase = __commonJS((exports, module) => {
  var { c } = require_runtime2();
  var external0 = require_legacy();
  var VERSION = 1;
  var version = VERSION;
  var encoding0 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.key);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      const r0 = c.fixed32.decode(state);
      const r1 = c.uint.decode(state);
      return {
        key: r0,
        length: r1
      };
    }
  };
  var encoding1 = c.array(encoding0);
  var encoding2 = {
    preencode(state, m) {
      c.fixed64.preencode(state, m.signature);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed64.encode(state, m.signature);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      const r0 = c.fixed64.decode(state);
      const r1 = c.uint.decode(state);
      return {
        signature: r0,
        length: r1
      };
    }
  };
  var encoding3 = external0.Wakeup;
  var encoding4 = external0.BootRecordV0;
  var encoding5 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.uint.preencode(state, m.systemLength);
      state.end++;
      if (m.recoveries)
        c.uint.preencode(state, m.recoveries);
    },
    encode(state, m) {
      const flags = (m.indexersUpdated ? 1 : 0) | (m.fastForwarding ? 2 : 0) | (m.recoveries ? 4 : 0);
      c.fixed32.encode(state, m.key);
      c.uint.encode(state, m.systemLength);
      c.uint.encode(state, flags);
      if (m.recoveries)
        c.uint.encode(state, m.recoveries);
    },
    decode(state, version2) {
      if (version2 === undefined)
        version2 = c.uint.decode(state);
      const r0 = c.fixed32.decode(state);
      const r1 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: version2,
        key: r0,
        systemLength: r1,
        indexersUpdated: (flags & 1) !== 0,
        fastForwarding: (flags & 2) !== 0,
        recoveries: (flags & 4) !== 0 ? c.uint.decode(state) : 0
      };
    }
  };
  var encoding6 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      switch (m.version) {
        case 0:
          encoding4.preencode(state, m);
          break;
        case 1:
        case 2:
        case 3:
          encoding5.preencode(state, m);
          break;
        default:
          throw new Error("Unsupported version");
      }
    },
    encode(state, m) {
      c.uint.encode(state, m.version);
      switch (m.version) {
        case 0:
          encoding4.encode(state, m);
          break;
        case 1:
        case 2:
        case 3:
          encoding5.encode(state, m);
          break;
        default:
          throw new Error("Unsupported version");
      }
    },
    decode(state) {
      const version2 = c.uint.decode(state);
      switch (version2) {
        case 0: {
          const decoded = encoding4.decode(state, version2);
          return decoded;
        }
        case 1:
        case 2:
        case 3: {
          const decoded = encoding5.decode(state, version2);
          return decoded;
        }
        default:
          throw new Error("Unsupported version");
      }
    }
  };
  var encoding7 = {
    preencode(state, m) {
      state.end++;
      if (m.checkpointer)
        c.uint.preencode(state, m.checkpointer);
      if (m.checkpoint)
        encoding2.preencode(state, m.checkpoint);
    },
    encode(state, m) {
      const flags = (m.checkpointer ? 1 : 0) | (m.checkpoint ? 2 : 0);
      c.uint.encode(state, flags);
      if (m.checkpointer)
        c.uint.encode(state, m.checkpointer);
      if (m.checkpoint)
        encoding2.encode(state, m.checkpoint);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        checkpointer: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
        checkpoint: (flags & 2) !== 0 ? encoding2.decode(state) : null
      };
    }
  };
  var encoding8_2 = c.array(encoding7);
  var encoding8 = {
    preencode(state, m) {
      state.end++;
      if (m.system)
        encoding7.preencode(state, m.system);
      if (m.encryption)
        encoding7.preencode(state, m.encryption);
      if (m.user)
        encoding8_2.preencode(state, m.user);
    },
    encode(state, m) {
      const flags = (m.system ? 1 : 0) | (m.encryption ? 2 : 0) | (m.user ? 4 : 0);
      c.uint.encode(state, flags);
      if (m.system)
        encoding7.encode(state, m.system);
      if (m.encryption)
        encoding7.encode(state, m.encryption);
      if (m.user)
        encoding8_2.encode(state, m.user);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        system: (flags & 1) !== 0 ? encoding7.decode(state) : null,
        encryption: (flags & 2) !== 0 ? encoding7.decode(state) : null,
        user: (flags & 4) !== 0 ? encoding8_2.decode(state) : null
      };
    }
  };
  var encoding9 = {
    preencode(state, m) {
      state.end++;
      if (m.pointer)
        c.uint.preencode(state, m.pointer);
      if (m.key)
        c.fixed32.preencode(state, m.key);
    },
    encode(state, m) {
      const flags = (m.pointer ? 1 : 0) | (m.key ? 2 : 0);
      c.uint.encode(state, flags);
      if (m.pointer)
        c.uint.encode(state, m.pointer);
      if (m.key)
        c.fixed32.encode(state, m.key);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        pointer: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
        key: (flags & 2) !== 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  var encoding10 = {
    preencode(state, m) {
      encoding1.preencode(state, m.heads);
      c.uint.preencode(state, m.batch);
      c.buffer.preencode(state, m.value);
    },
    encode(state, m) {
      encoding1.encode(state, m.heads);
      c.uint.encode(state, m.batch);
      c.buffer.encode(state, m.value);
    },
    decode(state) {
      const r0 = encoding1.decode(state);
      const r1 = c.uint.decode(state);
      const r2 = c.buffer.decode(state);
      return {
        heads: r0,
        batch: r1,
        value: r2
      };
    }
  };
  var encoding11 = external0.OplogMessageV0;
  var encoding12 = external0.OplogMessageV1;
  var encoding13_1 = c.frame(encoding8);
  var encoding13_2 = c.frame(encoding9);
  var encoding13 = {
    preencode(state, m) {
      encoding10.preencode(state, m.node);
      state.end++;
      if (m.checkpoint)
        encoding13_1.preencode(state, m.checkpoint);
      if (m.digest)
        encoding13_2.preencode(state, m.digest);
    },
    encode(state, m) {
      const flags = (m.checkpoint ? 1 : 0) | (m.digest ? 2 : 0) | (m.optimistic ? 4 : 0);
      encoding10.encode(state, m.node);
      c.uint.encode(state, flags);
      if (m.checkpoint)
        encoding13_1.encode(state, m.checkpoint);
      if (m.digest)
        encoding13_2.encode(state, m.digest);
    },
    decode(state, version2) {
      if (version2 === undefined)
        version2 = c.uint.decode(state);
      const r0 = encoding10.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: version2,
        node: r0,
        checkpoint: (flags & 1) !== 0 ? encoding13_1.decode(state) : null,
        digest: (flags & 2) !== 0 ? encoding13_2.decode(state) : null,
        optimistic: (flags & 4) !== 0
      };
    }
  };
  var encoding14 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      switch (m.version) {
        case 0:
          encoding11.preencode(state, m);
          break;
        case 1:
          encoding12.preencode(state, m);
          break;
        case 2:
          encoding13.preencode(state, m);
          break;
        default:
          throw new Error("Unsupported version");
      }
    },
    encode(state, m) {
      c.uint.encode(state, m.version);
      switch (m.version) {
        case 0:
          encoding11.encode(state, m);
          break;
        case 1:
          encoding12.encode(state, m);
          break;
        case 2:
          encoding13.encode(state, m);
          break;
        default:
          throw new Error("Unsupported version");
      }
    },
    decode(state) {
      const version2 = c.uint.decode(state);
      switch (version2) {
        case 0: {
          const decoded = encoding11.decode(state, version2);
          return decoded;
        }
        case 1: {
          const decoded = encoding12.decode(state, version2);
          return decoded;
        }
        case 2: {
          const decoded = encoding13.decode(state, version2);
          return decoded;
        }
        default:
          throw new Error("Unsupported version");
      }
    }
  };
  var encoding15_1 = c.array(c.fixed32);
  var encoding15 = {
    preencode(state, m) {
      c.uint.preencode(state, m.members);
      encoding15_1.preencode(state, m.pendingIndexers);
      encoding1.preencode(state, m.indexers);
      encoding1.preencode(state, m.heads);
      encoding1.preencode(state, m.views);
    },
    encode(state, m) {
      c.uint.encode(state, m.members);
      encoding15_1.encode(state, m.pendingIndexers);
      encoding1.encode(state, m.indexers);
      encoding1.encode(state, m.heads);
      encoding1.encode(state, m.views);
    },
    decode(state, version2) {
      if (version2 === undefined)
        version2 = c.uint.decode(state);
      const r0 = c.uint.decode(state);
      const r1 = encoding15_1.decode(state);
      const r2 = encoding1.decode(state);
      const r3 = encoding1.decode(state);
      const r4 = encoding1.decode(state);
      return {
        version: version2,
        members: r0,
        pendingIndexers: r1,
        indexers: r2,
        heads: r3,
        views: r4
      };
    }
  };
  var encoding16_1 = encoding15_1;
  var encoding16 = {
    preencode(state, m) {
      c.uint.preencode(state, m.members);
      encoding16_1.preencode(state, m.pendingIndexers);
      encoding1.preencode(state, m.indexers);
      encoding1.preencode(state, m.heads);
      encoding1.preencode(state, m.views);
      c.uint.preencode(state, m.encryptionLength);
      state.end++;
      if (m.entropy)
        c.fixed32.preencode(state, m.entropy);
    },
    encode(state, m) {
      const flags = m.entropy ? 1 : 0;
      c.uint.encode(state, m.members);
      encoding16_1.encode(state, m.pendingIndexers);
      encoding1.encode(state, m.indexers);
      encoding1.encode(state, m.heads);
      encoding1.encode(state, m.views);
      c.uint.encode(state, m.encryptionLength);
      c.uint.encode(state, flags);
      if (m.entropy)
        c.fixed32.encode(state, m.entropy);
    },
    decode(state, version2) {
      if (version2 === undefined)
        version2 = c.uint.decode(state);
      const r0 = c.uint.decode(state);
      const r1 = encoding16_1.decode(state);
      const r2 = encoding1.decode(state);
      const r3 = encoding1.decode(state);
      const r4 = encoding1.decode(state);
      const r5 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: version2,
        members: r0,
        pendingIndexers: r1,
        indexers: r2,
        heads: r3,
        views: r4,
        encryptionLength: r5,
        entropy: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  var encoding17 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      switch (m.version) {
        case 0:
        case 1:
          encoding15.preencode(state, m);
          break;
        case 2:
          encoding16.preencode(state, m);
          break;
        default:
          throw new Error("Unsupported version");
      }
    },
    encode(state, m) {
      c.uint.encode(state, m.version);
      switch (m.version) {
        case 0:
        case 1:
          encoding15.encode(state, m);
          break;
        case 2:
          encoding16.encode(state, m);
          break;
        default:
          throw new Error("Unsupported version");
      }
    },
    decode(state) {
      const version2 = c.uint.decode(state);
      switch (version2) {
        case 0:
        case 1: {
          const decoded = encoding15.decode(state, version2);
          const map = external0.infoLegacyMap;
          return map(decoded);
        }
        case 2: {
          const decoded = encoding16.decode(state, version2);
          return decoded;
        }
        default:
          throw new Error("Unsupported version");
      }
    }
  };
  var encoding18 = {
    preencode(state, m) {
      state.end++;
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      const flags = (m.isIndexer ? 1 : 0) | (m.isRemoved ? 2 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        isIndexer: (flags & 1) !== 0,
        isRemoved: (flags & 2) !== 0,
        length: c.uint.decode(state)
      };
    }
  };
  var encoding19 = external0.LinearizerKey;
  var encoding20 = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.uint.preencode(state, m.length);
      c.uint.preencode(state, m.batch);
      c.uint.preencode(state, m.systemLength);
      state.end++;
    },
    encode(state, m) {
      const flags = m.indexers ? 1 : 0;
      c.fixed32.encode(state, m.key);
      c.uint.encode(state, m.length);
      c.uint.encode(state, m.batch);
      c.uint.encode(state, m.systemLength);
      c.uint.encode(state, flags);
    },
    decode(state) {
      const r0 = c.fixed32.decode(state);
      const r1 = c.uint.decode(state);
      const r2 = c.uint.decode(state);
      const r3 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        key: r0,
        length: r1,
        batch: r2,
        systemLength: r3,
        indexers: (flags & 1) !== 0
      };
    }
  };
  var encoding21 = {
    preencode(state, m) {
      c.uint.preencode(state, m.type);
      c.buffer.preencode(state, m.payload);
    },
    encode(state, m) {
      c.uint.encode(state, m.type);
      c.buffer.encode(state, m.payload);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const r1 = c.buffer.decode(state);
      return {
        type: r0,
        payload: r1
      };
    }
  };
  var encoding22 = {
    preencode(state, m) {
      c.uint.preencode(state, m.version);
      state.end++;
      if (m.legacyBlocks)
        c.uint.preencode(state, m.legacyBlocks);
      if (m.namespace)
        c.fixed32.preencode(state, m.namespace);
    },
    encode(state, m) {
      const flags = (m.legacyBlocks ? 1 : 0) | (m.namespace ? 2 : 0);
      c.uint.encode(state, m.version);
      c.uint.encode(state, flags);
      if (m.legacyBlocks)
        c.uint.encode(state, m.legacyBlocks);
      if (m.namespace)
        c.fixed32.encode(state, m.namespace);
    },
    decode(state) {
      const r0 = c.uint.decode(state);
      const flags = c.uint.decode(state);
      return {
        version: r0,
        legacyBlocks: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
        namespace: (flags & 2) !== 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  function setVersion(v) {
    version = v;
  }
  function encode(name, value, v = VERSION) {
    version = v;
    return c.encode(getEncoding(name), value);
  }
  function decode(name, buffer, v = VERSION) {
    version = v;
    return c.decode(getEncoding(name), buffer);
  }
  function getEnum(name) {
    switch (name) {
      default:
        throw new Error("Enum not found " + name);
    }
  }
  function getEncoding(name) {
    switch (name) {
      case "@autobase/checkout":
        return encoding0;
      case "@autobase/clock":
        return encoding1;
      case "@autobase/index-checkpoint":
        return encoding2;
      case "@autobase/wakeup":
        return encoding3;
      case "@autobase/boot-record-v0":
        return encoding4;
      case "@autobase/boot-record-raw":
        return encoding5;
      case "@autobase/boot-record":
        return encoding6;
      case "@autobase/checkpointer":
        return encoding7;
      case "@autobase/checkpoint":
        return encoding8;
      case "@autobase/digest":
        return encoding9;
      case "@autobase/node":
        return encoding10;
      case "@autobase/oplog-message-v0":
        return encoding11;
      case "@autobase/oplog-message-v1":
        return encoding12;
      case "@autobase/oplog-message-v2":
        return encoding13;
      case "@autobase/oplog-message":
        return encoding14;
      case "@autobase/info-v1":
        return encoding15;
      case "@autobase/info-v2":
        return encoding16;
      case "@autobase/info":
        return encoding17;
      case "@autobase/member":
        return encoding18;
      case "@autobase/linearizer-key":
        return encoding19;
      case "@autobase/linearizer-update":
        return encoding20;
      case "@autobase/encryption-descriptor":
        return encoding21;
      case "@autobase/manifest-data":
        return encoding22;
      default:
        throw new Error("Encoder not found " + name);
    }
  }
  function getStruct(name, v = VERSION) {
    const enc = getEncoding(name);
    return {
      preencode(state, m) {
        version = v;
        enc.preencode(state, m);
      },
      encode(state, m) {
        version = v;
        enc.encode(state, m);
      },
      decode(state) {
        version = v;
        return enc.decode(state);
      }
    };
  }
  var resolveStruct = getStruct;
  module.exports = { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version };
});

// node_modules/autobase/lib/messages.js
var require_messages3 = __commonJS((exports, module) => {
  var schema = require_autobase();
  module.exports = {
    Wakeup: schema.resolveStruct("@autobase/wakeup"),
    Clock: schema.resolveStruct("@autobase/clock"),
    Checkout: schema.resolveStruct("@autobase/checkout"),
    BootRecord: schema.resolveStruct("@autobase/boot-record"),
    OplogMessage: schema.resolveStruct("@autobase/oplog-message"),
    Checkpoint: schema.resolveStruct("@autobase/checkpoint"),
    Info: schema.resolveStruct("@autobase/info"),
    Member: schema.resolveStruct("@autobase/member"),
    ManifestData: schema.resolveStruct("@autobase/manifest-data"),
    LINEARIZER_PREFIX: 1,
    LinearizerKey: schema.resolveStruct("@autobase/linearizer-key"),
    LinearizerUpdate: schema.resolveStruct("@autobase/linearizer-update"),
    EncryptionDescriptor: schema.resolveStruct("@autobase/encryption-descriptor")
  };
});

// node_modules/autobase/lib/local-state.js
var require_local_state = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var messages = require_messages3();
  var GTE = b4a.from([messages.LINEARIZER_PREFIX]);
  var LT = b4a.from([messages.LINEARIZER_PREFIX + 1]);
  module.exports = class LocalState {
    constructor(core) {
      this.core = core;
      this.tx = null;
    }
    static clear(core) {
      const tx = core.state.storage.write();
      tx.deleteLocalRange(GTE, LT);
      return tx.flush();
    }
    static async moveTo(src, dst) {
      const boot = await src.getUserData("autobase/boot");
      const tx = dst.state.storage.write();
      tx.deleteLocalRange(GTE, LT);
      for await (const data of src.state.storage.createLocalStream({ gte: GTE, lt: LT })) {
        tx.putLocal(data.key, data.value);
      }
      tx.putUserData("autobase/boot", boot);
      await tx.flush();
    }
    setBootRecord(boot) {
      if (this.tx === null)
        this.tx = this.core.state.storage.write();
      this.tx.putUserData("autobase/boot", c.encode(messages.BootRecord, boot));
    }
    async listUpdates() {
      const updates = [];
      for await (const data of this.core.state.storage.createLocalStream({ gte: GTE, lt: LT })) {
        const update = c.decode(messages.LinearizerUpdate, data.value);
        const seq = c.decode(messages.LinearizerKey, data.key);
        update.seq = seq;
        updates.push(update);
      }
      return updates;
    }
    clearUpdates() {
      if (this.tx === null)
        this.tx = this.core.state.storage.write();
      this.tx.deleteLocalRange(GTE, LT);
    }
    deleteUpdate(update) {
      if (this.tx === null)
        this.tx = this.core.state.storage.write();
      this.tx.deleteLocal(c.encode(messages.LinearizerKey, update.seq));
    }
    insertUpdate(update) {
      if (this.tx === null)
        this.tx = this.core.state.storage.write();
      this.tx.putLocal(c.encode(messages.LinearizerKey, update.seq), c.encode(messages.LinearizerUpdate, update));
    }
    flush() {
      if (!this.tx)
        return Promise.resolve();
      const flushing = this.tx.flush();
      this.tx = null;
      return flushing;
    }
  };
});

// node_modules/tiny-buffer-map/index.js
var require_tiny_buffer_map = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class BufferMap {
    constructor(other) {
      this.m = other ? new Map([...other.m]) : new Map;
    }
    get size() {
      return this.m.size;
    }
    get(key) {
      if (b4a.isBuffer(key))
        key = b4a.toString(key, "hex");
      return this.m.get(key);
    }
    set(key, value) {
      if (b4a.isBuffer(key))
        key = b4a.toString(key, "hex");
      return this.m.set(key, value);
    }
    delete(key) {
      if (b4a.isBuffer(key))
        key = b4a.toString(key, "hex");
      return this.m.delete(key);
    }
    has(key) {
      if (b4a.isBuffer(key))
        key = b4a.toString(key, "hex");
      return this.m.has(key);
    }
    *[Symbol.iterator]() {
      for (const [key, value] of this.m) {
        yield [b4a.from(key, "hex"), value];
      }
    }
    *keys() {
      for (const key of this.m.keys()) {
        yield b4a.from(key, "hex");
      }
    }
    values() {
      return this.m.values();
    }
    clear() {
      return this.m.clear();
    }
  };
});

// node_modules/autobase/lib/clock.js
var require_clock = __commonJS((exports, module) => {
  var BufferMap = require_tiny_buffer_map();
  module.exports = class Clock {
    constructor() {
      this.seen = new BufferMap;
    }
    get size() {
      return this.seen.size;
    }
    has(key) {
      return this.seen.has(key);
    }
    includes(key, length) {
      return this.seen.has(key) && this.seen.get(key) >= length;
    }
    get(key) {
      return this.seen.get(key) || 0;
    }
    set(key, len) {
      this.seen.set(key, len);
      return len;
    }
    add(clock) {
      for (const [key, l] of clock) {
        if (this.get(key) < l)
          this.set(key, l);
      }
    }
    [Symbol.iterator]() {
      return this.seen[Symbol.iterator]();
    }
  };
});

// node_modules/autobase/lib/consensus.js
var require_consensus = __commonJS((exports, module) => {
  var BufferMap = require_tiny_buffer_map();
  var Clock = require_clock();
  var UNSEEN = 0;
  var NEWER = 1;
  var ACKED = 2;
  module.exports = class Consensus {
    constructor(indexers) {
      this.merges = new Set;
      this.majority = (indexers.length >>> 1) + 1;
      this.indexers = indexers;
      this.removed = new Clock;
      this.updated = false;
      this.writers = new BufferMap;
      for (const idx of this.indexers) {
        this.writers.set(idx.core.key, idx);
      }
    }
    addHead(node) {
      if (!node.writer.isActiveIndexer)
        return;
      if (this._isMerge(node))
        this.merges.add(node);
      this.updated = true;
      return node;
    }
    _tails(node, tails) {
      const tailSet = new Set;
      for (const t of tails) {
        if (node.clock.includes(t.writer.core.key, t.length))
          tailSet.add(t);
      }
      return tailSet;
    }
    _tailsAndMerges(node, tails) {
      const all = this._tails(node, tails);
      for (const m of this.merges) {
        if (m !== node && node.clock.includes(m.writer.core.key, m.length)) {
          all.add(m);
        }
      }
      return all;
    }
    _isMerge(node) {
      if (!node.writer.isActiveIndexer)
        return false;
      const deps = [];
      for (const idx of this.indexers) {
        let seq = node.clock.get(idx.core.key) - 1;
        if (idx === node.writer)
          seq--;
        const head = idx.get(seq);
        if (!head || this.removed.includes(head.writer.core.key, head.length))
          continue;
        let isDep = true;
        for (let i = 0;i < deps.length; i++) {
          const d = deps[i];
          if (d === head)
            continue;
          if (d.clock.includes(head.writer.core.key, head.length)) {
            isDep = false;
            break;
          }
          if (head.clock.includes(d.writer.core.key, d.length)) {
            const popped = deps.pop();
            if (d === popped)
              continue;
            deps[i--] = popped;
          }
        }
        if (isDep)
          deps.push(head);
      }
      return deps.length > 1;
    }
    _indexerTails() {
      const tails = new Set;
      for (const idx of this.indexers) {
        const length = this.removed.has(idx.core.key) ? this.removed.get(idx.core.key) : idx.indexed;
        const head = idx.get(length);
        if (!head || this.removed.includes(head.writer.core.key, head.length))
          continue;
        let isTail = true;
        for (const t of tails) {
          if (head.clock.includes(t.writer.core.key, t.length)) {
            isTail = false;
            break;
          }
          if (t.clock.includes(head.writer.core.key, head.length)) {
            tails.delete(t);
          }
        }
        if (isTail)
          tails.add(head);
      }
      return tails;
    }
    _strictlyNewer(object, parent) {
      for (const [key, latest] of parent.clock) {
        const oldest = this.removed.get(key);
        if (latest <= oldest)
          continue;
        let length = object.clock.get(key);
        if (length <= oldest)
          length = oldest;
        if (latest < length)
          return false;
        if (latest === length)
          continue;
        const writer = this.writers.get(key);
        const next = writer && writer.get(length >= writer.indexed ? length : writer.indexed);
        if (!next)
          continue;
        if (next.clock.includes(object.writer.core.key, object.length))
          continue;
        if (!parent.clock.includes(next.writer.core.key, next.length))
          continue;
        return false;
      }
      return parent.clock.get(object.writer.core.key) >= object.length;
    }
    _acks(target) {
      const acks = target.writer.isActiveIndexer ? [target] : [];
      for (const idx of this.indexers) {
        if (idx === target.writer)
          continue;
        let next = target.clock.get(idx.core.key);
        if (next < idx.nodes.offset)
          next = idx.nodes.offset;
        const nextIndexNode = idx.get(next >= idx.indexed ? next : idx.indexed);
        if (!nextIndexNode)
          continue;
        if (!nextIndexNode.clock.includes(target.writer.core.key, target.length))
          continue;
        if (!this._strictlyNewer(target, nextIndexNode))
          continue;
        acks.push(nextIndexNode);
      }
      return acks;
    }
    acksFromNode(target, view) {
      const acks = new Set;
      if (!view || !view.clock.includes(target.writer.core.key, target.length))
        return acks;
      acks.add(view.writer);
      for (const idx of this.indexers) {
        if (idx === view.writer)
          continue;
        const length = view.clock.get(idx.core.key);
        if (!length)
          continue;
        if (target.clock.includes(idx.core.key, length))
          continue;
        const head = idx.get(length - 1);
        if (!head)
          continue;
        if (head.clock.includes(target.writer.core.key, target.length)) {
          acks.add(idx);
        }
      }
      return acks;
    }
    _ackedAt(acks, parent) {
      let seen = 0;
      let missing = acks.length;
      for (const node of acks) {
        missing--;
        if (!parent.clock.includes(node.writer.core.key, node.length)) {
          if (seen + missing < this.majority)
            return false;
          continue;
        }
        if (++seen >= this.majority)
          return true;
      }
      return false;
    }
    confirms(indexer, target, acks, length) {
      if (!length || this.removed.get(indexer.core.key) >= length)
        return UNSEEN;
      let jump = true;
      let newer = true;
      for (let i = length - 1;i >= 0; i--) {
        const head = indexer.get(i);
        if (head === null)
          return UNSEEN;
        let seen = 0;
        for (const node of acks) {
          if (!head.clock.includes(node.writer.core.key, node.length))
            continue;
          if (++seen >= this.majority)
            break;
        }
        if (!newer && seen < this.majority) {
          break;
        }
        if (!this._strictlyNewer(target, head)) {
          if (jump) {
            jump = false;
            let t = length - 1;
            let b = 0;
            while (t > b) {
              const mid = t + b >>> 1;
              const node = indexer.get(mid);
              if (node === null || !node.clock.includes(target.writer.core.key, target.length) || this._strictlyNewer(target, node)) {
                b = mid + 1;
              } else {
                t = mid - 1;
              }
            }
            if (b + 1 < i)
              i = b + 2;
          }
          newer = false;
          continue;
        } else if (seen < this.majority) {
          return NEWER;
        }
        return ACKED;
      }
      return UNSEEN;
    }
    _isConfirmed(target, parent = null) {
      const acks = this._acks(target);
      const confs = new Set;
      if (acks.length < this.majority)
        return false;
      let allNewer = true;
      for (const indexer of this.indexers) {
        const length = parent ? parent.writer === indexer ? parent.length - 1 : parent.clock.get(indexer.core.key) : indexer.length;
        const result = this.confirms(indexer, target, acks, length);
        if (result === ACKED) {
          confs.add(indexer);
          if (confs.size >= this.majority) {
            return true;
          }
        }
        if (result === UNSEEN)
          allNewer = false;
      }
      if (parent)
        return this._isConfirmableAt(target, parent, acks, confs);
      return allNewer;
    }
    _isConfirmableAt(target, parent, acks, confs) {
      if (!this._ackedAt(acks, parent))
        return false;
      let potential = confs.size;
      for (const indexer of this.indexers) {
        if (confs.has(indexer))
          continue;
        const length = parent.clock.get(indexer.core.key);
        const isSeen = target.clock.includes(indexer.core.key, length);
        if (!isSeen) {
          const head = indexer.get(length - 1);
          if (head && !this.removed.includes(head.writer.core.key, head.length) && !this._strictlyNewer(target, head)) {
            continue;
          }
        }
        if (++potential >= this.majority)
          return true;
      }
      return false;
    }
    remove(node) {
      this.merges.delete(node);
      this.removed.set(node.writer.core.key, node.length);
      return node;
    }
    shift() {
      if (!this.updated)
        return [];
      const tails = this._indexerTails();
      for (const tail of tails) {
        if (this._isConfirmed(tail)) {
          return [this.remove(tail)];
        }
      }
      for (const merge of this.merges) {
        if (this._isConfirmed(merge)) {
          return this._yieldNext(merge, tails);
        }
      }
      this.updated = false;
      return [];
    }
    _yieldNext(node, tails) {
      while (!tails.has(node)) {
        let next = null;
        for (const t of this._tailsAndMerges(node, tails)) {
          if (this._isConfirmed(t, node)) {
            next = t;
            break;
          }
        }
        if (next) {
          node = next;
          continue;
        }
        const tailSet = [];
        for (const t of this._tails(node, tails)) {
          tailSet.push(this.remove(t));
        }
        return tailSet;
      }
      return [this.remove(node)];
    }
    shouldAck(writer) {
      for (const t of this._indexerTails()) {
        if (t.writer === writer)
          continue;
        if (this._shouldAckNode(t, writer))
          return true;
      }
      return false;
    }
    _shouldAckNode(target, writer) {
      const head = writer.head();
      const next = target.clock.get(writer.core.key);
      const nextIndexNode = writer.get(next >= writer.indexed ? next : writer.indexed);
      if (!nextIndexNode && writer !== target.writer)
        return true;
      if (nextIndexNode) {
        if (!nextIndexNode.clock.includes(target.writer.core.key, target.length)) {
          return !head.clock.includes(target.writer.core.key, target.length);
        }
        if (!this._strictlyNewer(target, nextIndexNode))
          return false;
      }
      const acks = this._acks(target);
      if (acks.length >= this.majority) {
        return this.confirms(writer, target, acks, writer.length) === UNSEEN;
      }
      return false;
    }
  };
});

// node_modules/autobase/lib/topolist.js
var require_topolist = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var assert = require_nanoassert();
  module.exports = class TopoList {
    constructor() {
      this.tip = [];
      this.undo = 0;
      this.shared = 0;
    }
    static compare(a, b) {
      return cmp(a, b);
    }
    static add(node, indexed, offset) {
      addSorted(node, indexed, offset);
    }
    mark() {
      this.shared = this.tip.length;
      this.undo = 0;
    }
    flush(indexed = []) {
      if (indexed.length)
        this._applyIndexed(indexed);
      const u = {
        shared: this.shared,
        undo: this.undo,
        length: indexed.length + this.tip.length,
        indexed,
        tip: this.tip
      };
      this.mark();
      return u;
    }
    print() {
      return this.tip.map((n) => n.writer.core.key.toString() + n.length);
    }
    _applyIndexed(nodes) {
      assert(nodes.length <= this.tip.length, "Indexed batch cannot exceed tip");
      let shared = 0;
      for (;shared < nodes.length; shared++) {
        if (this.tip[shared] !== nodes[shared])
          break;
      }
      if (shared < nodes.length)
        this._track(shared);
      const tip = [];
      for (let i = shared;i < this.tip.length; i++) {
        const node = this.tip[i];
        if (node.yielded)
          continue;
        const s = addSorted(node, tip, 0);
        if (s === tip.length - 1)
          continue;
        this._track(shared + s);
      }
      this.tip = tip;
    }
    add(node) {
      const shared = addSorted(node, this.tip, 0);
      this._track(shared);
    }
    _track(shared) {
      if (shared < this.shared) {
        this.undo += this.shared - shared;
        this.shared = shared;
      }
    }
  };
  function hasOptimisticDeps(node) {
    for (const d of node.dependencies) {
      if (d.optimistic)
        return true;
    }
    return false;
  }
  function getOptimisticDeps(node, list) {
    const deps = new Set;
    const stack = [node];
    while (stack.length > 0) {
      const next = stack.pop();
      if (deps.has(next))
        continue;
      if (next.optimistic && next !== node)
        deps.add(next);
      for (const d of next.dependencies) {
        if (d.optimistic)
          stack.push(d);
      }
    }
    const result = [];
    for (let i = list.length - 1;deps.size !== result.length && i >= 0; i--) {
      const n = list[i];
      if (deps.has(n))
        result.push(n);
    }
    return result.reverse();
  }
  function addSortedOptimistic(node, list, offset) {
    const opt = getOptimisticDeps(node, list);
    const pos = new Uint32Array(opt.length);
    for (let i = 0;i < opt.length; i++) {
      const n = opt[i];
      pos[i] = n.index;
      moveDown(n, list, offset);
    }
    moveDownAndUp(node, list, offset);
    for (let i = opt.length - 1;i >= 0; i--) {
      moveOptimisticUp(opt[i], list, offset);
    }
    let shared = node.index;
    for (let i = 0;i < opt.length; i++) {
      const idx = pos[i];
      const n = opt[i];
      if (idx === n.index)
        continue;
      if (idx < shared)
        shared = idx;
      if (n.index < shared)
        shared = n.index;
    }
    return shared;
  }
  function addSorted(node, list, offset) {
    list.push(node);
    node.index = list.length - 1;
    if (hasOptimisticDeps(node))
      return addSortedOptimistic(node, list, offset);
    moveDownAndUp(node, list, offset);
    return node.index;
  }
  function moveDown(node, list, offset) {
    while (node.index > offset) {
      const prev = list[node.index - 1];
      if (links(node, prev))
        break;
      list[prev.index = node.index] = prev;
      list[--node.index] = node;
    }
  }
  function moveOptimisticUp(node, list, offset) {
    while (node.index < list.length - 1) {
      const next = list[node.index + 1];
      if (links(next, node))
        break;
      list[next.index = node.index] = next;
      list[++node.index] = node;
    }
    while (node.index > offset) {
      const prev = list[node.index - 1];
      if (!prev.optimistic)
        break;
      const c = cmp(prev, node);
      if (c <= 0)
        break;
      list[prev.index = node.index] = prev;
      list[--node.index] = node;
    }
  }
  function moveNonOptimisticUp(node, list, offset) {
    while (node.index < list.length - 1) {
      const next = list[node.index + 1];
      const c = cmpNonOptimistic(node, next, list);
      if (c <= 0)
        break;
      list[next.index = node.index] = next;
      list[++node.index] = node;
    }
  }
  function moveDownAndUp(node, list, offset) {
    moveDown(node, list, offset);
    if (node.optimistic)
      moveOptimisticUp(node, list, offset);
    else
      moveNonOptimisticUp(node, list, offset);
  }
  function links(a, b) {
    if (b.dependents.has(a))
      return true;
    return a.length > 0 && b.length === a.length - 1 && a.writer === b.writer;
  }
  function cmpNonOptimistic(a, b, list) {
    if (!b.optimistic)
      return cmp(a, b);
    for (let i = b.index + 1;i < list.length; i++) {
      const node = list[i];
      if (!node.optimistic)
        return cmp(a, node);
    }
    return -1;
  }
  function cmp(a, b) {
    return links(b, a) ? -1 : cmpUnlinked(a, b);
  }
  function cmpUnlinked(a, b) {
    const c = b4a.compare(a.writer.core.key, b.writer.core.key);
    return c === 0 ? a.length < b.length ? -1 : 1 : c;
  }
});

// node_modules/autobase/lib/linearizer.js
var require_linearizer = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var assert = require_nanoassert();
  var Clock = require_clock();
  var Consensus = require_consensus();
  var Topolist = require_topolist();

  class Node {
    constructor(writer, length, value, heads, batch, dependencies, optimistic) {
      this.writer = writer;
      this.length = length;
      this.value = value;
      this.heads = heads;
      this.actualHeads = heads.slice(0);
      this.dependents = new Set;
      this.dependencies = dependencies;
      this.index = 0;
      this.optimistic = optimistic && batch === 1 && !!value;
      this.batch = batch;
      this.dropped = 0;
      this.clock = new Clock;
      this.yielded = false;
      this.yielding = false;
    }
    isTail() {
      return this.dependencies.size === this.dropped;
    }
    causalDependencies(idx) {
      const order = [this];
      const stack = [this];
      let visited = null;
      while (stack.length > 0) {
        const node = stack.pop();
        for (const dep of node.dependencies) {
          if (!dep.writer.isRemoved || dep.writer.isActiveIndexer)
            continue;
          if (visited === null)
            visited = new Set;
          if (visited.has(dep))
            continue;
          visited.add(dep);
          stack.push(dep);
          order.push(dep);
        }
      }
      return order;
    }
    clear() {
      this.clock = null;
      this.dependents = null;
      return this;
    }
    reset() {
      this.yielded = false;
      this.yielding = false;
      for (const dep of this.dependents)
        dep.dependencies.add(this);
      this.dependents.clear();
    }
    active() {
      for (const dep of this.dependencies) {
        if (dep.yielded) {
          this.dependencies.delete(dep);
        } else {
          dep.dependents.add(this);
          this.clock.add(dep.clock);
        }
      }
      if (this.writer.isActiveIndexer)
        this.clock.set(this.writer.core.key, this.length);
    }
    tieBreak(node) {
      return tieBreak(this, node);
    }
    hasDependency(dep) {
      for (const h of this.actualHeads) {
        if (sameNode(h, dep))
          return true;
      }
      return false;
    }
    get ref() {
      return this.writer.core.key.toString("hex").slice(0, 2) + ":" + this.length;
    }
  }
  module.exports = class Linearizer {
    constructor(indexers, { heads = [], writers = new Map } = {}) {
      this.heads = new Set;
      this.tails = new Set;
      this.tip = new Topolist;
      this.size = 0;
      this.updated = false;
      this.indexersUpdated = false;
      this.writers = writers;
      this.consensus = new Consensus(indexers);
      this._initialHeads = heads.slice(0);
      this._strictlyAdded = null;
      for (const { key, length } of heads) {
        this.consensus.removed.set(key, length);
      }
    }
    get indexers() {
      return this.consensus.indexers;
    }
    static createNode(writer, length, value, heads, batch, dependencies, optimistic) {
      return new Node(writer, length, value, heads, batch, dependencies, optimistic);
    }
    getHeads() {
      const heads = this._initialHeads.slice(0);
      for (const node of this.heads)
        heads.push({ key: node.writer.core.key, length: node.length });
      return heads;
    }
    getBootstrapWriters() {
      const writers = [];
      for (const head of this.heads)
        writers.push(head.writer);
      for (let i = 0;i < this.consensus.indexers.length; i++)
        writers.push(this.consensus.indexers[i]);
      return writers;
    }
    addHead(node) {
      node.active();
      if (this._initialHeads.length > 0)
        this._updateInitialHeads(node);
      if (node.isTail()) {
        this.tails.add(node);
      }
      for (const head of this.heads) {
        if (node.hasDependency(head)) {
          this.heads.delete(head);
        }
      }
      this.tip.add(node);
      if (node.writer.isActiveIndexer)
        this.consensus.addHead(node);
      this.size++;
      this.heads.add(node);
      this.updated = true;
      return node;
    }
    update() {
      if (!this.updated)
        return null;
      this.updated = false;
      const indexed = [];
      while (true) {
        const nodes = this.consensus.shift();
        if (!nodes.length)
          break;
        this._yield(nodes, indexed);
      }
      return this.tip.flush(indexed);
    }
    _updateInitialHeads(node) {
      for (const head of node.actualHeads) {
        for (let i = 0;i < this._initialHeads.length; i++) {
          const { key, length } = this._initialHeads[i];
          if (length !== head.length || !b4a.equals(key, head.key))
            continue;
          this._initialHeads.splice(i--, 1);
        }
      }
    }
    shouldAck(writer, pending = false) {
      if (!writer || !writer.isActiveIndexer)
        return false;
      for (const w of this.indexers) {
        if (w.length !== w.available)
          return false;
      }
      let isHead = false;
      for (const head of this.heads) {
        if (!head.writer.isActiveIndexer)
          return true;
        if (head.writer === writer)
          isHead = true;
      }
      if (this.heads.size === 1 && isHead) {
        return false;
      }
      const visited = new Set;
      let valueCheck = false;
      for (const tail of this.tails) {
        if (pending || this._nonNull(tail, visited)) {
          valueCheck = true;
          break;
        }
      }
      if (!valueCheck)
        return false;
      if (this.consensus.shouldAck(writer))
        return true;
      return this._shouldAckHeads(writer, pending);
    }
    _nonNull(target, visited) {
      const stack = [target];
      while (stack.length) {
        const node = stack.pop();
        if (visited.has(node))
          continue;
        if (node.value !== null)
          return true;
        visited.add(node);
        for (const dep of node.dependents) {
          stack.push(dep);
        }
      }
      return false;
    }
    _shouldAckHeads(writer, pending) {
      const prev = writer.head();
      for (const head of this.heads) {
        if (head.writer === writer)
          continue;
        const stack = [head];
        const visited = new Set;
        while (stack.length) {
          const node = stack.pop();
          if (visited.has(node))
            continue;
          visited.add(node);
          if (pending || node.value !== null) {
            const acks = this.consensus.acksFromNode(node, head);
            const prevAcks = this.consensus.acksFromNode(node, prev);
            if (acks.size > prevAcks.size)
              return true;
            for (const idx of acks) {
              if (!prevAcks.has(idx))
                return true;
            }
            if (prevAcks.size && acks.size)
              continue;
          }
          stack.push(...node.dependencies);
        }
      }
      return false;
    }
    _yield(nodes, indexed = []) {
      const offset = indexed.length;
      const tails = [];
      while (nodes.length) {
        const node = nodes.pop();
        if (node.yielding)
          continue;
        node.yielding = true;
        if (node.isTail())
          tails.push(node);
        nodes.push(...node.dependencies);
      }
      while (tails.length) {
        let tail = tails.pop();
        for (tail of this._removeBatch(tail)) {
          Topolist.add(tail, indexed, offset);
        }
        for (const dep of tail.dependents) {
          if (dep.isTail() && dep.yielding)
            tails.push(dep);
        }
      }
      return indexed;
    }
    _isFutureTail(node) {
      let dropped = node.dropped;
      for (const dep of node.dependencies) {
        if (dep.yielded)
          continue;
        if (dropped === 0)
          return false;
        dropped--;
      }
      return true;
    }
    _removeNode(node) {
      this.tails.delete(node);
      this.heads.delete(node);
      this.consensus.remove(node);
      for (const d of node.dependents) {
        if (d.yielding && d.dependencies.has(node))
          d.dropped++;
        else
          d.dependencies.delete(node);
        if (this._isFutureTail(d))
          this.tails.add(d);
      }
      node.yielded = true;
      this.size--;
      if (this.heads.size === 0) {
        this._initialHeads.push({ key: node.writer.core.key, length: node.length });
      }
      return node;
    }
    _removeBatch(node) {
      const batch = [this._removeNode(node)];
      while (node.batch !== 1) {
        if (node.dependents.size === 0) {
          const next = node.writer.get(node.length);
          if (next && next.batch === node.batch - 1)
            node.dependents.add(next);
        }
        assert(node.dependents.size === 1, "Batch is linked partially, which is not allowed");
        node = getFirst(node.dependents);
        batch.push(this._removeNode(node));
      }
      return batch;
    }
  };
  function tieBreak(a, b) {
    return Topolist.compare(a, b) < 0;
  }
  function getFirst(set) {
    return set[Symbol.iterator]().next().value;
  }
  function sameNode(a, b) {
    return b4a.equals(a.key, b.writer.core.key) && a.length === b.length;
  }
});

// node_modules/codecs/index.js
var require_codecs = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = codecs;
  codecs.ascii = createString("ascii");
  codecs.utf8 = createString("utf-8");
  codecs.hex = createString("hex");
  codecs.base64 = createString("base64");
  codecs.ucs2 = createString("ucs2");
  codecs.utf16le = createString("utf16le");
  codecs.ndjson = createJSON(true);
  codecs.json = createJSON(false);
  codecs.binary = {
    name: "binary",
    encode: function encodeBinary(obj) {
      return typeof obj === "string" ? b4a.from(obj, "utf-8") : b4a.toBuffer(obj);
    },
    decode: function decodeBinary(buf) {
      return b4a.toBuffer(buf);
    }
  };
  function isCompactEncoding(c) {
    return !!(c.encode && c.decode && c.preencode);
  }
  function fromCompactEncoding(c) {
    return {
      name: "compact-encoding",
      encode: function encodeWithCompact(value) {
        const state = { start: 0, end: 0, buffer: null, cache: null };
        c.preencode(state, value);
        state.buffer = b4a.allocUnsafe(state.end);
        c.encode(state, value);
        return state.buffer;
      },
      decode: function decodeWithCompact(buffer) {
        return c.decode({ start: 0, end: buffer.byteLength, buffer, cache: null });
      }
    };
  }
  function codecs(fmt, fallback) {
    if (typeof fmt === "object" && fmt) {
      return isCompactEncoding(fmt) ? fromCompactEncoding(fmt) : fmt;
    }
    switch (fmt) {
      case "ndjson":
        return codecs.ndjson;
      case "json":
        return codecs.json;
      case "ascii":
        return codecs.ascii;
      case "utf-8":
      case "utf8":
        return codecs.utf8;
      case "hex":
        return codecs.hex;
      case "base64":
        return codecs.base64;
      case "ucs-2":
      case "ucs2":
        return codecs.ucs2;
      case "utf16-le":
      case "utf16le":
        return codecs.utf16le;
    }
    return fallback !== undefined ? fallback : codecs.binary;
  }
  function createJSON(newline) {
    return {
      name: newline ? "ndjson" : "json",
      encode: newline ? encodeNDJSON : encodeJSON,
      decode: function decodeJSON(buf) {
        return JSON.parse(b4a.toString(buf));
      }
    };
    function encodeJSON(val) {
      return b4a.from(JSON.stringify(val));
    }
    function encodeNDJSON(val) {
      return b4a.from(JSON.stringify(val) + `
`);
    }
  }
  function createString(type) {
    return {
      name: type,
      encode: function encodeString(val) {
        if (typeof val !== "string")
          val = val.toString();
        return b4a.from(val, type);
      },
      decode: function decodeString(buf) {
        return b4a.toString(buf, type);
      }
    };
  }
});

// node_modules/rache/index.js
var require_rache = __commonJS((exports, module) => {
  class CacheEntry {
    constructor(key, index, map) {
      this.key = key;
      this.index = index;
      this.map = map;
    }
  }

  class CacheValue {
    constructor(entry, value) {
      this.entry = entry;
      this.value = value;
    }
  }

  class Rache {
    constructor({ maxSize = 65536, parent = null } = {}) {
      this.maxSize = parent?.maxSize || maxSize;
      this._array = parent?._array || [];
      this._map = new Map;
    }
    static from(cache) {
      return cache ? new this({ parent: cache }) : new this;
    }
    get globalSize() {
      return this._array.length;
    }
    get size() {
      return this._map.size;
    }
    sub() {
      return new Rache({ parent: this });
    }
    set(key, value) {
      const existing = this._map.get(key);
      if (existing !== undefined) {
        existing.value = value;
        return;
      }
      if (this._array.length >= this.maxSize)
        this._gc();
      const entry = new CacheEntry(key, this._array.length, this._map);
      this._array.push(entry);
      const cacheValue = new CacheValue(entry, value);
      this._map.set(key, cacheValue);
    }
    delete(key) {
      const existing = this._map.get(key);
      if (existing === undefined)
        return false;
      this._delete(existing.entry.index);
      return true;
    }
    get(key) {
      const existing = this._map.get(key);
      return existing === undefined ? undefined : existing.value;
    }
    *[Symbol.iterator]() {
      for (const [key, { value }] of this._map) {
        yield [key, value];
      }
    }
    keys() {
      return this._map.keys();
    }
    *values() {
      for (const { value } of this._map.values()) {
        yield value;
      }
    }
    clear() {
      this._map.clear();
      this._map = new Map;
    }
    destroy() {
      this._map = null;
      this._array = null;
    }
    _gc() {
      this._delete(Math.floor(Math.random() * this._array.length));
    }
    _delete(index) {
      if (index >= this._array.length)
        throw new Error("Cannot delete unused index (logic bug?)");
      const head = this._array.pop();
      let removed = head;
      if (index < this._array.length) {
        removed = this._array[index];
        head.index = index;
        this._array[index] = head;
      }
      removed.map.delete(removed.key);
    }
  }
  module.exports = Rache;
});

// node_modules/hyperbee/iterators/range.js
var require_range2 = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class RangeIterator {
    constructor(batch, encoding, opts = {}) {
      this.batch = batch;
      this.stack = [];
      this.opened = false;
      this.encoding = encoding || batch.encoding;
      this._limit = typeof opts.limit === "number" ? opts.limit : -1;
      this._gIncl = !opts.gt;
      this._gKey = opts.gt || opts.gte || null;
      this._lIncl = !opts.lt;
      this._lKey = opts.lt || opts.lte || null;
      this._reverse = !!opts.reverse;
      this._version = 0;
      this._checkpoint = opts.checkpoint && opts.checkpoint.length ? opts.checkpoint : null;
      this._nexting = false;
    }
    snapshot(version = this.batch.version) {
      const checkpoint = [];
      for (const s of this.stack) {
        let { node, i } = s;
        if (this._nexting && s === this.stack[this.stack.length - 1])
          i = this._reverse ? i + 1 : i - 1;
        if (!node.block)
          continue;
        if (i < 0)
          continue;
        checkpoint.push(node.block.seq, node.offset, i);
      }
      return {
        version,
        gte: this._gIncl ? this._gKey : null,
        gt: this._gIncl ? null : this._gKey,
        lte: this._lIncl ? this._lKey : null,
        lt: this._lIncl ? null : this._lKey,
        limit: this._limit,
        reverse: this._reverse,
        ended: this.opened && !checkpoint.length,
        checkpoint: this.opened ? checkpoint : []
      };
    }
    async open() {
      await this._open();
      this.opened = true;
    }
    async _open() {
      if (this._checkpoint) {
        for (let j = 0;j < this._checkpoint.length; j += 3) {
          const seq = this._checkpoint[j];
          const offset = this._checkpoint[j + 1];
          const i = this._checkpoint[j + 2];
          this.stack.push({
            node: (await this.batch.getBlock(seq)).getTreeNode(offset),
            i
          });
        }
        return;
      }
      this._nexting = true;
      let node = await this.batch.getRoot(false);
      if (!node) {
        this._nexting = false;
        return;
      }
      const incl = this._reverse ? this._lIncl : this._gIncl;
      const start = this._reverse ? this._lKey : this._gKey;
      if (!start) {
        this.stack.push({ node, i: this._reverse ? node.keys.length << 1 : 0 });
        this._nexting = false;
        return;
      }
      while (true) {
        const entry = { node, i: this._reverse ? node.keys.length << 1 : 0 };
        let s = 0;
        let e = node.keys.length;
        let c;
        while (s < e) {
          const mid = s + e >> 1;
          c = b4a.compare(start, await node.getKey(mid));
          if (c === 0) {
            if (incl)
              entry.i = mid * 2 + 1;
            else
              entry.i = mid * 2 + (this._reverse ? 0 : 2);
            this.stack.push(entry);
            this._nexting = false;
            return;
          }
          if (c < 0)
            e = mid;
          else
            s = mid + 1;
        }
        const i = c < 0 ? e : s;
        entry.i = 2 * i + (this._reverse ? -1 : 1);
        if (entry.i >= 0 && entry.i <= node.keys.length << 1)
          this.stack.push(entry);
        if (!node.children.length) {
          this._nexting = false;
          return;
        }
        node = await node.getChildNode(i);
      }
    }
    async next() {
      this._nexting = true;
      const end = this._reverse ? this._gKey : this._lKey;
      const incl = this._reverse ? this._gIncl : this._lIncl;
      while (this.stack.length && (this._limit === -1 || this._limit > 0)) {
        const top = this.stack[this.stack.length - 1];
        const isKey = (top.i & 1) === 1;
        const n = this._reverse ? top.i < 0 ? top.node.keys.length : top.i-- >> 1 : top.i++ >> 1;
        if (!isKey) {
          if (!top.node.children.length)
            continue;
          const node = await top.node.getChildNode(n);
          if (top.node.block.seq < this.batch.core.length) {
            top.node.children[n].value = null;
          }
          this.stack.push({ i: this._reverse ? node.keys.length << 1 : 0, node });
          continue;
        }
        if (n >= top.node.keys.length) {
          this.stack.pop();
          continue;
        }
        const key = top.node.keys[n];
        const block = await this.batch.getBlock(key.seq);
        if (end) {
          const c = b4a.compare(block.key, end);
          if (c === 0 ? !incl : this._reverse ? c < 0 : c > 0) {
            this._limit = 0;
            break;
          }
        }
        if (this._limit > 0)
          this._limit--;
        this._nexting = false;
        return block.final(this.encoding);
      }
      this._nexting = false;
      return null;
    }
    close() {
      return this.batch._closeSnapshot();
    }
  };
});

// node_modules/hyperbee/iterators/history.js
var require_history = __commonJS((exports, module) => {
  module.exports = class HistoryIterator {
    constructor(batch, opts = {}) {
      this.batch = batch;
      this.options = opts;
      this.live = !!opts.live;
      this.gte = 0;
      this.lt = 0;
      this.reverse = !!opts.reverse;
      this.limit = typeof opts.limit === "number" ? opts.limit : -1;
      this.encoding = opts.encoding || batch.encoding;
      if (this.live && this.reverse) {
        throw new Error("Cannot have both live and reverse enabled");
      }
    }
    async open() {
      await this.batch.getRoot(false);
      this.gte = gte(this.options, this.batch.version);
      this.lt = this.live ? Infinity : lt(this.options, this.batch.version);
    }
    async next() {
      if (this.limit === 0)
        return null;
      if (this.limit > 0)
        this.limit--;
      if (this.gte >= this.lt)
        return null;
      if (this.reverse) {
        if (this.lt <= 1)
          return null;
        return final(await this.batch.getBlock(--this.lt), this.encoding);
      }
      return final(await this.batch.getBlock(this.gte++), this.encoding);
    }
    close() {
      return this.batch._closeSnapshot();
    }
  };
  function final(node, encoding) {
    const type = node.isDeletion() ? "del" : "put";
    return { type, ...node.final(encoding) };
  }
  function gte(opts, version) {
    if (opts.gt)
      return (opts.gt < 0 ? opts.gt + version : opts.gt) + 1;
    const gte2 = opts.gte || opts.since || 1;
    return gte2 < 0 ? gte2 + version : gte2;
  }
  function lt(opts, version) {
    if (opts.lte === 0 || opts.lt === 0 || opts.end === 0)
      return 0;
    if (opts.lte)
      return (opts.lte < 0 ? opts.lte + version : opts.lte) + 1;
    const lt2 = opts.lt || opts.end || version;
    return lt2 < 0 ? lt2 + version : lt2;
  }
});

// node_modules/hyperbee/iterators/diff.js
var require_diff = __commonJS((exports, module) => {
  var b4a = require_b4a();

  class SubTree {
    constructor(node, parent) {
      this.node = node;
      this.parent = parent;
      this.isKey = node.children.length === 0;
      this.i = this.isKey ? 1 : 0;
      this.n = 0;
      const child = this.isKey ? null : this.node.children[0];
      this.seq = child !== null ? child.seq : this.node.keys[0].seq;
      this.offset = child !== null ? child.offset : 0;
    }
    next() {
      this.i++;
      this.isKey = (this.i & 1) === 1;
      if (!this.isKey && !this.node.children.length)
        this.i++;
      return this.update();
    }
    async bisect(key, incl) {
      let s = 0;
      let e = this.node.keys.length;
      let c;
      while (s < e) {
        const mid = s + e >> 1;
        c = cmp(key, await this.node.getKey(mid));
        if (c === 0) {
          if (incl)
            this.i = mid * 2 + 1;
          else
            this.i = mid * 2 + (this.node.children.length ? 2 : 3);
          return true;
        }
        if (c < 0)
          e = mid;
        else
          s = mid + 1;
      }
      const i = c < 0 ? e : s;
      this.i = 2 * i + (this.node.children.length ? 0 : 1);
      return this.node.children.length === 0;
    }
    update() {
      this.isKey = (this.i & 1) === 1;
      this.n = this.i >> 1;
      if (this.n >= (this.isKey ? this.node.keys.length : this.node.children.length))
        return false;
      const child = this.isKey ? null : this.node.children[this.n];
      this.seq = child !== null ? child.seq : this.node.keys[this.n].seq;
      this.offset = child !== null ? child.offset : 0;
      return true;
    }
    async key() {
      return this.n < this.node.keys.length ? this.node.getKey(this.n) : this.parent && this.parent.key();
    }
    async compare(tree) {
      const [a, b] = await Promise.all([this.key(), tree.key()]);
      return cmp(a, b);
    }
  }

  class TreeIterator {
    constructor(batch, opts) {
      this.batch = batch;
      this.stack = [];
      this.lt = opts.lt || opts.lte || null;
      this.lte = !!opts.lte;
      this.gt = opts.gt || opts.gte || null;
      this.gte = !!opts.gte;
      this.seeking = !!this.gt;
      this.encoding = opts.encoding || batch.encoding;
    }
    async open() {
      const node = await this.batch.getRoot(false);
      if (!node || !node.keys.length)
        return;
      const tree = new SubTree(node, null);
      if (this.seeking && !await this._seek(tree))
        return;
      this.stack.push(tree);
    }
    async _seek(tree) {
      const done = await tree.bisect(this.gt, this.gte);
      const oob = !tree.update();
      if (done || oob) {
        this.seeking = false;
        if (oob)
          return false;
      }
      return true;
    }
    peek() {
      if (!this.stack.length)
        return null;
      return this.stack[this.stack.length - 1];
    }
    skip() {
      if (!this.stack.length)
        return;
      if (!this.stack[this.stack.length - 1].next())
        this.stack.pop();
    }
    async nextKey() {
      let n = null;
      while (this.stack.length && n === null)
        n = await this.next();
      if (n === null)
        return null;
      if (!this.lt)
        return n.final(this.encoding);
      const c = cmp(n.key, this.lt);
      if (this.lte ? c <= 0 : c < 0)
        return n.final(this.encoding);
      this.stack = [];
      return null;
    }
    async next() {
      if (!this.stack.length)
        return null;
      const top = this.stack[this.stack.length - 1];
      const { isKey, n, seq } = top;
      if (!top.next()) {
        this.stack.pop();
      }
      if (isKey) {
        this.seeking = false;
        return this.batch.getBlock(seq);
      }
      const child = await top.node.getChildNode(n);
      top.node.children[n] = null;
      const tree = new SubTree(child, top);
      if (this.seeking && !await this._seek(tree))
        return null;
      this.stack.push(tree);
      return null;
    }
    close() {
      return this.batch._closeSnapshot();
    }
  }
  module.exports = class DiffIterator {
    constructor(left, right, opts = {}) {
      this.left = new TreeIterator(left, opts);
      this.right = new TreeIterator(right, opts);
      this.limit = typeof opts.limit === "number" ? opts.limit : -1;
    }
    async open() {
      await Promise.all([this.left.open(), this.right.open()]);
    }
    async next() {
      if (this.limit === 0)
        return null;
      const res = await this._next();
      if (!res || res.left === null && res.right === null)
        return null;
      this.limit--;
      return res;
    }
    async _next() {
      const a = this.left;
      const b = this.right;
      while (true) {
        const [l, r] = await Promise.all([a.peek(), b.peek()]);
        if (!l && !r)
          return null;
        if (!l)
          return { left: null, right: await b.nextKey() };
        if (!r)
          return { left: await a.nextKey(), right: null };
        if (l.seq === r.seq && l.isKey === r.isKey && l.offset === r.offset) {
          a.skip();
          b.skip();
          continue;
        }
        const c = await l.compare(r);
        if (l.isKey && !r.isKey) {
          await b.next();
          continue;
        }
        if (!l.isKey && r.isKey) {
          await a.next();
          continue;
        }
        if (l.isKey && r.isKey) {
          if (c === 0)
            return { left: await a.nextKey(), right: await b.nextKey() };
          if (c < 0)
            return { left: await a.nextKey(), right: null };
          return { left: null, right: await b.nextKey() };
        }
        if (c === 0)
          await Promise.all([a.next(), b.next()]);
        else if (c < 0)
          await b.next();
        else
          await a.next();
      }
    }
    async close() {
      await Promise.all([this.left.close(), this.right.close()]);
    }
  };
  function cmp(a, b) {
    if (!a)
      return b ? 1 : 0;
    if (!b)
      return a ? -1 : 0;
    return b4a.compare(a, b);
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS((exports, module) => {
  module.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS((exports, module) => {
  module.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/varint/length.js
var require_length = __commonJS((exports, module) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/varint/index.js
var require_varint = __commonJS((exports, module) => {
  module.exports = {
    encode: require_encode(),
    decode: require_decode(),
    encodingLength: require_length()
  };
});

// node_modules/signed-varint/index.js
var require_signed_varint = __commonJS((exports) => {
  var varint = require_varint();
  exports.encode = function encode(v, b, o) {
    v = v >= 0 ? v * 2 : v * -2 - 1;
    var r = varint.encode(v, b, o);
    encode.bytes = varint.encode.bytes;
    return r;
  };
  exports.decode = function decode(b, o) {
    var v = varint.decode(b, o);
    decode.bytes = varint.decode.bytes;
    return v & 1 ? (v + 1) / -2 : v / 2;
  };
  exports.encodingLength = function(v) {
    return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1);
  };
});

// node_modules/protocol-buffers-encodings/index.js
var require_protocol_buffers_encodings = __commonJS((exports) => {
  var varint = require_varint();
  var svarint = require_signed_varint();
  var b4a = require_b4a();
  exports.make = encoder;
  exports.name = function(enc) {
    var keys = Object.keys(exports);
    for (var i = 0;i < keys.length; i++) {
      if (exports[keys[i]] === enc)
        return keys[i];
    }
    return null;
  };
  exports.skip = function(type, buffer, offset) {
    switch (type) {
      case 0:
        varint.decode(buffer, offset);
        return offset + varint.decode.bytes;
      case 1:
        return offset + 8;
      case 2:
        var len = varint.decode(buffer, offset);
        return offset + varint.decode.bytes + len;
      case 3:
      case 4:
        throw new Error("Groups are not supported");
      case 5:
        return offset + 4;
    }
    throw new Error("Unknown wire type: " + type);
  };
  exports.bytes = encoder(2, function encode(val, buffer, offset) {
    var oldOffset = offset;
    var len = bufferLength(val);
    varint.encode(len, buffer, offset);
    offset += varint.encode.bytes;
    if (b4a.isBuffer(val))
      b4a.copy(val, buffer, offset);
    else
      b4a.write(buffer, val, offset, len);
    offset += len;
    encode.bytes = offset - oldOffset;
    return buffer;
  }, function decode(buffer, offset) {
    var oldOffset = offset;
    var len = varint.decode(buffer, offset);
    offset += varint.decode.bytes;
    var val = buffer.subarray(offset, offset + len);
    offset += val.length;
    decode.bytes = offset - oldOffset;
    return val;
  }, function encodingLength(val) {
    var len = bufferLength(val);
    return varint.encodingLength(len) + len;
  });
  exports.string = encoder(2, function encode(val, buffer, offset) {
    var oldOffset = offset;
    var len = b4a.byteLength(val);
    varint.encode(len, buffer, offset, "utf-8");
    offset += varint.encode.bytes;
    b4a.write(buffer, val, offset, len);
    offset += len;
    encode.bytes = offset - oldOffset;
    return buffer;
  }, function decode(buffer, offset) {
    var oldOffset = offset;
    var len = varint.decode(buffer, offset);
    offset += varint.decode.bytes;
    var val = b4a.toString(buffer, "utf-8", offset, offset + len);
    offset += len;
    decode.bytes = offset - oldOffset;
    return val;
  }, function encodingLength(val) {
    var len = b4a.byteLength(val);
    return varint.encodingLength(len) + len;
  });
  exports.bool = encoder(0, function encode(val, buffer, offset) {
    buffer[offset] = val ? 1 : 0;
    encode.bytes = 1;
    return buffer;
  }, function decode(buffer, offset) {
    var bool = buffer[offset] > 0;
    decode.bytes = 1;
    return bool;
  }, function encodingLength() {
    return 1;
  });
  exports.int32 = encoder(0, function encode(val, buffer, offset) {
    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset);
    encode.bytes = varint.encode.bytes;
    return buffer;
  }, function decode(buffer, offset) {
    var val = varint.decode(buffer, offset);
    decode.bytes = varint.decode.bytes;
    return val > 2147483647 ? val - 4294967296 : val;
  }, function encodingLength(val) {
    return varint.encodingLength(val < 0 ? val + 4294967296 : val);
  });
  exports.int64 = encoder(0, function encode(val, buffer, offset) {
    if (val < 0) {
      var last = offset + 9;
      varint.encode(val * -1, buffer, offset);
      offset += varint.encode.bytes - 1;
      buffer[offset] = buffer[offset] | 128;
      while (offset < last - 1) {
        offset++;
        buffer[offset] = 255;
      }
      buffer[last] = 1;
      encode.bytes = 10;
    } else {
      varint.encode(val, buffer, offset);
      encode.bytes = varint.encode.bytes;
    }
    return buffer;
  }, function decode(buffer, offset) {
    var val = varint.decode(buffer, offset);
    if (val >= Math.pow(2, 63)) {
      var limit = 9;
      while (buffer[offset + limit - 1] === 255)
        limit--;
      limit = limit || 9;
      var subset = b4a.allocUnsafe(limit);
      b4a.copy(buffer, subset, 0, offset, offset + limit);
      subset[limit - 1] = subset[limit - 1] & 127;
      val = -1 * varint.decode(subset, 0);
      decode.bytes = 10;
    } else {
      decode.bytes = varint.decode.bytes;
    }
    return val;
  }, function encodingLength(val) {
    return val < 0 ? 10 : varint.encodingLength(val);
  });
  exports.sint32 = exports.sint64 = encoder(0, svarint.encode, svarint.decode, svarint.encodingLength);
  exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(0, varint.encode, varint.decode, varint.encodingLength);
  exports.fixed64 = exports.sfixed64 = encoder(1, function encode(val, buffer, offset) {
    b4a.copy(val, buffer, offset);
    encode.bytes = 8;
    return buffer;
  }, function decode(buffer, offset) {
    var val = buffer.subarray(offset, offset + 8);
    decode.bytes = 8;
    return val;
  }, function encodingLength() {
    return 8;
  });
  exports.double = encoder(1, function encode(val, buffer, offset) {
    b4a.writeDoubleLE(buffer, val, offset);
    encode.bytes = 8;
    return buffer;
  }, function decode(buffer, offset) {
    var val = b4a.readDoubleLE(buffer, offset);
    decode.bytes = 8;
    return val;
  }, function encodingLength() {
    return 8;
  });
  exports.fixed32 = encoder(5, function encode(val, buffer, offset) {
    b4a.writeUInt32LE(buffer, val, offset);
    encode.bytes = 4;
    return buffer;
  }, function decode(buffer, offset) {
    var val = b4a.readUInt32LE(buffer, offset);
    decode.bytes = 4;
    return val;
  }, function encodingLength() {
    return 4;
  });
  exports.sfixed32 = encoder(5, function encode(val, buffer, offset) {
    b4a.writeInt32LE(buffer, val, offset);
    encode.bytes = 4;
    return buffer;
  }, function decode(buffer, offset) {
    var val = b4a.readInt32LE(buffer, offset);
    decode.bytes = 4;
    return val;
  }, function encodingLength() {
    return 4;
  });
  exports.float = encoder(5, function encode(val, buffer, offset) {
    b4a.writeFloatLE(buffer, val, offset);
    encode.bytes = 4;
    return buffer;
  }, function decode(buffer, offset) {
    var val = b4a.readFloatLE(buffer, offset);
    decode.bytes = 4;
    return val;
  }, function encodingLength() {
    return 4;
  });
  function encoder(type, encode, decode, encodingLength) {
    encode.bytes = decode.bytes = 0;
    return {
      type,
      encode,
      decode,
      encodingLength
    };
  }
  function bufferLength(val) {
    return b4a.isBuffer(val) ? val.length : b4a.byteLength(val);
  }
});

// node_modules/hyperbee/lib/messages.js
var require_messages4 = __commonJS((exports) => {
  var encodings = require_protocol_buffers_encodings();
  var b4a = require_b4a();
  var varint = encodings.varint;
  var skip = encodings.skip;
  var YoloIndex = exports.YoloIndex = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  var Header = exports.Header = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  var Node = exports.Node = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  var Extension = exports.Extension = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  };
  defineYoloIndex();
  defineHeader();
  defineNode();
  defineExtension();
  function defineYoloIndex() {
    var Level = YoloIndex.Level = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    defineLevel();
    function defineLevel() {
      Level.encodingLength = encodingLength2;
      Level.encode = encode2;
      Level.decode = decode2;
      function encodingLength2(obj) {
        var length = 0;
        if (defined(obj.keys)) {
          var packedLen = 0;
          for (var i = 0;i < obj.keys.length; i++) {
            if (!defined(obj.keys[i]))
              continue;
            var len = encodings.varint.encodingLength(obj.keys[i]);
            packedLen += len;
          }
          if (packedLen) {
            length += 1 + packedLen + varint.encodingLength(packedLen);
          }
        }
        if (defined(obj.children)) {
          var packedLen = 0;
          for (var i = 0;i < obj.children.length; i++) {
            if (!defined(obj.children[i]))
              continue;
            var len = encodings.varint.encodingLength(obj.children[i]);
            packedLen += len;
          }
          if (packedLen) {
            length += 1 + packedLen + varint.encodingLength(packedLen);
          }
        }
        return length;
      }
      function encode2(obj, buf, offset) {
        if (!offset)
          offset = 0;
        if (!buf)
          buf = b4a.allocUnsafe(encodingLength2(obj));
        var oldOffset = offset;
        if (defined(obj.keys)) {
          var packedLen = 0;
          for (var i = 0;i < obj.keys.length; i++) {
            if (!defined(obj.keys[i]))
              continue;
            packedLen += encodings.varint.encodingLength(obj.keys[i]);
          }
          if (packedLen) {
            buf[offset++] = 10;
            varint.encode(packedLen, buf, offset);
            offset += varint.encode.bytes;
          }
          for (var i = 0;i < obj.keys.length; i++) {
            if (!defined(obj.keys[i]))
              continue;
            encodings.varint.encode(obj.keys[i], buf, offset);
            offset += encodings.varint.encode.bytes;
          }
        }
        if (defined(obj.children)) {
          var packedLen = 0;
          for (var i = 0;i < obj.children.length; i++) {
            if (!defined(obj.children[i]))
              continue;
            packedLen += encodings.varint.encodingLength(obj.children[i]);
          }
          if (packedLen) {
            buf[offset++] = 18;
            varint.encode(packedLen, buf, offset);
            offset += varint.encode.bytes;
          }
          for (var i = 0;i < obj.children.length; i++) {
            if (!defined(obj.children[i]))
              continue;
            encodings.varint.encode(obj.children[i], buf, offset);
            offset += encodings.varint.encode.bytes;
          }
        }
        encode2.bytes = offset - oldOffset;
        return buf;
      }
      function decode2(buf, offset, end) {
        if (!offset)
          offset = 0;
        if (!end)
          end = buf.length;
        if (!(end <= buf.length && offset <= buf.length))
          throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          keys: [],
          children: []
        };
        while (true) {
          if (end <= offset) {
            decode2.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              var packedEnd = varint.decode(buf, offset);
              offset += varint.decode.bytes;
              packedEnd += offset;
              while (offset < packedEnd) {
                obj.keys.push(encodings.varint.decode(buf, offset));
                offset += encodings.varint.decode.bytes;
              }
              break;
            case 2:
              var packedEnd = varint.decode(buf, offset);
              offset += varint.decode.bytes;
              packedEnd += offset;
              while (offset < packedEnd) {
                obj.children.push(encodings.varint.decode(buf, offset));
                offset += encodings.varint.decode.bytes;
              }
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    YoloIndex.encodingLength = encodingLength;
    YoloIndex.encode = encode;
    YoloIndex.decode = decode;
    function encodingLength(obj) {
      var length = 0;
      if (defined(obj.levels)) {
        for (var i = 0;i < obj.levels.length; i++) {
          if (!defined(obj.levels[i]))
            continue;
          var len = Level.encodingLength(obj.levels[i]);
          length += varint.encodingLength(len);
          length += 1 + len;
        }
      }
      return length;
    }
    function encode(obj, buf, offset) {
      if (!offset)
        offset = 0;
      if (!buf)
        buf = b4a.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;
      if (defined(obj.levels)) {
        for (var i = 0;i < obj.levels.length; i++) {
          if (!defined(obj.levels[i]))
            continue;
          buf[offset++] = 10;
          varint.encode(Level.encodingLength(obj.levels[i]), buf, offset);
          offset += varint.encode.bytes;
          Level.encode(obj.levels[i], buf, offset);
          offset += Level.encode.bytes;
        }
      }
      encode.bytes = offset - oldOffset;
      return buf;
    }
    function decode(buf, offset, end) {
      if (!offset)
        offset = 0;
      if (!end)
        end = buf.length;
      if (!(end <= buf.length && offset <= buf.length))
        throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        levels: []
      };
      while (true) {
        if (end <= offset) {
          decode.bytes = offset - oldOffset;
          return obj;
        }
        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;
        switch (tag) {
          case 1:
            var len = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            obj.levels.push(Level.decode(buf, offset, offset + len));
            offset += Level.decode.bytes;
            break;
          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }
  function defineHeader() {
    var Metadata = Header.Metadata = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    defineMetadata();
    function defineMetadata() {
      Metadata.encodingLength = encodingLength2;
      Metadata.encode = encode2;
      Metadata.decode = decode2;
      function encodingLength2(obj) {
        var length = 0;
        if (defined(obj.contentFeed)) {
          var len = encodings.bytes.encodingLength(obj.contentFeed);
          length += 1 + len;
        }
        if (defined(obj.userData)) {
          var len = encodings.bytes.encodingLength(obj.userData);
          length += 1 + len;
        }
        return length;
      }
      function encode2(obj, buf, offset) {
        if (!offset)
          offset = 0;
        if (!buf)
          buf = b4a.allocUnsafe(encodingLength2(obj));
        var oldOffset = offset;
        if (defined(obj.contentFeed)) {
          buf[offset++] = 10;
          encodings.bytes.encode(obj.contentFeed, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        if (defined(obj.userData)) {
          buf[offset++] = 18;
          encodings.bytes.encode(obj.userData, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        encode2.bytes = offset - oldOffset;
        return buf;
      }
      function decode2(buf, offset, end) {
        if (!offset)
          offset = 0;
        if (!end)
          end = buf.length;
        if (!(end <= buf.length && offset <= buf.length))
          throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          contentFeed: null,
          userData: null
        };
        while (true) {
          if (end <= offset) {
            decode2.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.contentFeed = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            case 2:
              obj.userData = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    Header.encodingLength = encodingLength;
    Header.encode = encode;
    Header.decode = decode;
    function encodingLength(obj) {
      var length = 0;
      if (!defined(obj.protocol))
        throw new Error("protocol is required");
      var len = encodings.string.encodingLength(obj.protocol);
      length += 1 + len;
      if (defined(obj.metadata)) {
        var len = Metadata.encodingLength(obj.metadata);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
      return length;
    }
    function encode(obj, buf, offset) {
      if (!offset)
        offset = 0;
      if (!buf)
        buf = b4a.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;
      if (!defined(obj.protocol))
        throw new Error("protocol is required");
      buf[offset++] = 10;
      encodings.string.encode(obj.protocol, buf, offset);
      offset += encodings.string.encode.bytes;
      if (defined(obj.metadata)) {
        buf[offset++] = 18;
        varint.encode(Metadata.encodingLength(obj.metadata), buf, offset);
        offset += varint.encode.bytes;
        Metadata.encode(obj.metadata, buf, offset);
        offset += Metadata.encode.bytes;
      }
      encode.bytes = offset - oldOffset;
      return buf;
    }
    function decode(buf, offset, end) {
      if (!offset)
        offset = 0;
      if (!end)
        end = buf.length;
      if (!(end <= buf.length && offset <= buf.length))
        throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        protocol: "",
        metadata: null
      };
      var found0 = false;
      while (true) {
        if (end <= offset) {
          if (!found0)
            throw new Error("Decoded message is not valid");
          decode.bytes = offset - oldOffset;
          return obj;
        }
        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;
        switch (tag) {
          case 1:
            obj.protocol = encodings.string.decode(buf, offset);
            offset += encodings.string.decode.bytes;
            found0 = true;
            break;
          case 2:
            var len = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            obj.metadata = Metadata.decode(buf, offset, offset + len);
            offset += Metadata.decode.bytes;
            break;
          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }
  function defineNode() {
    Node.encodingLength = encodingLength;
    Node.encode = encode;
    Node.decode = decode;
    function encodingLength(obj) {
      var length = 0;
      if (!defined(obj.index))
        throw new Error("index is required");
      var len = encodings.bytes.encodingLength(obj.index);
      length += 1 + len;
      if (!defined(obj.key))
        throw new Error("key is required");
      var len = encodings.bytes.encodingLength(obj.key);
      length += 1 + len;
      if (defined(obj.value)) {
        var len = encodings.bytes.encodingLength(obj.value);
        length += 1 + len;
      }
      return length;
    }
    function encode(obj, buf, offset) {
      if (!offset)
        offset = 0;
      if (!buf)
        buf = b4a.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;
      if (!defined(obj.index))
        throw new Error("index is required");
      buf[offset++] = 10;
      encodings.bytes.encode(obj.index, buf, offset);
      offset += encodings.bytes.encode.bytes;
      if (!defined(obj.key))
        throw new Error("key is required");
      buf[offset++] = 18;
      encodings.bytes.encode(obj.key, buf, offset);
      offset += encodings.bytes.encode.bytes;
      if (defined(obj.value)) {
        buf[offset++] = 26;
        encodings.bytes.encode(obj.value, buf, offset);
        offset += encodings.bytes.encode.bytes;
      }
      encode.bytes = offset - oldOffset;
      return buf;
    }
    function decode(buf, offset, end) {
      if (!offset)
        offset = 0;
      if (!end)
        end = buf.length;
      if (!(end <= buf.length && offset <= buf.length))
        throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        index: null,
        key: null,
        value: null
      };
      var found0 = false;
      var found1 = false;
      while (true) {
        if (end <= offset) {
          if (!found0 || !found1)
            throw new Error("Decoded message is not valid");
          decode.bytes = offset - oldOffset;
          return obj;
        }
        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;
        switch (tag) {
          case 1:
            obj.index = encodings.bytes.decode(buf, offset);
            offset += encodings.bytes.decode.bytes;
            found0 = true;
            break;
          case 2:
            obj.key = encodings.bytes.decode(buf, offset);
            offset += encodings.bytes.decode.bytes;
            found1 = true;
            break;
          case 3:
            obj.value = encodings.bytes.decode(buf, offset);
            offset += encodings.bytes.decode.bytes;
            break;
          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }
  function defineExtension() {
    var Get = Extension.Get = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Iterator = Extension.Iterator = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    var Cache = Extension.Cache = {
      buffer: true,
      encodingLength: null,
      encode: null,
      decode: null
    };
    defineGet();
    defineIterator();
    defineCache();
    function defineGet() {
      Get.encodingLength = encodingLength2;
      Get.encode = encode2;
      Get.decode = decode2;
      function encodingLength2(obj) {
        var length = 0;
        if (defined(obj.version)) {
          var len = encodings.varint.encodingLength(obj.version);
          length += 1 + len;
        }
        if (defined(obj.key)) {
          var len = encodings.bytes.encodingLength(obj.key);
          length += 1 + len;
        }
        return length;
      }
      function encode2(obj, buf, offset) {
        if (!offset)
          offset = 0;
        if (!buf)
          buf = b4a.allocUnsafe(encodingLength2(obj));
        var oldOffset = offset;
        if (defined(obj.version)) {
          buf[offset++] = 8;
          encodings.varint.encode(obj.version, buf, offset);
          offset += encodings.varint.encode.bytes;
        }
        if (defined(obj.key)) {
          buf[offset++] = 18;
          encodings.bytes.encode(obj.key, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        encode2.bytes = offset - oldOffset;
        return buf;
      }
      function decode2(buf, offset, end) {
        if (!offset)
          offset = 0;
        if (!end)
          end = buf.length;
        if (!(end <= buf.length && offset <= buf.length))
          throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          version: 0,
          key: null
        };
        while (true) {
          if (end <= offset) {
            decode2.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.version = encodings.varint.decode(buf, offset);
              offset += encodings.varint.decode.bytes;
              break;
            case 2:
              obj.key = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineIterator() {
      Iterator.encodingLength = encodingLength2;
      Iterator.encode = encode2;
      Iterator.decode = decode2;
      function encodingLength2(obj) {
        var length = 0;
        if (defined(obj.version)) {
          var len = encodings.varint.encodingLength(obj.version);
          length += 1 + len;
        }
        if (defined(obj.gte)) {
          var len = encodings.bytes.encodingLength(obj.gte);
          length += 1 + len;
        }
        if (defined(obj.gt)) {
          var len = encodings.bytes.encodingLength(obj.gt);
          length += 1 + len;
        }
        if (defined(obj.lte)) {
          var len = encodings.bytes.encodingLength(obj.lte);
          length += 1 + len;
        }
        if (defined(obj.lt)) {
          var len = encodings.bytes.encodingLength(obj.lt);
          length += 1 + len;
        }
        if (defined(obj.limit)) {
          var len = encodings.varint.encodingLength(obj.limit);
          length += 1 + len;
        }
        if (defined(obj.reverse)) {
          var len = encodings.bool.encodingLength(obj.reverse);
          length += 1 + len;
        }
        if (defined(obj.checkpoint)) {
          var packedLen = 0;
          for (var i = 0;i < obj.checkpoint.length; i++) {
            if (!defined(obj.checkpoint[i]))
              continue;
            var len = encodings.varint.encodingLength(obj.checkpoint[i]);
            packedLen += len;
          }
          if (packedLen) {
            length += 1 + packedLen + varint.encodingLength(packedLen);
          }
        }
        return length;
      }
      function encode2(obj, buf, offset) {
        if (!offset)
          offset = 0;
        if (!buf)
          buf = b4a.allocUnsafe(encodingLength2(obj));
        var oldOffset = offset;
        if (defined(obj.version)) {
          buf[offset++] = 8;
          encodings.varint.encode(obj.version, buf, offset);
          offset += encodings.varint.encode.bytes;
        }
        if (defined(obj.gte)) {
          buf[offset++] = 18;
          encodings.bytes.encode(obj.gte, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        if (defined(obj.gt)) {
          buf[offset++] = 26;
          encodings.bytes.encode(obj.gt, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        if (defined(obj.lte)) {
          buf[offset++] = 34;
          encodings.bytes.encode(obj.lte, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        if (defined(obj.lt)) {
          buf[offset++] = 42;
          encodings.bytes.encode(obj.lt, buf, offset);
          offset += encodings.bytes.encode.bytes;
        }
        if (defined(obj.limit)) {
          buf[offset++] = 48;
          encodings.varint.encode(obj.limit, buf, offset);
          offset += encodings.varint.encode.bytes;
        }
        if (defined(obj.reverse)) {
          buf[offset++] = 56;
          encodings.bool.encode(obj.reverse, buf, offset);
          offset += encodings.bool.encode.bytes;
        }
        if (defined(obj.checkpoint)) {
          var packedLen = 0;
          for (var i = 0;i < obj.checkpoint.length; i++) {
            if (!defined(obj.checkpoint[i]))
              continue;
            packedLen += encodings.varint.encodingLength(obj.checkpoint[i]);
          }
          if (packedLen) {
            buf[offset++] = 66;
            varint.encode(packedLen, buf, offset);
            offset += varint.encode.bytes;
          }
          for (var i = 0;i < obj.checkpoint.length; i++) {
            if (!defined(obj.checkpoint[i]))
              continue;
            encodings.varint.encode(obj.checkpoint[i], buf, offset);
            offset += encodings.varint.encode.bytes;
          }
        }
        encode2.bytes = offset - oldOffset;
        return buf;
      }
      function decode2(buf, offset, end) {
        if (!offset)
          offset = 0;
        if (!end)
          end = buf.length;
        if (!(end <= buf.length && offset <= buf.length))
          throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          version: 0,
          gte: null,
          gt: null,
          lte: null,
          lt: null,
          limit: 0,
          reverse: false,
          checkpoint: []
        };
        while (true) {
          if (end <= offset) {
            decode2.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.version = encodings.varint.decode(buf, offset);
              offset += encodings.varint.decode.bytes;
              break;
            case 2:
              obj.gte = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            case 3:
              obj.gt = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            case 4:
              obj.lte = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            case 5:
              obj.lt = encodings.bytes.decode(buf, offset);
              offset += encodings.bytes.decode.bytes;
              break;
            case 6:
              obj.limit = encodings.varint.decode(buf, offset);
              offset += encodings.varint.decode.bytes;
              break;
            case 7:
              obj.reverse = encodings.bool.decode(buf, offset);
              offset += encodings.bool.decode.bytes;
              break;
            case 8:
              var packedEnd = varint.decode(buf, offset);
              offset += varint.decode.bytes;
              packedEnd += offset;
              while (offset < packedEnd) {
                obj.checkpoint.push(encodings.varint.decode(buf, offset));
                offset += encodings.varint.decode.bytes;
              }
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    function defineCache() {
      Cache.encodingLength = encodingLength2;
      Cache.encode = encode2;
      Cache.decode = decode2;
      function encodingLength2(obj) {
        var length = 0;
        if (!defined(obj.start))
          throw new Error("start is required");
        var len = encodings.varint.encodingLength(obj.start);
        length += 1 + len;
        if (!defined(obj.end))
          throw new Error("end is required");
        var len = encodings.varint.encodingLength(obj.end);
        length += 1 + len;
        if (defined(obj.blocks)) {
          var packedLen = 0;
          for (var i = 0;i < obj.blocks.length; i++) {
            if (!defined(obj.blocks[i]))
              continue;
            var len = encodings.varint.encodingLength(obj.blocks[i]);
            packedLen += len;
          }
          if (packedLen) {
            length += 1 + packedLen + varint.encodingLength(packedLen);
          }
        }
        return length;
      }
      function encode2(obj, buf, offset) {
        if (!offset)
          offset = 0;
        if (!buf)
          buf = b4a.allocUnsafe(encodingLength2(obj));
        var oldOffset = offset;
        if (!defined(obj.start))
          throw new Error("start is required");
        buf[offset++] = 8;
        encodings.varint.encode(obj.start, buf, offset);
        offset += encodings.varint.encode.bytes;
        if (!defined(obj.end))
          throw new Error("end is required");
        buf[offset++] = 16;
        encodings.varint.encode(obj.end, buf, offset);
        offset += encodings.varint.encode.bytes;
        if (defined(obj.blocks)) {
          var packedLen = 0;
          for (var i = 0;i < obj.blocks.length; i++) {
            if (!defined(obj.blocks[i]))
              continue;
            packedLen += encodings.varint.encodingLength(obj.blocks[i]);
          }
          if (packedLen) {
            buf[offset++] = 26;
            varint.encode(packedLen, buf, offset);
            offset += varint.encode.bytes;
          }
          for (var i = 0;i < obj.blocks.length; i++) {
            if (!defined(obj.blocks[i]))
              continue;
            encodings.varint.encode(obj.blocks[i], buf, offset);
            offset += encodings.varint.encode.bytes;
          }
        }
        encode2.bytes = offset - oldOffset;
        return buf;
      }
      function decode2(buf, offset, end) {
        if (!offset)
          offset = 0;
        if (!end)
          end = buf.length;
        if (!(end <= buf.length && offset <= buf.length))
          throw new Error("Decoded message is not valid");
        var oldOffset = offset;
        var obj = {
          start: 0,
          end: 0,
          blocks: []
        };
        var found0 = false;
        var found1 = false;
        while (true) {
          if (end <= offset) {
            if (!found0 || !found1)
              throw new Error("Decoded message is not valid");
            decode2.bytes = offset - oldOffset;
            return obj;
          }
          var prefix = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          var tag = prefix >> 3;
          switch (tag) {
            case 1:
              obj.start = encodings.varint.decode(buf, offset);
              offset += encodings.varint.decode.bytes;
              found0 = true;
              break;
            case 2:
              obj.end = encodings.varint.decode(buf, offset);
              offset += encodings.varint.decode.bytes;
              found1 = true;
              break;
            case 3:
              var packedEnd = varint.decode(buf, offset);
              offset += varint.decode.bytes;
              packedEnd += offset;
              while (offset < packedEnd) {
                obj.blocks.push(encodings.varint.decode(buf, offset));
                offset += encodings.varint.decode.bytes;
              }
              break;
            default:
              offset = skip(prefix & 7, buf, offset);
          }
        }
      }
    }
    Extension.encodingLength = encodingLength;
    Extension.encode = encode;
    Extension.decode = decode;
    function encodingLength(obj) {
      var length = 0;
      if (defined(obj.cache)) {
        var len = Cache.encodingLength(obj.cache);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
      if (defined(obj.get)) {
        var len = Get.encodingLength(obj.get);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
      if (defined(obj.iterator)) {
        var len = Iterator.encodingLength(obj.iterator);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
      return length;
    }
    function encode(obj, buf, offset) {
      if (!offset)
        offset = 0;
      if (!buf)
        buf = b4a.allocUnsafe(encodingLength(obj));
      var oldOffset = offset;
      if (defined(obj.cache)) {
        buf[offset++] = 10;
        varint.encode(Cache.encodingLength(obj.cache), buf, offset);
        offset += varint.encode.bytes;
        Cache.encode(obj.cache, buf, offset);
        offset += Cache.encode.bytes;
      }
      if (defined(obj.get)) {
        buf[offset++] = 18;
        varint.encode(Get.encodingLength(obj.get), buf, offset);
        offset += varint.encode.bytes;
        Get.encode(obj.get, buf, offset);
        offset += Get.encode.bytes;
      }
      if (defined(obj.iterator)) {
        buf[offset++] = 26;
        varint.encode(Iterator.encodingLength(obj.iterator), buf, offset);
        offset += varint.encode.bytes;
        Iterator.encode(obj.iterator, buf, offset);
        offset += Iterator.encode.bytes;
      }
      encode.bytes = offset - oldOffset;
      return buf;
    }
    function decode(buf, offset, end) {
      if (!offset)
        offset = 0;
      if (!end)
        end = buf.length;
      if (!(end <= buf.length && offset <= buf.length))
        throw new Error("Decoded message is not valid");
      var oldOffset = offset;
      var obj = {
        cache: null,
        get: null,
        iterator: null
      };
      while (true) {
        if (end <= offset) {
          decode.bytes = offset - oldOffset;
          return obj;
        }
        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;
        switch (tag) {
          case 1:
            var len = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            obj.cache = Cache.decode(buf, offset, offset + len);
            offset += Cache.decode.bytes;
            break;
          case 2:
            var len = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            obj.get = Get.decode(buf, offset, offset + len);
            offset += Get.decode.bytes;
            break;
          case 3:
            var len = varint.decode(buf, offset);
            offset += varint.decode.bytes;
            obj.iterator = Iterator.decode(buf, offset, offset + len);
            offset += Iterator.decode.bytes;
            break;
          default:
            offset = skip(prefix & 7, buf, offset);
        }
      }
    }
  }
  function defined(val) {
    return val !== null && val !== undefined && (typeof val !== "number" || !isNaN(val));
  }
});

// node_modules/hyperbee/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { Extension } = require_messages4();
  var FLUSH_BATCH = 128;
  var MAX_PASSIVE_BATCH = 2048;
  var MAX_ACTIVE_BATCH = MAX_PASSIVE_BATCH + FLUSH_BATCH;

  class Batch {
    constructor(outgoing, from) {
      this.blocks = [];
      this.start = 0;
      this.end = 0;
      this.outgoing = outgoing;
      this.from = from;
    }
    push(seq) {
      const len = this.blocks.push(seq);
      if (len === 1 || seq < this.start)
        this.start = seq;
      if (len === 1 || seq >= this.end)
        this.end = seq + 1;
      if (len >= FLUSH_BATCH) {
        this.send();
        this.clear();
      }
    }
    send() {
      if (!this.blocks.length)
        return;
      this.outgoing.send(Extension.encode({ cache: { blocks: this.blocks, start: this.start, end: this.end } }), this.from);
    }
    clear() {
      this.start = this.end = 0;
      this.blocks = [];
    }
  }

  class HyperbeeExtension {
    constructor(db) {
      this.encoding = null;
      this.outgoing = null;
      this.db = db;
      this.active = 0;
    }
    get(version, key) {
      this.outgoing.broadcast(Extension.encode({ get: { version, key } }));
    }
    iterator(snapshot) {
      if (snapshot.ended)
        return;
      if (snapshot.limit === 0)
        return;
      if (snapshot.limit === -1)
        snapshot.limit = 0;
      this.outgoing.broadcast(Extension.encode({ iterator: snapshot }));
    }
    onmessage(buf, from) {
      const message = decode(buf);
      if (!message)
        return;
      if (message.cache)
        this.oncache(message.cache, from);
      if (message.get)
        this.onget(message.get, from);
      if (message.iterator)
        this.oniterator(message.iterator, from);
    }
    oncache(message, from) {
      if (!message.blocks.length)
        return;
      this.db.core.download(message);
    }
    onget(message, from) {
      if (!message.version || message.version > this.db.version)
        return;
      const b = new Batch(this.outgoing, from);
      const db = this.db.checkout(message.version);
      db.get(message.key, { extension: false, wait: false, update: false, onseq }).then(done, done);
      function done() {
        db.close().catch(noop);
        b.send();
      }
      function onseq(seq) {
        b.push(seq);
      }
    }
    async oniterator(message, from) {
      if (!message.version || message.version > this.db.version)
        return;
      const b = new Batch(this.outgoing, from);
      const seqs = new Set;
      let skip = message.checkpoint.length;
      let work = 0;
      const db = this.db.checkout(message.version);
      const ite = db.createRangeIterator({
        ...message,
        wait: false,
        extension: false,
        update: false,
        limit: message.limit === 0 ? -1 : message.limit,
        onseq(seq) {
          if (skip && skip--)
            return;
          if (seqs.has(seq))
            return;
          work++;
          seqs.add(seq);
          b.push(seq);
        }
      });
      try {
        await ite.open();
        while (work < MAX_ACTIVE_BATCH) {
          if (!await ite.next())
            break;
        }
      } catch (_) {} finally {
        ite.close().catch(noop);
        db.close().catch(noop);
        b.send();
      }
    }
    static register(db) {
      const e = new this(db);
      e.outgoing = db.core.registerExtension("hyperbee", e);
      return e;
    }
  }
  HyperbeeExtension.BATCH_SIZE = MAX_PASSIVE_BATCH;
  module.exports = HyperbeeExtension;
  function decode(buf) {
    try {
      return Extension.decode(buf);
    } catch (err) {
      return null;
    }
  }
  function noop() {}
});

// node_modules/hyperbee/index.js
var require_hyperbee = __commonJS((exports, module) => {
  var codecs = require_codecs();
  var { Readable } = require_streamx();
  var mutexify = require_promise();
  var b4a = require_b4a();
  var safetyCatch = require_safety_catch();
  var ReadyResource = require_ready_resource();
  var debounce = require_debounceify();
  var Rache = require_rache();
  var { all: unslabAll } = require_unslab();
  var RangeIterator = require_range2();
  var HistoryIterator = require_history();
  var DiffIterator = require_diff();
  var Extension = require_extension();
  var { YoloIndex, Node, Header } = require_messages4();
  var { BLOCK_NOT_AVAILABLE, DECODING_ERROR } = require_hypercore_errors();
  var T = 5;
  var MIN_KEYS = T - 1;
  var MAX_CHILDREN = MIN_KEYS * 2 + 1;
  var SEP = b4a.alloc(1);
  var EMPTY = b4a.alloc(0);

  class Key {
    constructor(seq, value) {
      this.seq = seq;
      this.value = value;
    }
  }

  class Child {
    constructor(seq, offset, value) {
      this.seq = seq;
      this.offset = offset;
      this.value = value;
    }
  }

  class Cache {
    constructor(rache) {
      this.keys = rache;
      this.length = 0;
    }
    get(seq) {
      return this.keys.get(seq) || null;
    }
    set(seq, key) {
      this.keys.set(seq, key);
      if (seq >= this.length)
        this.length = seq + 1;
    }
    gc(length) {
      if (this.length - length > 128) {
        this.keys.clear();
      } else {
        for (let i = length;i < this.length; i++) {
          this.keys.delete(i);
        }
      }
      this.length = length;
    }
  }

  class Pointers {
    constructor(decoded) {
      this.levels = decoded.levels.map((l) => {
        const children = [];
        const keys = [];
        for (let i = 0;i < l.keys.length; i++) {
          keys.push(new Key(l.keys[i], null));
        }
        for (let i = 0;i < l.children.length; i += 2) {
          children.push(new Child(l.children[i], l.children[i + 1], null));
        }
        return { keys, children };
      });
    }
    get(i) {
      return this.levels[i];
    }
    hasKey(seq) {
      for (const lvl of this.levels) {
        for (const key of lvl.keys) {
          if (key.seq === seq)
            return true;
        }
      }
      return false;
    }
  }
  function inflate(entry) {
    if (entry.inflated === null) {
      entry.inflated = YoloIndex.decode(entry.index);
      entry.index = null;
    }
    return new Pointers(entry.inflated);
  }
  function deflate(index) {
    const levels = index.map((l) => {
      const keys = [];
      const children = [];
      for (let i = 0;i < l.value.keys.length; i++) {
        keys.push(l.value.keys[i].seq);
      }
      for (let i = 0;i < l.value.children.length; i++) {
        children.push(l.value.children[i].seq, l.value.children[i].offset);
      }
      return { keys, children };
    });
    return YoloIndex.encode({ levels });
  }

  class TreeNode {
    constructor(block, keys, children, offset) {
      this.block = block;
      this.offset = offset;
      this.keys = keys;
      this.children = children;
      this.changed = false;
      this.preload();
    }
    preload() {
      if (this.block === null)
        return;
      const core = getBackingCore(this.block.tree.core);
      if (!core)
        return;
      const bitfield = core.core.bitfield;
      const blocks = [];
      for (let i = 0;i < this.keys.length; i++) {
        const k = this.keys[i];
        if (k.value)
          continue;
        if (k.seq >= core.signedLength || bitfield && bitfield.get(k.seq))
          continue;
        blocks.push(k.seq);
      }
      for (let i = 0;i < this.children.length; i++) {
        const c = this.children[i];
        if (c.value)
          continue;
        if (c.seq >= core.signedLength || bitfield && bitfield.get(c.seq))
          continue;
        blocks.push(c.seq);
      }
      if (blocks.length)
        core.download({ blocks });
    }
    async insertKey(key, value, child, node, encoding, cas) {
      let s = 0;
      let e = this.keys.length;
      let c;
      while (s < e) {
        const mid = s + e >> 1;
        c = b4a.compare(key.value, await this.getKey(mid));
        if (c === 0) {
          if (cas) {
            const prev = await this.getKeyNode(mid);
            if (!await cas(prev.final(encoding), node))
              return true;
          }
          if (!this.block.tree.tree.alwaysDuplicate) {
            const prev = await this.getKeyNode(mid);
            if (sameValue(prev.value, value))
              return true;
          }
          this.changed = true;
          this.keys[mid] = key;
          return true;
        }
        if (c < 0)
          e = mid;
        else
          s = mid + 1;
      }
      const i = c < 0 ? e : s;
      this.keys.splice(i, 0, key);
      if (child)
        this.children.splice(i + 1, 0, new Child(0, 0, child));
      this.changed = true;
      return this.keys.length < MAX_CHILDREN;
    }
    removeKey(index) {
      this.keys.splice(index, 1);
      if (this.children.length) {
        this.children[index + 1].seq = 0;
        this.children.splice(index + 1, 1);
      }
      this.changed = true;
    }
    async siblings(parent) {
      for (let i = 0;i < parent.children.length; i++) {
        if (parent.children[i].value === this) {
          const [left, right] = await Promise.all([
            i ? parent.getChildNode(i - 1) : null,
            i < parent.children.length - 1 ? parent.getChildNode(i + 1) : null
          ]);
          return { left, index: i, right };
        }
      }
      throw new Error("Bad parent");
    }
    merge(node, median) {
      this.changed = true;
      this.keys.push(median);
      for (let i = 0;i < node.keys.length; i++)
        this.keys.push(node.keys[i]);
      for (let i = 0;i < node.children.length; i++)
        this.children.push(node.children[i]);
    }
    async split() {
      const len = this.keys.length >> 1;
      const right = TreeNode.create(this.block);
      while (right.keys.length < len)
        right.keys.push(this.keys.pop());
      right.keys.reverse();
      await this.getKey(this.keys.length - 1);
      const median = this.keys.pop();
      if (this.children.length) {
        while (right.children.length < len + 1)
          right.children.push(this.children.pop());
        right.children.reverse();
      }
      this.changed = true;
      return {
        left: this,
        median,
        right
      };
    }
    getKeyNode(index) {
      return this.block.tree.getBlock(this.keys[index].seq);
    }
    async getChildNode(index) {
      const child = this.children[index];
      if (child.value)
        return child.value;
      const block = child.seq === this.block.seq ? this.block : await this.block.tree.getBlock(child.seq);
      return child.value = block.getTreeNode(child.offset);
    }
    setKey(index, key) {
      this.keys[index] = key;
      this.changed = true;
    }
    async getKey(index) {
      const key = this.keys[index];
      if (key.value)
        return key.value;
      const k = key.seq === this.block.seq ? this.block.key : await this.block.tree.getKey(key.seq);
      return key.value = k;
    }
    indexChanges(index, seq) {
      const offset = index.push(null) - 1;
      this.changed = false;
      for (const child of this.children) {
        if (!child.value || !child.value.changed)
          continue;
        child.seq = seq;
        child.offset = child.value.indexChanges(index, seq);
        index[child.offset] = child;
      }
      return offset;
    }
    updateChildren(seq, block) {
      for (const child of this.children) {
        if (!child.value || child.seq !== seq)
          continue;
        child.value.block = block;
        child.value.updateChildren(seq, block);
      }
    }
    static create(block) {
      const node = new TreeNode(block, [], [], 0);
      node.changed = true;
      return node;
    }
  }

  class BlockEntry {
    constructor(seq, tree, entry) {
      this.seq = seq;
      this.tree = tree;
      this.index = null;
      this.entry = entry;
      this.key = entry.key;
      this.value = entry.value;
    }
    isTarget(key) {
      return b4a.equals(this.key, key);
    }
    isDeletion() {
      if (this.value !== null)
        return false;
      if (this.index === null) {
        this.index = inflate(this.entry);
      }
      return !this.index.hasKey(this.seq);
    }
    final(encoding) {
      return {
        seq: this.seq,
        key: encoding.key ? encoding.key.decode(this.key) : this.key,
        value: this.value && (encoding.value ? encoding.value.decode(this.value) : this.value)
      };
    }
    getTreeNode(offset) {
      if (this.index === null) {
        this.index = inflate(this.entry);
      }
      const entry = this.index.get(offset);
      return new TreeNode(this, entry.keys, entry.children, offset);
    }
  }

  class BatchEntry extends BlockEntry {
    constructor(seq, tree, key, value, index) {
      super(seq, tree, { key, value, index: null, inflated: null });
      this.pendingIndex = index;
    }
    isTarget(key) {
      return false;
    }
    getTreeNode(offset) {
      return this.pendingIndex[offset].value;
    }
  }

  class Hyperbee extends ReadyResource {
    constructor(core, opts = {}) {
      super();
      this.feed = core;
      this.core = core;
      this.keyEncoding = opts.keyEncoding ? codecs(opts.keyEncoding) : null;
      this.valueEncoding = opts.valueEncoding ? codecs(opts.valueEncoding) : null;
      this.extension = opts.extension !== false ? opts.extension || Extension.register(this) : null;
      this.metadata = opts.metadata || null;
      this.lock = opts.lock || mutexify();
      this.sep = opts.sep || SEP;
      this.readonly = !!opts.readonly;
      this.prefix = opts.prefix || null;
      this.alwaysDuplicate = opts.alwaysDuplicate !== false;
      this._unprefixedKeyEncoding = this.keyEncoding;
      this._sub = !!this.prefix;
      this._checkout = opts.checkout || 0;
      this._view = !!opts._view;
      this._onappendBound = this._view ? null : this._onappend.bind(this);
      this._ontruncateBound = this._view ? null : this._ontruncate.bind(this);
      this._watchers = this._onappendBound ? [] : null;
      this._entryWatchers = this._onappendBound ? [] : null;
      this._sessions = opts.sessions !== false;
      this._keyCache = null;
      this._nodeCache = null;
      this._batches = [];
      if (this._watchers) {
        this.core.on("append", this._onappendBound);
        this.core.on("truncate", this._ontruncateBound);
      }
      if (this.prefix && opts._sub) {
        this.keyEncoding = prefixEncoding(this.prefix, this.keyEncoding);
      }
      this.ready().catch(safetyCatch);
    }
    async _open() {
      if (this.core.opened === false)
        await this.core.ready();
      if (this._checkout === -1)
        this._checkout = Math.max(1, this.core.length);
      const baseCache = Rache.from(this.core.globalCache);
      this._keyCache = new Cache(baseCache);
      this._nodeCache = new Cache(Rache.from(baseCache));
    }
    get version() {
      return Math.max(1, this._checkout || this.core.length);
    }
    get id() {
      return this.core.id;
    }
    get key() {
      return this.core.key;
    }
    get discoveryKey() {
      return this.core.discoveryKey;
    }
    get writable() {
      return this.core.writable;
    }
    get readable() {
      return this.core.readable;
    }
    replicate(isInitiator, opts) {
      return this.core.replicate(isInitiator, opts);
    }
    update(opts) {
      return this.core.update(opts);
    }
    peek(range, opts) {
      return iteratorPeek(this.createRangeIterator(range, { ...opts, limit: 1 }));
    }
    createRangeIterator(range, opts = {}) {
      opts = opts ? { ...opts, ...range } : range;
      const extension = opts.extension === false && opts.limit !== 0 ? null : this.extension;
      const keyEncoding = opts.keyEncoding ? codecs(opts.keyEncoding) : this.keyEncoding;
      if (extension) {
        const { onseq, onwait } = opts;
        let version = 0;
        let next = 0;
        opts = encRange(keyEncoding, {
          ...opts,
          sub: this._sub,
          onseq(seq) {
            if (!version)
              version = seq + 1;
            if (next)
              next--;
            if (onseq)
              onseq(seq);
          },
          onwait(seq) {
            if (!next) {
              next = Extension.BATCH_SIZE;
              extension.iterator(ite.snapshot(version));
            }
            if (onwait)
              onwait(seq);
          }
        });
      } else {
        opts = encRange(keyEncoding, { ...opts, sub: this._sub });
      }
      const ite = new RangeIterator(new Batch(this, this._makeSnapshot(), null, false, opts), null, opts);
      return ite;
    }
    createReadStream(range, opts) {
      const signal = opts && opts.signal || null;
      return iteratorToStream(this.createRangeIterator(range, opts), signal);
    }
    createHistoryStream(opts) {
      const session = opts && opts.live ? this.core.session() : this._makeSnapshot();
      const signal = opts && opts.signal || null;
      return iteratorToStream(new HistoryIterator(new Batch(this, session, null, false, opts), opts), signal);
    }
    createDiffStream(right, range, opts) {
      if (typeof right === "number")
        right = this.checkout(Math.max(1, right), { reuseSession: true });
      opts = opts ? { ...opts, ...range } : range;
      const signal = opts && opts.signal || null;
      const keyEncoding = opts && opts.keyEncoding ? codecs(opts.keyEncoding) : this.keyEncoding;
      if (keyEncoding)
        opts = encRange(keyEncoding, { ...opts, sub: this._sub });
      let done;
      let closing;
      let ite;
      const left = this;
      const rs = new Readable({
        signal,
        eagerOpen: true,
        async open(cb) {
          try {
            if (right.opened === false)
              await right.ready();
            if (left.opened === false)
              await left.ready();
          } catch (err) {
            cb(err);
            return;
          }
          if (closing) {
            cb(null);
            return;
          }
          if (left.core.closing || right.core.closing) {
            cb(new Error("Bee closed"));
            return;
          }
          const snapshot = right.version > left.version ? right._makeSnapshot() : left._makeSnapshot();
          done = cb;
          ite = new DiffIterator(new Batch(left, snapshot, null, false, opts), new Batch(right, snapshot, null, false, opts), opts);
          ite.open().then(fin, fin);
        },
        read(cb) {
          done = cb;
          ite.next().then(push, fin);
        },
        predestroy() {
          if (!ite) {
            closing = Promise.resolve();
          } else {
            closing = ite.close();
            closing.catch(noop);
          }
        },
        destroy(cb) {
          done = cb;
          if (!closing)
            closing = ite.close();
          closing.then(fin, fin);
        }
      });
      return rs;
      function fin(err) {
        done(err);
      }
      function push(val) {
        rs.push(val);
        done(null);
      }
    }
    get(key, opts) {
      const b = new Batch(this, this._makeSnapshot(), null, true, opts);
      return b.get(key);
    }
    getBySeq(seq, opts) {
      const b = new Batch(this, this._makeSnapshot(), null, true, opts);
      return b.getBySeq(seq);
    }
    put(key, value, opts) {
      const b = new Batch(this, this.core, null, true, opts);
      return b.put(key, value, opts);
    }
    batch(opts) {
      return new Batch(this, this.core, mutexify(), true, opts);
    }
    del(key, opts) {
      const b = new Batch(this, this.core, null, true, opts);
      return b.del(key, opts);
    }
    watch(range, opts) {
      if (!this._watchers)
        throw new Error("Can only watch the main bee instance");
      return new Watcher(this, range, opts);
    }
    async getAndWatch(key, opts) {
      if (!this._watchers)
        throw new Error("Can only watch the main bee instance");
      const watcher = new EntryWatcher(this, key, opts);
      await watcher._debouncedUpdate();
      if (this.closing) {
        await watcher.close();
        throw new Error("Bee closed");
      }
      return watcher;
    }
    _onappend() {
      for (const watcher of this._watchers) {
        watcher._onappend();
      }
      for (const watcher of this._entryWatchers) {
        watcher._onappend();
      }
    }
    _ontruncate(length) {
      for (const watcher of this._watchers) {
        watcher._ontruncate();
      }
      for (const watcher of this._entryWatchers) {
        watcher._ontruncate();
      }
      this._nodeCache.gc(length);
      this._keyCache.gc(length);
    }
    _makeSnapshot() {
      if (this._sessions === false)
        return this.core;
      return this._checkout <= this.core.length || this._checkout <= 1 ? this.core.snapshot() : this.core.session({ snapshot: false });
    }
    checkout(version, opts = {}) {
      if (version === 0)
        version = 1;
      const snap = opts.reuseSession || this._sessions === false ? this.core : version <= this.core.length || version <= 1 ? this.core.snapshot() : this.core.session({ snapshot: false });
      return new Hyperbee(snap, {
        _view: true,
        _sub: false,
        prefix: this.prefix,
        sep: this.sep,
        lock: this.lock,
        checkout: version,
        keyEncoding: opts.keyEncoding || this.keyEncoding,
        valueEncoding: opts.valueEncoding || this.valueEncoding,
        extension: this.extension !== null ? this.extension : false
      });
    }
    snapshot(opts) {
      return this.checkout(this.core.opened === false || this._checkout <= 0 ? -1 : Math.max(1, this.version), opts);
    }
    sub(prefix, opts = {}) {
      let sep = opts.sep || this.sep;
      if (!b4a.isBuffer(sep))
        sep = b4a.from(sep);
      prefix = b4a.concat([this.prefix || EMPTY, b4a.from(prefix), sep]);
      const valueEncoding = codecs(opts.valueEncoding || this.valueEncoding);
      const keyEncoding = codecs(opts.keyEncoding || this._unprefixedKeyEncoding);
      return new Hyperbee(this.core, {
        _view: true,
        _sub: true,
        prefix,
        sep: this.sep,
        lock: this.lock,
        checkout: this._checkout,
        valueEncoding,
        keyEncoding,
        extension: this.extension !== null ? this.extension : false,
        metadata: this.metadata
      });
    }
    async getHeader(opts) {
      const blk = await this.core.get(0, opts);
      try {
        return blk && Header.decode(blk);
      } catch {
        throw DECODING_ERROR();
      }
    }
    async _close() {
      if (this._watchers) {
        this.core.off("append", this._onappendBound);
        this.core.off("truncate", this._ontruncateBound);
        while (this._watchers.length) {
          await this._watchers[this._watchers.length - 1].close();
        }
      }
      if (this._entryWatchers) {
        while (this._entryWatchers.length) {
          await this._entryWatchers[this._entryWatchers.length - 1].close();
        }
      }
      while (this._batches.length) {
        await this._batches[this._batches.length - 1].close();
      }
      return this.core.close();
    }
    static async isHyperbee(core, opts) {
      await core.ready();
      const blk0 = await core.get(0, opts);
      if (blk0 === null)
        throw BLOCK_NOT_AVAILABLE();
      try {
        return Header.decode(blk0).protocol === "hyperbee";
      } catch (err) {
        return false;
      }
    }
  }

  class Batch {
    constructor(tree, core, batchLock, cache, options = {}) {
      this.tree = tree;
      this.feed = core;
      this.core = core;
      this.index = tree._batches.push(this) - 1;
      this.blocks = cache ? new Map : null;
      this.autoFlush = !batchLock;
      this.rootSeq = 0;
      this.root = null;
      this.length = 0;
      this.checkout = options.checkout === undefined ? -1 : options.checkout;
      this.options = options;
      this.locked = null;
      this.batchLock = batchLock;
      this.onseq = this.options.onseq || noop;
      this.appending = null;
      this.isSnapshot = this.core !== this.tree.core;
      this.shouldUpdate = this.options.update !== false;
      this.updating = null;
      this.encoding = {
        key: options.keyEncoding ? codecs(options.keyEncoding) : tree.keyEncoding,
        value: options.valueEncoding ? codecs(options.valueEncoding) : tree.valueEncoding
      };
    }
    async ready() {
      if (this.core.opened === false)
        await this.core.ready();
      if (this.tree.opened === false)
        await this.tree.ready();
    }
    async lock() {
      if (this.tree.readonly)
        throw new Error("Hyperbee is marked as read-only");
      if (this.locked === null)
        this.locked = await this.tree.lock();
    }
    get version() {
      if (this.checkout !== -1)
        return Math.max(1, this.checkout);
      return Math.max(1, this.tree._checkout || this.core.length + this.length);
    }
    async getRoot(ensureHeader) {
      await this.ready();
      if (ensureHeader) {
        if (this.core.length === 0 && this.core.writable && !this.tree.readonly) {
          await this.core.append(Header.encode({
            protocol: "hyperbee",
            metadata: this.tree.metadata
          }));
        }
      }
      if (this.tree._checkout === 0 && this.checkout === -1 && this.shouldUpdate) {
        if (this.updating === null)
          this.updating = this.core.update();
        await this.updating;
      }
      if (this.version < 2)
        return null;
      return (await this.getBlock(this.version - 1)).getTreeNode(0);
    }
    async getKey(seq) {
      const k = this.core.fork === this.tree.core.fork ? this.tree._keyCache.get(seq) : null;
      if (k !== null)
        return k;
      const key = (await this.getBlock(seq)).key;
      if (this.core.fork === this.tree.core.fork)
        this.tree._keyCache.set(seq, key);
      return key;
    }
    async _getNode(seq) {
      const cached = this.tree._nodeCache !== null && this.core.fork === this.tree.core.fork ? this.tree._nodeCache.get(seq) : null;
      if (cached !== null)
        return cached;
      const entry = await this.core.get(seq, { ...this.options, valueEncoding: Node });
      if (entry === null)
        throw BLOCK_NOT_AVAILABLE();
      const wrap = copyEntry(entry);
      if (this.core.fork === this.tree.core.fork && this.tree._nodeCache !== null)
        this.tree._nodeCache.set(seq, wrap);
      return wrap;
    }
    async getBlock(seq) {
      if (this.rootSeq === 0)
        this.rootSeq = seq;
      let b = this.blocks && this.blocks.get(seq);
      if (b)
        return b;
      this.onseq(seq);
      const entry = await this._getNode(seq);
      b = new BlockEntry(seq, this, entry);
      if (this.blocks && this.blocks.size - this.length < 128)
        this.blocks.set(seq, b);
      return b;
    }
    _onwait(key) {
      this.options.onwait = null;
      this.tree.extension.get(this.rootSeq + 1, key);
    }
    _getEncoding(opts) {
      if (!opts)
        return this.encoding;
      return {
        key: opts.keyEncoding ? codecs(opts.keyEncoding) : this.encoding.key,
        value: opts.valueEncoding ? codecs(opts.valueEncoding) : this.encoding.value
      };
    }
    peek(range, opts) {
      return iteratorPeek(this.createRangeIterator(range, { ...opts, limit: 1 }));
    }
    createRangeIterator(range, opts = {}) {
      opts = opts ? { ...opts, ...range } : range;
      const encoding = this._getEncoding(opts);
      return new RangeIterator(this, encoding, encRange(encoding.key, { ...opts, sub: this.tree._sub }));
    }
    createReadStream(range, opts) {
      const signal = opts && opts.signal || null;
      return iteratorToStream(this.createRangeIterator(range, opts), signal);
    }
    async getBySeq(seq, opts) {
      const encoding = this._getEncoding(opts);
      try {
        const block = (await this.getBlock(seq)).final(encoding);
        return { key: block.key, value: block.value };
      } finally {
        await this._closeSnapshot();
      }
    }
    async get(key, opts) {
      const encoding = this._getEncoding(opts);
      try {
        return await this._get(key, encoding);
      } finally {
        await this._closeSnapshot();
      }
    }
    async _get(key, encoding) {
      key = enc(encoding.key, key);
      if (this.tree.extension !== null && this.options.extension !== false) {
        this.options.onwait = this._onwait.bind(this, key);
      }
      let node = await this.getRoot(false);
      if (!node)
        return null;
      while (true) {
        if (node.block.isTarget(key)) {
          return node.block.isDeletion() ? null : node.block.final(encoding);
        }
        let s = 0;
        let e = node.keys.length;
        let c;
        while (s < e) {
          const mid = s + e >> 1;
          c = b4a.compare(key, await node.getKey(mid));
          if (c === 0)
            return (await this.getBlock(node.keys[mid].seq)).final(encoding);
          if (c < 0)
            e = mid;
          else
            s = mid + 1;
        }
        if (!node.children.length)
          return null;
        const i = c < 0 ? e : s;
        node = await node.getChildNode(i);
      }
    }
    async put(key, value, opts) {
      const release = this.batchLock ? await this.batchLock() : null;
      const cas = opts && opts.cas || null;
      const encoding = this._getEncoding(opts);
      if (!this.locked)
        await this.lock();
      if (!release)
        return this._put(key, value, encoding, cas);
      try {
        return await this._put(key, value, encoding, cas);
      } finally {
        release();
      }
    }
    async _put(key, value, encoding, cas) {
      const newNode = {
        seq: 0,
        key,
        value
      };
      key = enc(encoding.key, key);
      value = enc(encoding.value, value);
      const stack = [];
      let root;
      let node = root = await this.getRoot(true);
      if (!node)
        node = root = TreeNode.create(null);
      const seq = newNode.seq = this.core.length + this.length;
      const target = new Key(seq, key);
      while (node.children.length) {
        stack.push(node);
        node.changed = true;
        let s = 0;
        let e = node.keys.length;
        let c;
        while (s < e) {
          const mid = s + e >> 1;
          c = b4a.compare(target.value, await node.getKey(mid));
          if (c === 0) {
            if (cas) {
              const prev = await node.getKeyNode(mid);
              if (!await cas(prev.final(encoding), newNode))
                return this._unlockMaybe();
            }
            if (!this.tree.alwaysDuplicate) {
              const prev = await node.getKeyNode(mid);
              if (sameValue(prev.value, value))
                return this._unlockMaybe();
            }
            node.setKey(mid, target);
            return this._append(root, seq, key, value);
          }
          if (c < 0)
            e = mid;
          else
            s = mid + 1;
        }
        const i = c < 0 ? e : s;
        node = await node.getChildNode(i);
      }
      let needsSplit = !await node.insertKey(target, value, null, newNode, encoding, cas);
      if (!node.changed)
        return this._unlockMaybe();
      while (needsSplit) {
        const parent = stack.pop();
        const { median, right } = await node.split();
        if (parent) {
          needsSplit = !await parent.insertKey(median, value, right, null, encoding, null);
          node = parent;
        } else {
          root = TreeNode.create(node.block);
          root.changed = true;
          root.keys.push(median);
          root.children.push(new Child(0, 0, node), new Child(0, 0, right));
          needsSplit = false;
        }
      }
      return this._append(root, seq, key, value);
    }
    async del(key, opts) {
      const release = this.batchLock ? await this.batchLock() : null;
      const cas = opts && opts.cas || null;
      const encoding = this._getEncoding(opts);
      if (!this.locked)
        await this.lock();
      if (!release)
        return this._del(key, encoding, cas);
      try {
        return await this._del(key, encoding, cas);
      } finally {
        release();
      }
    }
    async _del(key, encoding, cas) {
      const delNode = {
        seq: 0,
        key,
        value: null
      };
      key = enc(encoding.key, key);
      const stack = [];
      let node = await this.getRoot(true);
      if (!node)
        return this._unlockMaybe();
      const seq = delNode.seq = this.core.length + this.length;
      while (true) {
        stack.push(node);
        let s = 0;
        let e = node.keys.length;
        let c;
        while (s < e) {
          const mid = s + e >> 1;
          c = b4a.compare(key, await node.getKey(mid));
          if (c === 0) {
            if (cas) {
              const prev = await node.getKeyNode(mid);
              if (!await cas(prev.final(encoding), delNode))
                return this._unlockMaybe();
            }
            if (node.children.length)
              await setKeyToNearestLeaf(node, mid, stack);
            else
              node.removeKey(mid);
            for (const node2 of stack)
              node2.changed = true;
            return this._append(await rebalance(stack), seq, key, null);
          }
          if (c < 0)
            e = mid;
          else
            s = mid + 1;
        }
        if (!node.children.length)
          return this._unlockMaybe();
        const i = c < 0 ? e : s;
        node = await node.getChildNode(i);
      }
    }
    async _closeSnapshot() {
      if (this.isSnapshot) {
        await this.core.close();
        this._finalize();
      }
    }
    async close() {
      if (this.isSnapshot)
        return this._closeSnapshot();
      this.root = null;
      if (this.blocks)
        this.blocks.clear();
      this.length = 0;
      this._unlock();
    }
    destroy() {
      this.close().catch(noop);
    }
    toBlocks() {
      if (this.appending)
        return this.appending;
      const batch = new Array(this.length);
      for (let i = 0;i < this.length; i++) {
        const seq = this.core.length + i;
        const { pendingIndex, key, value } = this.blocks.get(seq);
        if (i < this.length - 1) {
          pendingIndex[0] = null;
          let j = 0;
          while (j < pendingIndex.length) {
            const idx = pendingIndex[j];
            if (idx !== null && idx.seq === seq) {
              idx.offset = j++;
              continue;
            }
            if (j === pendingIndex.length - 1)
              pendingIndex.pop();
            else
              pendingIndex[j] = pendingIndex.pop();
          }
        }
        batch[i] = Node.encode({
          key,
          value,
          index: deflate(pendingIndex)
        });
      }
      this.appending = batch;
      return batch;
    }
    flush() {
      if (!this.length)
        return this.close();
      const batch = this.toBlocks();
      this.root = null;
      this.blocks.clear();
      this.length = 0;
      return this._appendBatch(batch);
    }
    _unlockMaybe() {
      if (this.autoFlush)
        this._unlock();
    }
    _unlock() {
      const locked = this.locked;
      this.locked = null;
      if (locked !== null)
        locked();
      this._finalize();
    }
    _finalize() {
      if (this.index >= this.tree._batches.length || this.tree._batches[this.index] !== this)
        return;
      const top = this.tree._batches.pop();
      if (top === this)
        return;
      top.index = this.index;
      this.tree._batches[top.index] = top;
    }
    _append(root, seq, key, value) {
      const index = [];
      root.indexChanges(index, seq);
      index[0] = new Child(seq, 0, root);
      if (!this.autoFlush) {
        const block = new BatchEntry(seq, this, key, value, index);
        root.block = block;
        this.root = root;
        this.length++;
        this.blocks.set(seq, block);
        root.updateChildren(seq, block);
        return;
      }
      return this._appendBatch(Node.encode({
        key,
        value,
        index: deflate(index)
      }));
    }
    async _appendBatch(raw) {
      try {
        await this.core.append(raw);
      } finally {
        this._unlock();
      }
    }
  }

  class EntryWatcher extends ReadyResource {
    constructor(bee, key, opts = {}) {
      super();
      this.keyEncoding = opts.keyEncoding || bee.keyEncoding;
      this.valueEncoding = opts.valueEncoding || bee.valueEncoding;
      this.index = bee._entryWatchers.push(this) - 1;
      this.bee = bee;
      this.key = key;
      this.node = null;
      this._forceUpdate = false;
      this._debouncedUpdate = debounce(this._processUpdate.bind(this));
    }
    _close() {
      const top = this.bee._entryWatchers.pop();
      if (top !== this) {
        top.index = this.index;
        this.bee._entryWatchers[top.index] = top;
      }
    }
    _onappend() {
      this._debouncedUpdate();
    }
    _ontruncate() {
      this._forceUpdate = true;
      this._debouncedUpdate();
    }
    async _processUpdate() {
      const force = this._forceUpdate;
      this._forceUpdate = false;
      let newNode;
      try {
        newNode = await this.bee.get(this.key, {
          keyEncoding: this.keyEncoding,
          valueEncoding: this.valueEncoding
        });
      } catch (e) {
        if (e.code === "SNAPSHOT_NOT_AVAILABLE") {
          return;
        } else if (this.bee.closing) {
          this.close().catch(safetyCatch);
          return;
        }
        this.emit("error", e);
        return;
      }
      if (force || newNode?.seq !== this.node?.seq) {
        this.node = newNode;
        this.emit("update");
      }
    }
  }

  class Watcher extends ReadyResource {
    constructor(bee, range, opts = {}) {
      super();
      this.keyEncoding = opts.keyEncoding || bee.keyEncoding;
      this.valueEncoding = opts.valueEncoding || bee.valueEncoding;
      this.index = bee._watchers.push(this) - 1;
      this.bee = bee;
      this.core = bee.core;
      this.latestDiff = 0;
      this.range = range;
      this.map = opts.map || defaultWatchMap;
      this.current = null;
      this.previous = null;
      this.currentMapped = null;
      this.previousMapped = null;
      this.stream = null;
      this._lock = mutexify();
      this._flowing = false;
      this._resolveOnChange = null;
      this._differ = opts.differ || defaultDiffer;
      this._eager = !!opts.eager;
      this._onchange = opts.onchange || null;
      this.on("newListener", autoFlowOnUpdate);
      this.ready().catch(safetyCatch);
    }
    async _consume() {
      if (this._flowing)
        return;
      try {
        for await (const _ of this) {}
      } catch {}
    }
    async _open() {
      await this.bee.ready();
      const opts = {
        keyEncoding: this.keyEncoding,
        valueEncoding: this.valueEncoding
      };
      this.current = this._eager ? this.bee.checkout(1, opts) : this.bee.snapshot(opts);
      await this.current.ready();
      if (this._onchange) {
        if (this._eager)
          await this._onchange();
        this._consume();
      }
    }
    [Symbol.asyncIterator]() {
      this._flowing = true;
      return this;
    }
    _ontruncate() {
      this._onappend();
    }
    _onappend() {
      const resolve = this._resolveOnChange;
      this._resolveOnChange = null;
      if (resolve)
        resolve();
    }
    async _waitForChanges() {
      if (this.current.version < this.bee.version || this.closing)
        return;
      await new Promise((resolve) => {
        this._resolveOnChange = resolve;
      });
    }
    async next() {
      try {
        return await this._next();
      } catch (err) {
        if (this.closing)
          return { value: undefined, done: true };
        await this.close();
        throw err;
      }
    }
    async _next() {
      const release = await this._lock();
      try {
        if (this.closing)
          return { value: undefined, done: true };
        if (!this.opened)
          await this.ready();
        while (true) {
          await this._waitForChanges();
          if (this.closing)
            return { value: undefined, done: true };
          await this._closePrevious();
          this.previous = this.current.snapshot();
          await this._closeCurrent();
          this.current = this.bee.snapshot({
            keyEncoding: this.keyEncoding,
            valueEncoding: this.valueEncoding
          });
          await this.current.ready();
          await this.previous.ready();
          if (this.current.core.fork !== this.previous.core.fork) {
            return await this._yield();
          }
          this.stream = this._differ(this.current, this.previous, this.range);
          try {
            for await (const data of this.stream) {
              return await this._yield();
            }
          } finally {
            this.stream = null;
          }
        }
      } finally {
        release();
      }
    }
    async _yield() {
      this.currentMapped = this.map(this.current);
      this.previousMapped = this.map(this.previous);
      if (this._onchange) {
        try {
          await this._onchange();
        } catch (err) {
          safetyCatch(err);
        }
      }
      this.emit("update");
      return { done: false, value: [this.currentMapped, this.previousMapped] };
    }
    async return() {
      await this.close();
      return { done: true };
    }
    async _close() {
      const top = this.bee._watchers.pop();
      if (top !== this) {
        top.index = this.index;
        this.bee._watchers[top.index] = top;
      }
      if (this.stream && !this.stream.destroying) {
        this.stream.destroy();
      }
      this._onappend();
      await this._closeCurrent().catch(safetyCatch);
      await this._closePrevious().catch(safetyCatch);
      const release = await this._lock();
      release();
    }
    destroy() {
      return this.close();
    }
    async _closeCurrent() {
      if (this.currentMapped)
        await this.currentMapped.close();
      if (this.current)
        await this.current.close();
      this.current = this.currentMapped = null;
    }
    async _closePrevious() {
      if (this.previousMapped)
        await this.previousMapped.close();
      if (this.previous)
        await this.previous.close();
      this.previous = this.previousMapped = null;
    }
  }
  function autoFlowOnUpdate(name) {
    if (name === "update")
      this._consume();
  }
  function defaultWatchMap(snapshot) {
    return snapshot;
  }
  async function leafSize(node, goLeft) {
    while (node.children.length)
      node = await node.getChildNode(goLeft ? 0 : node.children.length - 1);
    return node.keys.length;
  }
  async function setKeyToNearestLeaf(node, index, stack) {
    let [left, right] = await Promise.all([node.getChildNode(index), node.getChildNode(index + 1)]);
    const [ls, rs] = await Promise.all([leafSize(left, false), leafSize(right, true)]);
    if (ls < rs) {
      stack.push(right);
      while (right.children.length)
        stack.push(right = right.children[0].value);
      node.keys[index] = right.keys.shift();
    } else {
      stack.push(left);
      while (left.children.length)
        stack.push(left = left.children[left.children.length - 1].value);
      node.keys[index] = left.keys.pop();
    }
  }
  async function rebalance(stack) {
    const root = stack[0];
    while (stack.length > 1) {
      const node = stack.pop();
      const parent = stack[stack.length - 1];
      if (node.keys.length >= MIN_KEYS)
        return root;
      let { left, index, right } = await node.siblings(parent);
      if (left && left.keys.length > MIN_KEYS) {
        left.changed = true;
        node.keys.unshift(parent.keys[index - 1]);
        if (left.children.length)
          node.children.unshift(left.children.pop());
        parent.keys[index - 1] = left.keys.pop();
        return root;
      }
      if (right && right.keys.length > MIN_KEYS) {
        right.changed = true;
        node.keys.push(parent.keys[index]);
        if (right.children.length)
          node.children.push(right.children.shift());
        parent.keys[index] = right.keys.shift();
        return root;
      }
      if (left) {
        index--;
        right = node;
      } else {
        left = node;
      }
      left.merge(right, parent.keys[index]);
      parent.removeKey(index);
    }
    if (!root.keys.length && root.children.length)
      return root.getChildNode(0);
    return root;
  }
  function iteratorToStream(ite, signal) {
    let done;
    let closing;
    const rs = new Readable({
      signal,
      open(cb) {
        done = cb;
        ite.open().then(fin, fin);
      },
      read(cb) {
        done = cb;
        ite.next().then(push, fin);
      },
      predestroy() {
        closing = ite.close();
        closing.catch(noop);
      },
      destroy(cb) {
        done = cb;
        if (!closing)
          closing = ite.close();
        closing.then(fin, fin);
      }
    });
    return rs;
    function fin(err) {
      done(err);
    }
    function push(val) {
      rs.push(val);
      done(null);
    }
  }
  async function iteratorPeek(ite) {
    try {
      await ite.open();
      return await ite.next();
    } finally {
      await ite.close();
    }
  }
  function encRange(e, opts) {
    if (!e)
      return opts;
    if (e.encodeRange) {
      const r = e.encodeRange({ gt: opts.gt, gte: opts.gte, lt: opts.lt, lte: opts.lte });
      opts.gt = r.gt;
      opts.gte = r.gte;
      opts.lt = r.lt;
      opts.lte = r.lte;
      return opts;
    }
    if (opts.gt !== undefined)
      opts.gt = enc(e, opts.gt);
    if (opts.gte !== undefined)
      opts.gte = enc(e, opts.gte);
    if (opts.lt !== undefined)
      opts.lt = enc(e, opts.lt);
    if (opts.lte !== undefined)
      opts.lte = enc(e, opts.lte);
    if (opts.sub && !opts.gt && !opts.gte)
      opts.gt = enc(e, SEP);
    if (opts.sub && !opts.lt && !opts.lte)
      opts.lt = bump(enc(e, EMPTY));
    return opts;
  }
  function bump(key) {
    key[key.length - 1]++;
    return key;
  }
  function enc(e, v) {
    if (v === undefined || v === null)
      return null;
    if (e !== null)
      return e.encode(v);
    if (typeof v === "string")
      return b4a.from(v);
    return v;
  }
  function prefixEncoding(prefix, keyEncoding) {
    return {
      encode(key) {
        return b4a.concat([prefix, b4a.isBuffer(key) ? key : enc(keyEncoding, key)]);
      },
      decode(key) {
        const sliced = key.slice(prefix.length, key.length);
        return keyEncoding ? keyEncoding.decode(sliced) : sliced;
      }
    };
  }
  function copyEntry(entry) {
    let key = entry.key;
    let value = entry.value;
    let index = entry.index;
    const size = key.byteLength + (value === null ? 0 : value.byteLength) + (index === null ? 0 : index.byteLength);
    if (2 * size < key.buffer.byteLength) {
      const [newKey, newValue, newIndex] = unslabAll([entry.key, entry.value, entry.index]);
      key = newKey;
      value = newValue;
      index = newIndex;
    }
    return {
      key,
      value,
      index,
      inflated: null
    };
  }
  function defaultDiffer(currentSnap, previousSnap, opts) {
    return currentSnap.createDiffStream(previousSnap, opts);
  }
  function getBackingCore(core) {
    if (core.core)
      return core;
    if (core.getBackingCore)
      return core.getBackingCore().session;
    return null;
  }
  function sameValue(a, b) {
    return a === b || a !== null && b !== null && b4a.equals(a, b);
  }
  function noop() {}
  module.exports = Hyperbee;
});

// node_modules/sub-encoder/index.js
var require_sub_encoder = __commonJS((exports, module) => {
  var codecs = require_codecs();
  var b = require_b4a();
  var SEP = b.alloc(1);
  var SEP_BUMPED = b.from([1]);
  var EMPTY = b.alloc(0);
  module.exports = class SubEncoder {
    constructor(prefix, encoding, parent = null) {
      this.userEncoding = codecs(encoding);
      this.prefix = prefix != null ? createPrefix(prefix, parent) : null;
      this.lt = this.prefix && b.concat([this.prefix.subarray(0, this.prefix.byteLength - 1), SEP_BUMPED]);
    }
    _encodeRangeUser(r) {
      if (this.userEncoding.encodeRange)
        return this.userEncoding.encodeRange(r);
      const res = {};
      if (r.gt != null)
        res.gt = this.userEncoding.encode(r.gt);
      if (r.gte != null)
        res.gte = this.userEncoding.encode(r.gte);
      if (r.lte != null)
        res.lte = this.userEncoding.encode(r.lte);
      if (r.lt != null)
        res.lt = this.userEncoding.encode(r.lt);
      return res;
    }
    _addPrefix(key) {
      return this.prefix ? b.concat([this.prefix, key]) : key;
    }
    encode(key) {
      return this._addPrefix(this.userEncoding.encode(key));
    }
    encodeRange(range) {
      const r = this._encodeRangeUser(range);
      if (r.gt)
        r.gt = this._addPrefix(r.gt);
      else if (r.gte)
        r.gte = this._addPrefix(r.gte);
      else if (this.prefix)
        r.gte = this.prefix;
      if (r.lt)
        r.lt = this._addPrefix(r.lt);
      else if (r.lte)
        r.lte = this._addPrefix(r.lte);
      else if (this.prefix)
        r.lt = this.lt;
      return r;
    }
    decode(key) {
      return this.userEncoding.decode(this.prefix ? key.subarray(this.prefix.byteLength) : key);
    }
    sub(prefix, encoding) {
      return new SubEncoder(prefix || EMPTY, compat(encoding), this.prefix);
    }
  };
  function createPrefix(prefix, parent) {
    prefix = typeof prefix === "string" ? b.from(prefix) : prefix;
    if (prefix && parent)
      return b.concat([parent, prefix, SEP]);
    if (prefix)
      return b.concat([prefix, SEP]);
    if (parent)
      return b.concat([parent, SEP]);
    return SEP;
  }
  function compat(enc) {
    if (enc && enc.keyEncoding)
      return enc.keyEncoding;
    return enc;
  }
});

// node_modules/autobase/lib/caps.js
var require_caps2 = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var OPLOG_VERSION = 2;
  var DEFAULT_AUTOBASE_VERSION = 1;
  var MAX_AUTOBASE_VERSION = 2;
  var BOOT_RECORD_VERSION = 3;
  var [
    NS_SIGNER_NAMESPACE,
    NS_VIEW_BLOCK_KEY,
    NS_HASH_KEY,
    NS_ENCRYPTION
  ] = crypto.namespace("autobase", 4);
  module.exports = {
    OPLOG_VERSION,
    DEFAULT_AUTOBASE_VERSION,
    MAX_AUTOBASE_VERSION,
    BOOT_RECORD_VERSION,
    NS_SIGNER_NAMESPACE,
    NS_VIEW_BLOCK_KEY,
    NS_HASH_KEY,
    NS_ENCRYPTION
  };
});

// node_modules/autobase/lib/system.js
var require_system = __commonJS((exports, module) => {
  var Hyperbee = require_hyperbee();
  var SubEncoder = require_sub_encoder();
  var ReadyResource = require_ready_resource();
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var crypto = require_hypercore_crypto();
  var { Info, Member } = require_messages3();
  var { DEFAULT_AUTOBASE_VERSION } = require_caps2();
  var subs = new SubEncoder;
  var DIGEST = subs.sub(b4a.from([0]));
  var MEMBERS = subs.sub(b4a.from([1]));
  var INFO_KEY = DIGEST.encode("info");
  var [GENESIS_ENTROPY, NS_ENTROPY] = crypto.namespace("autobase/entropy", 2);
  module.exports = class SystemView extends ReadyResource {
    constructor(core, { checkout = 0, empty = false } = {}) {
      super();
      this.core = core;
      this.db = new Hyperbee(core, { keyEncoding: "binary", extension: false, checkout, sessions: typeof core.session === "function" });
      this.version = DEFAULT_AUTOBASE_VERSION;
      this.members = 0;
      this.pendingIndexers = [];
      this.indexers = [];
      this.heads = [];
      this.views = [];
      this.encryptionLength = 0;
      this.entropy = null;
      this.indexerUpdate = false;
      this._empty = empty;
      this._fork = 0;
      this._length = 0;
      this._changes = [];
      this._indexerMap = new Map;
      this._clockUpdates = new Map;
    }
    static GENESIS_ENTROPY = GENESIS_ENTROPY;
    static async getIndexedInfo(core, length) {
      const sys = new this(core.session());
      try {
        return await sys.getIndexedInfo(length);
      } finally {
        await sys.close();
      }
    }
    static async* flushes(core, { reverse, lt = core.length, gte = 0, wait = true } = {}) {
      if (lt <= 0)
        return;
      await core.get(lt - 1);
      const sys = new SystemView(core);
      try {
        for await (const data of sys.db.createHistoryStream({ lt, gte, wait, reverse: true })) {
          if (!b4a.equals(data.key, INFO_KEY))
            continue;
          const info = c.decode(Info, data.value);
          yield { length: data.seq + 1, info };
        }
      } finally {
        await sys.close();
      }
    }
    get bootstrapping() {
      return this.members === 0;
    }
    async checkout(length) {
      const checkout = new SystemView(this.core.session(), {
        checkout: length,
        empty: length === 0
      });
      await checkout.ready();
      return checkout;
    }
    async _open() {
      const info = this._empty ? null : await this.db.get("info", { valueEncoding: Info, keyEncoding: DIGEST, update: false, wait: false });
      await this._reset(info);
    }
    async _close() {
      await this.db.close();
    }
    async getIndexedInfo(length = this.core.signedLength) {
      if (this.opened === false)
        await this.ready();
      if (length === this.core.length) {
        return {
          version: this.version,
          members: this.members,
          pendingIndexers: this.pendingIndexers,
          indexers: this.indexers,
          heads: this.heads,
          views: this.views,
          encryptionLength: this.encryptionLength,
          entropy: this.entropy
        };
      }
      const node = length === 0 ? null : await this.db.getBySeq(length - 1);
      if (node === null) {
        return {
          version: DEFAULT_AUTOBASE_VERSION,
          members: 0,
          pendingIndexers: [],
          indexers: [],
          heads: [],
          views: [],
          encryptionLength: 0,
          entropy: null
        };
      }
      return c.decode(Info, node.value);
    }
    static sameIndexers(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0;i < a.length; i++) {
        if (!b4a.equals(a[i].key, b[i].core.key))
          return false;
      }
      return true;
    }
    sameIndexers(indexers) {
      return SystemView.sameIndexers(this.indexers, indexers);
    }
    async history(since) {
      const checkout = this.db.checkout(since);
      const seen = new Map;
      const nodes = [];
      const updates = [];
      const checkoutNode = since === 0 ? null : await this.db.getBySeq(since - 1);
      let prevInfo = checkoutNode === null ? null : c.decode(Info, checkoutNode.value);
      let updateBatch = 0;
      for await (const data of this.db.createHistoryStream({ gte: since })) {
        if (b4a.equals(data.key, INFO_KEY)) {
          const info = c.decode(Info, data.value);
          updates.push({
            batch: updateBatch,
            indexers: prevInfo === null || !sameIndexers(info, prevInfo),
            systemLength: data.seq + 1
          });
          prevInfo = info;
          updateBatch = 0;
          continue;
        }
        const key = data.key.subarray(2);
        const hex = b4a.toString(key, "hex");
        const len = c.decode(Member, data.value).length;
        if (!seen.has(hex)) {
          const node = await checkout.get(data.key);
          if (node === null) {
            seen.set(hex, 0);
          } else {
            const { length } = c.decode(Member, node.value);
            seen.set(hex, length);
          }
        }
        const prev = seen.get(hex);
        const batch = len - prev;
        seen.set(hex, len);
        if (batch === 0)
          continue;
        updateBatch += batch;
        if (nodes.length > 0) {
          const top = nodes[nodes.length - 1];
          if (b4a.equals(top.key, key)) {
            top.length = len;
            top.batch += batch;
            continue;
          }
        }
        nodes.push({
          key,
          length: len,
          batch
        });
      }
      await checkout.close();
      return { updates, nodes };
    }
    async update() {
      if (this.opened === false)
        await this.ready();
      if (this._fork === this.core.fork && this._length === this.core.length)
        return false;
      await this._reset(this._empty ? null : await this.db.get("info", { valueEncoding: Info, keyEncoding: DIGEST }));
      return true;
    }
    async _reset(info) {
      this.version = info === null ? DEFAULT_AUTOBASE_VERSION : info.value.version;
      this.members = info === null ? 0 : info.value.members;
      this.pendingIndexers = info === null ? [] : info.value.pendingIndexers;
      this.indexers = info === null ? [] : info.value.indexers;
      this.heads = info === null ? [] : info.value.heads;
      this.views = info === null ? [] : info.value.views;
      this.encryptionLength = info === null ? 0 : info.value.encryptionLength;
      this.entropy = info === null ? null : info.value.entropy;
      this.indexerUpdate = false;
      this._indexerMap.clear();
      this._clockUpdates.clear();
      this._length = this.core.length;
      this._fork = this.core.fork;
      this._changes = [];
      for (const idx of this.indexers) {
        this._indexerMap.set(b4a.toString(idx.key, "hex"), idx);
      }
    }
    flushLength() {
      const header = this.core.length ? 0 : 1;
      let updates = this._changes.length + this._clockUpdates.size;
      for (const { key } of this._changes) {
        const hex = b4a.toString(key, "hex");
        if (this._clockUpdates.has(hex))
          updates--;
      }
      return header + this.core.length + updates + 1;
    }
    async flush(views) {
      const batch = this.db.batch({ update: false });
      for (let i = 0;i < this._changes.length; i++) {
        const c2 = this._changes[i];
        if (this._clockUpdates.has(b4a.toString(c2.key, "hex")))
          continue;
        await batch.put(c2.key, c2.value, { valueEncoding: Member, keyEncoding: MEMBERS });
      }
      for (const [hex, length] of this._clockUpdates) {
        const isIndexer = this._indexerMap.get(hex) !== undefined;
        const key = b4a.from(hex, "hex");
        const info2 = await this._get(key, 0);
        const value = { isIndexer, isRemoved: info2 ? info2.isRemoved : true, length };
        await batch.put(key, value, { valueEncoding: Member, keyEncoding: MEMBERS });
      }
      if (this.indexerUpdate) {
        this._refreshEntropy(this.core.length + batch.length + 1);
      }
      this._clockUpdates.clear();
      let maxIndex = -1;
      for (const view of views) {
        if (view.mappedIndex > maxIndex)
          maxIndex = view.mappedIndex;
      }
      while (this.views.length > maxIndex + 1)
        this.views.pop();
      for (const view of views) {
        const length = view.core ? view.core.length : view.length;
        if (!length)
          continue;
        const v = { key: view.key, length };
        if (view.mappedIndex !== -1) {
          this.views[view.mappedIndex] = v;
        } else {
          view.mappedIndex = this.views.push(v) - 1;
        }
      }
      const info = {
        version: this.version,
        members: this.members,
        pendingIndexers: this.pendingIndexers,
        indexers: this.indexers,
        heads: this.heads,
        views: this.views,
        encryptionLength: this.encryptionLength,
        entropy: this.entropy
      };
      await batch.put("info", info, { valueEncoding: Info, keyEncoding: DIGEST });
      await batch.flush();
      this._length = this.core.length;
      this._changes = [];
      if (this.indexerUpdate)
        this.indexerUpdate = false;
    }
    getEntropy(indexers, length) {
      return generateEntropy(indexers, length, this.entropy);
    }
    _refreshEntropy(length) {
      if (this.version < 2)
        return;
      this.entropy = this.getEntropy(this.indexers, length);
    }
    checkpoint() {
      return {
        version: this.version,
        members: this.members,
        pendingIndexers: this.pendingIndexers.slice(0),
        indexers: cloneNodes(this.indexers),
        heads: cloneNodes(this.heads),
        views: cloneNodes(this.views),
        indexerUpdate: this.indexerUpdate,
        encryptionLength: this.encryptionLength,
        entropy: this.entropy ? b4a.from(this.entropy) : null,
        changes: this._changes.slice(0),
        clockUpdates: new Map([...this._clockUpdates])
      };
    }
    applyCheckpoint(checkpoint) {
      this.version = checkpoint.version;
      this.members = checkpoint.members;
      this.pendingIndexers = checkpoint.pendingIndexers;
      this.indexers = checkpoint.indexers;
      this.heads = checkpoint.heads;
      this.views = checkpoint.views;
      this.indexerUpdate = checkpoint.indexerUpdate;
      this.encryptionLength = checkpoint.encryptionLength;
      this.entropy = checkpoint.entropy;
      this._changes = checkpoint.changes;
      this._clockUpdates = checkpoint.clockUpdates;
      this._indexerMap = new Map;
      for (const idx of this.indexers) {
        this._indexerMap.set(b4a.toString(idx.key, "hex"), idx);
      }
    }
    addHead(node) {
      const h = { key: node.writer.core.key, length: node.length };
      for (let i = 0;i < this.heads.length; i++) {
        const head = this.heads[i];
        if (!hasDependency(node, head)) {
          if (!b4a.equals(node.writer.core.key, head.key))
            continue;
          if (head.length > h.length)
            return false;
        }
        const popped = this.heads.pop();
        if (popped !== head)
          this.heads[i--] = popped;
      }
      this.heads.push(h);
      const hex = b4a.toString(h.key, "hex");
      this._clockUpdates.set(hex, h.length);
      if (this.pendingIndexers.length > 0) {
        for (let i = 0;i < this.pendingIndexers.length; i++) {
          if (!b4a.equals(this.pendingIndexers[i], h.key))
            continue;
          this._updateIndexer(h.key, h.length, true, i);
          return true;
        }
      }
      const idx = this._indexerMap.get(hex);
      if (idx !== undefined) {
        idx.length = h.length;
      }
      return false;
    }
    _updateIndexer(key, length, isIndexer, i) {
      const hex = b4a.toString(key, "hex");
      if (!isIndexer) {
        const existing = this._indexerMap.get(hex);
        if (existing) {
          this.indexerUpdate = true;
          this.indexers.splice(this.indexers.indexOf(existing), 1);
          this._indexerMap.delete(hex);
        }
        return;
      }
      for (;i < this.pendingIndexers.length; i++) {
        if (b4a.equals(this.pendingIndexers[i], key)) {
          break;
        }
      }
      if (length === 0) {
        if (i >= this.pendingIndexers.length)
          this.pendingIndexers.push(key);
        return;
      }
      if (i < this.pendingIndexers.length) {
        const top = this.pendingIndexers.pop();
        if (i < this.pendingIndexers.length)
          this.pendingIndexers[i] = top;
      }
      const idx = this._indexerMap.get(hex);
      if (idx === undefined) {
        const newIdx = { key, length };
        this._indexerMap.set(hex, newIdx);
        this.indexers.push(newIdx);
        if (!this.bootstrapping)
          this.indexerUpdate = true;
      } else {
        idx.length = length;
      }
    }
    _seenLength(key) {
      return this._clockUpdates.get(b4a.toString(key, "hex")) || 0;
    }
    async ack(key) {
      const value = await this._get(key, 0);
      const length = this._seenLength(key);
      if (value && value.length === length)
        return;
      const isIndexer = value ? value.isIndexer : false;
      const isRemoved = value ? value.isRemoved : true;
      this._changes.push({ key, value: { isIndexer, isRemoved, length } });
    }
    async add(key, { isIndexer = false, length = this._seenLength(key) } = {}) {
      let value = null;
      let found = false;
      let changed = true;
      for (let i = this._changes.length - 1;i >= 0; i--) {
        const c2 = this._changes[i];
        if (b4a.equals(key, c2.key)) {
          value = c2.value;
          found = true;
          break;
        }
      }
      if (!found) {
        const node = await this.db.get(key, { valueEncoding: Member, keyEncoding: MEMBERS });
        if (node) {
          value = node.value;
          found = true;
        }
      }
      let wasTracked = false;
      let wasIndexer = false;
      if (found) {
        if (!value.isRemoved)
          wasTracked = true;
        if (value.isIndexer)
          wasIndexer = true;
        if (length < value.length)
          length = value.length;
        if (value.length === length && value.isIndexer === isIndexer && value.isRemoved === false)
          changed = false;
      }
      if (changed) {
        this._changes.push({ key, value: { isIndexer, isRemoved: false, length } });
      }
      if (!wasTracked)
        this.members++;
      if (wasIndexer || isIndexer)
        this._updateIndexer(key, length, isIndexer, 0);
    }
    async remove(key) {
      let isIndexer = false;
      for (const idx of this.indexers) {
        isIndexer = b4a.equals(idx.key, key);
        if (isIndexer)
          break;
      }
      if (isIndexer)
        this._updateIndexer(key, null, false, 0);
      let value = null;
      let found = false;
      for (let i = this._changes.length - 1;i >= 0; i--) {
        const c2 = this._changes[i];
        if (b4a.equals(key, c2.key)) {
          value = c2.value;
          found = true;
          break;
        }
      }
      if (!found) {
        const node = await this.db.get(key, { valueEncoding: Member, keyEncoding: MEMBERS });
        if (node) {
          value = node.value;
          found = true;
        }
      }
      const changed = !found || !value.isRemoved;
      const wasTracked = found && !value.isRemoved;
      const length = found ? value.length : 0;
      if (changed) {
        this._changes.push({ key, value: { isIndexer: false, isRemoved: true, length } });
      }
      if (wasTracked)
        this.members--;
      return isIndexer;
    }
    async linkable(key, length) {
      const len = this._seenLength(key);
      if (len > 0)
        return length > len;
      const info = await this._get(key, 0);
      const prevLength = info ? info.length : 0;
      return length > prevLength;
    }
    async has(key, opts) {
      return await this.get(key, opts) !== null;
    }
    async _get(key, timeout) {
      let value = null;
      let found = false;
      for (let i = this._changes.length - 1;i >= 0; i--) {
        const c2 = this._changes[i];
        if (b4a.equals(key, c2.key)) {
          value = c2.value;
          found = true;
          break;
        }
      }
      if (!found) {
        const node = await this.db.get(key, { timeout, valueEncoding: Member, keyEncoding: MEMBERS });
        if (node) {
          value = node.value;
          found = true;
        }
      }
      return found ? value : null;
    }
    async get(key, opts = {}) {
      if (this._empty)
        return null;
      let value = await this._get(key, opts.timeout || 0);
      if (opts.unflushed) {
        const hex = b4a.toString(key, "hex");
        for (let i = this._changes.length - 1;i >= 0; i--) {
          const c2 = this._changes[i];
          if (b4a.equals(c2.key, key))
            value = c2.value;
        }
        if (this._clockUpdates.has(hex))
          value.length = this._clockUpdates.get(hex);
      }
      return opts.onlyActive !== false || !value.isRemoved ? value : null;
    }
    async hasLocal(key) {
      if (this._empty)
        return false;
      try {
        const node = await this.db.get(key, { valueEncoding: Member, keyEncoding: MEMBERS, update: false, wait: false });
        return node !== null;
      } catch {
        return false;
      }
    }
    async getLocalLength(key) {
      if (this._empty)
        return 0;
      try {
        const node = await this.db.get(key, { valueEncoding: Member, keyEncoding: MEMBERS, update: false, wait: false });
        return node === null ? 0 : node.value.length;
      } catch {
        return 0;
      }
    }
    list() {
      return this.db.createReadStream({
        valueEncoding: Member,
        keyEncoding: MEMBERS
      });
    }
    async isIndexed(key, length) {
      const co = this.db.checkout(this.core.indexedLength);
      try {
        const node = await co.get(key, { valueEncoding: Member, keyEncoding: MEMBERS });
        return node !== null && node.value.length >= length;
      } finally {
        await co.close();
      }
    }
    async fork(indexers, manifests, encryptionLength, views) {
      this.indexers = [];
      this.pendingIndexers = [];
      this.views = views;
      if (this.version < 2)
        this.version = 2;
      for (const { key } of indexers) {
        const { length } = await this.get(key);
        this.indexers.push({ key, length });
      }
      this._refreshEntropy(this.core.length);
      const blocks = [];
      let truncate = this.core.length - 1;
      for await (const data of this.db.createHistoryStream({ lt: truncate, reverse: true })) {
        if (b4a.equals(data.key, INFO_KEY)) {
          truncate = data.seq + 1;
          break;
        }
        blocks.push(data);
      }
      await this.core.truncate(truncate, this.core.fork);
      const batch = this.db.batch({ update: false });
      await batch.ready();
      for (const { key, value } of blocks) {
        await batch.put(key, value);
      }
      const info = {
        version: this.version,
        members: this.members,
        pendingIndexers: this.pendingIndexers,
        indexers: this.indexers,
        heads: this.heads,
        views: this.views,
        encryptionLength,
        entropy: this.entropy
      };
      await batch.put("info", info, { valueEncoding: Info, keyEncoding: DIGEST });
      await batch.flush();
      await this._reset(await this.db.get("info", { valueEncoding: Info, keyEncoding: DIGEST }));
      return truncate;
    }
  };
  function hasDependency(node, dep) {
    for (const h of node.actualHeads) {
      if (sameNode(h, dep))
        return true;
    }
    return false;
  }
  function sameNode(a, b) {
    return b4a.equals(a.key, b.key) && a.length === b.length;
  }
  function sameIndexers(a, b) {
    if (a.views.length > 0 && b.views.length > 0)
      return b4a.equals(a.views[0].key, b.views[0].key);
    if (a.indexers.length !== b.indexers.length)
      return false;
    for (let i = 0;i < a.indexers.length; i++) {
      if (!b4a.equals(a.indexers[i].key, b.indexers[i].key))
        return false;
    }
    return true;
  }
  function cloneNodes(arr) {
    const c2 = [];
    for (let i = 0;i < arr.length; i++) {
      c2.push({ key: arr[i].key, length: arr[i].length });
    }
    return c2;
  }
  function generateEntropy(indexers, length, entropy) {
    const buffer = b4a.alloc(8 + 32 + indexers.length * 32);
    const state = { start: 0, end: buffer.byteLength, buffer };
    c.uint64.encode(state, length);
    c.fixed32.encode(state, entropy || GENESIS_ENTROPY);
    for (const { key } of indexers)
      c.fixed32.encode(state, key);
    return crypto.hash([NS_ENTROPY, buffer]);
  }
});

// node_modules/autobase/lib/encryption.js
var require_encryption = __commonJS((exports, module) => {
  var HypercoreEncryption = require_default_encryption();
  var sodium = require_sodium_native();
  var crypto = require_hypercore_crypto();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var rrp = require_resolve_reject_promise();
  var ReadyResource = require_ready_resource();
  var SystemView = require_system();
  var { EncryptionDescriptor, ManifestData } = require_messages3();
  var { NS_VIEW_BLOCK_KEY, NS_HASH_KEY, NS_ENCRYPTION } = require_caps2();
  var nonce = b4a.alloc(sodium.crypto_stream_NONCEBYTES);
  var hash = nonce.subarray(0, sodium.crypto_generichash_BYTES_MIN);

  class AutobaseEncryption {
    static PADDING = 8;
    constructor(encryption) {
      this.encryption = encryption;
      this.compat = null;
      this.keys = null;
      this.keysById = new Map;
    }
    get id() {
      return this.keys ? this.keys.id : 0;
    }
    padding() {
      return AutobaseEncryption.PADDING;
    }
    isCompat() {
      return false;
    }
    load(keys) {
      if (this.keys === null)
        this.keys = keys;
    }
    async update(ctx) {
      if (this.id !== 0 && this.id === this.encryption.id)
        return;
      const keys = await this.get(this.encryption.id, ctx);
      if (keys)
        this.keys = keys;
    }
    async get(id, ctx) {
      if (this.keysById.has(id))
        return this.keysById.get(id);
      const keys = await this.getKeys(id, ctx);
      this.keysById.set(id, keys);
      return keys;
    }
    async getKeys(id, ctx) {
      const entropy = await this.encryption.get(id);
      if (!entropy)
        return null;
      const block = this.blockKey(entropy, ctx);
      const hash2 = crypto.hash([NS_HASH_KEY, block]);
      return {
        id,
        block,
        hash: hash2
      };
    }
    blockKey(entropy, ctx) {
      return this.encryption.blockKey(entropy, ctx);
    }
    async _ensureCompat(ctx) {
      if (!this.compat)
        this.compat = this.compatKeys(ctx);
    }
    compatKeys() {
      throw new Error("Compatability method is not specified");
    }
    async encrypt(index, block, fork, ctx) {
      if (this.isCompat(ctx, index)) {
        this._ensureCompat(ctx);
        return HypercoreEncryption.encrypt(index, block, fork, this.compat.block, this.compat.blinding);
      }
      await this.update(ctx);
      encryptBlock(index, block, this.keys.id, this.keys.block, this.keys.hash);
    }
    async decrypt(index, block, ctx) {
      if (this.isCompat(ctx, index)) {
        this._ensureCompat(ctx);
        return HypercoreEncryption.decrypt(index, block, this.compat.block);
      }
      const padding = block.subarray(0, AutobaseEncryption.PADDING);
      block = block.subarray(AutobaseEncryption.PADDING);
      const type = padding[0];
      switch (type) {
        case 0:
          return block;
        case 1:
          break;
        default:
          throw new Error("Unrecognised encryption type");
      }
      const id = c.uint32.decode({ start: 4, end: 8, buffer: padding });
      const keys = await this.get(id, ctx);
      c.uint64.encode({ start: 0, end: 8, buffer: nonce }, index);
      nonce.set(padding, 8, 16);
      decrypt(block, nonce, keys.block);
    }
  }

  class ViewEncryption extends AutobaseEncryption {
    constructor(encryption, name) {
      super(encryption);
      this.name = name;
    }
    isCompat(ctx, index) {
      if (ctx.manifest.version <= 1)
        return true;
      if (!ctx.manifest.userData)
        return false;
      const { legacyBlocks } = c.decode(ManifestData, ctx.manifest.userData);
      return index < legacyBlocks;
    }
    compatKeys() {
      const { bootstrap, encryptionKey } = this.encryption.base;
      const block = getCompatBlockKey(bootstrap, encryptionKey, this.name);
      return {
        block,
        blinding: crypto.hash(block)
      };
    }
    blockKey(entropy) {
      return getCompatBlockKey(this.encryption.base.bootstrap, entropy, this.name);
    }
  }

  class WriterEncryption extends AutobaseEncryption {
    isCompat(ctx) {
      return ctx.manifest.version <= 1;
    }
    compatKeys(ctx) {
      return HypercoreEncryption.deriveKeys(this.encryption.base.encryptionKey, ctx.key);
    }
    blockKey(entropy, ctx) {
      if (ctx.manifest.userData) {
        const userData = c.decode(ManifestData, ctx.manifest.userData);
        if (userData.namespace !== null) {
          return this.encryption.blockKey(entropy, { key: userData.namespace });
        }
      }
      return this.encryption.blockKey(entropy, ctx);
    }
  }

  class EncryptionView extends ReadyResource {
    constructor(base, core) {
      super();
      this.base = base;
      this.core = core || null;
      this.sessions = new Map;
      this._initialising = null;
    }
    async _open() {
      await this.initialised();
      await this.core.ready();
    }
    initialised() {
      if (this.core !== null)
        return this.core.ready();
      if (this._initialising)
        return this._initialising;
      this._initialising = rrp();
      return this._initialising.promise;
    }
    _close() {
      if (this._initialising) {
        this._initialising.reject(new Error("Encryption closed"));
        this._initialising = null;
      }
      if (this.core)
        return this.core.close();
    }
    get bootstrapped() {
      return !!(this.core && this.core.length > 0);
    }
    get id() {
      return this.core ? this.core.length : 0;
    }
    _createPayload(key) {
      return key;
    }
    async reload(core) {
      if (this.core)
        await this.core.close();
      this.core = core;
      await this.core.ready();
      if (this._initialising) {
        this._initialising.resolve();
        this._initialising = null;
      }
    }
    unpack(type, payload) {
      if (type > 0)
        throw new Error("Unsupported version");
      return payload;
    }
    async update(key) {
      const payload = await this._createPayload(key);
      const desc = { type: 0, payload };
      await this.core.append(c.encode(EncryptionDescriptor, desc));
    }
    async _preload() {
      await this.ready();
      return this.id();
    }
    getViewEncryption(name) {
      if (this.sessions.has(name))
        return this.sessions.get(name);
      const encryption = new ViewEncryption(this, name);
      this.sessions.set(name, encryption);
      return encryption;
    }
    getWriterEncryption() {
      return new WriterEncryption(this);
    }
    async encryptAnchor(block, namespace) {
      const entropy = await this.get(this.id);
      if (!entropy)
        return null;
      const blockKey = this.blockKey(entropy, { key: namespace });
      const hashKey = crypto.hash([NS_HASH_KEY, block]);
      encryptBlock(0, block, this.id, blockKey, hashKey);
    }
    blockKey(entropy, ctx) {
      return getBlockKey(this.base.bootstrap, this.base.encryptionKey, entropy, ctx.key);
    }
    async get(encryptionId) {
      if (encryptionId === 0)
        return SystemView.GENESIS_ENTROPY;
      if (!this.core)
        await this.initialised();
      const index = encryptionId - 1;
      const desc = await this.core.get(index);
      const { type, payload } = c.decode(EncryptionDescriptor, desc);
      const key = this.unpack(type, payload);
      return key;
    }
    getSystemEncryption() {
      return this.getViewEncryption("_system");
    }
    static namespace(entropy) {
      return crypto.hash([NS_ENCRYPTION, entropy]);
    }
    static getBlockKey(bootstrap, encryptionKey, entropy, hypercoreKey) {
      return getBlockKey(bootstrap, encryptionKey, entropy, hypercoreKey);
    }
    static getSystemEncryption(base, core) {
      const view = new EncryptionView(base, core);
      return view.getSystemEncryption();
    }
    static async setSystemEncryption(base, core, opts) {
      if (base.encryptionKey === null)
        return null;
      await core.ready();
      if (core.manifest.version === 1) {
        const key = getCompatBlockKey(base.bootstrap, base.encryptionKey, "_system");
        return core.setEncryptionKey(key, { block: true });
      }
      if (!core.manifest.linked.length) {
        throw new Error("System manifest does not link encryption view");
      }
      const enc = base.store.get({ key: core.manifest.linked[0], active: false });
      const encryption = EncryptionView.getSystemEncryption(base, enc);
      await core.setEncryption(encryption, opts);
      return enc;
    }
  }
  module.exports = {
    AutobaseEncryption,
    EncryptionView
  };
  function encrypt(block, nonce2, key) {
    sodium.crypto_stream_xor(block, block, nonce2, key);
  }
  function decrypt(block, nonce2, key) {
    return encrypt(block, nonce2, key);
  }
  function getBlockKey(bootstrap, encryptionKey, entropy, hypercoreKey) {
    return encryptionKey && crypto.hash([NS_VIEW_BLOCK_KEY, bootstrap, encryptionKey, entropy, hypercoreKey]);
  }
  function getCompatBlockKey(bootstrap, encryptionKey, name) {
    if (typeof name === "string")
      return getCompatBlockKey(bootstrap, encryptionKey, b4a.from(name));
    return encryptionKey && crypto.hash([NS_VIEW_BLOCK_KEY, bootstrap, encryptionKey, name]);
  }
  function blockhash(block, padding, hashKey) {
    sodium.crypto_generichash(hash, block, hashKey);
    padding.set(hash.subarray(0, 8));
    hash.fill(0);
  }
  function encryptBlock(index, block, id, blockKey, hashKey) {
    const padding = block.subarray(0, AutobaseEncryption.PADDING);
    block = block.subarray(AutobaseEncryption.PADDING);
    blockhash(block, padding, hashKey);
    c.uint32.encode({ start: 4, end: 8, buffer: padding }, id);
    c.uint64.encode({ start: 0, end: 8, buffer: nonce }, index);
    padding[0] = 1;
    nonce.set(padding, 8, 16);
    encrypt(block, nonce, blockKey);
  }
});

// node_modules/autobase/lib/updates.js
var require_updates = __commonJS((exports, module) => {
  module.exports = class UpdateChanges {
    constructor(base) {
      this.base = base;
      this.byName = new Map;
      this.tracking = null;
    }
    get discoveryKey() {
      return this.base.discoveryKey;
    }
    get key() {
      return this.base.key;
    }
    get id() {
      return this.base.id;
    }
    get system() {
      return this.base.system;
    }
    track(state) {
      this.tracking = [];
      this.byName.clear();
      if (!state)
        return;
      for (const v of state.views) {
        if (v.ref)
          this._add(v.ref);
      }
      this._add(state.systemView.ref);
      this._add(state.encryptionView.ref);
    }
    _add(ref) {
      this.tracking.push({ ref, from: ref.atomicBatch ? ref.atomicBatch.length : 0 });
    }
    finalise() {
      if (this.tracking === null)
        return;
      for (const { ref, from } of this.tracking) {
        const core = ref.atomicBatch || ref.batch;
        const trunc = ref.atomicBatch ? ref.atomicBatch.state.lastTruncation : null;
        this.byName.set(ref.name, {
          from,
          to: core ? core.length : from,
          shared: trunc ? trunc.to : from
        });
      }
      this.tracking = null;
    }
    get(name) {
      return this.byName.get(name);
    }
  };
});

// node_modules/autobase/lib/timer.js
var require_timer = __commonJS((exports, module) => {
  var safetyCatch = require_safety_catch();
  var MAX_WAIT = 2 * 60 * 1000;
  var DEFAULT_INTERVAL = 10 * 1000;
  module.exports = class Timer {
    constructor(handler, interval, opts = {}) {
      this.handler = handler || noop;
      this.interval = interval || DEFAULT_INTERVAL;
      this.limit = opts.limit || MAX_WAIT;
      this._executing = null;
      this._limit = random2over1(this.limit);
      this._timer = null;
      this._resolve = null;
      this._start = 0;
      this._stopped = false;
      this._asap = false;
      this._standalone = new Set;
      this._unref = opts.unref !== false;
      this._timerCallback = this._executeBackground.bind(this);
    }
    _executeBackground() {
      this._executing = this._execute();
      this._executing.catch(safetyCatch);
    }
    async _execute() {
      this._asap = false;
      await this.handler();
      this._start = 0;
      this._executing = null;
      this.bump();
    }
    bump() {
      if (this._stopped || this._executing || this._asap)
        return;
      if (!this._start)
        this._start = Date.now();
      else if (Date.now() - this._start > this._limit)
        return;
      const interval = random2over1(this.interval);
      clearTimeout(this._timer);
      this._timer = setTimeout(this._timerCallback, interval);
      if (this._unref && this._timer.unref)
        this._timer.unref();
    }
    async trigger() {
      if (this._stopped)
        return;
      if (this._executing)
        await this._executing;
      if (this._stopped)
        return;
      clearTimeout(this._timer);
      this._timer = null;
      this._executeBackground();
      await this._executing;
    }
    async flush() {
      if (this._executing)
        await this._executing;
    }
    bau() {
      if (!this._asap)
        return;
      this._asap = false;
      this.bump();
    }
    asap() {
      if (this._asap)
        return;
      this._asap = true;
      const interval = Math.floor(Math.random() * this.interval / 3);
      clearTimeout(this._timer);
      this._timer = setTimeout(this._timerCallback, interval);
      if (this._unref && this._timer.unref)
        this._timer.unref();
    }
    stop() {
      if (this._timer)
        clearTimeout(this._timer);
      this._timer = null;
      this._start = 0;
      this._asap = false;
      this._stopped = true;
      for (const { timer, resolve } of this._standalone) {
        clearTimeout(timer);
        resolve();
      }
      this._standalone.clear();
    }
    asapStandalone() {
      const interval = Math.floor(Math.random() * this.interval / 3);
      return new Promise((resolve) => {
        const ref = { timer: null, resolve };
        ref.timer = setTimeout(resolveStandalone, interval, ref, this._standalone);
        if (ref.timer.unref)
          ref.timer.unref();
        this._standalone.add(ref);
      });
    }
    unref() {
      if (this._timer && this._timer.unref)
        this._timer.unref();
    }
  };
  function resolveStandalone(ref, set) {
    set.delete(ref);
    ref.resolve();
  }
  function random2over1(n) {
    return Math.floor(n + Math.random() * n);
  }
  function noop() {}
});

// node_modules/autobase/lib/node-buffer.js
var require_node_buffer = __commonJS((exports, module) => {
  var DEFAULT_SIZE = 32;
  module.exports = class NodeBuffer {
    constructor(offset, hwm) {
      this.hwm = hwm || DEFAULT_SIZE;
      this.defaultHwm = this.hwm;
      this.mask = this.hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.buffer = new Array(this.hwm);
      this.offset = offset || 0;
      this.length = this.offset;
    }
    get size() {
      return this.length - this.offset;
    }
    isEmpty() {
      return this.length === this.offset;
    }
    isFull() {
      return this.size === this.buffer.length;
    }
    grow() {
      this.hwm <<= 1;
      const size = this.size;
      const buffer = new Array(this.hwm);
      const mask = this.hwm - 1;
      for (let i = 0;i < size; i++) {
        buffer[i] = this.buffer[this.btm + i & this.mask];
      }
      this.mask = mask;
      this.top = size;
      this.btm = 0;
      this.buffer = buffer;
    }
    push(data) {
      if (this.isFull())
        this.grow();
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return this.length++;
    }
    shift() {
      if (this.isEmpty())
        return null;
      const last = this.buffer[this.btm];
      this.buffer[this.btm] = undefined;
      this.btm = this.btm + 1 & this.mask;
      this.offset++;
      if (this.isEmpty() && this.hwm !== this.defaultHwm) {
        this.buffer = new Array(this.defaultHwm);
        this.hwm = this.buffer.length;
        this.mask = this.hwm - 1;
        this.top = this.btm = 0;
      }
      return last;
    }
    get(seq) {
      if (seq < this.offset || seq >= this.length)
        return null;
      return this.buffer[this.btm + (seq - this.offset) & this.mask];
    }
  };
});

// node_modules/autobase/lib/writer.js
var require_writer = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var ReadyResource = require_ready_resource();
  var assert = require_nanoassert();
  var SignalPromise = require_signal_promise();
  var Linearizer = require_linearizer();
  var NodeBuffer = require_node_buffer();
  var MAX_PRELOAD = 4;
  var MAX_PREFETCH = 256;
  module.exports = class Writer extends ReadyResource {
    constructor(base, core, length, isRemoved) {
      super();
      this.base = base;
      this.core = core;
      this.isRemoved = isRemoved;
      this.updated = false;
      this.range = null;
      this.nodes = new NodeBuffer(length);
      this.node = null;
      this.isActive = false;
      this.isCurrentlyCoupled = false;
      this.isCoupled = false;
      this.isBootstrap = false;
      this.isActiveIndexer = false;
      this.available = length;
      this.length = length;
      this.seenLength = 0;
      this.recover = false;
      this.frozen = false;
      this.syncSignal = null;
    }
    _pause() {
      if (!this.range)
        return;
      this.range.destroy();
      this.range = null;
    }
    _resume() {
      if (this.range) {
        if (this.range.range.end === this.nodes.length + MAX_PREFETCH)
          return;
        this.range.destroy();
      }
      this.range = this.core.download({ start: this.nodes.length, end: this.nodes.length + MAX_PREFETCH, linear: true });
    }
    _updateCoupling() {
      if (!this.base._coupler || this.isCoupled === this.isCurrentlyCoupled)
        return;
      if (this.isCurrentlyCoupled)
        this.base._coupler.remove(this.core);
      else
        this.base._coupler.add(this.core);
      this.isCurrentlyCoupled = this.isCoupled;
    }
    _removeCouple() {
      if (this.base._coupler && !this.isCoupled && this.isCurrentlyCoupled) {
        this.isCurrentlyCoupled = false;
        this.base._coupler.remove(this.core);
      }
    }
    updateActivity() {
      if (!this.core.opened)
        return;
      if (this.seenLength > this.core.length || this.length < this.core.length || this.isBootstrap) {
        this.isActive = true;
        this.core.setActive(true);
      } else if (this.length === this.core.length) {
        this.isActive = false;
        this.core.setActive(false);
      }
      this._updateCoupling();
      if (this.core.writable)
        return;
      if (this.base.isFastForwarding() || !this.isActive) {
        this._pause();
      } else {
        this._resume();
      }
    }
    setBootstrap(bool) {
      this.isBootstrap = bool;
      this.updateActivity();
    }
    seen(length) {
      if (length > this.seenLength)
        this.seenLength = length;
      this.updateActivity();
    }
    waitForSynced() {
      if (this.core.length === this.length)
        return Promise.resolve();
      if (this.syncSignal === null)
        this.syncSignal = new SignalPromise;
      return this.syncSignal.wait();
    }
    async _open() {
      await this.core.ready();
      await this.core.setUserData("referrer", this.base.key);
      if (this.base.closing)
        return;
      this.recover = autoRecover(this.core);
      await this.base._wakeup.add(this.core.core);
      this.updateActivity();
      if (this.core.length > this.length)
        this.base._queueBump();
      this.base.emit("writer", this);
    }
    _close() {
      if (this.syncSignal !== null)
        this.syncSignal.notify();
      return this.core.close();
    }
    get indexed() {
      return this.nodes.offset;
    }
    idle() {
      return this.length === this.available && this.length === this.core.length && this.core.opened;
    }
    flushed() {
      return this.seenLength <= this.length && this.length === this.available && this.length === this.core.length && this.shiftable() === false && !this.core.core.upgrading && this.core.opened;
    }
    compare(writer) {
      return b4a.compare(this.core.key, writer.core.key);
    }
    head() {
      return this.nodes.get(this.length - 1);
    }
    advance() {
      if (this.syncSignal !== null && this.length + 1 === this.core.length)
        this.syncSignal.notify();
      return this.length < this.available ? this.nodes.get(this.length++) : null;
    }
    shiftable() {
      return this.length > this.nodes.offset;
    }
    shift() {
      if (this.shiftable() === false)
        return false;
      let node = this._shiftAndClear();
      while (node.batch > 1)
        node = this._shiftAndClear();
      return true;
    }
    get(seq) {
      return seq < this.length ? this.nodes.get(seq) : null;
    }
    append(value, heads, batch, dependencies, optimistic) {
      const node = Linearizer.createNode(this, this.nodes.length + 1, value, heads, batch, dependencies, optimistic);
      node.actualHeads = node.heads.slice(0);
      this.nodes.push(node);
      this.available++;
      this.length++;
      return node;
    }
    async update(boot) {
      if (this.opened === false)
        await this.ready();
      if (this.frozen)
        return false;
      const preload = boot ? 1 : MAX_PRELOAD;
      while (this.available - this.length < preload) {
        if (this.nodes.length === this.core.length || this.core.length === 0)
          break;
        if (this.node === null && !await this._loadNextNode())
          break;
        if (!await this._ensureNodeDependencies(boot))
          break;
        if (this.recover)
          this.node.value = null;
        this.nodes.push(this.node);
        if (this.node.batch === 1)
          this.available = this.nodes.length;
        this.node = null;
      }
      this.updateActivity();
      return this.length < this.available;
    }
    _shiftAndClear() {
      const node = this.nodes.shift();
      node.clear();
      return node;
    }
    async _loadNextNode() {
      const seq = this.nodes.length;
      if (!await this.core.has(seq))
        return false;
      try {
        const { node, optimistic } = await this.core.get(seq, { wait: false });
        const value = node.value == null ? null : c.decode(this.base.valueEncoding, node.value);
        this.node = Linearizer.createNode(this, seq + 1, value, node.heads, node.batch, new Set, optimistic);
        return true;
      } catch (err) {
        this.frozen = true;
        throw err;
      }
    }
    async _ensureNodeDependencies(boot) {
      while (this.node.dependencies.size < this.node.heads.length) {
        const rawHead = this.node.heads[this.node.dependencies.size];
        const headWriter = await this.base._getWriterByKey(rawHead.key, -1, rawHead.length, true, false, boot);
        if (headWriter !== this && (headWriter === null || headWriter.length < rawHead.length)) {
          if (!boot)
            this.base._ensureWakeup(headWriter);
          return false;
        }
        let headNode = headWriter.nodes.get(rawHead.length - 1);
        if (!headNode) {
          for (const node of this.base.linearizer.heads) {
            if (!compareHead(node, rawHead))
              continue;
            headNode = node;
            break;
          }
        }
        assert(!this.node.dependencies.has(headNode), "Corrupted DAG");
        if (headNode === null) {
          this.node.heads.splice(this.node.dependencies.size, 1);
          continue;
        }
        this.node.dependencies.add(headNode);
      }
      const offset = this.node.length - 1;
      if (offset > this.indexed) {
        this.node.dependencies.add(this.nodes.get(offset - 1));
      }
      return true;
    }
  };
  function compareHead(node, head) {
    if (node.length !== head.length)
      return false;
    return b4a.equals(node.writer.core.key, head.key);
  }
  function autoRecover(core) {
    assert(core.opened);
    switch (core.id) {
      case "ghrpexaboutdm46ombqho7mroxknassnntrxx3cubfux4qi6w6hy":
      case "qoaanao71s4he1rcd197d336qepykk4467geo1uq8cwnzmpb786o":
      case "fomhdxgn4j4tzjqy6y7iskhffimzokt7kraddyd8orcht3r8q61o":
      case "d8f5taxxrit51apftoi38e5b86hb98cgfd7dfp3uo1uoh95qt49o":
      case "objyf75uggsqpjcut69xdgj46ks8r71jjrq7oxdfsz95sstchkno":
        return true;
    }
    return false;
  }
});

// node_modules/autobase/lib/values.js
var require_values = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var { OPLOG_VERSION } = require_caps2();
  var { OplogMessage } = require_messages3();
  var { EncryptionView } = require_encryption();
  module.exports = {
    encodeValue,
    decodeValue
  };
  function encodeValue(value, opts = {}) {
    const state = { start: 0, end: 0, buffer: null };
    const message = {
      version: opts.version || OPLOG_VERSION,
      digest: null,
      checkpoint: null,
      optimistic: !!opts.optimistic,
      node: {
        heads: opts.heads || [],
        batch: 1,
        value
      }
    };
    OplogMessage.preencode(state, message);
    if (opts.padding) {
      state.start = opts.padding;
      state.end += opts.padding;
    }
    state.buffer = b4a.alloc(state.end);
    OplogMessage.encode(state, message);
    if (!opts.encrypted)
      return state.buffer;
    if (!opts.optimistic) {
      throw new Error("Encoding an encrypted value is not supported");
    }
    const padding = b4a.alloc(16);
    crypto.hash(state.buffer, padding);
    padding[0] = 0;
    return b4a.concat([padding.subarray(0, 8), state.buffer]);
  }
  async function decodeValue(value, { autobase, encryptionKey, key, manifest, index = 0 } = {}) {
    if (encryptionKey) {
      const e = new EncryptionView({ encryptionKey, bootstrap: autobase });
      const w = e.getWriterEncryption();
      await w.decrypt(index, value, { key, manifest });
      value = value.subarray(8);
    }
    const op = c.decode(OplogMessage, value);
    return op.node.value;
  }
});

// node_modules/autobase/lib/active-writers.js
var require_active_writers = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class ActiveWriters {
    constructor() {
      this.map = new Map;
    }
    get size() {
      return this.map.size;
    }
    [Symbol.iterator]() {
      return this.map.values();
    }
    get(key) {
      return this.map.get(b4a.toString(key, "hex")) || null;
    }
    has(key) {
      return this.get(key) !== null;
    }
    add(writer) {
      this.map.set(b4a.toString(writer.core.key, "hex"), writer);
    }
    delete(writer) {
      this.map.delete(b4a.toString(writer.core.key, "hex"));
    }
    updateActivity() {
      for (const w of this.map.values())
        w.updateActivity();
    }
    clear() {
      const p = [];
      for (const w of this.map.values())
        p.push(w.close());
      this.map.clear();
      return Promise.all(p);
    }
  };
});

// node_modules/autobase/lib/wakeup.js
var require_wakeup = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var safetyCatch = require_safety_catch();
  var ReadyResource = require_ready_resource();
  var WakeupEntry = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.key);
      c.uint.preencode(state, m.length);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.key);
      c.uint.encode(state, m.length);
    },
    decode(state) {
      return {
        key: c.fixed32.decode(state),
        length: c.uint.decode(state)
      };
    }
  };
  module.exports = class AutoWakeup extends ReadyResource {
    constructor(base) {
      super();
      this.base = base;
      this.flushing = null;
      this._rootStore = this.base.store;
      this._addBound = this.add.bind(this);
      this._preupdateBound = this._preupdate.bind(this);
      this._needsFlush = false;
      this._map = new Map;
    }
    [Symbol.iterator]() {
      return this._map.values();
    }
    async _preupdate(batch, key) {
      this.queue(key, batch.length);
      await this.flush();
      this.base._onwakeup();
    }
    async _save() {
      const slab = b4a.allocUnsafe(8 + this._map.size * 40);
      const state = { start: 0, end: 0, buffer: slab };
      c.uint.encode(state, this._map.size);
      for (const m of this._map.values())
        WakeupEntry.encode(state, m);
      await this.base.local.setUserData("autobase/wakeup", slab.subarray(0, state.start));
    }
    async _load() {
      const buffer = await this.base.local.getUserData("autobase/wakeup");
      if (!buffer)
        return;
      const state = { start: 0, end: buffer.byteLength, buffer };
      let len = c.uint.decode(state);
      while (len-- > 0) {
        const m = WakeupEntry.decode(state);
        this._map.set(b4a.toString(m.key, "hex"), m);
      }
    }
    async _open() {
      await this._load();
      this._rootStore.watch(this._addBound);
      for (const core of this._rootStore.cores) {
        if (core.opened === false)
          await core.ready().catch(noop);
        if (!core.closing)
          this.add(core);
      }
    }
    async _close() {
      this._rootStore.unwatch(this._addBound);
      for (const core of this._rootStore.cores) {
        if (core.opened && !core.closing)
          this.remove(core);
      }
      this._map.clear();
      while (this.flushing) {
        try {
          await this.flushing;
        } catch {}
      }
    }
    queue(key, length) {
      const hex = b4a.toString(key, "hex");
      const m = this._map.get(hex);
      if (m && m.length > length) {
        return false;
      }
      this._needsFlush = true;
      this._map.set(hex, { key, length });
      return true;
    }
    unqueue(key, length) {
      const hex = b4a.toString(key, "hex");
      const m = this._map.get(hex);
      if (!m)
        return true;
      if (m.length > length)
        return false;
      this._needsFlush = true;
      this._map.delete(hex);
      return true;
    }
    async flush() {
      if (this.closing)
        throw new Error("Closing");
      if (this.flushing)
        await this.flushing;
      if (this.flushing)
        return this.flushing;
      if (this._needsFlush === false)
        return;
      this._needsFlush = false;
      try {
        this.flushing = this._save();
        return await this.flushing;
      } finally {
        this.flushing = null;
      }
    }
    add(core) {
      return this._add(core).catch(safetyCatch);
    }
    remove(core) {
      return this._remove(core);
    }
    async _add(core) {
      if (core.opened === false)
        await core.ready();
      if (core.closing)
        return false;
      if (core === this.base.local.core)
        return false;
      const rx = core.storage.read();
      const referrerPromise = rx.getUserData("referrer");
      const viewPromise = rx.getUserData("autobase/view");
      rx.tryFlush();
      const [referrer, view] = await Promise.all([referrerPromise, viewPromise]);
      if (view)
        return false;
      if (referrer === null || !b4a.equals(referrer, this.base.key))
        return false;
      core.preupdate = this._preupdateBound;
      return true;
    }
    _remove(core) {
      if (core.preupdate !== this._preupdateBound)
        return false;
      core.preupdate = null;
      return true;
    }
  };
  function noop() {}
});

// node_modules/autobase/lib/fast-forward.js
var require_fast_forward = __commonJS((exports, module) => {
  var rrp = require_resolve_reject_promise();
  var safetyCatch = require_safety_catch();
  var SystemView = require_system();
  var { EncryptionView } = require_encryption();
  var DEFAULT_OP_TIMEOUT = 5000;
  var DEFAULT_MIN_FF = 16;
  module.exports = class FastForward {
    constructor(base, key, { timeout = DEFAULT_OP_TIMEOUT, verified = true, minimum = DEFAULT_MIN_FF, force = false } = {}) {
      this.base = base;
      this.key = key;
      this.timeout = timeout;
      this.force = force;
      this.core = base.store.get({ key, active: true, encryption: null });
      this.length = 0;
      this.views = [];
      this.encryption = null;
      this.entropy = null;
      this.indexers = [];
      this.minimum = minimum;
      this.verified = verified;
      this.waiting = new Set;
      this.cores = [this.core];
      this.system = null;
      this.destroyed = false;
      this.upgrading = null;
      this.failed = false;
    }
    static MINIMUM = DEFAULT_MIN_FF;
    async upgrade() {
      if (!this.upgrading)
        this.upgrading = this._upgrade();
      try {
        if (!await this.upgrading)
          return null;
        return {
          length: this.length,
          force: this.force,
          key: this.key,
          indexers: this.indexers,
          views: this.views,
          entropy: this.entropy,
          manifestVersion: this.core.manifest.version,
          minimum: this.minimum
        };
      } catch (err) {
        safetyCatch(err);
        this.failed = true;
        return null;
      } finally {
        await this.close();
      }
    }
    _waitForAppend(core) {
      if (core.length > 0)
        return Promise.resolve();
      const promise = rrp();
      const timeout = setTimeout(this.close.bind(this), this.timeout);
      const wait = { promise, timeout };
      this.waiting.add(wait);
      core.once("append", () => {
        this.waiting.delete(wait);
        clearTimeout(timeout);
        promise.resolve();
      });
      return promise.promise;
    }
    _minLength() {
      return this.base.core.length + this.minimum;
    }
    async _upgrade() {
      await this.core.ready();
      if (!this.verified)
        await this._waitForAppend(this.core);
      if (this.destroyed)
        return false;
      if (this.core.manifest.linked) {
        const appends = [];
        for (const key of this.core.manifest.linked) {
          const core = this.base.store.get({ key, active: true });
          this.cores.push(core);
          await core.ready();
          appends.push(this._waitForAppend(core));
        }
        await Promise.all(appends);
      }
      this.length = this.core.length;
      if (!this.force && (this.length === 0 || this.length < this._minLength()))
        return false;
      await this.core.get(this.length - 1, { timeout: this.timeout });
      await this.base.ready();
      if (this.destroyed)
        return false;
      if (this.base.encryptionKey && !await this._ensureEncryption())
        return false;
      if (this.destroyed)
        return false;
      this.system = new SystemView(this.core, { checkout: this.length });
      await this.system.ready();
      if (this.destroyed)
        return false;
      this.entropy = this.system.entropy;
      if (this.core.manifest.version >= 2) {
        const linked = this.core.manifest.linked;
        if (this.system.encryptionLength === 0 || linked === null || !linked.length) {
          return false;
        }
        this.views.push({
          key: linked[0],
          length: this.system.encryptionLength
        });
      }
      const promises = [];
      promises.push(this.system.get(this.base.local.key, { timeout: this.timeout }));
      if (this.encryption && this.encryption.core) {
        promises.push(this.encryption.core.get(this.system.encryptionLength - 1, { timeout: this.timeout }));
      }
      for (const v of this.system.views) {
        this.views.push(v);
        const core = this.base.store.get({ key: v.key, active: true });
        this.cores.push(core);
        if (!v.length)
          continue;
        promises.push(core.get(v.length - 1, { timeout: this.timeout }));
      }
      for (const idx of this.system.indexers) {
        this.indexers.push(idx);
        if (idx.length === 0)
          continue;
        const core = this.base.store.get({ key: idx.key, active: true });
        this.cores.push(core);
        promises.push(core.get(idx.length - 1, { timeout: this.timeout }));
        promises.push(this.system.get(idx.key, { timeout: this.timeout }));
      }
      for (const head of this.system.heads) {
        promises.push(this.system.get(head.key, { timeout: this.timeout }));
      }
      await Promise.all(promises);
      if (this.destroyed)
        return false;
      return true;
    }
    async _ensureEncryption() {
      if (this.core.encryption !== null)
        return true;
      const encCore = this.core.manifest.version <= 1 ? null : this.cores[1];
      this.encryption = new EncryptionView(this.base, encCore);
      const encryption = this.encryption.getViewEncryption("_system");
      await this.core.setEncryption(encryption);
      return true;
    }
    async close() {
      this.destroyed = true;
      for (const { promise, timeout } of this.waiting) {
        clearTimeout(timeout);
        promise.resolve();
      }
      if (this.system)
        await this.system.close();
      if (this.encryption)
        await this.encryption.close();
      for (const core of this.cores)
        await core.close();
      await this.core.close();
    }
  };
});

// node_modules/autobase/lib/store.js
var require_store = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var crypto = require_hypercore_crypto();
  var Hypercore = require_hypercore();
  var messages = require_messages3();
  var DEFAULT_MANIFEST_VERSION = 1;
  var INDEX_VERSION = 1;
  var EMPTY = b4a.alloc(0);
  var [NS_SIGNER_NAMESPACE] = crypto.namespace("autobase", 1);

  class CompatExtension {
    constructor(base, core) {
      this.base = base;
      this.core = core;
      this.unlinked = false;
      this.extension = this.core.registerExtension("autobase", {
        onmessage: this._onmessage.bind(this)
      });
      if (this.core.opened)
        this._onready();
      else
        this.core.ready().then(this._onready.bind(this), noop);
    }
    _onready() {
      if (!this.core.manifest || !this.core.manifest.signers.length)
        return;
      const req = c.encode(messages.Wakeup, { version: 1, type: 0 });
      this.core.on("peer-add", (peer) => {
        if (this.base.isFastForwarding()) {
          this.base._needsWakeupRequest = true;
          return;
        }
        this.extension.send(req, peer);
      });
      this._broadcastRequest(req);
    }
    _broadcastRequest(req) {
      if (this.base.isFastForwarding()) {
        this.base._needsWakeupRequest = true;
        return;
      }
      for (const peer of this.core.peers) {
        this.extension.send(req, peer);
      }
    }
    broadcast() {
      const req = c.encode(messages.Wakeup, { version: 1, type: 0 });
      this._broadcastRequest(req);
    }
    unlink() {
      this.unlinked = true;
    }
    _onmessage(buf, from) {
      if (!buf)
        return;
      let value = null;
      try {
        value = c.decode(messages.Wakeup, buf);
      } catch {
        return;
      }
      if (value.type === 0)
        return;
      if (this.unlinked || this.base.isFastForwarding())
        return;
      if (!this.core.manifest || !this.core.manifest.signers.length)
        return;
      this.base.hintWakeup(value.writers);
    }
  }

  class ViewCore {
    constructor(name, core, base) {
      this.name = name;
      this.core = null;
      this.batch = null;
      this.atomicBatch = null;
      this.compatExtension = null;
      this.migrated(base, core);
    }
    getCore() {
      return this.atomicBatch || this.batch || this.core;
    }
    migrated(base, core) {
      this.core = core;
      if (this.name === "_system") {
        const ff = base._queueFastForward.bind(base);
        this.core.on("append", ff);
        this.core.ready().then(ff, ff);
        if (!this.compatExtension || this.compatExtension.core !== core) {
          if (this.compatExtension)
            this.compatExtension.unlink();
          this.compatExtension = new CompatExtension(base, core);
        }
      }
    }
    async matchesKey(key) {
      if (!this.core.opened)
        await this.core.ready();
      return b4a.equals(this.core.key, key);
    }
    async matchesNamespace(target) {
      if (!this.core.opened)
        await this.core.ready();
      if (this.core.manifest && this.core.manifest.signers.length > 0) {
        const ns = this.core.manifest.signers[0].namespace;
        if (b4a.equals(ns, target))
          return true;
      }
      return false;
    }
    async commit(atom, length, signature) {
      await this.core.commit(this._getAtomicBatch(atom), { length, signature });
    }
    async release() {
      if (!this.atomicBatch)
        return;
      await this.atomicBatch.ready();
      const sessions = this.atomicBatch.state.sessions;
      for (let i = sessions.length - 1;i >= 0; i--) {
        if (!sessions[i])
          break;
        await sessions[i].close();
      }
      await this.atomicBatch.close();
      this.atomicBatch = null;
    }
    _getAtomicBatch(atom) {
      if (this.atomicBatch === null) {
        this.atomicBatch = this.batch.session({ atom, writable: true });
      }
      return this.atomicBatch;
    }
    async catchup(atom, length) {
      await this.release();
      const batch = this._getAtomicBatch(atom);
      await batch.ready();
      await batch.state.catchup(length);
    }
    createSession(atom, valueEncoding) {
      if (this.batch === null) {
        this.batch = this.core.session({ name: "batch", writable: true });
      }
      const s = atom ? this._getAtomicBatch(atom).session({ valueEncoding, writable: true }) : this.batch.session({ valueEncoding, writable: false });
      return s;
    }
  }

  class AutoStore {
    constructor(base, byName) {
      this.base = base;
      this.store = base.store;
      this.byName = byName || new Map;
      this.opened = [];
      this.atom = null;
      this.local = null;
    }
    async close() {
      if (this.local)
        await this.local.close();
      for (const v of this.byName.values()) {
        await v.release();
      }
      if (this.atom)
        return;
      for (const v of this.byName.values()) {
        if (v.core)
          await v.core.close();
        if (v.batch)
          await v.batch.close();
      }
    }
    atomize() {
      const store = new AutoStore(this.base, this.byName);
      store.atom = this.store.storage.createAtom();
      return store;
    }
    async updateLocal() {
      if (!this.local)
        return;
      await this.local.close();
      this.local = null;
    }
    flush() {
      return this.atom ? this.atom.flush() : Promise.resolve();
    }
    get(opts, moreOpts) {
      if (typeof opts === "string")
        opts = { name: opts };
      if (moreOpts)
        opts = { ...opts, ...moreOpts };
      const {
        name,
        valueEncoding = null
      } = opts;
      if (!name)
        throw new Error("name is required");
      return this.getViewByName(name).createSession(this.atom, valueEncoding);
    }
    getViewByName(name) {
      let view = this.byName.get(name);
      if (!view) {
        const preload = this._preload(name);
        const core = this.base.store.get({ preload });
        view = new ViewCore(name, core, this.base);
        this.byName.set(name, view);
      }
      if (this.opened.indexOf(view) === -1) {
        this.opened.push(view);
      }
      return view;
    }
    getLocal() {
      if (this.local !== null)
        return this.local;
      this.local = this.base.local.session({
        atom: this.atom,
        valueEncoding: messages.OplogMessage,
        encryption: this.base.getWriterEncryption(this.base.local.key),
        active: false
      });
      return this.local;
    }
    getViews() {
      return [...this.byName.values()];
    }
    getSystemView() {
      return this.getViewByName("_system");
    }
    getSystemCore() {
      return this.getSystemView().core;
    }
    getEncryption(name) {
      if (!this.base.encryptionKey)
        return null;
      if (name === "_encryption")
        return null;
      return this.base.encryption.getViewEncryption(name);
    }
    async getIndexerManifests(entries) {
      const manifests = [];
      for (const { key } of entries) {
        const core = this.store.get({ key, active: false });
        await core.ready();
        if (!core.manifest)
          continue;
        manifests.push(core.manifest);
        await core.close();
      }
      return manifests;
    }
    getViewCore(indexerManifests, name, prologue, manifestVersion, entropy, linked, manifestData) {
      const manifest = this._createManifest(indexerManifests, name, prologue, manifestVersion, entropy, linked, manifestData);
      return this.base.store.get({
        manifest,
        exclusive: false,
        encryption: this.getEncryption(name)
      });
    }
    listViews() {
      const views = [];
      for (const [name, ref] of this.byName) {
        const core = ref.batch || ref.core;
        views.push({ name, key: core.key, length: core.length, signedLength: core.signedLength });
      }
      return views;
    }
    createAnchorCore(prologue, manifestData) {
      const manifest = {
        version: 2,
        hash: "blake2b",
        prologue,
        allowPatch: false,
        quorum: 0,
        signers: [],
        userData: manifestData,
        linked: null
      };
      const core = this.store.get({
        manifest,
        active: false
      });
      return core;
    }
    async createView(indexerManifests, name, prologue, manifestVersion, entropy, linked, manifestData) {
      const manifest = this._createManifest(indexerManifests, name, prologue, manifestVersion, entropy, linked, manifestData);
      const core = this.store.get({
        key: Hypercore.key(manifest),
        manifest,
        active: false
      });
      await core.ready();
      const key = core.key;
      await core.close();
      return key;
    }
    async _preload(name) {
      await Promise.resolve();
      if (!this.base.opening)
        throw new Error("Autobase failed to open");
      await this.base._preopen;
      const boot = await this.base._getSystemInfo() || { key: this.getBootstrapSystemKey(), indexers: [], views: [], entropy: null };
      const indexerManifests = await this.getIndexerManifests(boot.indexers);
      if (boot.indexers.length === 0) {
        return this._freshCorePreload(indexerManifests, name, boot.entropy);
      }
      if (name === "_system") {
        return {
          key: boot.key,
          exclusive: false,
          encryption: this.getEncryption(name)
        };
      }
      if (name === "_encryption") {
        const core = this.getSystemCore();
        await core.ready();
        if (!core.manifest.linked) {
          return this._freshCorePreload(indexerManifests, name, boot.entropy);
        }
        return {
          key: core.manifest.linked[0],
          exclusive: false,
          encryption: null
        };
      }
      const v = await this.findViewByName(indexerManifests, boot.views, name, boot.entropy);
      if (v === null) {
        return this._freshCorePreload(indexerManifests, name, boot.entropy);
      }
      return {
        key: v.key,
        exclusive: false,
        encryption: this.getEncryption(name)
      };
    }
    _freshCorePreload(indexerManifests, name, entropy) {
      if (name === "_system")
        return this._freshSystemPreload(indexerManifests, entropy);
      return {
        manifest: this._createManifest(indexerManifests, name, null, DEFAULT_MANIFEST_VERSION, entropy, [], null),
        exclusive: true,
        encryption: this.getEncryption(name)
      };
    }
    _freshSystemPreload(indexerManifests, entropy) {
      return {
        manifest: this._createSystemManifest(indexerManifests, null, DEFAULT_MANIFEST_VERSION, entropy, null),
        exclusive: true,
        encryption: this.getEncryption("_system")
      };
    }
    _deriveStaticHash(name) {
      return crypto.hash([this.base.key, b4a.from(name)]);
    }
    _deriveNamespace(name, entropy) {
      const encryptionId = crypto.hash(this.base.encryptionKey || EMPTY);
      const version = c.encode(c.uint, INDEX_VERSION);
      const bootstrap = this.base.key;
      return crypto.hash([
        NS_SIGNER_NAMESPACE,
        version,
        bootstrap,
        encryptionId,
        entropy,
        b4a.from(name)
      ]);
    }
    async _getCoreManifest(key) {
      const core = this.store.get({ key, active: false });
      await core.ready();
      const manifest = core.manifest;
      await core.close();
      return manifest;
    }
    getBootstrapSystemKey() {
      return Hypercore.key(this._createSystemManifest([], null, DEFAULT_MANIFEST_VERSION, null));
    }
    async findViewByKey(key, indexers, manifestVersion, entropy) {
      for (const v of this.byName.values()) {
        if (await v.matchesKey(key))
          return v;
      }
      const manifest = await this._getCoreManifest(key);
      const target = manifest && manifest.signers.length ? manifest.signers[0].namespace : null;
      if (target) {
        for (const v of this.byName.values()) {
          if (await v.matchesNamespace(target))
            return v;
        }
      }
      const indexerManifests = await this.getIndexerManifests(indexers);
      if (entropy === null) {
        entropy = indexerManifests[0].signers[0].namespace;
      }
      if (target) {
        for (const v of this.byName.values()) {
          const namespace = this._deriveNamespace(v.name, entropy);
          if (b4a.equals(namespace, target))
            return v;
        }
      }
      for (const v of this.byName.values()) {
        const manifestData = v.core ? v.core.manifest.userData : null;
        const manifest2 = this._createManifest(indexerManifests, v.name, null, manifestVersion, entropy, [], manifestData);
        const manifestKey = Hypercore.key(manifest2);
        if (!b4a.equals(manifestKey, key))
          continue;
        const core = this.store.get({ key: manifestKey, manifest: manifest2, active: false });
        await core.ready();
        await core.close();
        return v;
      }
      return null;
    }
    async findViewByName(indexerManifests, views, name, entropy) {
      if (indexerManifests.length === 0)
        return null;
      if (entropy === null)
        entropy = indexerManifests[0].signers[0].namespace;
      const namespace = this._deriveNamespace(name, entropy);
      for (const v of views) {
        const manifest = await this._getCoreManifest(v.key);
        if (manifest.signers.length === 0)
          continue;
        const signer = manifest.signers[0];
        if (b4a.equals(signer.namespace, namespace))
          return v;
      }
      return null;
    }
    _createManifest(indexerManifests, name, prologue, version, entropy, linked, manifestData) {
      if (!indexerManifests.length) {
        prologue = {
          hash: this._deriveStaticHash(name),
          length: 0
        };
      } else if (prologue && prologue.length === 0) {
        prologue = null;
      }
      const signers = [];
      if (indexerManifests.length && entropy === null) {
        entropy = indexerManifests[0].signers[0].namespace;
      }
      for (const manifest of indexerManifests) {
        const signer = manifest.signers[0];
        signers.push({
          namespace: this._deriveNamespace(name, entropy),
          signature: "ed25519",
          publicKey: signer.publicKey
        });
      }
      return {
        version,
        hash: "blake2b",
        prologue,
        allowPatch: true,
        quorum: Math.min(signers.length, (signers.length >> 1) + 1),
        signers,
        userData: manifestData,
        linked: version > 1 ? linked : null
      };
    }
    _createSystemManifest(indexerManifests, prologue, version, entropy, manifestData) {
      if (prologue !== null)
        throw new Error("Can only derive fresh system core");
      const linked = [];
      if (version > DEFAULT_MANIFEST_VERSION) {
        const encManifest = this._createManifest(indexerManifests, "_encryption", null, version, entropy, [], manifestData);
        linked.push(Hypercore.key(encManifest));
      }
      return this._createManifest(indexerManifests, "_system", null, version, entropy, linked, manifestData);
    }
  }
  module.exports = AutoStore;
  function noop() {}
});

// node_modules/autobase/lib/apply-calls.js
var require_apply_calls = __commonJS((exports, module) => {
  class PublicApplyCalls {
    constructor(base) {
      this.base = base;
      this.internal = false;
    }
    get discoveryKey() {
      return this.base.discoveryKey;
    }
    get key() {
      return this.base.key;
    }
    get id() {
      return this.base.id;
    }
    async addWriter() {
      throw new Error("Not allowed on the public view");
    }
    async ackWriter() {
      throw new Error("Not allowed on the public view");
    }
    async removeWriter() {
      throw new Error("Not allowed on the public view");
    }
    preferFastForward() {
      throw new Error("Not allowed on the public view");
    }
    interrupt() {
      throw new Error("Not allowed on the public view");
    }
    removeable() {
      throw new Error("Not allowed on the public view");
    }
    fork() {
      throw new Error("Not allowed on the public view");
    }
    anchor() {
      throw new Error("Not allowed on the public view");
    }
  }

  class PrivateApplyCalls extends PublicApplyCalls {
    constructor(state) {
      super(state.base);
      this.state = state;
      this.internal = true;
    }
    get system() {
      return this.state.system;
    }
    async addWriter(key, { indexer = true, isIndexer = indexer } = {}) {
      await this.state.system.add(key, { isIndexer });
      await this.base._addWriter(key, this.state.system);
    }
    async ackWriter(key) {
      await this.state.system.ack(key);
    }
    async removeWriter(key) {
      if (!this.state.removeable(key)) {
        throw new Error("Not allowed to remove the last indexer");
      }
      await this.state.system.remove(key);
      this.base._removeWriter(key);
    }
    preferFastForward() {
      this.base._preferFastForward();
    }
    interrupt(reason) {
      this.base._interrupt(reason);
    }
    removeable(key) {
      return this.state.removeable(key);
    }
    async fork(indexerKeys, system) {
      if (!await this.state.validateFork(indexerKeys, system))
        return false;
      const indexers = indexerKeys.map(toIndexer);
      this.state.pendingFork = { indexers, length: system.length };
      return true;
    }
    async createAnchor() {
      return await this.state.createAnchor();
    }
  }
  module.exports = { PublicApplyCalls, PrivateApplyCalls };
  function toIndexer(key) {
    return { key, length: 0 };
  }
});

// node_modules/autobase/lib/fork.js
var require_fork = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var SystemView = require_system();
  var { EncryptionView } = require_encryption();
  var { ManifestData } = require_messages3();
  module.exports = class Fork {
    constructor(base, store, state, fork) {
      this.base = base;
      this.store = store;
      this.state = state;
      this.indexers = fork.indexers;
      this.length = fork.length;
      this.system = null;
      this.encryption = null;
      this.manifests = null;
      this.cores = [];
    }
    async upgrade() {
      try {
        await this._upgrade();
        return true;
      } catch {
        return false;
      } finally {
        await this.close();
      }
    }
    async _upgrade() {
      this.manifests = await this.store.getIndexerManifests(this.indexers);
      this.system = new SystemView(await this._get("_system", this.length));
      this.encryption = new EncryptionView(this, await this._get("_encryption", -1));
      await this.system.ready();
      await this.encryption.ready();
      this.entropy = this.system.getEntropy(this.indexers, this.length);
      this.manifestVersion = Math.max(this.system.core.manifest.version, 2);
      const views = [];
      for (const view of this.state.views) {
        const v = this.getViewFromSystem(view, this.system);
        const indexedLength = v ? v.length : 0;
        const session = await this._get(view.name, indexedLength);
        await session.ready();
        const next = await this.createView(view.name, session, null);
        await next.ready();
        await this._migrate(view.ref, next, view.core, indexedLength);
        views.push({ key: next.key, length: indexedLength });
      }
      const entropy = EncryptionView.namespace(this.entropy);
      await this.encryption.update(entropy);
      const system = this.store.getViewByName("_system");
      const encryption = this.store.getViewByName("_encryption");
      const enc = await this.createView("_encryption", this.encryption.core, null);
      await enc.ready();
      await this._migrate(encryption, enc, this.encryption.core, this.encryption.core.length);
      await this.system.fork(this.indexers, this.manifests, this.encryption.core.length, views);
      const sys = await this.createView("_system", this.system.core, [enc.key]);
      await sys.ready();
      await this._migrate(system, sys, this.system.core, this.system.core.length);
    }
    async createView(name, core, linked) {
      const prologue = await getPrologue(core);
      const manifestData = this._manifestData(core);
      return this.store.getViewCore(this.manifests, name, prologue, this.manifestVersion, this.entropy, linked, manifestData);
    }
    async _get(name, length) {
      const core = this.store.get({ name });
      this.cores.push(core);
      if (length !== -1)
        await core.truncate(length);
      return core;
    }
    getViewFromSystem(view) {
      if (view.mappedIndex === -1 || view.mappedIndex >= this.system.views.length)
        return null;
      return this.system.views[view.mappedIndex];
    }
    _manifestData(session) {
      if (session.manifest.version > 1)
        return session.manifest.userData;
      return c.encode(ManifestData, { version: 0, legacyBlocks: session.length });
    }
    async _migrate(ref, next, source, length) {
      if (length > 0) {
        await next.core.copyPrologue(source.state);
      }
      const batch = next.session({ name: "batch", overwrite: true, checkout: length });
      await batch.ready();
      if (source !== null) {
        while (batch.length < source.length) {
          await batch.append(await source.get(batch.length));
        }
      }
      await ref.batch.state.moveTo(batch, batch.length);
      await batch.close();
      ref.migrated(this.base, next);
    }
    async _ensureEncryption() {
      if (this.core.encryption !== null)
        return true;
      const encCore = this.core.manifest.version <= 1 ? null : this.cores[1];
      this.encryption = new EncryptionView(this.base, encCore);
      const encryption = this.encryption.getViewEncryption("_system");
      await this.core.setEncryption(encryption);
      return true;
    }
    async close() {
      this.destroyed = true;
      if (this.system)
        await this.system.close();
      if (this.encryption)
        await this.encryption.close();
      for (const core of this.cores)
        await core.close();
    }
  };
  async function getPrologue(core) {
    if (!core.length)
      return null;
    return {
      hash: await core.treeHash(),
      length: core.length
    };
  }
});

// node_modules/autobase/lib/apply-state.js
var require_apply_state = __commonJS((exports, module) => {
  var ReadyResource = require_ready_resource();
  var assert = require_nanoassert();
  var c = require_compact_encoding();
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var safetyCatch = require_safety_catch();
  var { partialSignature } = require_multisig();
  var SystemView = require_system();
  var { AutobaseEncryption } = require_encryption();
  var UpdateChanges = require_updates();
  var messages = require_messages3();
  var { PrivateApplyCalls } = require_apply_calls();
  var { encodeValue } = require_values();
  var Fork = require_fork();
  var LocalState = require_local_state();
  var { OPLOG_VERSION, BOOT_RECORD_VERSION } = require_caps2();
  var SHOULD_WRITE_THRESHOLD = 16;

  class CheckpointCore {
    constructor(view, core, signer, paused) {
      this.view = view;
      this.core = core;
      this.signer = signer;
      this.length = 0;
      this.digest = null;
      this.signatures = { system: null, encryption: null, user: [] };
      this.closed = false;
      this.paused = paused;
    }
    pause() {
      this.paused = true;
    }
    resume() {
      if (!this.paused)
        return;
      this.paused = false;
      this.updateBackground();
    }
    async update() {
      if (await this.updateCheckpoints())
        await this.view.maybeSigned();
    }
    async updateCheckpoints() {
      if (this.core.length <= this.length || this.closed || this.paused)
        return false;
      const length = this.core.length;
      const value = await this.core.get(length - 1);
      if (length <= this.length || this.closed || !value.digest || this.paused)
        return false;
      const [
        digest,
        checkpoints
      ] = await Promise.all([
        this._inflateDigest(length, value.digest),
        this._inflateAllCheckpoints(length, value.checkpoint)
      ]);
      if (length <= this.length || this.closed || !digest || !checkpoints || this.paused)
        return false;
      for (let i = 0;i < checkpoints.length; i++) {
        if (checkpoints[i] === null)
          return false;
      }
      this.length = length;
      this.digest = digest;
      this.signatures = checkpoints;
      return true;
    }
    updateBackground() {
      return this.update().catch(safetyCatch);
    }
    updateInternalSignatures(length, signatures) {
      this.signatures.system = updateSignature(length, signatures.system, this.signatures.system);
      this.signatures.encryption = updateSignature(length, signatures.encryption, this.signatures.encryption);
    }
    updateUserSignatures(length, signatures) {
      this.signatures.user = updateSignatures(length, signatures, this.signatures.user);
    }
    makeCheckpoints(length) {
      return {
        system: makeCheckpoint(length, this.signatures.system),
        encryption: makeCheckpoint(length, this.signatures.encryption),
        user: makeCheckpoints(length, this.signatures.user)
      };
    }
    makeDigest(length, key) {
      if (this.digest && (this.digest.key === key || b4a.equals(this.digest.key, key))) {
        return { key: null, pointer: length - this.digest.at };
      }
      this.digest = { key, at: length };
      return { key, pointer: 0 };
    }
    async ready() {
      await this.core.ready();
      this.core.on("append", this.updateBackground.bind(this));
      if (this.core.writable)
        await this.updateCheckpoints();
      this.updateBackground();
    }
    signedLength() {
      return this.signatures.system ? this.signatures.system.length : 0;
    }
    close() {
      this.closed = true;
      return this.core.close();
    }
    async _inflateDigest(length, dig) {
      if (!dig)
        return null;
      if (dig.pointer === 0) {
        return { key: dig.key, at: length };
      }
      const len = length - dig.pointer;
      if (this.digest && len === this.digest.at)
        return this.digest;
      if (len <= 0)
        return null;
      const { digest } = await this.core.get(len - 1);
      if (!digest || !digest.key)
        return null;
      return { key: digest.key, at: len };
    }
    _sameSignatures(b, a) {
      return sameSignature(a.system, b.system) && sameSignature(a.encryption, b.encryption) && sameSignatures(a.user, b.user);
    }
    async _inflateAllCheckpoints(length, checkpoints) {
      if (!checkpoints)
        return { system: null, encryption: null, user: [] };
      if (this._sameSignatures(checkpoints, this.signatures))
        return this.signatures;
      const system = this._inflateSystemCheckpoint(checkpoints.system, length);
      const encryption = this._inflateEncryptionCheckpoint(checkpoints.encryption, length);
      const user = checkpoints.user ? new Array(checkpoints.user.length) : [];
      for (let i = 0;i < user.length; i++) {
        const chk = checkpoints.user[i];
        user[i] = this._inflateUserCheckpoint(chk, i, length);
      }
      return {
        system: await system,
        encryption: await encryption,
        user: await Promise.all(user)
      };
    }
    async _inflateSystemCheckpoint(chk, coreLength) {
      if (chk.checkpoint) {
        const { signature: signature2, length: length2 } = chk.checkpoint;
        return { signature: signature2, length: length2, at: coreLength };
      }
      const len = coreLength - chk.checkpointer;
      if (this.signatures.system && this.signatures.system.at === len) {
        return this.signatures.system;
      }
      if (len <= 0)
        return null;
      const { checkpoint } = await this.core.get(len - 1);
      if (!checkpoint || !checkpoint.system || !checkpoint.system.checkpoint)
        return null;
      const { signature, length } = checkpoint.system.checkpoint;
      return { signature, length, at: len };
    }
    async _inflateEncryptionCheckpoint(chk, coreLength) {
      if (!chk)
        return { length: 0, signature: null, at: 0 };
      if (chk.checkpoint) {
        const { signature: signature2, length: length2 } = chk.checkpoint;
        return { signature: signature2, length: length2, at: coreLength };
      }
      const len = coreLength - chk.checkpointer;
      if (this.signatures.encryption && this.signatures.encryption.at === len) {
        return this.signatures.encryption;
      }
      if (len <= 0)
        return null;
      const { checkpoint } = await this.core.get(len - 1);
      if (!checkpoint || !checkpoint.encryption || !checkpoint.encryption.checkpoint)
        return null;
      const { signature, length } = checkpoint.encryption.checkpoint;
      return { signature, length, at: len };
    }
    async _inflateUserCheckpoint(chk, i, coreLength) {
      if (chk.checkpoint) {
        const { signature: signature2, length: length2 } = chk.checkpoint;
        return { signature: signature2, length: length2, at: coreLength };
      }
      const len = coreLength - chk.checkpointer;
      if (i < this.signatures.user.length && this.signatures.user[i].at === len) {
        return this.signatures.user[i];
      }
      if (len <= 0)
        return null;
      const { checkpoint } = await this.core.get(len - 1);
      if (!checkpoint || i >= checkpoint.user.length || !checkpoint.user[i].checkpoint)
        return null;
      const { signature, length } = checkpoint.user[i].checkpoint;
      return { signature, length, at: len };
    }
  }
  module.exports = class ApplyState extends ReadyResource {
    constructor(base) {
      super();
      this.base = base;
      this.encryption = this.base.encryption;
      this.valueEncoding = base.valueEncoding;
      this.store = base._viewStore.atomize();
      this.key = null;
      this.system = null;
      this.view = null;
      this.views = [];
      this.systemView = null;
      this.encryptionView = null;
      this.hostcalls = null;
      this.changes = base._hasUpdate ? new UpdateChanges(base) : null;
      this.updates = [];
      this.local = null;
      this.localState = null;
      this.fastForwarding = false;
      this.indexersUpdated = false;
      this.quorum = 0;
      this.stretchedThreshold = 0;
      this.needsIndexedLengthUpdate = false;
      this.interrupted = false;
      this.applying = null;
      this.applyBatch = null;
      this.localCheckpoint = null;
      this.localIndexer = false;
      this.systemUpgrade = null;
      this.checkpoints = [];
      this.pendingViews = null;
      this.pendingFork = null;
      this.dirty = false;
    }
    shouldFlush() {
      return this.dirty;
    }
    shouldWrite() {
      if (!this.localIndexer || !this.localCheckpoint || !this.localCheckpoint.opened)
        return false;
      if (!this.localCheckpoint.signedLength() < this.indexedLength + this.stretchedThreshold)
        return false;
      const len = Math.min(this.localCheckpoint.signatures.length, this.views.length + 1);
      for (let i = 1;i < len; i++) {
        const sig = this.localCheckpoint.signatures[i];
        const core = this.views[i - 1].core;
        if (core && sig.length > core.length)
          return true;
      }
      return false;
    }
    get indexedLength() {
      return this.systemView.indexedLength;
    }
    get systemRef() {
      return this.systemView.ref;
    }
    async validateFork(indexerKeys, system) {
      if (!b4a.equals(system.key, this.system.core.key))
        return false;
      if (this.pendingIndexedLength() < system.length)
        return false;
      for (const key of indexerKeys) {
        const info = await this.system.get(key);
        if (!info || !info.length || info.isRemoved)
          return false;
      }
      return true;
    }
    async shouldMigrate() {
      if (!this.fastForwarding && !this.indexersUpdated)
        return false;
      if (this.system.indexers.length === 0)
        return false;
      if (!this.system.core.manifest || !this.system.core.manifest.signers)
        return true;
      if (this.system.indexers.length !== this.system.core.manifest.signers.length) {
        return true;
      }
      const manifests = await this.store.getIndexerManifests(this.system.indexers);
      for (let i = 0;i < this.system.core.manifest.signers.length; i++) {
        const { publicKey } = this.system.core.manifest.signers[i];
        if (!b4a.equals(publicKey, manifests[i].signers[0].publicKey))
          return true;
      }
      return false;
    }
    isLocalPendingIndexer() {
      if (this.system.pendingIndexers.length === 0)
        return false;
      const key = this.base.local.key;
      for (const k of this.system.pendingIndexers) {
        if (b4a.equals(k, key))
          return !b4a.equals(this.base.key, key) && this.base.local.length === 0;
      }
      return false;
    }
    removeable(key) {
      if (this.system.indexers.length !== 1)
        return true;
      return !b4a.equals(this.system.indexers[0].key, key);
    }
    isLocalIndexer() {
      return !!this.localCheckpoint;
    }
    _createCheckpointCore(key, active, signer, paused) {
      const encryption = this.base.getWriterEncryption(key);
      const session = this.base.store.get({
        key,
        valueEncoding: messages.OplogMessage,
        encryption,
        active
      });
      return new CheckpointCore(this, session, signer, paused);
    }
    async _openInternalView(name, indexedLength) {
      const core = this.store.get({ name });
      await core.ready();
      await core.setUserData("referrer", this.base.key);
      await core.setUserData("autobase/view", b4a.from(name));
      const ref = this.store.getViewByName(name);
      return { ref, core, indexedLength };
    }
    async _open() {
      const boot = await this.base._getBootRecord();
      this.systemView = await this._openInternalView("_system", boot.systemLength);
      this.encryptionView = await this._openInternalView("_encryption", -1);
      const sysCore = this.systemView.core;
      if (sysCore.manifest.version >= 2) {
        if (this.encryption !== null)
          await this.encryption.reload(this.encryptionView.core);
      }
      const system = new SystemView(sysCore);
      await system.ready();
      this.store.opened = [];
      this.hostcalls = new PrivateApplyCalls(this);
      const view = this.base._hasOpen ? this.base._handlers.open(this.store, this.hostcalls) : null;
      for (const v of this.store.opened)
        await v.atomicBatch.ready();
      this.system = system;
      this.key = system.core.key;
      this.view = view;
      this.fastForwarding = boot.fastForwarding;
      this.indexersUpdated = boot.indexersUpdated;
      this.stretchedThreshold = this.system.indexers.length * SHOULD_WRITE_THRESHOLD;
      this.quorum = sysCore.manifest ? sysCore.manifest.quorum : 0;
      const added = new Set;
      for (let i = 0;i < system.views.length; i++) {
        const { key, length } = system.views[i];
        const v = await this.store.findViewByKey(key, system.indexers, sysCore.manifest.version, system.entropy);
        if (v === null) {
          this.views.push({ name: null, key, length, core: null, ref: null, mappedIndex: i });
          continue;
        }
        await v.atomicBatch.ready();
        await v.core.setUserData("referrer", this.base.key);
        await v.core.setUserData("autobase/view", b4a.from(v.name));
        this.views.push({ name: v.name, key, length, core: v.atomicBatch, ref: v, mappedIndex: i });
        added.add(v);
      }
      for (const v of this.store.opened) {
        if (added.has(v))
          continue;
        const core = v.atomicBatch;
        this.views.push({ name: v.name, key: core.key, length: core.length, core, ref: v, mappedIndex: -1 });
      }
      this.local = this.store.getLocal();
      await this.local.ready();
      this.localState = new LocalState(this.local);
      let isLocalIndexer = false;
      const paused = this.base.isFastForwarding();
      for (let i = 0;i < system.indexers.length; i++) {
        const idx = system.indexers[i];
        const chk = this._createCheckpointCore(idx.key, true, i, paused);
        await chk.ready();
        this.checkpoints.push(chk);
        if (b4a.equals(idx.key, this.base.local.key))
          isLocalIndexer = true;
      }
      const shouldSign = this.quorum > 0 && isLocalIndexer;
      if (shouldSign) {
        this.localIndexer = true;
        await this._startLocalCheckpoint();
      }
      await this._refreshWriters();
      this.maybeSigned().catch(noop);
    }
    async _startLocalCheckpoint() {
      for (const chk of this.checkpoints) {
        if (chk.core.id === this.base.local.id) {
          this.localCheckpoint = chk;
          return;
        }
      }
      this.localCheckpoint = this._createCheckpointCore(this.base.local.key, false, 0, false);
      await this.localCheckpoint.ready();
    }
    interrupt() {
      this.interrupted = true;
      this.pause();
    }
    pause() {
      for (const chk of this.checkpoints) {
        if (chk !== this.localCheckpoint)
          chk.pause();
      }
    }
    resume() {
      for (const chk of this.checkpoints) {
        if (chk !== this.localCheckpoint)
          chk.resume();
      }
    }
    _checkSystemUpgrade() {
      if (this.systemUpgrade)
        return;
      const tally = new Map;
      for (const chk of this.checkpoints) {
        if (chk.signedLength() <= this.system.core.signedLength)
          continue;
        if (!chk.digest)
          continue;
        const id = b4a.toString(chk.digest.key, "hex");
        const cnt = (tally.get(id) || 0) + 1;
        if (cnt >= this.quorum) {
          this.systemUpgrade = chk.digest.key;
          this.base._queueStaticFastForward(this.systemUpgrade);
          return;
        }
        tally.set(id, cnt);
      }
    }
    mapIndexToView(index) {
      for (const { mappedIndex, ref } of this.views) {
        if (mappedIndex === index)
          return ref;
      }
    }
    async maybeSigned() {
      if (this.opened === false)
        await this.ready();
      if (this.interrupted)
        return;
      const thres = this.checkpoints.length - this.quorum;
      if (thres < 0 || this.checkpoints.length <= thres)
        return;
      this.checkpoints.sort(cmpCheckpoints);
      const signableLength = this.checkpoints[thres].signedLength();
      if (signableLength <= this.system.core.signedLength)
        return;
      const expected = this.system.core.key;
      if (signableLength > this.indexedLength) {
        if (!b4a.equals(expected, this.checkpoints[thres].digest.key))
          this._checkSystemUpgrade();
        this.needsIndexedLengthUpdate = true;
        return;
      }
      for (let i = thres;i < this.checkpoints.length; i++) {
        const chk2 = this.checkpoints[i];
        if (!b4a.equals(expected, chk2.digest.key)) {
          this._checkSystemUpgrade();
          return;
        }
        if (!chk2.signatures.system || chk2.signatures.system.length > this.indexedLength) {
          this.needsIndexedLengthUpdate = true;
          return;
        }
      }
      this.needsIndexedLengthUpdate = false;
      const chk = [];
      for (let i = thres;i < this.checkpoints.length; i++) {
        chk.push({ signer: this.checkpoints[i].signer, signatures: this.checkpoints[i].signatures });
      }
      const { system } = this.checkpoints[thres].signatures;
      await this._assembleMultisig(system.length, chk);
    }
    async _assembleMultisig(signableLength, checkpoints) {
      const views = new Array(this.views.length + 2);
      const sys = await this.system.getIndexedInfo(signableLength);
      if (this.interrupted)
        return;
      if (this.pendingViews && this.pendingViews[0].length >= signableLength) {
        return;
      }
      views[0] = createCheckpointSignature(signableLength, this.systemView, checkpoints.length);
      if (sys.encryptionLength) {
        views[1] = createCheckpointSignature(sys.encryptionLength, this.encryptionView, checkpoints.length);
      }
      const offset = 2;
      for (let i = offset;i < views.length; i++) {
        const view = this.views[i - offset];
        const core = view.core;
        const v = this.getViewFromSystem(view, sys);
        const length = v ? v.length : 0;
        if (!core || length <= core.signedLength)
          continue;
        const viewIndex = view.mappedIndex + offset;
        views[viewIndex] = createCheckpointSignature(length, view, checkpoints.length);
      }
      for (let i = 0;i < checkpoints.length; i++) {
        addCheckpointSignatures(views, checkpoints, i);
      }
      const promises = [];
      for (const view of views) {
        if (!view)
          continue;
        for (let i = 0;i < view.signatures.length; i++) {
          promises.push(setPartialSignature(view, i));
        }
      }
      await Promise.all(promises);
      for (const v of views) {
        if (!v)
          continue;
        for (let i = 0;i < v.signatures.length; i++) {
          if (!v.partials[i])
            return;
        }
      }
      if (this.interrupted)
        return;
      if (this.pendingViews && this.pendingViews[0].length >= signableLength) {
        return;
      }
      if (!views[0])
        return;
      this.pendingViews = views;
      this.dirty = true;
      this.base._queueBump();
    }
    async _close() {
      this.interrupted = true;
      if (this.applying)
        this._postApply();
      for (const chk of this.checkpoints)
        await chk.close();
      if (this.localCheckpoint)
        await this.localCheckpoint.close();
      if (this.base._hasClose)
        await this.base._handlers.close(this.view);
      if (this.system)
        await this.system.close();
      const promises = [];
      for (const v of this.views) {
        if (v.ref)
          promises.push(v.ref.release());
      }
      promises.push(this.systemView.ref.release());
      promises.push(this.encryptionView.ref.release());
      await Promise.all(promises);
      await this.store.close();
    }
    _pushUpdate(u) {
      u.version = 1;
      u.seq = this.updates.length === 0 ? 0 : this.updates[this.updates.length - 1].seq + 1;
      u.systemLength = this.systemView.core.length;
      this.updates.push(u);
      this.localState.insertUpdate(u);
    }
    async catchup(linearizer) {
      if (!this.opened)
        await this.ready();
      if (!this.system.heads.length)
        return;
      const writers = new Map;
      const updates = await this.localState.listUpdates();
      const sys = await this.system.checkout(this.indexedLength);
      for (const node of updates) {
        const hex = b4a.toString(node.key, "hex");
        let w = writers.get(hex);
        if (w === undefined) {
          w = await this.base._getWriterByKey(node.key, -1, 0, true, false, sys);
          writers.set(hex, w);
        }
        assert(w.length < node.length, "Update expects writer to be consumed here");
        while (w.length < node.length) {
          await w.update(sys);
          const next = w.advance();
          assert(next, "Node must exist for catchup");
          linearizer.addHead(next);
        }
      }
      await sys.close();
      this.updates = updates;
      if (this.indexersUpdated) {
        this.indexersUpdated = false;
        await this.truncate(this.indexedLength);
        await this._rollbackViews();
        if (this.tx === null)
          this.tx = this.local.state.storage.write();
        while (this.updates.length > 0 && this.updates[this.updates.length - 1].systemLength >= this.indexedLength) {
          const u = this.updates.pop();
          this.localState.deleteUpdate(u);
        }
      } else {
        linearizer.update();
      }
      await this._refreshWriters();
    }
    async getIndexedSystem() {
      if (this.opened === false)
        await this.ready();
      const indexedLength = this.pendingFork ? this.pendingFork.length : this.indexedLength;
      const sys = await this.system.checkout(indexedLength);
      await sys.ready();
      return sys;
    }
    getViewFromSystem(view, sys = this.system) {
      if (view.mappedIndex === -1 || view.mappedIndex >= sys.views.length)
        return null;
      return sys.views[view.mappedIndex];
    }
    async recoverAt() {
      await this.systemRef.core.ready();
      const lt = this.systemRef.core.signedLength;
      for await (const { length, info } of SystemView.flushes(this.systemRef.core, { reverse: true, lt })) {
        for (let i = 0;i < info.views.length; i++) {
          if (i >= this.views.length)
            continue;
          if (!b4a.equals(info.views[i].key, this.views[i].key))
            continue;
          if (info.views[i].length > this.views[i].core.signedLength)
            continue;
          return { length, force: true, key: this.system.core.key, indexers: info.indexers, views: info.views };
        }
      }
      return null;
    }
    bootstrap() {
      return this.system.add(this.base.key, { isIndexer: true, isPending: false });
    }
    async undo(popped) {
      if (!popped)
        return;
      let indexersUpdated = false;
      while (popped > 0) {
        const u2 = this.updates.pop();
        this.localState.deleteUpdate(u2);
        popped -= u2.batch;
        if (u2.indexers)
          indexersUpdated = true;
      }
      const u = this.updates.length === 0 ? null : this.updates[this.updates.length - 1];
      const systemLength = u ? u.systemLength : this.indexedLength;
      await this.truncate(systemLength);
      if (indexersUpdated)
        await this._rollbackViews();
    }
    async truncate(systemLength) {
      if (this.opened === false)
        await this.ready();
      if (systemLength === this.system.core.length)
        return;
      await this.system.core.truncate(systemLength);
      const migrated = await this.system.update();
      if (this.encryptionView.core.length !== this.system.encryptionLength) {
        await this.encryptionView.core.truncate(this.system.encryptionLength);
      }
      for (const view of this.views) {
        if (!view.core)
          continue;
        const v = this.getViewFromSystem(view);
        if (v && view.core.length === v.length)
          continue;
        if (v === null)
          view.mappedIndex = -1;
        await view.core.truncate(v ? v.length : 0);
      }
      if (!migrated)
        return;
      await this._refreshWriters();
      await this._rollbackViews();
    }
    async _refreshWriters() {
      for (const w of this.base.activeWriters) {
        const data = await this.system.get(w.core.key);
        const bootstrapper = this.system.core.length === 0 && b4a.equals(w.core.key, this.base.key);
        const isRemoved = data ? data.isRemoved : !bootstrapper;
        w.isRemoved = isRemoved;
      }
    }
    async _updateSystem() {
      if (!await this.system.update())
        return;
      await this._refreshWriters();
      await this._rollbackViews();
    }
    async _signViewCore(core, length) {
      const s = await core.signable(length, 0);
      const signature = crypto.sign(s, this.base.local.keyPair.secretKey);
      return { signature, length };
    }
    async _signInternalViewCores(sys) {
      return {
        system: await this._signViewCore(this.systemView.core, this.systemView.indexedLength),
        encryption: await this._signViewCore(this.encryptionView.core, sys.encryptionLength)
      };
    }
    async _signUserViewCores(sys) {
      const promises = new Array(sys.views.length);
      for (let i = 0;i < this.views.length; i++) {
        const view = this.views[i];
        const v = this.getViewFromSystem(view, sys);
        const indexedLength = v ? v.length : 0;
        if (!indexedLength)
          continue;
        const viewIndex = view.mappedIndex;
        promises[viewIndex] = this._signViewCore(view.ref.atomicBatch, indexedLength);
      }
      return Promise.all(promises);
    }
    async finalize(key) {
      this.localState.setBootRecord({
        version: BOOT_RECORD_VERSION,
        key,
        systemLength: this.systemView.indexedLength,
        indexersUpdated: true,
        fastForwarding: false,
        recoveries: this.base.recoveries
      });
      await this.localState.flush();
      await this.store.flush();
      await this.close();
    }
    async _flush(localNodes) {
      if (localNodes)
        await this._appendLocalNodes(localNodes);
      this.localState.setBootRecord({
        version: BOOT_RECORD_VERSION,
        key: this.key,
        systemLength: this.systemView.indexedLength,
        indexersUpdated: false,
        fastForwarding: false,
        recoveries: this.base.recoveries
      });
      await this.localState.flush();
      if (this.localCheckpoint) {
        await this.store.flush();
        await this.localCheckpoint.update();
      }
      if (this.pendingViews) {
        const views = this.pendingViews;
        this.pendingViews = null;
        for (let i = views.length - 1;i >= 0; i--) {
          const v = views[i];
          if (!v || v.length <= v.core.signedLength)
            continue;
          const signature = v.core.core.verifier.assemble(v.partials);
          try {
            await v.ref.commit(this.store.atom, v.length, signature);
          } catch (err) {
            if (!this.base.closing)
              this.base._warn(err);
          }
        }
      }
      await this.store.flush();
      this.fastForwarding = false;
      if (this.pendingViews === null)
        this.dirty = false;
    }
    _indexUpdates(indexed) {
      let shift = 0;
      while (indexed > 0)
        indexed -= this.updates[shift++].batch;
      const last = this.updates[shift - 1];
      this.systemView.indexedLength = last.systemLength;
      for (let i = 0;i < shift; i++)
        this.localState.deleteUpdate(this.updates[i]);
      this.updates.splice(0, shift);
      if (!this.needsIndexedLengthUpdate)
        return;
      this.maybeSigned().catch(noop);
    }
    pendingIndexedLength() {
      let indexed = this.applying.indexed.length;
      if (!this.applying || !this.updates.length || !indexed)
        return this.indexedLength;
      let pos = 0;
      while (indexed > 0 && pos < this.updates.length) {
        indexed -= this.updates[pos++].batch;
      }
      const last = this.updates[pos - 1];
      return last.systemLength;
    }
    async _assertNode(node, batch) {
      const v = await this.system.get(node.writer.core.key) || { length: 0, isRemoved: false };
      const expected = v.length + batch;
      if (node.length === expected)
        return;
      console.trace("INVALID_INSERTION", "length=", node.length, "key=", node.writer.core.key, "local=", node.writer.core.writable, "batch=", batch, "dag=", v);
      process.exit(1);
    }
    _postApply() {
      this.applyBatch = this.applying = null;
      this.base._postApply();
    }
    async _optimisticApply(u, node, indexed) {
      const checkpoint = this.system.checkpoint();
      this.system.addHead(node);
      const applyBatch = [];
      const key = node.writer.core.key;
      applyBatch.push({
        indexed,
        optimistic: true,
        from: node.writer.core,
        length: node.length,
        value: node.value,
        heads: node.actualHeads
      });
      const pre = await this.system.get(key);
      const preLength = pre ? pre.length : 0;
      let failed = false;
      this.applying = u;
      this.applyBatch = applyBatch;
      try {
        await this.base._handlers.apply(applyBatch, this.view, this.hostcalls);
      } catch {
        failed = true;
      }
      this._postApply();
      if (!failed) {
        const post = await this.system.get(key);
        if (!post || preLength === post.length)
          failed = true;
      }
      if (!failed) {
        await this._refreshWriters();
        return true;
      }
      this.system.applyCheckpoint(checkpoint);
      if (this.encryptionView.core.length !== this.system.encryptionLength) {
        await this.encryptionView.core.truncate(this.system.encryptionLength);
      }
      for (const view of this.views) {
        const viewLength = view.core ? view.core.length : view.length;
        const viewLookup = this.getViewFromSystem(view);
        const viewSystemLength = viewLookup ? viewLookup.length : 0;
        if (viewSystemLength === viewLength)
          continue;
        await view.core.truncate(viewSystemLength);
      }
      await this._refreshWriters();
      await this._rollbackViews();
      return false;
    }
    async update(u, localNodes) {
      if (this.changes !== null)
        this.changes.track(this);
      let batch = 0;
      let applyBatch = [];
      let indexersUpdated = 0;
      let j = 0;
      let i = 0;
      let forkedAt = -1;
      while (i < Math.min(u.indexed.length, u.shared)) {
        const node = u.indexed[i++];
        if (node.batch > 1)
          continue;
        this.base._shiftWriter(node.writer);
        const update = this.updates[j++];
        if (update.indexers) {
          indexersUpdated = i;
          break;
        }
      }
      if (u.undo)
        await this.undo(u.undo);
      if (this.system.bootstrapping)
        await this.bootstrap();
      await this._updateSystem();
      for (i = u.shared;i < u.length; i++) {
        const indexed = i < u.indexed.length;
        const node = indexed ? u.indexed[i] : u.tip[i - u.indexed.length];
        batch++;
        const optimist = node.writer.isRemoved && node.optimistic && batch === 1 && this.base._hasOptimisticApply === true && await this._optimisticApply(u, node, indexed);
        if (!optimist) {
          if (node.writer.isRemoved && !node.writer.isActiveIndexer) {
            if (node.batch > 1)
              continue;
            const u2 = { seq: 0, key: node.writer.core.key, length: node.length, batch, systemLength: 0, indexers: false };
            this._pushUpdate(u2);
            batch = 0;
            assert(applyBatch.length === 0, "Apply batch should not have been modified");
            continue;
          }
          const deps = node.causalDependencies();
          for (let i2 = deps.length - 1;i2 >= 1; i2--) {
            const d = deps[i2];
            if (await this.system.linkable(d.writer.core.key, d.length, true)) {
              this.system.addHead(deps[i2]);
            }
          }
          this.system.addHead(deps[0]);
          if (node.value !== null && !node.writer.isRemoved) {
            applyBatch.push({
              indexed,
              optimistic: false,
              from: node.writer.core,
              length: node.length,
              value: node.value,
              heads: node.actualHeads
            });
          }
          if (node.batch > 1)
            continue;
          if (applyBatch.length && this.base._hasApply === true) {
            this.applying = u;
            this.applyBatch = applyBatch;
            await this.base._handlers.apply(applyBatch, this.view, this.hostcalls);
            if (forkedAt === -1 && this.pendingFork)
              forkedAt = i;
            this._postApply();
          }
        }
        const update = {
          seq: 0,
          key: node.writer.core.key,
          length: node.length,
          batch,
          systemLength: 0,
          indexers: false
        };
        update.indexers = !!this.system.indexerUpdate;
        if (this.system.indexerUpdate)
          await this._generateNextViews();
        await this.system.flush(this.views);
        await this.system.update();
        batch = 0;
        applyBatch = [];
        this._pushUpdate(update);
        if (!indexed || indexersUpdated)
          continue;
        this.base._shiftWriter(node.writer);
        if (update.indexers) {
          indexersUpdated = i + 1;
        }
      }
      if (this.pendingFork) {
        const pending = this.pendingFork;
        if (pending.length > this.indexedLength)
          this._indexUpdates(u.indexed.length);
        const fork = new Fork(this.base, this.store, this, pending);
        const forked = await fork.upgrade();
        if (!forked)
          throw new Error("Fork failed");
        await this._flush(localNodes);
        return {
          reboot: true,
          migrated: false
        };
      }
      if (u.indexed.length) {
        this._indexUpdates(indexersUpdated || u.indexed.length);
      }
      const migrated = indexersUpdated !== 0;
      if (migrated)
        this.key = await this.base._premigrate();
      if (this.changes !== null) {
        this.changes.finalise();
        await this.base._handlers.update(this.view, this.changes);
      }
      await this._flush(localNodes);
      return {
        reboot: migrated,
        migrated
      };
    }
    flush() {
      return this._flush(null);
    }
    async _appendLocalNodes(localNodes) {
      if (localNodes.length === 0)
        return;
      const blocks = new Array(localNodes.length);
      const local = this.local;
      if (!local.opened)
        await local.ready();
      for (let i = 0;i < blocks.length; i++) {
        const { value, heads, batch, optimistic } = localNodes[i];
        blocks[i] = {
          version: OPLOG_VERSION,
          maxSupportedVersion: this.base.maxSupportedVersion,
          checkpoint: null,
          digest: null,
          optimistic,
          node: {
            heads,
            batch,
            value: value === null ? null : c.encode(this.base.valueEncoding, value)
          },
          trace: []
        };
      }
      if (this.localIndexer) {
        const signedLength = this.localCheckpoint.signedLength();
        const local2 = this.local;
        let signedAt = 0;
        let internalSignatures = null;
        let signatures = null;
        if (this.indexedLength > signedLength) {
          const sys = await this.system.getIndexedInfo(this.indexedLength);
          internalSignatures = await this._signInternalViewCores(sys);
          signatures = await this._signUserViewCores(sys);
          signedAt = local2.length + blocks.length;
        }
        for (let i = 0;i < blocks.length; i++) {
          const length = local2.length + i + 1;
          if (length === signedAt) {
            this.localCheckpoint.updateInternalSignatures(length, internalSignatures);
            this.localCheckpoint.updateUserSignatures(length, signatures);
          }
          const blk = blocks[i];
          blk.checkpoint = this.localCheckpoint.makeCheckpoints(length);
          blk.digest = this.localCheckpoint.makeDigest(length, this.key);
        }
      } else {
        if (!this.localCheckpoint)
          await this._startLocalCheckpoint();
        for (let i = 0;i < blocks.length; i++) {
          const length = local.length + i + 1;
          blocks[i].digest = this.localCheckpoint.makeDigest(length, this.key);
        }
      }
      await local.append(blocks);
    }
    async _rollbackViews() {
      for (const view of this.views) {
        const v = this.getViewFromSystem(view);
        if (v) {
          view.key = v.key;
        } else {
          await this._resetView(view);
        }
      }
    }
    async createAnchor() {
      const node = this.applyBatch[this.applyBatch.length - 1];
      const key = node.from.key;
      const length = node.length;
      const info = await this.system.get(key, { unflushed: true });
      if (!info || info.length < length)
        throw new Error("Anchor node is not in system");
      const state = { start: 0, end: 40, buffer: b4a.alloc(40) };
      c.fixed32.encode(state, key);
      c.uint64.encode(state, length);
      const namespace = crypto.hash(state.buffer);
      const manifestData = c.encode(messages.ManifestData, { version: 0, legacyBlocks: 0, namespace });
      const padding = this.encryption ? AutobaseEncryption.PADDING : 0;
      const block = encodeValue(null, { heads: [{ key, length }], padding });
      if (this.encryption)
        await this.encryption.encryptAnchor(block, namespace);
      const root = { index: 0, size: block.byteLength, hash: crypto.data(block) };
      const hash = crypto.tree([root]);
      const prologue = { hash, length: 1 };
      const core = this.store.createAnchorCore(prologue, manifestData);
      await core.ready();
      if (core.length === 0)
        await core.append(block, { writable: true, maxLength: 1 });
      await this.system.add(core.key, { isIndexer: false, length: 0 });
      await this.base._addWriter(core.key, this.system);
      const anchor = { key: core.key, length: core.length };
      await core.close();
      await this.base.hintWakeup(anchor);
      return anchor;
    }
    async _resetView(view) {
      const manifests = await this.store.getIndexerManifests(this.system.indexers);
      const manifestData = view.core ? view.core.manifest.userData : null;
      view.key = await this.store.createView(manifests, view.name, null, this.system.core.manifest.version, this.system.entropy, null, manifestData);
      view.length = 0;
    }
    async _generateNextViews() {
      const sys = this.system;
      const manifests = await this.store.getIndexerManifests(sys.indexers);
      const entropy = sys.version < 2 ? null : sys.getEntropy(sys.indexers, sys.flushLength());
      for (const v of this.views) {
        const manifestData = v.core ? v.core.manifest.userData : null;
        const prologue = await getPrologue(v);
        const key = await this.store.createView(manifests, v.name, prologue, sys.core.manifest.version, entropy, null, manifestData);
        v.key = key;
      }
    }
  };
  async function getPrologue(view) {
    const length = view.core ? view.core.length : view.length;
    if (!length)
      return null;
    const hash = await view.core.treeHash(length);
    return {
      hash,
      length
    };
  }
  function noop() {}
  function cmpCheckpoints(a, b) {
    return a.signedLength() - b.signedLength();
  }
  function sameSignature(a, b) {
    if (!a || !b)
      return a === b;
    return a.length === b.length;
  }
  function sameSignatures(a, b) {
    if (!a || !b)
      return a === b;
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; i++) {
      if (a[i].length !== b[i].length)
        return false;
    }
    return true;
  }
  function createCheckpointSignature(length, view, checkpoints) {
    return {
      length,
      core: view.core,
      ref: view.ref,
      signatures: new Array(checkpoints),
      partials: new Array(checkpoints)
    };
  }
  function addCheckpointSignatures(pending, checkpoints, index) {
    const { signer, signatures } = checkpoints[index];
    pending[0].signatures[index] = {
      signature: signatures.system.signature,
      length: signatures.system.length,
      signer
    };
    if (pending[1]) {
      pending[1].signatures[index] = {
        signature: signatures.encryption.signature,
        length: signatures.encryption.length,
        signer
      };
    }
    for (let i = 2;i < pending.length; i++) {
      if (!pending[i])
        continue;
      const { length, signature } = signatures.user[i - 2];
      pending[i].signatures[index] = {
        signature,
        length,
        signer
      };
    }
  }
  async function setPartialSignature(view, index) {
    const sig = view.signatures[index];
    if (sig.length < view.length && sig.length > 0)
      await view.core.get(sig.length - 1);
    view.partials[index] = await partialSignature(view.core, sig.signer, view.length, sig.length, sig.signature);
  }
  function updateSignature(length, sig, existing) {
    return sig ? { signature: sig.signature, length: sig.length, at: length } : existing;
  }
  function updateSignatures(length, signatures, existing) {
    const updated = new Array(signatures.length);
    for (let i = 0;i < updated.length; i++) {
      updated[i] = updateSignature(length, signatures[i], i < existing.length ? existing[i] : null);
    }
    return updated;
  }
  function makeCheckpoint(length, chk) {
    if (!chk)
      return null;
    const checkpointer = length - chk.at;
    return {
      checkpointer,
      checkpoint: checkpointer === 0 ? { signature: chk.signature, length: chk.length } : null
    };
  }
  function makeCheckpoints(length, signatures) {
    if (!signatures.length)
      return null;
    const checkpoints = new Array(signatures.length);
    for (let i = 0;i < signatures.length; i++) {
      checkpoints[i] = makeCheckpoint(length, signatures[i]);
    }
    return checkpoints;
  }
});

// node_modules/autobase/lib/boot.js
var require_boot = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var messages = require_messages3();
  module.exports = async function boot(corestore, key, { encrypt, encryptionKey, keyPair, exclusive = true } = {}) {
    const result = {
      key: null,
      local: null,
      bootstrap: null,
      encryptionKey: null,
      boot: null
    };
    const manifest = keyPair ? { version: corestore.manifestVersion, signers: [{ publicKey: keyPair.publicKey }] } : null;
    if (key) {
      result.key = key;
      const bootstrap = corestore.get({ key, active: false, valueEncoding: messages.OplogMessage });
      await bootstrap.ready();
      const localKey = await bootstrap.getUserData("autobase/local");
      if (keyPair) {
        result.local = corestore.get({ keyPair, active: false, exclusive, valueEncoding: messages.OplogMessage, manifest });
      } else {
        if (bootstrap.writable && !localKey) {
          result.local = bootstrap.session({ active: false, exclusive, valueEncoding: messages.OplogMessage });
        } else {
          const local = localKey ? corestore.get({ key: localKey, active: false, exclusive, valueEncoding: messages.OplogMessage }) : corestore.get({ name: "local", active: false, exclusive, valueEncoding: messages.OplogMessage });
          await local.ready();
          result.local = local;
        }
      }
      result.bootstrap = bootstrap;
    } else {
      result.local = keyPair ? corestore.get({ keyPair, manifest, active: false, exclusive, valueEncoding: messages.OplogMessage }) : corestore.get({ name: "local", active: false, exclusive, valueEncoding: messages.OplogMessage });
      await result.local.ready();
      const key2 = await result.local.getUserData("referrer");
      if (key2) {
        result.key = key2;
        result.bootstrap = corestore.get({ key: key2, active: false, valueEncoding: messages.OplogMessage });
        await result.bootstrap.ready();
      } else {
        result.key = result.local.key;
        result.bootstrap = result.local.session({ active: false, valueEncoding: messages.OplogMessage });
        await result.bootstrap.setUserData("autobase/local", result.local.key);
      }
    }
    if (key || keyPair) {
      await result.bootstrap.setUserData("referrer", result.key);
      await result.bootstrap.setUserData("autobase/local", result.local.key);
      await result.local.setUserData("referrer", result.key);
    }
    const [encryptionKeyBuffer, pointer] = await Promise.all([
      result.local.getUserData("autobase/encryption"),
      result.local.getUserData("autobase/boot")
    ]);
    if (pointer) {
      result.boot = c.decode(messages.BootRecord, pointer);
    }
    if (encryptionKeyBuffer) {
      result.encryptionKey = encryptionKeyBuffer;
    }
    if (!result.encryptionKey && (encryptionKey || encrypt)) {
      if (!encryptionKey)
        encryptionKey = (await corestore.createKeyPair("autobase/encryption")).secretKey.subarray(0, 32);
      await result.bootstrap.setUserData("autobase/encryption", encryptionKey);
      await result.local.setUserData("autobase/encryption", encryptionKey);
      result.encryptionKey = encryptionKey;
    }
    return result;
  };
});

// node_modules/autobase/index.js
var require_autobase2 = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var ReadyResource = require_ready_resource();
  var debounceify = require_debounceify();
  var c = require_compact_encoding();
  var safetyCatch = require_safety_catch();
  var hypercoreId = require_hypercore_id_encoding();
  var assert = require_nanoassert();
  var SignalPromise = require_signal_promise();
  var CoreCoupler = require_core_coupler();
  var mutexify = require_promise();
  var ProtomuxWakeup = require_protomux_wakeup();
  var rrp = require_resolve_reject_promise();
  var Hypercore = require_hypercore();
  var LocalState = require_local_state();
  var Linearizer = require_linearizer();
  var SystemView = require_system();
  var { EncryptionView } = require_encryption();
  var UpdateChanges = require_updates();
  var messages = require_messages3();
  var Timer = require_timer();
  var Writer = require_writer();
  var { encodeValue, decodeValue } = require_values();
  var ActiveWriters = require_active_writers();
  var AutoWakeup = require_wakeup();
  var FastForward = require_fast_forward();
  var AutoStore = require_store();
  var ApplyState = require_apply_state();
  var { PublicApplyCalls } = require_apply_calls();
  var boot = require_boot();
  var {
    MAX_AUTOBASE_VERSION,
    BOOT_RECORD_VERSION
  } = require_caps2();
  var inspect = Symbol.for("nodejs.util.inspect.custom");
  var INTERRUPT = new Error("Apply interrupted");
  var BINARY_ENCODING = c.from("binary");
  var RECOVERIES = 3;
  var FF_RECOVERY = 1;
  var DEFAULT_ACK_INTERVAL = 1e4;
  var DEFAULT_ACK_THRESHOLD = 4;
  var REMOTE_ADD_BATCH = 64;
  var MIN_FF_WAIT = 300000;

  class WakeupHandler {
    constructor(base, discoveryKey) {
      this.active = true;
      this.discoveryKey = discoveryKey;
      this.base = base;
    }
    onpeeractive(peer, session) {
      this.base._bumpWakeupPeer(peer);
    }
    onlookup(req, peer, session) {
      const wakeup = this.base._getWakeup();
      if (wakeup.length === 0)
        return;
      session.announce(peer, wakeup);
    }
    onannounce(wakeup, peer, session) {
      if (this.base.isFastForwarding()) {
        this.base._needsWakeupRequest = true;
        return;
      }
      this.base.hintWakeup(wakeup);
    }
  }
  module.exports = class Autobase extends ReadyResource {
    constructor(store, bootstrap, handlers = {}) {
      if (Array.isArray(bootstrap))
        bootstrap = bootstrap[0];
      if (bootstrap && typeof bootstrap !== "string" && !b4a.isBuffer(bootstrap)) {
        handlers = bootstrap;
        bootstrap = null;
      }
      super();
      const key = bootstrap ? toKey(bootstrap) : null;
      this.id = null;
      this.key = key;
      this.discoveryKey = null;
      this.keyPair = null;
      this.valueEncoding = c.from(handlers.valueEncoding || "binary");
      this.store = store;
      this.globalCache = store.globalCache || null;
      this.migrated = false;
      this.encrypted = handlers.encrypted || !!handlers.encryptionKey;
      this.encrypt = !!handlers.encrypt;
      this.encryptionKey = handlers.encryptionKey || null;
      this.encryption = null;
      this.local = null;
      this.localWriter = null;
      this.isIndexer = false;
      this.activeWriters = new ActiveWriters;
      this.linearizer = null;
      this.updating = false;
      this.nukeTip = !!handlers.nukeTip;
      this.wakeupOwner = !handlers.wakeup;
      this.wakeupCapability = null;
      this.wakeupProtocol = handlers.wakeup || new ProtomuxWakeup;
      this.wakeupSession = null;
      this._primaryBootstrap = null;
      this.fastForwardEnabled = handlers.fastForward !== false;
      this.fastForwarding = null;
      this.fastForwardTo = null;
      this.fastForwardFailedAt = 0;
      this.fastForwardMinimum = FastForward.MINIMUM;
      this._bootstrapWriters = [];
      this._bootstrapWritersChanged = false;
      this._flushSignal = new SignalPromise;
      this._flushing = 0;
      this._checkWriters = [];
      this._optimistic = -1;
      this._appended = 0;
      this._appending = null;
      this._wakeup = new AutoWakeup(this);
      this._wakeupHints = new Map;
      this._wakeupPeerBound = this._wakeupPeer.bind(this);
      this._coupler = null;
      this._updateLocalCore = null;
      this._lock = mutexify();
      this._needsWakeupRequest = false;
      this._needsWakeup = true;
      this._needsWakeupHeads = true;
      this._updates = [];
      this._handlers = handlers || {};
      this._warn = emitWarning.bind(this);
      this._draining = false;
      this._writable = null;
      this._advancing = null;
      this._interrupting = false;
      this._caughtup = false;
      this.paused = false;
      this._bump = debounceify(() => {
        this._advancing = this._advance();
        return this._advancing;
      });
      this._onremotewriterchangeBound = this._onremotewriterchange.bind(this);
      this._onlocalwriterchangeBound = this._onlocalwriterchange.bind(this);
      this._preopen = null;
      this._hasOpen = !!this._handlers.open;
      this._hasApply = !!this._handlers.apply;
      this._hasOptimisticApply = !!this._handlers.optimistic;
      this._hasUpdate = !!this._handlers.update;
      this._hasClose = !!this._handlers.close;
      this._viewStore = new AutoStore(this);
      this._applyState = null;
      this.view = null;
      this.core = null;
      this.version = -1;
      this.interrupted = null;
      this.recoveries = RECOVERIES;
      const {
        ackInterval = DEFAULT_ACK_INTERVAL,
        ackThreshold = DEFAULT_ACK_THRESHOLD
      } = handlers;
      this._ackInterval = ackInterval;
      this._ackThreshold = ackThreshold;
      this._ackTickThreshold = ackThreshold;
      this._ackTick = 0;
      this._ackTimer = null;
      this._acking = false;
      this._waiting = new SignalPromise;
      this._bootRecovery = false;
      this.view = this._hasOpen ? this._handlers.open(this._viewStore, new PublicApplyCalls(this)) : null;
      this.core = this._viewStore.get({ name: "_system" });
      if (this.fastForwardEnabled && isObject(handlers.fastForward)) {
        this._runFastForward(new FastForward(this, handlers.fastForward.key, { verified: false })).catch(noop);
      }
      this.ready().catch(safetyCatch);
    }
    [inspect](depth, opts) {
      let indent = "";
      if (typeof opts.indentationLvl === "number") {
        while (indent.length < opts.indentationLvl)
          indent += " ";
      }
      return indent + "Autobase { ... }";
    }
    get bootstrap() {
      return this.key;
    }
    get bootstraps() {
      return [this.bootstrap];
    }
    get writable() {
      return this.localWriter !== null && !this.localWriter.isRemoved;
    }
    get ackable() {
      return this.localWriter !== null && this.localWriter.isActiveIndexer;
    }
    get signedLength() {
      return this.core.signedLength;
    }
    get indexedLength() {
      return this._applyState ? this._applyState.indexedLength : 0;
    }
    get length() {
      return this.core.length;
    }
    get flushing() {
      return this._flushing > 0;
    }
    hash() {
      return this.core.treeHash();
    }
    getSystemKey() {
      return this.core.key;
    }
    get system() {
      return this._applyState && this._applyState.system;
    }
    async getIndexedInfo() {
      if (this.opened === false)
        await this.ready();
      return this._applyState && this._applyState.system.getIndexedInfo(this._applyState.indexedLength);
    }
    _isActiveIndexer() {
      return this.localWriter ? this.localWriter.isActiveIndexer : false;
    }
    replicate(isInitiator, opts) {
      const stream = this.store.replicate(isInitiator, opts);
      this.wakeupProtocol.addStream(stream);
      return stream;
    }
    heads() {
      if (!this._applyState || !this._applyState.opened)
        return [];
      const nodes = new Array(this._applyState.system.heads.length);
      for (let i = 0;i < this._applyState.system.heads.length; i++)
        nodes[i] = this._applyState.system.heads[i];
      return nodes.sort(compareNodes);
    }
    hintWakeup(hints) {
      if (!Array.isArray(hints))
        hints = [hints];
      for (const { key, length } of hints) {
        const hex = b4a.toString(key, "hex");
        const prev = this._wakeupHints.get(hex);
        if (!prev || length === -1 || prev < length)
          this._wakeupHints.set(hex, length);
      }
      this._queueBump();
    }
    _queueBump() {
      this._bump().catch(safetyCatch);
    }
    async _runPreOpen() {
      if (this._handlers.wait)
        await this._handlers.wait();
      await this.store.ready();
      this.keyPair = await this._handlers.keyPair || null;
      const result = await boot(this.store, this.key, {
        encryptionKey: this.encryptionKey,
        encrypt: this.encrypt,
        keyPair: this.keyPair
      });
      const pointer = await result.local.getUserData("autobase/boot");
      if (pointer) {
        const { recoveries } = c.decode(messages.BootRecord, pointer);
        this.recoveries = recoveries;
      }
      this._primaryBootstrap = result.bootstrap;
      this.local = result.local;
      this.key = result.bootstrap.key;
      this.discoveryKey = result.bootstrap.discoveryKey;
      this.id = result.bootstrap.id;
      this.encryptionKey = result.encryptionKey;
      if (this.encrypted) {
        assert(this.encryptionKey !== null, "Encryption key is expected");
      }
      if (this.encryptionKey) {
        this.encryption = new EncryptionView(this, null);
        this.local.setEncryption(this.getWriterEncryption());
        this._primaryBootstrap.setEncryption(this.getWriterEncryption());
      }
      if (this.nukeTip)
        await this._nukeTip();
      this.local.on("append", this._onlocalwriterchangeBound);
      this.wakeupCapability = await this._handlers.wakeupCapability || { key: this.key, discoveryKey: this.discoveryKey };
      this.setWakeup(this.wakeupCapability.key, this.wakeupCapability.discoveryKey);
    }
    async _nukeTipBatch(key, length) {
      const core = this.store.get({ key, active: false });
      await core.ready();
      const batch = core.session({ name: "batch" });
      await batch.ready();
      if (batch.length > length)
        await batch.truncate(length);
      await batch.close();
      await core.close();
    }
    async _nukeTip() {
      const pointer = await this.local.getUserData("autobase/boot");
      if (!pointer)
        return;
      const boot2 = c.decode(messages.BootRecord, pointer);
      await LocalState.clear(this.local);
      await this._nukeTipBatch(boot2.key, boot2.systemLength);
      const core = this.store.get({ key: boot2.key, active: false, encryption: null });
      const encCore = await EncryptionView.setSystemEncryption(this, core);
      const batch = core.session({ name: "batch" });
      await batch.ready();
      const info = await SystemView.getIndexedInfo(batch, boot2.systemLength);
      await batch.close();
      for (const view of info.views) {
        await this._nukeTipBatch(view.key, view.length);
      }
      if (boot2.heads)
        this.hintWakeup(boot2.heads);
      if (this.local.length)
        this.hintWakeup([{ key: this.local.key, length: this.local.length }]);
      await core.close();
      if (encCore)
        await encCore.close();
    }
    _bumpWakeupPeer(peer) {
      if (this._coupler)
        this._coupler.update(peer.stream);
    }
    async _rotateLocalWriter(newLocal) {
      assert(!this.writable, "Cannot rotate a newLocal writer if a current one is open");
      const oldLocal = this.local;
      if (this._applyState)
        await this._applyState.close();
      this.local = newLocal;
      this.local.on("append", this._onlocalwriterchangeBound);
      this.localWriter = null;
      this._updateLocalCore = null;
      const store = this._viewStore.atomize();
      const local = store.getLocal();
      await local.ready();
      await LocalState.moveTo(oldLocal, local);
      await local.setUserData("referrer", this.key);
      if (this.encryptionKey)
        await local.setUserData("autobase/encryption", this.encryptionKey);
      await store.flush();
      await store.close();
      await this._primaryBootstrap.setUserData("autobase/local", local.key);
      await this._clearWriters();
      await oldLocal.close();
      await this._viewStore.updateLocal();
      await this._clearWriters();
      this._applyState = new ApplyState(this);
      await this._applyState.ready();
      await this._makeLinearizerFromViewState();
      this._caughtup = false;
      this._rebooted();
    }
    async setLocal(key, { keyPair } = {}) {
      if (!this.opened)
        await this.ready();
      const manifest = keyPair ? { version: this.store.manifestVersion, signers: [{ publicKey: keyPair.publicKey }] } : null;
      if (!key)
        key = Hypercore.key(manifest);
      if (b4a.equals(key, this.local.key))
        return;
      const encryption = this.encryptionKey ? this.getWriterEncryption() : null;
      const local = this.store.get({ key, manifest, active: false, exclusive: true, encryption, valueEncoding: messages.OplogMessage });
      await local.ready();
      this._updateLocalCore = local;
      await this._bump();
    }
    setWakeup(cap, discoveryKey) {
      if (this.wakeupSession)
        this.wakeupSession.destroy();
      if (!discoveryKey && b4a.equals(cap, this.key))
        discoveryKey = this.discoveryKey;
      this.wakeupSession = this.wakeupProtocol.session(cap, new WakeupHandler(this, discoveryKey || null));
      for (const peer of this.wakeupSession.peers) {
        if (peer.active)
          this._bumpWakeupPeer(peer);
      }
    }
    async _getMigrationPointer(key, length) {
      const core = this.store.get({ key, active: false, encryption: null });
      const encCore = await EncryptionView.setSystemEncryption(this, core);
      const min = core.manifest && core.manifest.prologue ? core.manifest.prologue.length : 0;
      for (let i = length - 1;i >= min; i--) {
        if (!await core.has(i))
          continue;
        const sys = new SystemView(core, { checkout: i + 1 });
        await sys.ready();
        let good = true;
        for (const v of sys.views) {
          const vc = this.store.get({ key: v.key, active: false });
          await vc.ready();
          if (vc.length < v.length)
            good = false;
          await vc.close();
        }
        await sys.close();
        if (!good)
          continue;
        return i + 1;
      }
      await core.close();
      if (encCore)
        await encCore.close();
      return min;
    }
    async _migrate6(key, length) {
      const core = this.store.get({ key, active: false });
      await core.ready();
      const batch = core.session({ name: "batch", overwrite: true, checkout: length });
      await batch.ready();
      await batch.close();
      await core.close();
    }
    async _getSystemInfo() {
      const boot2 = await this._getBootRecord();
      if (!boot2.key)
        return null;
      const migrated = !!boot2.heads;
      const indexedLength = boot2.systemLength;
      if (migrated) {
        await this._migrate6(boot2.key, indexedLength);
      }
      const core = this.store.get({ key: boot2.key, encryption: null, active: false });
      await core.ready();
      const batch = core.session({ name: "batch" });
      const encCore = await EncryptionView.setSystemEncryption(this, batch);
      const info = await SystemView.getIndexedInfo(batch, indexedLength);
      if (encCore)
        await encCore.close();
      await batch.close();
      await core.close();
      if (info.version > MAX_AUTOBASE_VERSION) {
        throw new Error("Autobase upgrade required.");
      }
      if (migrated) {
        this.migrated = true;
        for (const view of info.views) {
          await this._migrate6(view.key, view.length);
        }
        if (boot2.heads)
          this.hintWakeup(boot2.heads);
        if (this.local.length)
          this.hintWakeup([{ key: this.local.key, length: this.local.length }]);
      }
      return {
        key: boot2.key,
        indexers: info.indexers,
        views: info.views,
        entropy: info.entropy
      };
    }
    async _getBootRecord() {
      await this._preopen;
      const pointer = await this.local.getUserData("autobase/boot");
      const boot2 = pointer ? c.decode(messages.BootRecord, pointer) : { version: BOOT_RECORD_VERSION, key: null, systemLength: 0, indexersUpdated: false, fastForwarding: false, recoveries: RECOVERIES, heads: null };
      if (boot2.heads) {
        const len = await this._getMigrationPointer(boot2.key, boot2.systemLength);
        if (len !== boot2.systemLength)
          this._warn(new Error("Invalid pointer in migration, correcting (" + len + " vs " + boot2.systemLength + ")"));
        boot2.systemLength = len;
      }
      return boot2;
    }
    static async getBootRecord(store, key) {
      const result = await boot(store, key, { exclusive: false });
      await result.bootstrap.close();
      await result.local.close();
      return result.boot;
    }
    _interrupt(reason) {
      assert(!!this._applyState.applying, "Interrupt is only allowed in apply");
      this._interrupting = true;
      if (reason)
        this.interrupted = reason;
      throw INTERRUPT;
    }
    async flush() {
      if (this._flushing === 0)
        return;
      return this._flushSignal.wait();
    }
    async advance() {
      if (this.opened === false)
        await this.ready();
      await this._advancing;
    }
    recouple() {
      if (this._coupler)
        this._coupler.destroy();
      const core = this._viewStore.getSystemCore();
      this._coupler = new CoreCoupler(core, this._wakeupPeerBound);
    }
    _updateBootstrapWriters() {
      const writers = this.linearizer.getBootstrapWriters();
      for (const writer of this._bootstrapWriters) {
        writer.isBootstrap = false;
        writer.isCoupled = false;
      }
      for (const writer of writers) {
        writer.isCoupled = true;
        writer.setBootstrap(true);
      }
      for (const writer of this._bootstrapWriters) {
        if (writer.isBootstrap === false)
          writer.setBootstrap(false);
      }
      this._bootstrapWriters = writers;
      this._bootstrapWritersChanged = false;
    }
    async _openLinearizer() {
      if (this._applyState.system.bootstrapping) {
        await this._makeLinearizer(null);
        this._bootstrapLinearizer();
        return;
      }
      await this._makeLinearizerFromViewState();
    }
    async _catchupApplyState() {
      if (await this._applyState.shouldMigrate()) {
        await this._migrate();
      } else {
        await this._applyState.catchup(this.linearizer);
      }
      this._caughtup = true;
    }
    async _open() {
      this._preopen = this._runPreOpen();
      await this._preopen;
      if (this.closing)
        return;
      this._applyState = new ApplyState(this);
      try {
        await this._applyState.ready();
      } catch (err) {
        if (this.closing)
          return;
        try {
          await this._applyState.close();
        } catch {}
        try {
          await this.core.ready();
        } catch {}
        this._applyState = null;
        if (this.closing)
          return;
        this._warn(new Error("Failed to boot due to: " + err.message));
        if (this.recoveries < RECOVERIES) {
          this._bootRecovery = true;
          this._queueBump();
          return;
        }
        throw err;
      }
      try {
        await this._openLinearizer();
        await this.core.ready();
        await this._wakeup.ready();
      } catch (err) {
        if (this.closing)
          return;
        throw err;
      }
      if (this.core.length - this._applyState.indexedLength > this._ackTickThreshold) {
        this._ackTick = this._ackTickThreshold;
      }
      if (this.localWriter && this._ackInterval) {
        this._startAckTimer();
      }
      this._updateBootstrapWriters();
      this.recouple();
      this._queueFastForward();
      this._queueBump();
    }
    async _close() {
      await this.flush();
      this._interrupting = true;
      await Promise.resolve();
      if (this.wakeupSession)
        this.wakeupSession.destroy();
      if (this.wakeupOwner)
        this.wakeupProtocol.destroy();
      if (this.fastForwarding)
        await this.fastForwarding.close();
      if (this._coupler)
        this._coupler.destroy();
      this._coupler = null;
      this._waiting.notify(null);
      await this.activeWriters.clear();
      const closing = this._advancing ? this._advancing.catch(safetyCatch) : null;
      await this._clearWriters();
      if (this._primaryBootstrap)
        await this._primaryBootstrap.close();
      await this.local.close();
      if (this._ackTimer) {
        this._ackTimer.stop();
        await this._ackTimer.flush();
      }
      await this._wakeup.close();
      if (this._hasClose)
        await this._handlers.close(this.view);
      if (this._applyState)
        await this._applyState.close();
      await this._viewStore.close();
      await this.core.close();
      await this.store.close();
      if (this._writable)
        this._writable.resolve(false);
      await closing;
    }
    _onError(err) {
      if (this.closing)
        return;
      if (err === INTERRUPT) {
        this.emit("interrupt", this.interrupted);
        this.emit("update");
        return;
      }
      this.close().catch(safetyCatch);
      if (ReadyResource.listenerCount(this, "error") === 0) {
        crashSoon(err);
        return;
      }
      this.emit("error", err);
    }
    async _closeWriter(w) {
      this.activeWriters.delete(w);
      await w.close();
    }
    async _gcWriters() {
      if (this._checkWriters.length === 0)
        return;
      while (this._checkWriters.length > 0) {
        const w = this._checkWriters.pop();
        w.updateActivity();
        if (!w.flushed())
          continue;
        const unqueued = this._wakeup.unqueue(w.core.key, w.core.length);
        if (!unqueued || w.isActiveIndexer)
          continue;
        if (this.localWriter === w)
          continue;
        await this._closeWriter(w);
      }
      await this._wakeup.flush();
    }
    _startAckTimer() {
      if (this._ackTimer)
        return;
      this._ackTimer = new Timer(this._backgroundAck.bind(this), this._ackInterval);
      this._bumpAckTimer();
    }
    _bumpAckTimer() {
      if (!this._ackTimer)
        return;
      this._ackTimer.bump();
    }
    async update() {
      if (this.opened === false)
        await this.ready();
      try {
        await this._bump();
        if (this._acking)
          await this._bump();
      } catch (err) {
        if (this._interrupting)
          return;
        throw err;
      }
    }
    async _onremotewriterchange() {
      this._bumpAckTimer();
      try {
        await this._bump();
      } catch {}
    }
    _onlocalwriterchange() {
      if (!this.localWriter || this.localWriter.isRemoved)
        this._queueBump();
    }
    _onwakeup() {
      this._needsWakeup = true;
      this._queueBump();
    }
    isFastForwarding() {
      if (this.fastForwardTo !== null)
        return true;
      return this.fastForwardEnabled && this.fastForwarding !== null;
    }
    _backgroundAck() {
      return this.ack(true);
    }
    async ack(bg = false) {
      if (this.opened === false)
        await this.ready();
      if (this.localWriter === null || this._acking || this._interrupting || this._appending !== null)
        return;
      if (this._applyState === null) {
        try {
          await this._bump();
        } catch {}
        if (this._applyState === null || this._interrupting)
          return;
      }
      const applyState = this._applyState;
      if (applyState.opened === false)
        await applyState.ready();
      const isPendingIndexer = applyState.isLocalPendingIndexer();
      if (!isPendingIndexer && this.isFastForwarding() || this._interrupting)
        return;
      const isIndexer = applyState.isLocalIndexer() || isPendingIndexer;
      if (!isIndexer)
        return;
      this._acking = true;
      try {
        await this._bump();
      } catch (err) {
        if (!this._interrupting)
          throw err;
      }
      if (this._interrupting || !this.localWriter || this.localWriter.closed) {
        this._acking = false;
        return;
      }
      if (this._ackTimer && bg)
        await this._ackTimer.asapStandalone();
      if (this._interrupting) {
        this._acking = false;
        return;
      }
      const alwaysWrite = isPendingIndexer || this._applyState.shouldWrite();
      if (alwaysWrite || this.linearizer.shouldAck(this.localWriter, false)) {
        try {
          if (this.localWriter && !this.localWriter.closed)
            await this.append(null);
        } catch (err) {
          if (!this._interrupting)
            throw err;
        }
      }
      if (!this._interrupting) {
        this._updateAckThreshold();
        this._bumpAckTimer();
      }
      this._acking = false;
    }
    views() {
      if (this._applyState)
        return this._applyState.store.listViews();
      return this._viewStore.listViews();
    }
    async append(value, opts) {
      if (this.opened === false)
        await this.ready();
      if (this._advancing !== null)
        await this._advancing;
      if (this._interrupting)
        throw new Error("Autobase is closing");
      if (value && this.valueEncoding !== BINARY_ENCODING)
        value = normalize(this.valueEncoding, value);
      const optimistic = !!opts && !!opts.optimistic && !!value;
      if (!optimistic && (this.localWriter === null || this.localWriter.isRemoved && value !== null)) {
        throw new Error("Not writable");
      }
      if (this._appending === null)
        this._appending = [];
      let len = 0;
      if (Array.isArray(value)) {
        for (const v of value)
          len = this._append(v);
      } else {
        len = this._append(value);
      }
      const localLength = this.local.length;
      if (optimistic)
        this._optimistic = this._appending.length - 1;
      const target = this._appended + this._appending.length;
      if (this._advancing)
        await this._advancing;
      let runs = 0;
      while (this._appended < target && !this._interrupting) {
        await this._bump();
        if (runs++ >= 16 && this.localWriter && this.localWriter.idle())
          break;
      }
      if (this._advancing)
        await this._advancing;
      return localLength + len;
    }
    _append(value) {
      if (this._appending.length > 0) {
        if (value === null)
          return this._appending.length;
        if (this._appending[this._appending.length - 1] === null) {
          this._appending.pop();
        }
      }
      return this._appending.push(value);
    }
    static decodeValue(value, opts) {
      return decodeValue(value, opts);
    }
    static encodeValue(value, opts) {
      return encodeValue(value, opts);
    }
    static async getLocalKey(store, opts = {}) {
      const core = opts.keyPair ? store.get({ ...opts, active: false }) : store.get({ ...opts, name: "local", active: false });
      await core.ready();
      const key = core.key;
      await core.close();
      return key;
    }
    static getLocalCore(store, handlers, encryptionKey) {
      const encryption = !encryptionKey ? null : { key: encryptionKey };
      const opts = { ...handlers, compat: false, active: false, exclusive: true, valueEncoding: messages.OplogMessage, encryption };
      return opts.keyPair ? store.get(opts) : store.get({ ...opts, name: "local" });
    }
    static async getUserData(core) {
      const view = await core.getUserData("autobase/view");
      return {
        referrer: await core.getUserData("referrer"),
        view: view ? b4a.toString(view) : null
      };
    }
    static async isAutobase(core, opts = {}) {
      const block = await core.get(0, opts);
      if (!block)
        throw new Error("Core is empty.");
      if (!b4a.isBuffer(block))
        return isAutobaseMessage(block);
      try {
        const m = c.decode(messages.OplogMessage, block);
        return isAutobaseMessage(m);
      } catch {
        return false;
      }
    }
    async setUserData(key, val) {
      await this._preopen;
      const core = this._primaryBootstrap === null ? this.local : this._primaryBootstrap;
      await core.setUserData(key, val);
    }
    async getUserData(key) {
      await this._preopen;
      const core = this._primaryBootstrap === null ? this.local : this._primaryBootstrap;
      return await core.getUserData(key);
    }
    _needsLocalWriter() {
      return this.localWriter === null || this.localWriter.closed;
    }
    async _getWriterByKey(key, len, seen, allowGC, isAdded, system) {
      assert(this._draining === true || this.opening && !this.opened || this._optimistic > -1);
      const release = await this._lock();
      if (this._interrupting) {
        release();
        throw new Error("Autobase is closing");
      }
      try {
        let w = this.activeWriters.get(key);
        const alreadyActive = !!w;
        const sys = system || this._applyState.system;
        const writerInfo = await sys.get(key);
        if (len === -1) {
          if (!allowGC && writerInfo === null) {
            if (w)
              w.isRemoved = !isAdded;
            return null;
          }
          len = writerInfo === null ? 0 : writerInfo.length;
        }
        const isActive = writerInfo !== null && (isAdded || !writerInfo.isRemoved);
        const isRemoved = !isActive;
        if (w) {
          w.isRemoved = isRemoved;
        } else {
          w = this._makeWriter(key, len, isActive, isRemoved);
          if (!w)
            return null;
        }
        if (isRemoved && sys.bootstrapping && b4a.equals(w.core.key, this.key)) {
          w.isRemoved = false;
        }
        if (this._isLocalCore(w.core) && this._needsLocalWriter()) {
          this._setLocalWriter(w);
        }
        w.seen(seen);
        if (alreadyActive)
          return w;
        await w.ready();
        if (this._isLocalCore(w.core) && this._needsLocalWriter()) {
          this._setLocalWriter(w);
        }
        if (allowGC && w.flushed()) {
          this._wakeup.unqueue(key, len);
          if (w !== this.localWriter) {
            await w.close();
            return w;
          }
        }
        this.activeWriters.add(w);
        this._checkWriters.push(w);
        assert(w.opened);
        assert(!w.closed);
        w.updateActivity();
        return w;
      } finally {
        release();
      }
    }
    _updateAll() {
      const p = [];
      for (const w of this.activeWriters)
        p.push(w.update(null).catch(this._warn));
      return Promise.all(p);
    }
    getWriterEncryption() {
      if (!this.encryptionKey)
        return null;
      return this.encryption.getWriterEncryption();
    }
    _makeWriterCore(key) {
      if (this.closing)
        throw new Error("Autobase is closing");
      if (this._interrupting)
        throw INTERRUPT();
      const local = b4a.equals(key, this.local.key);
      const encryption = this.getWriterEncryption();
      const core = local ? this.local.session({ valueEncoding: messages.OplogMessage, encryption, active: false }) : this.store.get({ key, compat: false, writable: false, valueEncoding: messages.OplogMessage, encryption, active: false });
      return core;
    }
    _makeWriter(key, length, isActive, isRemoved) {
      const core = this._makeWriterCore(key);
      const w = new Writer(this, core, length, isRemoved);
      if (this._isLocalCore(core)) {
        if (isActive)
          this._setLocalWriter(w);
        return w;
      }
      core.on("append", this._onremotewriterchangeBound);
      core.on("download", this._onremotewriterchangeBound);
      core.on("manifest", this._onremotewriterchangeBound);
      return w;
    }
    _updateLinearizer(indexers, heads) {
      for (const w of this.activeWriters)
        w.isActiveIndexer = false;
      if (this.localWriter)
        this.localWriter.isActiveIndexer = false;
      for (const writer of indexers)
        writer.isActiveIndexer = true;
      if (this._isActiveIndexer() && !this.isIndexer) {
        this._setLocalIndexer();
      } else if (!this._isActiveIndexer() && this.isIndexer) {
        this._clearLocalIndexer();
      }
      this.linearizer = new Linearizer(indexers, { heads, writers: this.activeWriters });
      this._updateAckThreshold();
    }
    async _updateLocalWriter(sys) {
      if (this.localWriter !== null && !this.localWriter.closed)
        return;
      await this._getWriterByKey(this.local.key, -1, 0, true, false, sys);
    }
    async _bootstrapLinearizer() {
      const bootstrap = this._makeWriter(this.key, 0, true, false);
      this.activeWriters.add(bootstrap);
      this._checkWriters.push(bootstrap);
      await bootstrap.ready();
      this._ensureWakeup(bootstrap);
      this._updateLinearizer([bootstrap], []);
    }
    async _makeLinearizer(sys) {
      if (sys === null) {
        return this._bootstrapLinearizer();
      }
      if (this.opened || await sys.hasLocal(this.local.key)) {
        await this._updateLocalWriter(sys);
      }
      const indexers = [];
      for (const head of sys.indexers) {
        const writer = await this._getWriterByKey(head.key, head.length, 0, false, false, sys);
        indexers.push(writer);
      }
      if (!this._isActiveIndexer()) {
        for (const key of sys.pendingIndexers) {
          if (b4a.equals(key, this.local.key)) {
            this._setLocalIndexer();
            break;
          }
        }
      }
      this._updateLinearizer(indexers, sys.heads);
      for (const { key, length } of sys.heads) {
        await this._getWriterByKey(key, length, 0, false, false, sys);
      }
    }
    async _clearWriters() {
      await this.activeWriters.clear();
      if (this.localWriter !== null)
        await this.localWriter.close();
      this._checkWriters = [];
    }
    async _makeLinearizerFromViewState() {
      const sys = await this._applyState.getIndexedSystem();
      await this._makeLinearizer(sys);
      await sys.close();
    }
    async _recoverMaybe() {
      if (!this._applyState) {
        if (!this._bootRecovery)
          return;
        await this._runFastForward(new FastForward(this, this.core.key, { force: true }));
        this._queueBump();
        return;
      }
      this._bootRecovery = false;
      const ff = await this._applyState.recoverAt();
      if (!ff || this.fastForwardTo)
        return;
      this.fastForwardTo = ff;
      this._queueBump();
    }
    async _applyFastForward() {
      if (!this.fastForwardTo.force && this.fastForwardTo.length < this.core.length + this.fastForwardTo.minimum) {
        this.fastForwardTo = null;
        this._updateActivity();
        return;
      }
      this._flushing++;
      try {
        const changes = this._hasUpdate ? new UpdateChanges(this) : null;
        if (changes)
          changes.track(this._applyState);
        if (this._applyState)
          await this._applyState.close();
        const {
          key,
          length,
          views,
          indexers,
          manifestVersion,
          entropy
        } = this.fastForwardTo;
        const from = this.core.signedLength;
        const store = this._viewStore.atomize();
        const ffed = new Set;
        const migrated = !b4a.equals(key, this.core.key);
        const systemRef = await this._viewStore.findViewByKey(key, indexers, manifestVersion, entropy);
        ffed.add(systemRef);
        if (migrated) {
          await this._applyFastForwardMigration(systemRef, { key, length });
        } else {
          await systemRef.catchup(store.atom, length);
        }
        for (const v of views) {
          const ref = await this._viewStore.findViewByKey(v.key, indexers, manifestVersion, entropy);
          if (!ref)
            continue;
          ffed.add(ref);
          if (migrated) {
            await this._applyFastForwardMigration(ref, v);
          } else {
            await ref.catchup(store.atom, v.length);
          }
        }
        if (migrated) {
          const manifests = await this._viewStore.getIndexerManifests(indexers);
          for (const [name, ref] of this._viewStore.byName) {
            if (ffed.has(ref))
              continue;
            await this._migrateView(manifests, null, name, 0, manifestVersion, entropy, [], null);
          }
        }
        const value = c.encode(messages.BootRecord, {
          version: BOOT_RECORD_VERSION,
          key,
          systemLength: length,
          indexersUpdated: false,
          fastForwarding: true,
          recoveries: RECOVERIES
        });
        const local = store.getLocal();
        await local.ready();
        await local.setUserData("autobase/boot", value);
        await LocalState.clear(local);
        if (changes)
          changes.finalise();
        await store.flush();
        await store.close();
        const to = this.core.signedLength;
        for (const ref of ffed)
          await ref.release();
        this.recoveries = RECOVERIES;
        this.fastForwardTo = null;
        this._queueFastForward();
        await this._clearWriters();
        this._applyState = new ApplyState(this);
        await this._applyState.ready();
        if (changes)
          await this._handlers.update(this._applyState.view, changes);
        if (await this._applyState.shouldMigrate()) {
          await this._migrate();
        } else {
          await this._makeLinearizerFromViewState();
          await this._applyState.catchup(this.linearizer);
        }
        if (!this.localWriter || this.localWriter.closed) {
          await this._updateLocalWriter(this._applyState.system);
        }
        this._caughtup = true;
        this._rebooted();
        this.emit("fast-forward", to, from);
      } finally {
        if (--this._flushing === 0)
          this._flushSignal.notify();
      }
    }
    async _applyFastForwardMigration(ref, v) {
      const next = this.store.get(v.key);
      await next.ready();
      const prologue = next.manifest && next.manifest.prologue;
      if (prologue && prologue.length > 0 && ref.core.length >= prologue.length) {
        try {
          await next.core.copyPrologue(ref.core.state);
        } catch {}
      }
      const batch = next.session({ name: "batch", overwrite: true, checkout: v.length });
      await batch.ready();
      await ref.batch.state.moveTo(batch, batch.length);
      await batch.close();
      ref.migrated(this, next);
    }
    async _migrateView(indexerManifests, source, name, indexedLength, manifestVersion, entropy, linked, manifestData) {
      const ref = this._viewStore.byName.get(name);
      const prologue = indexedLength === 0 ? null : { length: indexedLength, hash: await source.treeHash(indexedLength) };
      if (manifestData === null && ref.core.manifest.userData !== null) {
        manifestData = ref.core.manifest.userData;
      }
      const next = this._viewStore.getViewCore(indexerManifests, name, prologue, manifestVersion, entropy, linked, manifestData);
      await next.ready();
      if (indexedLength > 0) {
        await next.core.copyPrologue(source.state);
      }
      const batch = next.session({ name: "batch", overwrite: true, checkout: indexedLength });
      await batch.ready();
      if (source !== null) {
        while (batch.length < source.length) {
          await batch.append(await source.get(batch.length));
        }
      }
      await ref.batch.state.moveTo(batch, batch.length);
      await batch.close();
      ref.migrated(this, next);
      return ref;
    }
    async _premigrate() {
      this._flushing++;
      try {
        const length = this._applyState.indexedLength;
        const system = this._applyState.system;
        const info = await system.getIndexedInfo(length);
        const indexerManifests = await this._viewStore.getIndexerManifests(info.indexers);
        const { views, systemView, encryptionView } = this._applyState;
        const manifestVersion = this._applyState.system.core.manifest.version;
        for (const view of views) {
          const v = this._applyState.getViewFromSystem(view, info);
          const indexedLength = v ? v.length : 0;
          const ref2 = this._viewStore.getViewByName(view.name);
          const source2 = ref2.getCore();
          await source2.ready();
          await this._migrateView(indexerManifests, source2, view.name, indexedLength, manifestVersion, info.entropy, null, null);
        }
        const source = encryptionView.ref.getCore();
        await source.ready();
        const enc = await this._migrateView(indexerManifests, source, "_encryption", info.encryptionLength, manifestVersion, info.entropy, null, null);
        const linked = [enc.core.key];
        const sysCore = systemView.ref.getCore();
        const ref = await this._migrateView(indexerManifests, sysCore, "_system", length, manifestVersion, info.entropy, linked, null, null);
        return ref.core.key;
      } finally {
        if (--this._flushing === 0)
          this._flushSignal.notify();
      }
    }
    async _migrate() {
      return this._reboot(await this._premigrate());
    }
    async _reboot(key) {
      await this._clearWriters();
      await this._makeLinearizerFromViewState();
      await this._applyState.finalize(key);
      this._applyState = new ApplyState(this);
      await this._applyState.ready();
      await this._applyState.catchup(this.linearizer);
      this._queueFastForward();
      this._rebooted();
    }
    _rebooted() {
      this.recouple();
      this._updateActivity();
      this.emit("reboot");
      this._bootstrapWritersChanged = true;
      this._needsWakeup = true;
      this.updating = true;
      this._queueBump();
    }
    _setLocalWriter(w) {
      this.localWriter = w;
      if (this._ackInterval)
        this._startAckTimer();
    }
    _unsetLocalWriter() {
      if (!this.localWriter)
        return;
      this._closeWriter(this.localWriter);
      if (this.localWriter.isActiveIndexer)
        this._clearLocalIndexer();
      this.localWriter = null;
    }
    _setLocalIndexer() {
      assert(this.localWriter !== null);
      this.isIndexer = true;
      this.emit("is-indexer");
    }
    _clearLocalIndexer() {
      assert(this.localWriter !== null);
      if (this._ackTimer)
        this._ackTimer.stop();
      this.isIndexer = false;
      this._ackTimer = null;
      this.emit("is-non-indexer");
    }
    _isLocalCore(core) {
      return core.writable && core.id === this.local.id;
    }
    _addLocalHeads() {
      if (!this.localWriter || this.localWriter.closed)
        return null;
      if (!this.localWriter.idle())
        return null;
      const length = this._optimistic === -1 ? this._appending.length : this._optimistic || 1;
      const nodes = new Array(length);
      for (let i = 0;i < length; i++) {
        const heads = this.linearizer.getHeads();
        const deps = new Set(this.linearizer.heads);
        const batch = this._appending.length - i;
        const value = this._appending[i];
        const node = this.localWriter.append(value, heads, batch, deps, this._optimistic === 0);
        this.linearizer.addHead(node);
        nodes[i] = node;
      }
      return nodes;
    }
    _flushLocalHeads(length) {
      this._appending = length === this._appending.length ? null : this._appending.slice(length);
      this._appended += length;
      if (this._optimistic > -1 && this._optimistic < length)
        this._optimistic = -1;
    }
    async _addRemoteHeads() {
      let added = 0;
      while (added < REMOTE_ADD_BATCH) {
        await this._updateAll();
        let advanced = 0;
        for (const w of this.activeWriters) {
          let node = w.advance();
          if (node === null)
            continue;
          advanced += node.batch;
          while (true) {
            this.linearizer.addHead(node);
            if (node.batch === 1)
              break;
            node = w.advance();
          }
        }
        if (advanced === 0)
          break;
        added += advanced;
      }
      return added;
    }
    async _drain() {
      const writable = this.writable;
      while (!this._interrupting && !this.paused) {
        if (this.fastForwardTo !== null) {
          await this._applyFastForward();
          continue;
        }
        if (this._caughtup === false) {
          await this._catchupApplyState();
          continue;
        }
        const remoteAdded = await this._addRemoteHeads();
        const localNodes = this._appending !== null ? this._addLocalHeads() : null;
        if (this._interrupting)
          return;
        if (remoteAdded > 0 || localNodes !== null) {
          this.updating = true;
        }
        const u = this.linearizer.update();
        const update = u ? await this._applyState.update(u, localNodes) : { reboot: false, migrated: false };
        if (localNodes)
          this._flushLocalHeads(localNodes.length);
        if (!update.reboot) {
          if (this._applyState.shouldFlush()) {
            await this._applyState.flush();
            this.updating = true;
          }
          if (this._checkWriters.length > 0) {
            await this._gcWriters();
            continue;
          }
          if (remoteAdded >= REMOTE_ADD_BATCH)
            continue;
          break;
        }
        await this._gcWriters();
        await this._reboot(this._applyState.key);
      }
      if (writable !== this.writable) {
        if (this.writable && this._writable)
          this._writable.resolve(true);
        this.emit(writable ? "unwritable" : "writable");
      }
    }
    _wakeupPeer(stream) {
      if (!this.wakeupSession)
        return;
      const wakeup = this._getWakeup();
      if (wakeup.length === 0)
        return;
      this.wakeupSession.announceByStream(stream, wakeup);
    }
    _getWakeup() {
      const writers = [];
      for (const w of this.activeWriters) {
        if (w.isActiveIndexer || w.flushed())
          continue;
        writers.push({ key: w.core.key, length: w.length });
      }
      return writers;
    }
    async _wakeupWriter(key, length) {
      this._ensureWakeup(await this._getWriterByKey(key, -1, length, true, false, null));
    }
    _ensureWakeup(w) {
      if (w === null || w.isBootstrap === true)
        return;
      w.setBootstrap(true);
      this._bootstrapWriters.push(w);
      this._bootstrapWritersChanged = true;
    }
    async _drainWakeup() {
      const promises = [];
      if (this._needsWakeup) {
        for (const { key, length } of this._wakeup) {
          const w = this.activeWriters.get(key);
          if (w) {
            if (w.length < length)
              w.seen(length);
            continue;
          }
          promises.push(this._applyState.system.get(key));
        }
        if (this._needsWakeupHeads) {
          for (const { key } of await this._applyState.system.heads) {
            if (this.activeWriters.has(key))
              continue;
            promises.push(this._applyState.system.get(key));
          }
        }
      }
      for (const [hex, length] of this._wakeupHints) {
        const key = b4a.from(hex, "hex");
        if (length !== -1) {
          const w = this.activeWriters.get(key);
          if (w) {
            if (w.length < length)
              w.seen(length);
            continue;
          }
        }
        promises.push(this._applyState.system.get(key));
      }
      await Promise.allSettled(promises);
      if (this._needsWakeup === true) {
        this._needsWakeup = false;
        for (const { key, length } of this._wakeup) {
          if (this.activeWriters.has(key))
            continue;
          await this._wakeupWriter(key, length);
        }
        if (this._needsWakeupHeads === true) {
          this._needsWakeupHeads = false;
          for (const { key } of await this._applyState.system.heads) {
            if (this.activeWriters.has(key))
              continue;
            await this._wakeupWriter(key, 0);
          }
        }
      }
      for (const [hex, length] of this._wakeupHints) {
        const key = b4a.from(hex, "hex");
        if (this.activeWriters.has(key))
          continue;
        if (length !== -1) {
          const info = await this._applyState.system.get(key);
          if (info && length <= info.length)
            continue;
        }
        await this._wakeupWriter(key, length === -1 ? 0 : length);
      }
      this._wakeupHints.clear();
    }
    pause() {
      this.paused = true;
    }
    resume() {
      this.paused = false;
      this._queueBump();
    }
    waitForWritable() {
      if (this.writable)
        return Promise.resolve(true);
      if (!this._writable)
        this._writable = rrp();
      return this._writable.promise;
    }
    async _drainWithInterupt() {
      while (true) {
        try {
          await this._drain();
          return;
        } catch (err) {
          if (this.closing || !this.fastForwardTo)
            throw err;
        }
      }
    }
    async _advance() {
      if (this.opened === false)
        await this.ready();
      if (this.paused || this._interrupting)
        return;
      this._draining = true;
      if (this.recoveries < FF_RECOVERY || this._bootRecovery) {
        await this._recoverMaybe();
      }
      if (this._updateLocalCore !== null) {
        await this._rotateLocalWriter(this._updateLocalCore);
      }
      const local = this.local.length;
      try {
        await this._drainWithInterupt();
        if (this._caughtup && (this._needsWakeup === true || this._wakeupHints.size > 0))
          await this._drainWakeup();
        if (!this.localWriter || this.localWriter.closed) {
          await this._updateLocalWriter(this._applyState.system);
        }
        this._draining = false;
      } catch (err) {
        this._onError(err);
        return;
      }
      if (this._interrupting)
        return;
      if (this.localWriter && !this.localWriter.closed) {
        if (this._applyState.isLocalPendingIndexer())
          this.ack().catch(noop);
        else if (this._triggerAckAsap())
          this._ackTimer.asap();
      }
      if (this.updating === true || this._bootstrapWritersChanged === true) {
        this._updateBootstrapWriters();
      }
      if (this.updating === true) {
        this.updating = false;
        if (local !== this.local.length)
          this._resetAckTick();
        else
          this._ackTick++;
        if (!this._interrupting)
          this.emit("update");
        this._waiting.notify(null);
      }
      if (!this._interrupting)
        await this._gcWriters();
    }
    _triggerAckAsap() {
      if (!this._ackTimer)
        return false;
      if (this._ackTickThreshold && !this._acking && this._ackTick >= this._ackTickThreshold) {
        if (this._ackTimer) {
          for (const w of this.linearizer.indexers) {
            if (w.core.length > w.length)
              return false;
          }
        }
        return true;
      }
      return false;
    }
    _queueFastForward() {
      if (!this.core.opened)
        return;
      const latestSignedLength = this.core.core.state.length;
      if (!this.fastForwardEnabled || this.fastForwarding !== null || this._interrupting)
        return;
      if (latestSignedLength - this.core.length < this.fastForwardMinimum)
        return;
      if (this.fastForwardTo !== null)
        return;
      if (Date.now() - this.fastForwardFailedAt < MIN_FF_WAIT)
        return;
      this._runFastForward(new FastForward(this, this.core.key, { minimum: this.fastForwardMinimum })).catch(noop);
    }
    _queueStaticFastForward(key) {
      if (!this.fastForwardEnabled || this.fastForwarding !== null || this._interrupting)
        return;
      if (this.fastForwardTo !== null)
        return;
      if (Date.now() - this.fastForwardFailedAt < MIN_FF_WAIT)
        return;
      this._runFastForward(new FastForward(this, key, { verified: false })).catch(noop);
    }
    _updateActivity() {
      this.activeWriters.updateActivity();
      if (this._applyState) {
        if (this.isFastForwarding())
          this._applyState.pause();
        else
          this._applyState.resume();
      }
      if (this._needsWakeupRequest && !this.isFastForwarding() && this.wakeupSession) {
        this._needsWakeupRequest = false;
        this.wakeupSession.broadcastLookup({});
        const sys = this._viewStore.getSystemView();
        if (sys.compatExtension)
          sys.compatExtension.broadcast();
      }
    }
    _preferFastForward() {
      this.fastForwardMinimum = 1;
      this._queueFastForward();
    }
    _postApply() {
      this.fastForwardMinimum = FastForward.MINIMUM;
    }
    async _runFastForward(ff) {
      this.fastForwarding = ff;
      this._updateActivity();
      const result = await ff.upgrade();
      await ff.close();
      if (this.fastForwarding === ff)
        this.fastForwarding = null;
      if (!result) {
        if (ff.failed)
          this.fastForwardFailedAt = Date.now();
        else
          this._queueFastForward();
        this._updateActivity();
        return;
      }
      this.fastForwardFailedAt = 0;
      this.fastForwardTo = result;
      if (this._applyState && this._applyState.applying && this.fastForwardMinimum === 1) {
        await this._applyState.close();
      }
      this._bumpAckTimer();
      this._queueBump();
    }
    async _addWriter(key, sys) {
      assert(!!this._applyState.applying, "System changes are only allowed in apply");
      const writer = await this._getWriterByKey(key, -1, 0, false, true, sys) || this._makeWriter(key, 0, true, false);
      await writer.ready();
      if (!this.activeWriters.has(key)) {
        this.activeWriters.add(writer);
        this._checkWriters.push(writer);
        this._ensureWakeup(writer);
      }
      this._queueBump();
    }
    _removeWriter(key) {
      const w = this.activeWriters.get(key);
      if (w)
        w.isRemoved = true;
      this._queueBump();
    }
    removeable(key) {
      return this._applyState ? this._applyState.removeable(key) : false;
    }
    _updateAckThreshold() {
      if (this._ackThreshold === 0)
        return;
      if (this._ackTimer)
        this._ackTimer.bau();
      this._ackTick = 0;
      this._ackTickThreshold = random2over1(this.linearizer.indexers.length * this._ackThreshold);
    }
    _resetAckTick() {
      this._ackTick = 0;
      if (this._ackTimer)
        this._ackTimer.bau();
    }
    _shiftWriter(w) {
      w.shift();
      if (w.flushed())
        this._checkWriters.push(w);
    }
  };
  function toKey(k) {
    return b4a.isBuffer(k) ? k : hypercoreId.decode(k);
  }
  function isAutobaseMessage(msg) {
    return msg.checkpoint ? msg.checkpoint.length > 0 : msg.checkpoint === null;
  }
  function compareNodes(a, b) {
    return b4a.compare(a.key, b.key);
  }
  function random2over1(n) {
    return Math.floor(n + Math.random() * n);
  }
  function noop() {}
  function crashSoon(err) {
    queueMicrotask(() => {
      throw err;
    });
    throw err;
  }
  function isObject(obj) {
    return typeof obj === "object" && obj !== null;
  }
  function emitWarning(err) {
    safetyCatch(err);
    this.emit("warning", err);
  }
  function normalize(valueEncoding, value) {
    const state = { buffer: null, start: 0, end: 0 };
    valueEncoding.preencode(state, value);
    state.buffer = b4a.allocUnsafe(state.end);
    valueEncoding.encode(state, value);
    state.start = 0;
    return valueEncoding.decode(state);
  }
});

// node_modules/kademlia-routing-table/index.js
var require_kademlia_routing_table = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  module.exports = class RoutingTable extends EventEmitter {
    constructor(id, opts) {
      if (!opts)
        opts = {};
      super();
      this.id = id;
      this.k = opts.k || 20;
      this.size = 0;
      this.rows = new Array(id.length * 8);
    }
    add(node) {
      const i = this._diff(node.id);
      let row = this.rows[i];
      if (!row) {
        row = this.rows[i] = new Row(this, i);
        this.emit("row", row);
      }
      const len = row.nodes.length;
      if (!row.add(node, this.k))
        return false;
      this.size += row.nodes.length - len;
      return true;
    }
    remove(id) {
      const i = this._diff(id);
      const row = this.rows[i];
      if (!row)
        return false;
      if (!row.remove(id))
        return false;
      this.size--;
      return true;
    }
    get(id) {
      const i = this._diff(id);
      const row = this.rows[i];
      if (!row)
        return null;
      return row.get(id);
    }
    has(id) {
      return this.get(id) !== null;
    }
    random() {
      let n = Math.random() * this.size | 0;
      for (let i = 0;i < this.rows.length; i++) {
        const r = this.rows[i];
        if (!r)
          continue;
        if (n < r.nodes.length)
          return r.nodes[n];
        n -= r.nodes.length;
      }
      return null;
    }
    closest(id, k) {
      if (!k)
        k = this.k;
      const result = [];
      const d = this._diff(id);
      for (let i = d;i >= 0 && result.length < k; i--)
        this._pushNodes(i, k, result);
      for (let i = d + 1;i < this.rows.length && result.length < k; i++)
        this._pushNodes(i, k, result);
      return result;
    }
    _pushNodes(i, k, result) {
      const row = this.rows[i];
      if (!row)
        return;
      const missing = Math.min(k - result.length, row.nodes.length);
      for (let j = 0;j < missing; j++)
        result.push(row.nodes[j]);
    }
    toArray() {
      return this.closest(this.id, Infinity);
    }
    _diff(id) {
      for (let i = 0;i < id.length; i++) {
        const a = id[i];
        const b = this.id[i];
        if (a !== b)
          return i * 8 + Math.clz32(a ^ b) - 24;
      }
      return this.rows.length - 1;
    }
  };

  class Row extends EventEmitter {
    constructor(table, index) {
      super();
      this.data = null;
      this.byteOffset = index >> 3;
      this.index = index;
      this.table = table;
      this.nodes = [];
    }
    add(node) {
      const id = node.id;
      let l = 0;
      let r = this.nodes.length - 1;
      while (l <= r) {
        const m = l + r >> 1;
        const c = this.compare(id, this.nodes[m].id);
        if (c === 0) {
          this.nodes[m] = node;
          return true;
        }
        if (c < 0)
          r = m - 1;
        else
          l = m + 1;
      }
      if (this.nodes.length >= this.table.k) {
        this.emit("full", node);
        return false;
      }
      this.insert(l, node);
      return true;
    }
    remove(id) {
      let l = 0;
      let r = this.nodes.length - 1;
      while (l <= r) {
        const m = l + r >> 1;
        const c = this.compare(id, this.nodes[m].id);
        if (c === 0) {
          this.splice(m);
          return true;
        }
        if (c < 0)
          r = m - 1;
        else
          l = m + 1;
      }
      return false;
    }
    get(id) {
      let l = 0;
      let r = this.nodes.length - 1;
      while (l <= r) {
        const m = l + r >> 1;
        const node = this.nodes[m];
        const c = this.compare(id, node.id);
        if (c === 0)
          return node;
        if (c < 0)
          r = m - 1;
        else
          l = m + 1;
      }
      return null;
    }
    insert(i, node) {
      this.nodes.push(node);
      for (let j = this.nodes.length - 1;j > i; j--)
        this.nodes[j] = this.nodes[j - 1];
      this.nodes[i] = node;
      this.emit("add", node);
    }
    splice(i) {
      for (;i < this.nodes.length - 1; i++)
        this.nodes[i] = this.nodes[i + 1];
      this.emit("remove", this.nodes.pop());
    }
    compare(a, b) {
      for (let i = this.byteOffset;i < a.length; i++) {
        const ai = a[i];
        const bi = b[i];
        if (ai === bi)
          continue;
        return ai < bi ? -1 : 1;
      }
      return 0;
    }
  }
});

// node_modules/time-ordered-set/index.js
var require_time_ordered_set = __commonJS((exports, module) => {
  module.exports = class TimeOrderedSet {
    constructor() {
      this.oldest = null;
      this.latest = null;
      this.length = 0;
    }
    has(node) {
      return !!(node.next || node.prev) || node === this.oldest;
    }
    add(node) {
      if (this.has(node))
        this.remove(node);
      if (!this.latest && !this.oldest) {
        this.latest = this.oldest = node;
        node.prev = node.next = null;
      } else {
        this.latest.next = node;
        node.prev = this.latest;
        node.next = null;
        this.latest = node;
      }
      this.length++;
      return node;
    }
    remove(node) {
      if (!this.has(node))
        return node;
      if (this.oldest !== node && this.latest !== node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
      } else {
        if (this.oldest === node) {
          this.oldest = node.next;
          if (this.oldest)
            this.oldest.prev = null;
        }
        if (this.latest === node) {
          this.latest = node.prev;
          if (this.latest)
            this.latest.next = null;
        }
      }
      node.next = node.prev = null;
      this.length--;
      return node;
    }
    toArray({ limit = Infinity, reverse = false } = {}) {
      const list = [];
      if (reverse) {
        let node = this.latest;
        while (node && limit--) {
          list.push(node);
          node = node.prev;
        }
      } else {
        let node = this.oldest;
        while (node && limit--) {
          list.push(node);
          node = node.next;
        }
      }
      return list;
    }
  };
});

// node_modules/udx-native/binding.js
var require_binding6 = __commonJS((exports, module) => {
  var __filename = "/Users/odinsson/Dev/pear/easybase/node_modules/udx-native/binding.js";
  __require.addon = require_require_addon();
  module.exports = __require.addon(".", __filename);
});

// node_modules/udx-native/lib/ip.js
var require_ip = __commonJS((exports) => {
  var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
  var IPv4Pattern = new RegExp(`^${v4Str}$`);
  var v6Seg = "(?:[0-9a-fA-F]{1,4})";
  var IPv6Pattern = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
  var isIPv4 = exports.isIPv4 = function isIPv4(host) {
    return IPv4Pattern.test(host);
  };
  var isIPv6 = exports.isIPv6 = function isIPv6(host) {
    return IPv6Pattern.test(host);
  };
  exports.isIP = function isIP(host) {
    if (isIPv4(host))
      return 4;
    if (isIPv6(host))
      return 6;
    return 0;
  };
});

// node_modules/udx-native/lib/socket.js
var require_socket = __commonJS((exports, module) => {
  var events = __require("events");
  var b4a = require_b4a();
  var binding = require_binding6();
  var ip = require_ip();
  module.exports = class UDXSocket extends events.EventEmitter {
    constructor(udx, opts = {}) {
      super();
      this.udx = udx;
      this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_socket_t);
      this._inited = false;
      this._host = null;
      this._family = 0;
      this._ipv6Only = opts.ipv6Only === true;
      this._reuseAddress = opts.reuseAddress === true;
      this._port = 0;
      this._reqs = [];
      this._free = [];
      this._closing = null;
      this._closed = false;
      this._view64 = new BigUint64Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 3);
      this.streams = new Set;
      this.userData = null;
    }
    get bound() {
      return this._port !== 0;
    }
    get closing() {
      return this._closing !== null;
    }
    get idle() {
      return this.streams.size === 0;
    }
    get busy() {
      return this.streams.size > 0;
    }
    get bytesTransmitted() {
      if (this._inited !== true)
        return 0;
      return Number(this._view64[binding.offsetof_udx_socket_t_bytes_tx >> 3]);
    }
    get packetsTransmitted() {
      if (this._inited !== true)
        return 0;
      return Number(this._view64[binding.offsetof_udx_socket_t_packets_tx >> 3]);
    }
    get bytesReceived() {
      if (this._inited !== true)
        return 0;
      return Number(this._view64[binding.offsetof_udx_socket_t_bytes_rx >> 3]);
    }
    get packetsReceived() {
      if (this._inited !== true)
        return 0;
      return Number(this._view64[binding.offsetof_udx_socket_t_packets_rx >> 3]);
    }
    get packetsDroppedByKernel() {
      if (this._inited !== true)
        return 0;
      return Number(this._view64[binding.offsetof_udx_socket_t_packets_dropped_by_kernel >> 3]);
    }
    toJSON() {
      return {
        bound: this.bound,
        closing: this.closing,
        streams: this.streams.size,
        address: this.address(),
        ipv6Only: this._ipv6Only,
        reuseAddress: this._reuseAddress,
        idle: this.idle,
        busy: this.busy
      };
    }
    _init() {
      if (this._inited)
        return;
      binding.udx_napi_socket_init(this.udx._handle, this._handle, this, this._onsend, this._onmessage, this._onclose, this._reallocMessage);
      this._inited = true;
    }
    _onsend(id, err) {
      const req = this._reqs[id];
      const onflush = req.onflush;
      req.buffer = null;
      req.onflush = null;
      this._free.push(id);
      onflush(err >= 0);
      if (this._free.length >= 16 && this._free.length === this._reqs.length) {
        this._free = [];
        this._reqs = [];
      }
    }
    _onmessage(len, port, host, family) {
      this.emit("message", this.udx._consumeMessage(len), { host, family, port });
      return this.udx._buffer;
    }
    _onclose() {
      this.emit("close");
    }
    _reallocMessage() {
      return this.udx._reallocMessage();
    }
    _onidle() {
      this.emit("idle");
    }
    _onbusy() {
      this.emit("busy");
    }
    _addStream(stream) {
      if (this.streams.has(stream))
        return false;
      this.streams.add(stream);
      if (this.streams.size === 1)
        this._onbusy();
      return true;
    }
    _removeStream(stream) {
      if (!this.streams.has(stream))
        return false;
      this.streams.delete(stream);
      const closed = this._closeMaybe();
      if (this.idle && !closed)
        this._onidle();
      return true;
    }
    address() {
      if (!this.bound)
        return null;
      return { host: this._host, family: this._family, port: this._port };
    }
    bind(port, host) {
      if (this.bound)
        throw new Error("Already bound");
      if (this.closing)
        throw new Error("Socket is closed");
      if (!port)
        port = 0;
      let flags = 0;
      if (this._ipv6Only)
        flags |= binding.UV_UDP_IPV6ONLY;
      if (this._reuseAddress)
        flags |= binding.UV_UDP_REUSEADDR;
      let family;
      if (host) {
        family = ip.isIP(host);
        if (!family)
          throw new Error(`${host} is not a valid IP address`);
        if (!this._inited)
          this._init();
        this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags);
      } else {
        if (!this._inited)
          this._init();
        try {
          host = "::";
          family = 6;
          this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags);
        } catch {
          host = "0.0.0.0";
          family = 4;
          this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags);
        }
      }
      this._host = host;
      this._family = family;
      this.emit("listening");
    }
    async close() {
      if (this._closing)
        return this._closing;
      this._closing = new Promise((resolve) => this.once("close", resolve));
      this._closeMaybe();
      return this._closing;
    }
    _closeMaybe() {
      if (this._closed || this._closing === null)
        return this._closed;
      if (!this._inited) {
        this._closed = true;
        this.emit("close");
        return true;
      }
      if (this.idle) {
        binding.udx_napi_socket_close(this._handle);
        this._closed = true;
      }
      return this._closed;
    }
    setTTL(ttl) {
      if (!this._inited)
        throw new Error("Socket not active");
      binding.udx_napi_socket_set_ttl(this._handle, ttl);
    }
    getRecvBufferSize() {
      if (!this._inited)
        throw new Error("Socket not active");
      return binding.udx_napi_socket_get_recv_buffer_size(this._handle);
    }
    setRecvBufferSize(size) {
      if (!this._inited)
        throw new Error("Socket not active");
      return binding.udx_napi_socket_set_recv_buffer_size(this._handle, size);
    }
    getSendBufferSize() {
      if (!this._inited)
        throw new Error("Socket not active");
      return binding.udx_napi_socket_get_send_buffer_size(this._handle);
    }
    setSendBufferSize(size) {
      if (!this._inited)
        throw new Error("Socket not active");
      return binding.udx_napi_socket_set_send_buffer_size(this._handle, size);
    }
    addMembership(group, ifaceAddress) {
      if (!this._inited)
        throw new Error("Socket not active");
      return binding.udx_napi_socket_set_membership(this._handle, group, ifaceAddress || "", true);
    }
    dropMembership(group, ifaceAddress) {
      if (!this._inited)
        throw new Error("Socket not active");
      return binding.udx_napi_socket_set_membership(this._handle, group, ifaceAddress || "", false);
    }
    async send(buffer, port, host, ttl) {
      if (this.closing)
        return false;
      if (!host)
        host = "127.0.0.1";
      const family = ip.isIP(host);
      if (!family)
        throw new Error(`${host} is not a valid IP address`);
      if (!this.bound)
        this.bind(0);
      const id = this._allocSend();
      const req = this._reqs[id];
      req.buffer = buffer;
      const promise = new Promise((resolve) => {
        req.onflush = resolve;
      });
      binding.udx_napi_socket_send_ttl(this._handle, req.handle, id, buffer, port, host, family, ttl || 0);
      return promise;
    }
    trySend(buffer, port, host, ttl) {
      if (this.closing)
        return;
      if (!host)
        host = "127.0.0.1";
      const family = ip.isIP(host);
      if (!family)
        throw new Error(`${host} is not a valid IP address`);
      if (!this.bound)
        this.bind(0);
      const id = this._allocSend();
      const req = this._reqs[id];
      req.buffer = buffer;
      req.onflush = noop;
      binding.udx_napi_socket_send_ttl(this._handle, req.handle, id, buffer, port, host, family, ttl || 0);
    }
    _allocSend() {
      if (this._free.length > 0)
        return this._free.pop();
      const handle = b4a.allocUnsafe(binding.sizeof_udx_socket_send_t);
      return this._reqs.push({ handle, buffer: null, onflush: null }) - 1;
    }
  };
  function noop() {}
});

// node_modules/udx-native/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var streamx = require_streamx();
  var b4a = require_b4a();
  var binding = require_binding6();
  var ip = require_ip();
  var MAX_PACKET = 2048;
  var BUFFER_SIZE = 65536 + MAX_PACKET;
  module.exports = class UDXStream extends streamx.Duplex {
    constructor(udx, id, opts = {}) {
      super({ mapWritable: toBuffer, eagerOpen: true });
      this.udx = udx;
      this.socket = null;
      this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_stream_t);
      this._view = new Uint32Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 2);
      this._view16 = new Uint16Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 1);
      this._view64 = new BigUint64Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 3);
      this._wreqs = [];
      this._wfree = [];
      this._sreqs = [];
      this._sfree = [];
      this._closed = false;
      this._flushing = 0;
      this._flushes = [];
      this._buffer = null;
      this._reallocData();
      this._onwrite = null;
      this._ondestroy = null;
      this._firewall = opts.firewall || firewallAll;
      this._remoteChanging = null;
      this._previousSocket = null;
      this.id = id;
      this.remoteId = 0;
      this.remoteHost = null;
      this.remoteFamily = 0;
      this.remotePort = 0;
      this.userData = null;
      binding.udx_napi_stream_init(this.udx._handle, this._handle, id, opts.framed ? 1 : 0, this, this._ondata, this._onend, this._ondrain, this._onack, this._onsend, this._onmessage, this._onclose, this._onfirewall, this._onremotechanged, this._reallocData, this._reallocMessage);
      if (opts.seq)
        binding.udx_napi_stream_set_seq(this._handle, opts.seq);
      binding.udx_napi_stream_recv_start(this._handle, this._buffer);
    }
    get connected() {
      return this.socket !== null;
    }
    get mtu() {
      return this._view16[binding.offsetof_udx_stream_t_mtu >> 1];
    }
    get rtt() {
      return this._view[binding.offsetof_udx_stream_t_srtt >> 2];
    }
    get cwnd() {
      return this._view[binding.offsetof_udx_stream_t_cwnd >> 2];
    }
    get rtoCount() {
      return this._view16[binding.offsetof_udx_stream_t_rto_count >> 1];
    }
    get retransmits() {
      return this._view16[binding.offsetof_udx_stream_t_retransmit_count >> 1];
    }
    get fastRecoveries() {
      return this._view16[binding.offsetof_udx_stream_t_fast_recovery_count >> 1];
    }
    get inflight() {
      return this._view[binding.offsetof_udx_stream_t_inflight >> 2];
    }
    get bytesTransmitted() {
      return Number(this._view64[binding.offsetof_udx_stream_t_bytes_tx >> 3]);
    }
    get packetsTransmitted() {
      return Number(this._view64[binding.offsetof_udx_stream_t_packets_tx >> 3]);
    }
    get bytesReceived() {
      return Number(this._view64[binding.offsetof_udx_stream_t_bytes_rx >> 3]);
    }
    get packetsReceived() {
      return Number(this._view64[binding.offsetof_udx_stream_t_packets_rx >> 3]);
    }
    get localHost() {
      return this.socket ? this.socket.address().host : null;
    }
    get localFamily() {
      return this.socket ? this.socket.address().family : 0;
    }
    get localPort() {
      return this.socket ? this.socket.address().port : 0;
    }
    setInteractive(bool) {
      if (!this._closed)
        return;
      binding.udx_napi_stream_set_mode(this._handle, bool ? 0 : 1);
    }
    connect(socket, remoteId, port, host, opts = {}) {
      if (this._closed)
        return;
      if (this.connected)
        throw new Error("Already connected");
      if (socket.closing)
        throw new Error("Socket is closed");
      if (typeof host === "object") {
        opts = host;
        host = null;
      }
      if (!host)
        host = "127.0.0.1";
      const family = ip.isIP(host);
      if (!family)
        throw new Error(`${host} is not a valid IP address`);
      if (!(port > 0 && port < 65536))
        throw new Error(`${port} is not a valid port`);
      if (!socket.bound)
        socket.bind(0);
      this.remoteId = remoteId;
      this.remotePort = port;
      this.remoteHost = host;
      this.remoteFamily = family;
      this.socket = socket;
      if (opts.ack)
        binding.udx_napi_stream_set_ack(this._handle, opts.ack);
      binding.udx_napi_stream_connect(this._handle, socket._handle, remoteId, port, host, family);
      this.socket._addStream(this);
      this.emit("connect");
    }
    changeRemote(socket, remoteId, port, host) {
      if (this._remoteChanging)
        throw new Error("Remote already changing");
      if (!this.connected)
        throw new Error("Not yet connected");
      if (socket.closing)
        throw new Error("Socket is closed");
      if (this.socket.udx !== socket.udx) {
        throw new Error("Cannot change to a socket on another UDX instance");
      }
      if (!host)
        host = "127.0.0.1";
      const family = ip.isIP(host);
      if (!family)
        throw new Error(`${host} is not a valid IP address`);
      if (!(port > 0 && port < 65536))
        throw new Error(`${port} is not a valid port`);
      if (this.socket !== socket)
        this._previousSocket = this.socket;
      this.remoteId = remoteId;
      this.remotePort = port;
      this.remoteHost = host;
      this.remoteFamily = family;
      this.socket = socket;
      this._remoteChanging = new Promise((resolve, reject) => {
        const onchanged = () => {
          this.off("close", onclose);
          resolve();
        };
        const onclose = () => {
          this.off("remote-changed", onchanged);
          reject(new Error("Stream is closed"));
        };
        this.once("remote-changed", onchanged).once("close", onclose);
      });
      binding.udx_napi_stream_change_remote(this._handle, socket._handle, remoteId, port, host, family);
      this.socket._addStream(this);
      return this._remoteChanging;
    }
    relayTo(destination) {
      if (this._closed)
        return;
      binding.udx_napi_stream_relay_to(this._handle, destination._handle);
    }
    async send(buffer) {
      if (!this.connected || this._closed)
        return false;
      const id = this._allocSend();
      const req = this._sreqs[id];
      req.buffer = buffer;
      const promise = new Promise((resolve) => {
        req.onflush = resolve;
      });
      binding.udx_napi_stream_send(this._handle, req.handle, id, buffer);
      return promise;
    }
    trySend(buffer) {
      if (!this.connected || this._closed)
        return;
      const id = this._allocSend();
      const req = this._sreqs[id];
      req.buffer = buffer;
      req.onflush = noop;
      binding.udx_napi_stream_send(this._handle, req.handle, id, buffer);
    }
    async flush() {
      if (await streamx.Writable.drained(this) === false)
        return false;
      if (this.destroying)
        return false;
      const missing = this._wreqs.length - this._wfree.length;
      if (missing === 0)
        return true;
      return new Promise((resolve) => {
        this._flushes.push({ flush: this._flushing++, missing, resolve });
      });
    }
    toJSON() {
      return {
        id: this.id,
        connected: this.connected,
        destroying: this.destroying,
        destroyed: this.destroyed,
        remoteId: this.remoteId,
        remoteHost: this.remoteHost,
        remoteFamily: this.remoteFamily,
        remotePort: this.remotePort,
        mtu: this.mtu,
        rtt: this.rtt,
        cwnd: this.cwnd,
        inflight: this.inflight,
        socket: this.socket ? this.socket.toJSON() : null
      };
    }
    _read(cb) {
      cb(null);
    }
    _writeContinue(err) {
      if (this._onwrite === null)
        return;
      const cb = this._onwrite;
      this._onwrite = null;
      cb(err);
    }
    _destroyContinue(err) {
      if (this._ondestroy === null)
        return;
      const cb = this._ondestroy;
      this._ondestroy = null;
      cb(err);
    }
    _writev(buffers, cb) {
      if (!this.connected)
        throw customError("Writing while not connected not currently supported", "ERR_ASSERTION");
      let drained = true;
      if (buffers.length === 1) {
        const id = this._allocWrite(1);
        const req = this._wreqs[id];
        req.flush = this._flushing;
        req.buffer = buffers[0];
        drained = binding.udx_napi_stream_write(this._handle, req.handle, id, req.buffer) !== 0;
      } else {
        const id = this._allocWrite(nextBatchSize(buffers.length));
        const req = this._wreqs[id];
        req.flush = this._flushing;
        req.buffers = buffers;
        drained = binding.udx_napi_stream_writev(this._handle, req.handle, id, req.buffers) !== 0;
      }
      if (drained)
        cb(null);
      else
        this._onwrite = cb;
    }
    _final(cb) {
      const id = this._allocWrite(1);
      const req = this._wreqs[id];
      req.flush = this._flushes;
      req.buffer = b4a.allocUnsafe(0);
      const drained = binding.udx_napi_stream_write_end(this._handle, req.handle, id, req.buffer) !== 0;
      if (drained)
        cb(null);
      else
        this._onwrite = cb;
    }
    _predestroy() {
      if (!this._closed)
        binding.udx_napi_stream_destroy(this._handle);
      this._closed = true;
      this._writeContinue(null);
    }
    _destroy(cb) {
      if (this.connected)
        this._ondestroy = cb;
      else
        cb(null);
    }
    _ondata(read) {
      this.push(this._consumeData(read));
      return this._buffer;
    }
    _onend(read) {
      if (read > 0)
        this.push(this._consumeData(read));
      this.push(null);
    }
    _ondrain() {
      this._writeContinue(null);
    }
    _flushAck(flush) {
      for (let i = this._flushes.length - 1;i >= 0; i--) {
        const f = this._flushes[i];
        if (f.flush < flush)
          break;
        f.missing--;
      }
      while (this._flushes.length > 0 && this._flushes[0].missing === 0) {
        this._flushes.shift().resolve(true);
      }
    }
    _onack(id) {
      const req = this._wreqs[id];
      req.buffers = req.buffer = null;
      this._wfree.push(id);
      if (this._flushes.length > 0)
        this._flushAck(req.flush);
      if (this._wfree.length >= 64 && this._wfree.length === this._wreqs.length) {
        this._wfree = [];
        this._wreqs = [];
      }
    }
    _onsend(id, err) {
      const req = this._sreqs[id];
      const onflush = req.onflush;
      req.buffer = null;
      req.onflush = null;
      this._sfree.push(id);
      onflush(err >= 0);
      if (this._sfree.length >= 16 && this._sfree.length === this._sreqs.length) {
        this._sfree = [];
        this._sreqs = [];
      }
    }
    _onmessage(len) {
      this.emit("message", this.udx._consumeMessage(len));
      return this.udx._buffer;
    }
    _onclose(err) {
      this._closed = true;
      if (this.socket) {
        this.socket._removeStream(this);
        this.socket = null;
      }
      if (this._previousSocket) {
        this._previousSocket._removeStream(this);
        this._previousSocket = null;
      }
      if (!err)
        return this._destroyContinue(null);
      if (this._ondestroy === null)
        this.destroy(err);
      else
        this._destroyContinue(err);
    }
    _onfirewall(socket, port, host, family) {
      return this._firewall(socket, port, host, family) ? 1 : 0;
    }
    _onremotechanged() {
      if (this._previousSocket) {
        this._previousSocket._removeStream(this);
        this._previousSocket = null;
      }
      this._remoteChanging = null;
      this.emit("remote-changed");
    }
    _consumeData(len) {
      const next = this._buffer.subarray(0, len);
      this._buffer = this._buffer.subarray(len);
      if (this._buffer.byteLength < MAX_PACKET)
        this._reallocData();
      return next;
    }
    _reallocData() {
      this._buffer = b4a.allocUnsafe(BUFFER_SIZE);
      return this._buffer;
    }
    _reallocMessage() {
      return this.udx._reallocMessage();
    }
    _allocWrite(size) {
      if (this._wfree.length === 0) {
        const handle = b4a.allocUnsafe(binding.udx_napi_stream_write_sizeof(size));
        return this._wreqs.push({ handle, size, buffers: null, buffer: null, flush: 0 }) - 1;
      }
      const free = this._wfree.pop();
      if (size === 1)
        return free;
      const next = this._wreqs[free];
      if (next.size < size) {
        next.handle = b4a.allocUnsafe(binding.udx_napi_stream_write_sizeof(size));
        next.size = size;
      }
      return free;
    }
    _allocSend() {
      if (this._sfree.length > 0)
        return this._sfree.pop();
      const handle = b4a.allocUnsafe(binding.sizeof_udx_stream_send_t);
      return this._sreqs.push({ handle, buffer: null, resolve: null, reject: null }) - 1;
    }
  };
  function noop() {}
  function toBuffer(data) {
    return typeof data === "string" ? b4a.from(data) : data;
  }
  function firewallAll(socket, port, host) {
    return true;
  }
  function customError(message, code) {
    const error = new Error(message);
    error.code = code;
    return error;
  }
  function nextBatchSize(n) {
    if (n === 1)
      return 1;
    if (n < 8)
      return 8;
    if (n < 16)
      return 16;
    if (n < 32)
      return 32;
    if (n < 64)
      return 64;
    return n;
  }
});

// node_modules/udx-native/lib/network-interfaces.js
var require_network_interfaces = __commonJS((exports, module) => {
  var events = __require("events");
  var b4a = require_b4a();
  var binding = require_binding6();
  module.exports = class NetworkInterfaces extends events.EventEmitter {
    constructor(udx) {
      super();
      this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_interface_event_t);
      this._watching = false;
      this._destroying = null;
      binding.udx_napi_interface_event_init(udx._handle, this._handle, this, this._onevent, this._onclose);
      this.interfaces = binding.udx_napi_interface_event_get_addrs(this._handle);
    }
    _onclose() {
      this.emit("close");
    }
    _onevent() {
      this.interfaces = binding.udx_napi_interface_event_get_addrs(this._handle);
      this.emit("change", this.interfaces);
    }
    watch() {
      if (this._watching)
        return this;
      this._watching = true;
      binding.udx_napi_interface_event_start(this._handle);
      return this;
    }
    unwatch() {
      if (!this._watching)
        return this;
      this._watching = false;
      binding.udx_napi_interface_event_stop(this._handle);
      return this;
    }
    async destroy() {
      if (this._destroying)
        return this._destroying;
      this._destroying = events.once(this, "close");
      binding.udx_napi_interface_event_close(this._handle);
      return this._destroying;
    }
    [Symbol.iterator]() {
      return this.interfaces[Symbol.iterator]();
    }
  };
});

// node_modules/udx-native/lib/udx.js
var require_udx = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var binding = require_binding6();
  var ip = require_ip();
  var Socket = require_socket();
  var Stream = require_stream();
  var NetworkInterfaces = require_network_interfaces();
  var MAX_MESSAGE = 4096;
  var BUFFER_SIZE = 65536 + MAX_MESSAGE;
  module.exports = class UDX {
    constructor() {
      this._handle = b4a.allocUnsafe(binding.sizeof_udx_napi_t);
      this._watchers = new Set;
      this._view64 = new BigUint64Array(this._handle.buffer, this._handle.byteOffset, this._handle.byteLength >> 3);
      this._buffer = null;
      this._reallocMessage();
      binding.udx_napi_init(this._handle, this._buffer);
    }
    static isIPv4(host) {
      return ip.isIPv4(host);
    }
    static isIPv6(host) {
      return ip.isIPv6(host);
    }
    static isIP(host) {
      return ip.isIP(host);
    }
    get bytesTransmitted() {
      return Number(this._view64[binding.offsetof_udx_t_bytes_tx >> 3]);
    }
    get packetsTransmitted() {
      return Number(this._view64[binding.offsetof_udx_t_packets_tx >> 3]);
    }
    get bytesReceived() {
      return Number(this._view64[binding.offsetof_udx_t_bytes_rx >> 3]);
    }
    get packetsReceived() {
      return Number(this._view64[binding.offsetof_udx_t_packets_rx >> 3]);
    }
    get packetsDroppedByKernel() {
      return Number(this._view64[binding.offsetof_udx_t_packets_dropped_by_kernel >> 3]);
    }
    _consumeMessage(len) {
      const next = this._buffer.subarray(0, len);
      this._buffer = this._buffer.subarray(len);
      if (this._buffer.byteLength < MAX_MESSAGE)
        this._reallocMessage();
      return next;
    }
    _reallocMessage() {
      this._buffer = b4a.allocUnsafe(BUFFER_SIZE);
      return this._buffer;
    }
    createSocket(opts) {
      return new Socket(this, opts);
    }
    createStream(id, opts) {
      return new Stream(this, id, opts);
    }
    networkInterfaces() {
      let [watcher = null] = this._watchers;
      if (watcher)
        return watcher.interfaces;
      watcher = new NetworkInterfaces(this);
      watcher.destroy();
      return watcher.interfaces;
    }
    watchNetworkInterfaces(onchange) {
      const watcher = new NetworkInterfaces(this);
      this._watchers.add(watcher);
      watcher.on("close", () => {
        this._watchers.delete(watcher);
      });
      if (onchange)
        watcher.on("change", onchange);
      return watcher.watch();
    }
    async lookup(host, opts = {}) {
      const {
        family = 0
      } = opts;
      const req = b4a.allocUnsafe(binding.sizeof_udx_napi_lookup_t);
      const ctx = {
        req,
        resolve: null,
        reject: null
      };
      const promise = new Promise((resolve, reject) => {
        ctx.resolve = resolve;
        ctx.reject = reject;
      });
      binding.udx_napi_lookup(this._handle, req, host, family, ctx, onlookup);
      return promise;
    }
  };
  function onlookup(err, host, family) {
    if (err)
      this.reject(err);
    else
      this.resolve({ host, family });
  }
});

// node_modules/nat-sampler/index.js
var require_nat_sampler = __commonJS((exports, module) => {
  module.exports = class NatSampler {
    constructor() {
      this.host = null;
      this.port = 0;
      this.size = 0;
      this._a = null;
      this._b = null;
      this._threshold = 0;
      this._top = 0;
      this._samples = [];
    }
    add(host, port) {
      const a = this._bump(host, port, 2);
      const b = this._bump(host, 0, 1);
      if (this._samples.length < 32) {
        this.size++;
        this._threshold = this.size - (this.size < 4 ? 0 : this.size < 8 ? 1 : this.size < 12 ? 2 : 3);
        this._samples.push(a, b);
        this._top += 2;
      } else {
        if (this._top === 32)
          this._top = 0;
        const oa = this._samples[this._top];
        this._samples[this._top++] = a;
        oa.hits--;
        const ob = this._samples[this._top];
        this._samples[this._top++] = b;
        ob.hits--;
      }
      if (this._a === null || this._a.hits < a.hits)
        this._a = a;
      if (this._b === null || this._b.hits < b.hits)
        this._b = b;
      if (this._a.hits >= this._threshold) {
        this.host = this._a.host;
        this.port = this._a.port;
      } else if (this._b.hits >= this._threshold) {
        this.host = this._b.host;
        this.port = 0;
      } else {
        this.host = null;
        this.port = 0;
      }
      return a.hits;
    }
    _bump(host, port, inc) {
      for (let i = 0;i < 4; i++) {
        const j = this._top - inc - 2 * i & 31;
        if (j >= this._samples.length)
          return { host, port, hits: 1 };
        const s = this._samples[j];
        if (s.port === port && s.host === host) {
          s.hits++;
          return s;
        }
      }
      return { host, port, hits: 1 };
    }
  };
});

// node_modules/compact-encoding-net/index.js
var require_compact_encoding_net = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var port = c.uint16;
  var address = (host, family) => {
    return {
      preencode(state, m) {
        host.preencode(state, m.host);
        port.preencode(state, m.port);
      },
      encode(state, m) {
        host.encode(state, m.host);
        port.encode(state, m.port);
      },
      decode(state) {
        return {
          host: host.decode(state),
          family,
          port: port.decode(state)
        };
      }
    };
  };
  var ipv4 = {
    preencode(state) {
      state.end += 4;
    },
    encode(state, string) {
      const start = state.start;
      const end = start + 4;
      let i = 0;
      while (i < string.length) {
        let n = 0;
        let c2;
        while (i < string.length && (c2 = string.charCodeAt(i++)) !== 46) {
          n = n * 10 + (c2 - 48);
        }
        state.buffer[state.start++] = n;
      }
      state.start = end;
    },
    decode(state) {
      if (state.end - state.start < 4)
        throw new Error("Out of bounds");
      return state.buffer[state.start++] + "." + state.buffer[state.start++] + "." + state.buffer[state.start++] + "." + state.buffer[state.start++];
    }
  };
  var ipv4Address = address(ipv4, 4);
  var ipv6 = {
    preencode(state) {
      state.end += 16;
    },
    encode(state, string) {
      const start = state.start;
      const end = start + 16;
      let i = 0;
      let split = null;
      while (i < string.length) {
        let n = 0;
        let c2;
        while (i < string.length && (c2 = string.charCodeAt(i++)) !== 58) {
          if (c2 >= 48 && c2 <= 57)
            n = n * 16 + (c2 - 48);
          else if (c2 >= 65 && c2 <= 70)
            n = n * 16 + (c2 - 65 + 10);
          else if (c2 >= 97 && c2 <= 102)
            n = n * 16 + (c2 - 97 + 10);
        }
        state.buffer[state.start++] = n >>> 8;
        state.buffer[state.start++] = n;
        if (i < string.length && string.charCodeAt(i) === 58) {
          i++;
          split = state.start;
        }
      }
      if (split !== null) {
        const offset = end - state.start;
        state.buffer.copyWithin(split + offset, split).fill(0, split, split + offset);
      }
      state.start = end;
    },
    decode(state) {
      if (state.end - state.start < 16)
        throw new Error("Out of bounds");
      return (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ":" + (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16);
    }
  };
  var ipv6Address = address(ipv6, 6);
  var ip = {
    preencode(state, string) {
      const family = string.includes(":") ? 6 : 4;
      c.uint8.preencode(state, family);
      if (family === 4)
        ipv4.preencode(state);
      else
        ipv6.preencode(state);
    },
    encode(state, string) {
      const family = string.includes(":") ? 6 : 4;
      c.uint8.encode(state, family);
      if (family === 4)
        ipv4.encode(state, string);
      else
        ipv6.encode(state, string);
    },
    decode(state) {
      const family = c.uint8.decode(state);
      if (family === 4)
        return ipv4.decode(state);
      else
        return ipv6.decode(state);
    }
  };
  var ipAddress = {
    preencode(state, m) {
      ip.preencode(state, m.host);
      port.preencode(state, m.port);
    },
    encode(state, m) {
      ip.encode(state, m.host);
      port.encode(state, m.port);
    },
    decode(state) {
      const family = c.uint8.decode(state);
      return {
        host: family === 4 ? ipv4.decode(state) : ipv6.decode(state),
        family,
        port: port.decode(state)
      };
    }
  };
  module.exports = {
    port,
    ipv4,
    ipv4Address,
    ipv6,
    ipv6Address,
    ip,
    ipAddress
  };
});

// node_modules/dht-rpc/lib/peer.js
var require_peer = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var c = require_compact_encoding();
  var net = require_compact_encoding_net();
  var b4a = require_b4a();
  var ipv4 = {
    ...net.ipv4Address,
    decode(state) {
      const ip = net.ipv4Address.decode(state);
      return {
        id: null,
        host: ip.host,
        port: ip.port
      };
    }
  };
  module.exports = { id, ipv4, ipv4Array: c.array(ipv4) };
  function id(host, port, out = b4a.allocUnsafeSlow(32)) {
    const addr = out.subarray(0, 6);
    ipv4.encode({ start: 0, end: 6, buffer: addr }, { host, port });
    sodium.crypto_generichash(out, addr);
    return out;
  }
});

// node_modules/dht-rpc/lib/errors.js
var require_errors4 = __commonJS((exports, module) => {
  module.exports = class DHTError extends Error {
    constructor(msg, code, fn = DHTError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "DHTError";
    }
    static UNKNOWN_COMMAND = 1;
    static INVALID_TOKEN = 2;
    static REQUEST_TIMEOUT(msg = "Request timed out") {
      return new DHTError(msg, "REQUEST_TIMEOUT", DHTError.REQUEST_TIMEOUT);
    }
    static REQUEST_DESTROYED(msg = "Request destroyed") {
      return new DHTError(msg, "REQUEST_DESTROYED", DHTError.REQUEST_DESTROYED);
    }
    static IO_SUSPENDED(msg = "I/O suspended") {
      return new DHTError(msg, "IO_SUSPENDED", DHTError.IO_SUSPENDED);
    }
  };
});

// node_modules/dht-rpc/lib/io.js
var require_io = __commonJS((exports, module) => {
  var FIFO = require_fast_fifo();
  var sodium = require_sodium_native();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var peer = require_peer();
  var {
    INVALID_TOKEN,
    REQUEST_TIMEOUT,
    REQUEST_DESTROYED,
    IO_SUSPENDED
  } = require_errors4();
  var VERSION = 3;
  var RESPONSE_ID = 1 << 4 | VERSION;
  var REQUEST_ID = 0 << 4 | VERSION;
  var EMPTY_ARRAY = [];
  module.exports = class IO {
    constructor(table, udx, { maxWindow = 80, port = 0, host = "0.0.0.0", anyPort = true, firewalled = true, onrequest, onresponse = noop, ontimeout = noop } = {}) {
      this.table = table;
      this.udx = udx;
      this.inflight = [];
      this.clientSocket = null;
      this.serverSocket = null;
      this.firewalled = firewalled !== false;
      this.ephemeral = true;
      this.congestion = new CongestionWindow(maxWindow);
      this.networkInterfaces = udx.watchNetworkInterfaces();
      this.suspended = false;
      this.stats = {
        commands: [
          { tx: 0, rx: 0 },
          { tx: 0, rx: 0 },
          { tx: 0, rx: 0 },
          { tx: 0, rx: 0 }
        ]
      };
      this.onrequest = onrequest;
      this.onresponse = onresponse;
      this.ontimeout = ontimeout;
      this._pending = new FIFO;
      this._rotateSecrets = 10;
      this._tid = Math.random() * 65536 | 0;
      this._secrets = null;
      this._drainInterval = null;
      this._destroying = null;
      this._binding = null;
      this.portRange = port.length ? port : port === 0 ? [0, 0] : [port, port + 5];
      this._host = host;
      this._anyPort = anyPort !== false;
      this._boundServerPort = 0;
      this._boundClientPort = 0;
    }
    onmessage(socket, buffer, { host, port }) {
      if (buffer.byteLength < 2 || !(port > 0 && port < 65536) || this.suspended === true)
        return;
      const from = { id: null, host, port };
      const state = { start: 1, end: buffer.byteLength, buffer };
      const expectedSocket = this.firewalled ? this.clientSocket : this.serverSocket;
      const external = socket !== expectedSocket;
      if (buffer[0] === REQUEST_ID) {
        const req = Request.decode(this, socket, from, state);
        if (req === null)
          return;
        if (req.token !== null && !b4a.equals(req.token, this.token(req.from, 1)) && !b4a.equals(req.token, this.token(req.from, 0))) {
          req.error(INVALID_TOKEN, { token: true });
          return;
        }
        this.onrequest(req, external);
        return;
      }
      if (buffer[0] === RESPONSE_ID) {
        const res = decodeReply(from, state);
        if (res === null)
          return;
        for (let i = 0;i < this.inflight.length; i++) {
          const req = this.inflight[i];
          if (req.tid !== res.tid)
            continue;
          res.rtt = Date.now() - req._timestamp;
          if (i === this.inflight.length - 1)
            this.inflight.pop();
          else
            this.inflight[i] = this.inflight.pop();
          if (req.session)
            req.session._detach(req);
          if (req._timeout) {
            clearTimeout(req._timeout);
            req._timeout = null;
          }
          this.congestion.recv();
          if (req.internal && req.command < this.stats.commands.length) {
            this.stats.commands[req.command].rx++;
          }
          this.onresponse(res, external);
          req.onresponse(res, req);
          break;
        }
      }
    }
    token(addr, i) {
      if (this._secrets === null) {
        const buf = b4a.alloc(64);
        this._secrets = [buf.subarray(0, 32), buf.subarray(32, 64)];
        sodium.randombytes_buf(this._secrets[0]);
        sodium.randombytes_buf(this._secrets[1]);
      }
      const token = b4a.allocUnsafe(32);
      sodium.crypto_generichash(token, b4a.from(addr.host), this._secrets[i]);
      return token;
    }
    async destroy() {
      if (this._destroying)
        return this._destroying;
      this._destroying = this._destroy();
      return this._destroying;
    }
    async _destroy() {
      await this.bind();
      await this._clear(false);
    }
    async _clear(suspended) {
      if (this._drainInterval) {
        clearInterval(this._drainInterval);
        this._drainInterval = null;
      }
      while (this.inflight.length) {
        const req = this.inflight.pop();
        if (req._timeout)
          clearTimeout(req._timeout);
        req._timeout = null;
        req.destroyed = true;
        if (req.session)
          req.session._detach(req);
        this.congestion.recv();
        req.onerror(suspended ? IO_SUSPENDED() : REQUEST_DESTROYED(), req);
      }
      await Promise.allSettled([
        this.serverSocket.close(),
        this.clientSocket.close()
      ]);
      this.networkInterfaces.destroy();
    }
    async suspend() {
      this.suspended = true;
      await this._clear(true);
      this.congestion.clear();
      if (this._drainInterval) {
        clearInterval(this._drainInterval);
        this._drainInterval = null;
      }
    }
    async _rebind(binding) {
      if (binding)
        await binding;
      if (this._destroying)
        return this._destroying;
      await this._bindSockets();
      this.networkInterfaces = this.udx.watchNetworkInterfaces();
    }
    resume() {
      this.suspended = false;
      const binding = this._binding;
      this._binding = this._rebind(binding);
      return this._binding;
    }
    bind() {
      if (this._binding)
        return this._binding;
      this._binding = this._bindSockets();
      return this._binding;
    }
    async _bindSockets() {
      const serverSocket = this.udx.createSocket();
      const candidatePorts = [];
      if (this._boundServerPort)
        candidatePorts.push(this._boundServerPort);
      for (let i = this.portRange[0];i < this.portRange[1]; i++)
        candidatePorts.push(i);
      for (const port of candidatePorts) {
        if (serverSocket.bound)
          break;
        try {
          serverSocket.bind(port, this._host);
        } catch (err) {
          if (!this._anyPort) {
            await serverSocket.close();
            throw err;
          }
        }
      }
      if (!serverSocket.bound) {
        try {
          serverSocket.bind(0, this._host);
        } catch (err) {
          await serverSocket.close();
          throw err;
        }
      }
      const clientSocket = this.udx.createSocket();
      try {
        clientSocket.bind(this._boundClientPort || 0, this._host);
      } catch {
        try {
          clientSocket.bind(0, this._host);
        } catch (err) {
          await serverSocket.close();
          await clientSocket.close();
          throw err;
        }
      }
      this._boundServerPort = serverSocket.address().port;
      this._boundClientPort = clientSocket.address().port;
      this.clientSocket = clientSocket;
      this.serverSocket = serverSocket;
      this.serverSocket.on("message", this.onmessage.bind(this, this.serverSocket));
      this.clientSocket.on("message", this.onmessage.bind(this, this.clientSocket));
      if (this._drainInterval === null) {
        this._drainInterval = setInterval(this._drain.bind(this), 750);
        if (this._drainInterval.unref)
          this._drainInterval.unref();
      }
      for (const req of this.inflight) {
        if (!req.socket)
          req.socket = this.firewalled ? this.clientSocket : this.serverSocket;
        req.sent = 0;
        req.send(false);
      }
    }
    _drain() {
      if (this._secrets !== null && --this._rotateSecrets === 0) {
        this._rotateSecrets = 10;
        const tmp = this._secrets[0];
        this._secrets[0] = this._secrets[1];
        this._secrets[1] = tmp;
        sodium.crypto_generichash(tmp, tmp);
      }
      this.congestion.drain();
      while (!this.congestion.isFull()) {
        const p = this._pending.shift();
        if (p === undefined)
          return;
        p._sendNow();
      }
    }
    createRequest(to, token, internal, command, target, value, session, ttl) {
      if (this._destroying !== null)
        return null;
      if (this._tid === 65536)
        this._tid = 0;
      const tid = this._tid++;
      const socket = this.firewalled ? this.clientSocket : this.serverSocket;
      const req = new Request(this, socket, tid, null, to, token, internal, command, target, value, session, ttl || 0);
      this.inflight.push(req);
      if (session)
        session._attach(req);
      if (internal && command < this.stats.commands.length) {
        this.stats.commands[command].tx++;
      }
      return req;
    }
  };

  class Request {
    constructor(io, socket, tid, from, to, token, internal, command, target, value, session, ttl) {
      this.socket = socket;
      this.tid = tid;
      this.from = from;
      this.to = to;
      this.token = token;
      this.command = command;
      this.target = target;
      this.value = value;
      this.internal = internal;
      this.session = session;
      this.ttl = ttl;
      this.index = -1;
      this.sent = 0;
      this.retries = 3;
      this.destroyed = false;
      this.oncycle = noop;
      this.onerror = noop;
      this.onresponse = noop;
      this._buffer = null;
      this._io = io;
      this._timeout = null;
      this._timestamp = Date.now();
    }
    static decode(io, socket, from, state) {
      try {
        const flags = c.uint.decode(state);
        const tid = c.uint16.decode(state);
        const to = peer.ipv4.decode(state);
        const id = flags & 1 ? c.fixed32.decode(state) : null;
        const token = flags & 2 ? c.fixed32.decode(state) : null;
        const internal = (flags & 4) !== 0;
        const command = c.uint.decode(state);
        const target = flags & 8 ? c.fixed32.decode(state) : null;
        const value = flags & 16 ? c.buffer.decode(state) : null;
        if (id !== null)
          from.id = validateId(id, from);
        return new Request(io, socket, tid, from, to, token, internal, command, target, value, null, 0);
      } catch {
        return null;
      }
    }
    reply(value, opts = {}) {
      const socket = opts.socket || this.socket;
      const to = opts.to || this.from;
      this._sendReply(0, value || null, opts.token !== false, opts.closerNodes !== false, to, socket);
    }
    error(code, opts = {}) {
      const socket = opts.socket || this.socket;
      const to = opts.to || this.from;
      this._sendReply(code, null, opts.token === true, opts.closerNodes !== false, to, socket);
    }
    relay(value, to, opts) {
      const socket = opts && opts.socket || this.socket;
      const buffer = this._encodeRequest(null, value, to, socket);
      socket.trySend(buffer, to.port, to.host, this.ttl);
    }
    send(force = false) {
      if (this.destroyed)
        return;
      if (this.socket === null)
        return;
      if (this._buffer === null)
        this._buffer = this._encodeRequest(this.token, this.value, this.to, this.socket);
      if (!force && this._io.congestion.isFull()) {
        this._io._pending.push(this);
        return;
      }
      this._sendNow();
    }
    sendReply(error, value, token, hasCloserNodes) {
      this._sendReply(error, value, token, hasCloserNodes, this.from, this.socket, null);
    }
    _sendNow() {
      if (this.destroyed)
        return;
      this.sent++;
      this._io.congestion.send();
      this.socket.trySend(this._buffer, this.to.port, this.to.host, this.ttl);
      if (this._timeout)
        clearTimeout(this._timeout);
      this._timeout = setTimeout(oncycle, 1000, this);
    }
    destroy(err) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }
      const i = this._io.inflight.indexOf(this);
      if (i === -1)
        return;
      if (i === this._io.inflight.length - 1)
        this._io.inflight.pop();
      else
        this._io.inflight[i] = this._io.inflight.pop();
      if (this.session)
        this.session._detach(this);
      this._io.congestion.recv();
      this.onerror(err || REQUEST_DESTROYED(), this);
    }
    _sendReply(error, value, token, hasCloserNodes, from, socket) {
      if (socket === null || this.destroyed)
        return;
      const id = this._io.ephemeral === false && socket === this._io.serverSocket;
      const closerNodes = this.target !== null && hasCloserNodes ? this._io.table.closest(this.target) : EMPTY_ARRAY;
      const state = { start: 0, end: 1 + 1 + 6 + 2, buffer: null };
      if (id)
        state.end += 32;
      if (token)
        state.end += 32;
      if (closerNodes.length > 0)
        peer.ipv4Array.preencode(state, closerNodes);
      if (error > 0)
        c.uint.preencode(state, error);
      if (value)
        c.buffer.preencode(state, value);
      state.buffer = b4a.allocUnsafe(state.end);
      state.buffer[state.start++] = RESPONSE_ID;
      state.buffer[state.start++] = (id ? 1 : 0) | (token ? 2 : 0) | (closerNodes.length > 0 ? 4 : 0) | (error > 0 ? 8 : 0) | (value ? 16 : 0);
      c.uint16.encode(state, this.tid);
      peer.ipv4.encode(state, from);
      if (id)
        c.fixed32.encode(state, this._io.table.id);
      if (token)
        c.fixed32.encode(state, this._io.token(from, 1));
      if (closerNodes.length > 0)
        peer.ipv4Array.encode(state, closerNodes);
      if (error > 0)
        c.uint.encode(state, error);
      if (value)
        c.buffer.encode(state, value);
      socket.trySend(state.buffer, from.port, from.host, this.ttl);
    }
    _encodeRequest(token, value, to, socket) {
      const id = this._io.ephemeral === false && socket === this._io.serverSocket;
      const state = { start: 0, end: 1 + 1 + 6 + 2, buffer: null };
      if (id)
        state.end += 32;
      if (token)
        state.end += 32;
      c.uint.preencode(state, this.command);
      if (this.target)
        state.end += 32;
      if (value)
        c.buffer.preencode(state, value);
      state.buffer = b4a.allocUnsafe(state.end);
      state.buffer[state.start++] = REQUEST_ID;
      state.buffer[state.start++] = (id ? 1 : 0) | (token ? 2 : 0) | (this.internal ? 4 : 0) | (this.target ? 8 : 0) | (value ? 16 : 0);
      c.uint16.encode(state, this.tid);
      peer.ipv4.encode(state, to);
      if (id)
        c.fixed32.encode(state, this._io.table.id);
      if (token)
        c.fixed32.encode(state, token);
      c.uint.encode(state, this.command);
      if (this.target)
        c.fixed32.encode(state, this.target);
      if (value)
        c.buffer.encode(state, value);
      return state.buffer;
    }
  }

  class CongestionWindow {
    constructor(maxWindow) {
      this._i = 0;
      this._total = 0;
      this._window = [0, 0, 0, 0];
      this._maxWindow = maxWindow;
    }
    clear() {
      this._i = 0;
      this._total = 0;
      this._window = [0, 0, 0, 0];
    }
    isFull() {
      return this._total >= 2 * this._maxWindow || this._window[this._i] >= this._maxWindow;
    }
    recv() {
      if (this._window[this._i] > 0) {
        this._window[this._i]--;
        this._total--;
      }
    }
    send() {
      this._total++;
      this._window[this._i]++;
    }
    drain() {
      this._i = this._i + 1 & 3;
      this._total -= this._window[this._i];
      this._window[this._i] = 0;
    }
  }
  function noop() {}
  function oncycle(req) {
    req._timeout = null;
    req.oncycle(req);
    if (req.sent >= req.retries) {
      req.destroy(REQUEST_TIMEOUT());
      req._io.ontimeout(req);
    } else {
      req.send();
    }
  }
  function decodeReply(from, state) {
    try {
      const flags = c.uint.decode(state);
      const tid = c.uint16.decode(state);
      const to = peer.ipv4.decode(state);
      const id = flags & 1 ? c.fixed32.decode(state) : null;
      const token = flags & 2 ? c.fixed32.decode(state) : null;
      const closerNodes = flags & 4 ? peer.ipv4Array.decode(state) : null;
      const error = flags & 8 ? c.uint.decode(state) : 0;
      const value = flags & 16 ? c.buffer.decode(state) : null;
      if (id !== null)
        from.id = validateId(id, from);
      return { tid, rtt: 0, from, to, token, closerNodes, error, value };
    } catch {
      return null;
    }
  }
  function validateId(id, from) {
    const expected = peer.id(from.host, from.port);
    return b4a.equals(expected, id) ? expected : null;
  }
});

// node_modules/dht-rpc/lib/commands.js
var require_commands = __commonJS((exports) => {
  exports.PING = 0;
  exports.PING_NAT = 1;
  exports.FIND_NODE = 2;
  exports.DOWN_HINT = 3;
});

// node_modules/dht-rpc/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { Readable } = require_streamx();
  var b4a = require_b4a();
  var peer = require_peer();
  var { DOWN_HINT } = require_commands();
  var DONE = [];
  var DOWN = [];
  module.exports = class Query extends Readable {
    constructor(dht, target, internal, command, value, opts = {}) {
      super();
      dht.stats.queries.total++;
      dht.stats.queries.active++;
      this.force = !!opts.force;
      this.dht = dht;
      this.k = this.dht.table.k;
      this.target = target;
      this.internal = internal;
      this.command = command;
      this.value = value;
      this.errors = 0;
      this.successes = 0;
      this.concurrency = opts.concurrency || this.dht.concurrency;
      this.inflight = 0;
      this.map = opts.map || defaultMap;
      this.maxSlow = opts.maxSlow === 0 ? 0 : opts.maxSlow || 5;
      this.closestReplies = [];
      this._slow = 0;
      this._online = false;
      this._slowdown = false;
      this._seen = new Map;
      this._pending = [];
      this._fromTable = false;
      this._commit = opts.commit === true ? autoCommit : opts.commit || null;
      this._commiting = false;
      this._session = opts.session || dht.session();
      this._autoDestroySession = !opts.session;
      this._onlyClosestNodes = false;
      this._onvisitbound = this._onvisit.bind(this);
      this._onerrorbound = this._onerror.bind(this);
      this._oncyclebound = this._oncycle.bind(this);
      const nodes = opts.nodes || opts.closestNodes;
      const replies = opts.replies || opts.closestReplies;
      if (nodes) {
        for (let i = nodes.length - 1;i >= 0; i--) {
          const node = nodes[i];
          this._addPending({ id: node.id || peer.id(node.host, node.port), host: node.host, port: node.port }, null);
        }
      } else if (replies) {
        for (let i = replies.length - 1;i >= 0; i--) {
          this._addPending(replies[i].from, null);
        }
      }
      if (opts.onlyClosestNodes)
        this._onlyClosestNodes = true;
    }
    get closestNodes() {
      const nodes = new Array(this.closestReplies.length);
      for (let i = 0;i < nodes.length; i++) {
        nodes[i] = this.closestReplies[i].from;
      }
      return nodes;
    }
    finished() {
      return new Promise((resolve, reject) => {
        const self = this;
        let error = null;
        this.resume();
        this.on("error", onerror);
        this.on("close", onclose);
        function onclose() {
          self.removeListener("error", onerror);
          self.removeListener("close", onclose);
          if (error)
            reject(error);
          else
            resolve();
        }
        function onerror(err) {
          error = err;
        }
      });
    }
    _addFromTable() {
      if (this._pending.length >= this.k)
        return;
      this._fromTable = true;
      const closest = this.dht.table.closest(this.target, this.k - this._pending.length);
      for (const node of closest) {
        this._addPending({ id: node.id, host: node.host, port: node.port }, null);
      }
    }
    async _open(cb) {
      this._addFromTable();
      if (this._pending.length >= this.k)
        return cb(null);
      for await (const node of this.dht._resolveBootstrapNodes()) {
        this._addPending(node, null);
      }
      cb(null);
    }
    _isCloser(id) {
      return this.closestReplies.length < this.k || this._compare(id, this.closestReplies[this.closestReplies.length - 1].from.id) < 0;
    }
    _addPending(node, ref) {
      if (this._onlyClosestNodes)
        return false;
      const addr = node.host + ":" + node.port;
      const refs = this._seen.get(addr);
      const isCloser = this._isCloser(node.id);
      if (refs === DONE) {
        return isCloser;
      }
      if (refs === DOWN) {
        if (ref)
          this._downHint(ref, node);
        return isCloser;
      }
      if (refs) {
        if (ref !== null)
          refs.push(ref);
        return isCloser;
      }
      if (!isCloser) {
        return false;
      }
      this._seen.set(addr, ref === null ? [] : [ref]);
      this._pending.push(node);
      return true;
    }
    _read(cb) {
      this._readMore();
      cb(null);
    }
    _readMore() {
      if (this.destroying || this._commiting)
        return;
      const concurrency = (this._slowdown ? 3 : this.concurrency) + this._slow;
      while (this.inflight < concurrency && this._pending.length > 0) {
        const next = this._pending.pop();
        if (next && next.id && !this._isCloser(next.id))
          continue;
        this._visit(next);
      }
      if (!this._fromTable && this.successes === 0 && this.errors === 0) {
        this._slowdown = true;
      }
      if (this._pending.length > 0)
        return;
      if (this.inflight === 0 || this._slow <= this.maxSlow && this._slow === this.inflight && this.closestReplies.length >= this.k) {
        if (!this._fromTable && this.successes < this.k / 4) {
          this._addFromTable();
          this._readMore();
          return;
        }
        this._flush();
      }
    }
    _flush() {
      if (this._commiting)
        return;
      this._commiting = true;
      if (this._commit === null) {
        this.push(null);
        return;
      }
      const p = [];
      for (const m of this.closestReplies)
        p.push(this._commit(m, this.dht, this));
      this._endAfterCommit(p);
    }
    _endAfterCommit(ps) {
      if (!ps.length) {
        this.destroy(new Error("Too few nodes responded"));
        return;
      }
      const self = this;
      let pending = ps.length;
      let success = 0;
      for (const p of ps)
        p.then(ondone, onerror);
      function ondone() {
        success++;
        if (--pending === 0)
          self.push(null);
      }
      function onerror(err) {
        if (--pending > 0)
          return;
        if (success)
          self.push(null);
        else
          self.destroy(err);
      }
    }
    _dec(req) {
      if (req.oncycle === noop) {
        this._slow--;
      } else {
        req.oncycle = noop;
      }
      this.inflight--;
    }
    _onvisit(m, req) {
      this._dec(req);
      this._online = true;
      if (!this.dht.online)
        this.dht._online();
      const addr = req.to.host + ":" + req.to.port;
      this._seen.set(addr, DONE);
      if (this._commiting)
        return;
      if (m.error === 0)
        this.successes++;
      else
        this.errors++;
      if (m.error === 0 && m.from.id !== null && this._isCloser(m.from.id))
        this._pushClosest(m);
      if (m.closerNodes !== null) {
        for (const node of m.closerNodes) {
          node.id = peer.id(node.host, node.port);
          if (this.dht._filterNode !== null && !this.dht._filterNode(node))
            continue;
          if (b4a.equals(node.id, this.dht.table.id))
            continue;
          if (!this._addPending(node, m.from))
            break;
        }
      }
      if (!this._fromTable && this.successes + this.errors >= this.concurrency) {
        this._slowdown = false;
      }
      if (m.error !== 0) {
        this._readMore();
        return;
      }
      const data = this.map(m);
      if (!data || this.push(data) !== false) {
        this._readMore();
      }
    }
    _onerror(err, req) {
      const addr = req.to.host + ":" + req.to.port;
      const refs = this._seen.get(addr);
      if (err.code === "REQUEST_TIMEOUT") {
        this._seen.set(addr, DOWN);
        for (const node of refs)
          this._downHint(node, req.to);
      }
      this._dec(req);
      this.errors++;
      this._readMore();
    }
    _oncycle(req) {
      req.oncycle = noop;
      this._slow++;
      this._readMore();
    }
    _downHint(node, down) {
      const state = { start: 0, end: 6, buffer: b4a.allocUnsafe(6) };
      peer.ipv4.encode(state, down);
      this.dht._request(node, false, true, DOWN_HINT, null, state.buffer, this._session, noop, noop);
    }
    _pushClosest(m) {
      this.closestReplies.push(m);
      for (let i = this.closestReplies.length - 2;i >= 0; i--) {
        const prev = this.closestReplies[i];
        const cmp = this._compare(prev.from.id, m.from.id);
        if (cmp < 0)
          break;
        if (cmp === 0) {
          this.closestReplies.splice(i + 1, 1);
          break;
        }
        this.closestReplies[i + 1] = prev;
        this.closestReplies[i] = m;
      }
      if (this.closestReplies.length > this.k)
        this.closestReplies.pop();
    }
    _compare(a, b) {
      for (let i = 0;i < a.length; i++) {
        if (a[i] === b[i])
          continue;
        const t = this.target[i];
        return (t ^ a[i]) - (t ^ b[i]);
      }
      return 0;
    }
    _visit(to) {
      this.inflight++;
      const req = this.dht._request(to, this.force, this.internal, this.command, this.target, this.value, this._session, this._onvisitbound, this._onerrorbound);
      if (req === null) {
        this.destroy(new Error("Node was destroyed"));
        return;
      }
      req.oncycle = this._oncyclebound;
      if (this.force)
        req.retries = 0;
    }
    _destroy(cb) {
      this.dht.stats.queries.active--;
      if (!this._online && this.dht.online)
        this.dht._offline();
      if (this._autoDestroySession)
        this._session.destroy();
      cb(null);
    }
  };
  function autoCommit(reply, dht, query) {
    if (!reply.token)
      return Promise.reject(new Error("No token received for closest node"));
    return dht.request({ token: reply.token, target: query.target, command: query.command, value: query.value }, reply.from);
  }
  function defaultMap(m) {
    return m;
  }
  function noop() {}
});

// node_modules/dht-rpc/lib/session.js
var require_session = __commonJS((exports, module) => {
  module.exports = class Session {
    constructor(dht) {
      this.dht = dht;
      this.inflight = [];
    }
    _attach(req) {
      req.index = this.inflight.push(req) - 1;
    }
    _detach(req) {
      const i = req.index;
      if (i === -1)
        return;
      req.index = -1;
      if (i === this.inflight.length - 1)
        this.inflight.pop();
      else {
        const req2 = this.inflight[i] = this.inflight.pop();
        req2.index = i;
      }
    }
    query({ target, command, value }, opts = {}) {
      return this.dht.query({ target, command, value }, { ...opts, session: this });
    }
    request({ token, command, target, value }, { host, port }, opts = {}) {
      return this.dht.request({ token, command, target, value }, { host, port }, { ...opts, session: this });
    }
    ping({ host, port }, opts = {}) {
      return this.dht.ping({ host, port }, { ...opts, session: this });
    }
    destroy(err) {
      while (this.inflight.length) {
        const req = this.inflight[0];
        this.dht.io.congestion.recv();
        req.destroy(err);
      }
    }
  };
});

// node_modules/dht-rpc/index.js
var require_dht_rpc = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var Table = require_kademlia_routing_table();
  var TOS = require_time_ordered_set();
  var UDX = require_udx();
  var sodium = require_sodium_native();
  var c = require_compact_encoding();
  var NatSampler = require_nat_sampler();
  var b4a = require_b4a();
  var IO = require_io();
  var Query = require_query();
  var Session = require_session();
  var peer = require_peer();
  var { UNKNOWN_COMMAND, INVALID_TOKEN } = require_errors4();
  var { PING, PING_NAT, FIND_NODE, DOWN_HINT } = require_commands();
  var TMP = b4a.allocUnsafe(32);
  var TICK_INTERVAL = 5000;
  var SLEEPING_INTERVAL = 3 * TICK_INTERVAL;
  var STABLE_TICKS = 240;
  var MORE_STABLE_TICKS = 3 * STABLE_TICKS;
  var REFRESH_TICKS = 60;
  var RECENT_NODE = 12;
  var OLD_NODE = 360;

  class DHT extends EventEmitter {
    constructor(opts = {}) {
      super();
      this.bootstrapNodes = opts.bootstrap === false ? [] : (opts.bootstrap || []).map(parseNode);
      this.table = new Table(randomBytes(32));
      this.nodes = new TOS;
      this.udx = opts.udx || new UDX;
      this.io = new IO(this.table, this.udx, {
        ...opts,
        onrequest: this._onrequest.bind(this),
        onresponse: this._onresponse.bind(this),
        ontimeout: this._ontimeout.bind(this)
      });
      this.concurrency = opts.concurrency || 10;
      this.bootstrapped = false;
      this.ephemeral = true;
      this.firewalled = this.io.firewalled;
      this.adaptive = typeof opts.ephemeral !== "boolean" && opts.adaptive !== false;
      this.destroyed = false;
      this.suspended = false;
      this.online = true;
      this.stats = {
        queries: { active: 0, total: 0 },
        commands: {
          ping: this.io.stats.commands[PING],
          pingNat: this.io.stats.commands[PING_NAT],
          findNode: this.io.stats.commands[FIND_NODE],
          downHint: this.io.stats.commands[DOWN_HINT]
        }
      };
      this._nat = new NatSampler;
      this._quickFirewall = opts.quickFirewall !== false;
      this._forcePersistent = opts.ephemeral === false;
      this._repinging = 0;
      this._checks = 0;
      this._tick = randomOffset(100);
      this._refreshTicks = randomOffset(REFRESH_TICKS);
      this._stableTicks = this.adaptive ? STABLE_TICKS : 0;
      this._tickInterval = setInterval(this._ontick.bind(this), TICK_INTERVAL);
      this._lastTick = Date.now();
      this._lastHost = null;
      this._filterNode = opts.filterNode || opts.addNode || null;
      this._onrow = (row) => row.on("full", (node) => this._onfullrow(node, row));
      this._nonePersistentSamples = [];
      this._bootstrapping = this._bootstrap();
      this._bootstrapping.catch(noop);
      this.table.on("row", this._onrow);
      this.io.networkInterfaces.on("change", (interfaces) => this._onnetworkchange(interfaces));
      if (opts.nodes) {
        for (let i = opts.nodes.length - 1;i >= 0; i--) {
          this.addNode(opts.nodes[i]);
        }
      }
    }
    static bootstrapper(port, host, opts) {
      if (!port)
        throw new Error("Port is required");
      if (!host)
        throw new Error("Host is required");
      if (host === "0.0.0.0" || host === "::")
        throw new Error("Invalid host");
      if (!UDX.isIPv4(host))
        throw new Error("Host must be a IPv4 address");
      const dht = new this({ port, ephemeral: false, firewalled: false, anyPort: false, bootstrap: [], ...opts });
      dht._nat.add(host, port);
      return dht;
    }
    get id() {
      return this.ephemeral ? null : this.table.id;
    }
    get host() {
      return this._nat.host;
    }
    get port() {
      return this._nat.port;
    }
    get randomized() {
      return this._nat.host !== null && this._nat.port === 0;
    }
    get socket() {
      return this.firewalled ? this.io.clientSocket : this.io.serverSocket;
    }
    onmessage(socket, buf, rinfo) {
      if (buf.byteLength > 1)
        this.io.onmessage(socket, buf, rinfo);
    }
    bind() {
      return this.io.bind();
    }
    async suspend({ log = noop } = {}) {
      log("Suspending waiting for io bind...");
      await this.io.bind();
      log("Done, continuing");
      if (this.suspended || this.destroyed)
        return;
      this.suspended = true;
      clearInterval(this._tickInterval);
      log("Done, suspending io");
      await this.io.suspend({ log });
      log("Done, dht suspended");
      this.emit("suspend");
    }
    async resume({ log = noop } = {}) {
      if (!this.suspended || this.destroyed)
        return;
      this.suspended = false;
      this._tickInterval = setInterval(this._ontick.bind(this), TICK_INTERVAL);
      this._onwakeup();
      log("Resuming io");
      await this.io.resume();
      log("Done, dht resumed");
      this.io.networkInterfaces.on("change", (interfaces) => this._onnetworkchange(interfaces));
      this.refresh();
      this.emit("resume");
    }
    address() {
      const socket = this.socket;
      return socket ? socket.address() : null;
    }
    localAddress() {
      if (!this.io.serverSocket)
        return null;
      return {
        host: localIP(this.udx),
        port: this.io.serverSocket.address().port
      };
    }
    remoteAddress() {
      if (!this.host)
        return null;
      if (!this.port)
        return null;
      if (this.firewalled)
        return null;
      if (!this.io.serverSocket)
        return null;
      const port = this.io.serverSocket.address().port;
      if (port !== this.port)
        return null;
      return {
        host: this.host,
        port
      };
    }
    addNode({ host, port }) {
      this._addNode({
        id: peer.id(host, port),
        port,
        host,
        token: null,
        to: null,
        sampled: 0,
        added: this._tick,
        pinged: 0,
        seen: 0,
        downHints: 0,
        prev: null,
        next: null
      });
    }
    toArray(opts) {
      const limit = opts && opts.limit;
      if (limit === 0)
        return [];
      return this.nodes.toArray({ limit, reverse: true }).map(({ host, port }) => ({ host, port }));
    }
    async fullyBootstrapped() {
      return this._bootstrapping;
    }
    ready() {
      return this.fullyBootstrapped();
    }
    findNode(target, opts) {
      if (this.destroyed)
        throw new Error("Node destroyed");
      this._refreshTicks = REFRESH_TICKS;
      return new Query(this, target, true, FIND_NODE, null, opts);
    }
    query({ target, command, value }, opts) {
      if (this.destroyed)
        throw new Error("Node destroyed");
      this._refreshTicks = REFRESH_TICKS;
      return new Query(this, target, false, command, value || null, opts);
    }
    ping({ host, port }, opts) {
      let value = null;
      if (opts && opts.size && opts.size > 0)
        value = b4a.alloc(opts.size);
      const req = this.io.createRequest({ id: null, host, port }, null, true, PING, null, value, opts && opts.session || null, opts && opts.ttl);
      return this._requestToPromise(req, opts);
    }
    request({ token = null, command, target = null, value = null }, { host, port }, opts) {
      const req = this.io.createRequest({ id: null, host, port }, token, false, command, target, value, opts && opts.session || null, opts && opts.ttl);
      return this._requestToPromise(req, opts);
    }
    session() {
      return new Session(this);
    }
    _requestToPromise(req, opts) {
      if (req === null)
        return Promise.reject(new Error("Node destroyed"));
      if (opts && opts.socket)
        req.socket = opts.socket;
      if (opts && opts.retry === false)
        req.retries = 0;
      return new Promise((resolve, reject) => {
        req.onresponse = resolve;
        req.onerror = reject;
        req.send();
      });
    }
    async _bootstrap() {
      const self = this;
      await Promise.resolve();
      await this.io.bind();
      this.emit("listening");
      let first = this.firewalled && this._quickFirewall && !this._forcePersistent;
      let testNat = false;
      const onlyFirewall = !this._forcePersistent;
      for (let i = 0;i < 2; i++) {
        await this._backgroundQuery(this.table.id).on("data", ondata).finished();
        if (this.bootstrapped || !testNat && !this._forcePersistent)
          break;
        if (!await this._updateNetworkState(onlyFirewall))
          break;
      }
      if (this.bootstrapped)
        return;
      this.bootstrapped = true;
      this.emit("ready");
      function ondata(data) {
        if (!first)
          return;
        first = false;
        const value = b4a.allocUnsafe(2);
        c.uint16.encode({ start: 0, end: 2, buffer: value }, self.io.serverSocket.address().port);
        self._request(data.from, false, true, PING_NAT, null, value, null, () => {
          testNat = true;
        }, noop);
      }
    }
    refresh() {
      const node = this.table.random();
      this._backgroundQuery(node ? node.id : this.table.id).on("error", noop);
    }
    async destroy() {
      const emitClose = !this.destroyed;
      this.destroyed = true;
      clearInterval(this._tickInterval);
      await this.io.destroy();
      if (emitClose)
        this.emit("close");
    }
    _request(to, force, internal, command, target, value, session, onresponse, onerror) {
      const req = this.io.createRequest(to, null, internal, command, target, value, session);
      if (req === null)
        return null;
      req.onresponse = onresponse;
      req.onerror = onerror;
      req.send(force);
      return req;
    }
    _natAdd(host, port) {
      const prevHost = this._nat.host;
      const prevPort = this._nat.port;
      this._nat.add(host, port);
      if (prevHost === this._nat.host && prevPort === this._nat.port)
        return;
      this.emit("nat-update", this._nat.host, this._nat.port);
    }
    _sampleBootstrapMaybe(from, to) {
      if (this._nonePersistentSamples.length >= Math.max(1, this.bootstrapNodes.length))
        return;
      const id = from.host + ":" + from.port;
      if (this._nonePersistentSamples.indexOf(id) > -1)
        return;
      this._nonePersistentSamples.push(id);
      this._natAdd(to.host, to.port);
    }
    _addNodeFromNetwork(sample, from, to) {
      if (this._filterNode !== null && !this._filterNode(from)) {
        return;
      }
      if (from.id === null) {
        this._sampleBootstrapMaybe(from, to);
        return;
      }
      const oldNode = this.table.get(from.id);
      if (oldNode) {
        if (sample && (oldNode.sampled === 0 || this._tick - oldNode.sampled >= OLD_NODE)) {
          oldNode.to = to;
          oldNode.sampled = this._tick;
          this._natAdd(to.host, to.port);
        }
        oldNode.pinged = oldNode.seen = this._tick;
        this.nodes.add(oldNode);
        return;
      }
      this._addNode({
        id: from.id,
        port: from.port,
        host: from.host,
        to,
        sampled: 0,
        added: this._tick,
        pinged: this._tick,
        seen: this._tick,
        downHints: 0,
        prev: null,
        next: null
      });
    }
    _addNode(node) {
      if (this.nodes.has(node) || b4a.equals(node.id, this.table.id))
        return;
      node.added = node.pinged = node.seen = this._tick;
      if (!this.table.add(node))
        return;
      this.nodes.add(node);
      if (node.to && node.sampled === 0) {
        node.sampled = this._tick;
        this._natAdd(node.to.host, node.to.port);
      }
      this.emit("add-node", node);
    }
    _removeStaleNode(node, lastSeen) {
      if (node.seen <= lastSeen)
        this._removeNode(node);
    }
    _removeNode(node) {
      if (!this.nodes.has(node))
        return;
      this.table.remove(node.id);
      this.nodes.remove(node);
      this.emit("remove-node", node);
    }
    _onwakeup() {
      this._tick += 2 * OLD_NODE;
      this._tick += 8 - (this._tick & 7) - 2;
      this._stableTicks = MORE_STABLE_TICKS;
      this._refreshTicks = 1;
      this._lastHost = null;
      if (this.adaptive) {
        if (!this.ephemeral) {
          this.ephemeral = true;
          this.io.ephemeral = true;
          this.emit("ephemeral");
        }
      }
      this.emit("wakeup");
    }
    _onfullrow(newNode, row) {
      if (!this.bootstrapped || this._repinging >= 3)
        return;
      let oldest = null;
      for (const node of row.nodes) {
        if (node.pinged === this._tick)
          continue;
        if (oldest === null || oldest.pinged > node.pinged || oldest.pinged === node.pinged && oldest.added > node.added)
          oldest = node;
      }
      if (oldest === null)
        return;
      if (this._tick - oldest.pinged < RECENT_NODE && this._tick - oldest.added > OLD_NODE)
        return;
      this._repingAndSwap(newNode, oldest);
    }
    _onnetworkchange(interfaces) {
      this.emit("network-change", interfaces);
      this.emit("network-update");
    }
    _repingAndSwap(newNode, oldNode) {
      const self = this;
      const lastSeen = oldNode.seen;
      oldNode.pinged = this._tick;
      this._repinging++;
      this._request({ id: null, host: oldNode.host, port: oldNode.port }, false, true, PING, null, null, null, onsuccess, onswap);
      function onsuccess(m) {
        if (oldNode.seen <= lastSeen)
          return onswap();
        self._repinging--;
      }
      function onswap(e) {
        self._repinging--;
        self._removeNode(oldNode);
        self._addNode(newNode);
      }
    }
    _onrequest(req, external) {
      if (req.from.id !== null) {
        this._addNodeFromNetwork(!external, req.from, req.to);
      }
      if (req.internal) {
        switch (req.command) {
          case PING: {
            req.sendReply(0, null, false, false);
            return;
          }
          case PING_NAT: {
            if (req.value === null || req.value.byteLength < 2)
              return;
            const port = c.uint16.decode({ start: 0, end: 2, buffer: req.value });
            if (port === 0)
              return;
            req.from.port = port;
            req.sendReply(0, null, false, false);
            return;
          }
          case FIND_NODE: {
            if (!req.target)
              return;
            req.sendReply(0, null, false, true);
            return;
          }
          case DOWN_HINT: {
            if (req.value === null || req.value.byteLength < 6)
              return;
            if (this._checks < 10) {
              sodium.crypto_generichash(TMP, req.value.subarray(0, 6));
              const node = this.table.get(TMP);
              if (node && (node.pinged < this._tick || node.downHints === 0)) {
                node.downHints++;
                this._check(node);
              }
            }
            req.sendReply(0, null, false, false);
            return;
          }
        }
        req.sendReply(UNKNOWN_COMMAND, null, false, req.target !== null);
        return;
      }
      if (this.onrequest(req) === false) {
        req.sendReply(UNKNOWN_COMMAND, null, false, req.target !== null);
      }
    }
    onrequest(req) {
      return this.emit("request", req);
    }
    _onresponse(res, external) {
      this._addNodeFromNetwork(!external, res.from, res.to);
    }
    _ontimeout(req) {
      if (!req.to.id)
        return;
      const node = this.table.get(req.to.id);
      if (node)
        this._removeNode(node);
    }
    _pingSome() {
      let cnt = this.io.inflight.length > 2 ? 3 : 5;
      let oldest = this.nodes.oldest;
      if (!oldest) {
        this.refresh();
        return;
      }
      if (this._tick - oldest.pinged < RECENT_NODE) {
        cnt = 2;
      }
      while (cnt--) {
        if (!oldest || this._tick === oldest.pinged)
          continue;
        this._check(oldest);
        oldest = oldest.next;
      }
    }
    _check(node) {
      node.pinged = this._tick;
      const lastSeen = node.seen;
      const onresponse = () => {
        this._checks--;
        this._removeStaleNode(node, lastSeen);
      };
      const onerror = () => {
        this._checks--;
        this._removeNode(node);
      };
      this._checks++;
      this._request({ id: null, host: node.host, port: node.port }, false, true, PING, null, null, null, onresponse, onerror);
    }
    _ontick() {
      const time = Date.now();
      if (time - this._lastTick > SLEEPING_INTERVAL && this.suspended === false) {
        this._onwakeup();
      } else {
        this._tick++;
      }
      this._lastTick = time;
      if (!this.bootstrapped || this.suspended)
        return;
      if (this.adaptive && this.ephemeral && --this._stableTicks <= 0) {
        if (this._lastHost === this._nat.host) {
          this._stableTicks = MORE_STABLE_TICKS;
        } else {
          this._updateNetworkState();
        }
      }
      if ((this._tick & 7) === 0) {
        this._pingSome();
      }
      if ((this._tick & 63) === 0 && this.nodes.length < this.table.k || --this._refreshTicks <= 0) {
        this.refresh();
      }
    }
    async _updateNetworkState(onlyFirewall = false) {
      if (!this.ephemeral)
        return false;
      if (onlyFirewall && !this.firewalled)
        return false;
      const { host, port } = this._nat;
      if (!onlyFirewall) {
        this._stableTicks = MORE_STABLE_TICKS;
        this._lastHost = host;
      }
      if (host === null || port === 0) {
        return false;
      }
      const natSampler = this.firewalled ? new NatSampler : this._nat;
      const firewalled = this.firewalled && await this._checkIfFirewalled(natSampler);
      if (firewalled)
        return false;
      this.firewalled = this.io.firewalled = false;
      if (!this.ephemeral || host !== this._nat.host || port !== this._nat.port)
        return false;
      if (natSampler.host !== host || natSampler.port === 0)
        return false;
      const id = peer.id(natSampler.host, natSampler.port);
      if (!onlyFirewall) {
        this.ephemeral = this.io.ephemeral = false;
      }
      if (natSampler !== this._nat) {
        const prevHost = this._nat.host;
        const prevPort = this._nat.port;
        this._nonePersistentSamples = [];
        this._nat = natSampler;
        if (prevHost !== this._nat.host || prevPort !== this._nat.port) {
          this.emit("nat-update", this._nat.host, this._nat.port);
        }
      }
      if (!b4a.equals(this.table.id, id)) {
        const nodes = this.table.toArray();
        this.table = this.io.table = new Table(id);
        for (const node of nodes) {
          if (b4a.equals(node.id, id))
            continue;
          if (!this.table.add(node))
            this.nodes.remove(node);
        }
        this.table.on("row", this._onrow);
        if (this.bootstrapped)
          this.refresh();
      }
      if (!this.ephemeral) {
        this.emit("persistent");
      }
      return true;
    }
    async* _resolveBootstrapNodes() {
      for (let { host, port } of this.bootstrapNodes) {
        let doLookup = false;
        if (host.indexOf("@") === -1) {
          doLookup = true;
        } else {
          const [suggestedIP, fallbackHost] = host.split("@");
          try {
            await this.ping({ host: suggestedIP, port });
            host = suggestedIP;
          } catch {
            host = fallbackHost;
            doLookup = true;
          }
        }
        if (doLookup) {
          try {
            host = UDX.isIPv4(host) ? host : (await this.udx.lookup(host, { family: 4 })).host;
          } catch {
            continue;
          }
        }
        yield {
          id: peer.id(host, port),
          host,
          port
        };
      }
    }
    async _addBootstrapNodes(nodes) {
      for await (const node of this._resolveBootstrapNodes()) {
        nodes.push(node);
      }
    }
    async _checkIfFirewalled(natSampler = new NatSampler) {
      const nodes = [];
      for (let node = this.nodes.latest;node && nodes.length < 5; node = node.prev) {
        nodes.push(node);
      }
      if (nodes.length < 5)
        await this._addBootstrapNodes(nodes);
      if (nodes.length === 0)
        return true;
      const hosts = new Set;
      const value = b4a.allocUnsafe(2);
      c.uint16.encode({ start: 0, end: 2, buffer: value }, this.io.serverSocket.address().port);
      this.io.serverSocket.on("message", onmessage);
      const pongs = await requestAll(this, true, PING_NAT, value, nodes);
      let count = 0;
      for (const res of pongs) {
        if (hosts.has(res.from.host)) {
          count++;
          natSampler.add(res.to.host, res.to.port);
        }
      }
      this.io.serverSocket.removeListener("message", onmessage);
      if (count < (nodes.length >= 5 ? 3 : 1))
        return true;
      if (natSampler.host === null || this._nat.host !== natSampler.host)
        return true;
      if (natSampler.port === 0 || natSampler.port !== this.io.serverSocket.address().port)
        return true;
      return false;
      function onmessage(_, { host }) {
        hosts.add(host);
      }
    }
    _backgroundQuery(target) {
      this._refreshTicks = REFRESH_TICKS;
      const backgroundCon = Math.min(this.concurrency, Math.max(2, this.concurrency / 8 | 0));
      const q = new Query(this, target, true, FIND_NODE, null, { concurrency: backgroundCon, maxSlow: 0 });
      q.on("data", () => {
        q.concurrency = this.io.inflight.length < 3 ? this.concurrency : backgroundCon;
      });
      return q;
    }
    _online() {
      if (this.online)
        return;
      this.online = true;
      this.emit("network-update");
    }
    _offline() {
      if (!this.online)
        return;
      this.online = false;
      this.emit("network-update");
    }
  }
  DHT.OK = 0;
  DHT.ERROR_UNKNOWN_COMMAND = UNKNOWN_COMMAND;
  DHT.ERROR_INVALID_TOKEN = INVALID_TOKEN;
  module.exports = DHT;
  function localIP(udx, family = 4) {
    let host = null;
    for (const n of udx.networkInterfaces()) {
      if (n.family !== family || n.internal)
        continue;
      if (n.name === "en0")
        return n.host;
      if (host === null)
        host = n.host;
    }
    return host || (family === 4 ? "127.0.0.1" : "::1");
  }
  function parseNode(s) {
    if (typeof s === "object")
      return s;
    if (typeof s === "number")
      return { host: "127.0.0.1", port: s };
    const [host, port] = s.split(":");
    if (!port)
      throw new Error("Bootstrap node format is host:port");
    return {
      host,
      port: Number(port)
    };
  }
  function randomBytes(n) {
    const b = b4a.alloc(n);
    sodium.randombytes_buf(b);
    return b;
  }
  function randomOffset(n) {
    return n - (Math.random() * 0.5 * n | 0);
  }
  function requestAll(dht, internal, command, value, nodes) {
    let missing = nodes.length;
    const replies = [];
    return new Promise((resolve) => {
      for (const node of nodes) {
        const req = dht._request(node, false, internal, command, null, value, null, onsuccess, onerror);
        if (!req)
          return resolve(replies);
      }
      function onsuccess(res) {
        replies.push(res);
        if (--missing === 0)
          resolve(replies);
      }
      function onerror() {
        if (--missing === 0)
          resolve(replies);
      }
    });
  }
  function noop() {}
});

// node_modules/hyperdht/lib/messages.js
var require_messages5 = __commonJS((exports) => {
  var c = require_compact_encoding();
  var net = require_compact_encoding_net();
  var ipv4 = {
    ...net.ipv4Address,
    decode(state) {
      const ip = net.ipv4Address.decode(state);
      return {
        host: ip.host,
        port: ip.port
      };
    }
  };
  var ipv4Array = c.array(ipv4);
  var ipv6 = {
    ...net.ipv6Address,
    decode(state) {
      const ip = net.ipv6Address.decode(state);
      return {
        host: ip.host,
        port: ip.port
      };
    }
  };
  var ipv6Array = c.array(ipv6);
  exports.handshake = {
    preencode(state, m) {
      state.end += 1 + 1 + (m.peerAddress ? 6 : 0) + (m.relayAddress ? 6 : 0);
      c.buffer.preencode(state, m.noise);
    },
    encode(state, m) {
      const flags = (m.peerAddress ? 1 : 0) | (m.relayAddress ? 2 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.mode);
      c.buffer.encode(state, m.noise);
      if (m.peerAddress)
        ipv4.encode(state, m.peerAddress);
      if (m.relayAddress)
        ipv4.encode(state, m.relayAddress);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        mode: c.uint.decode(state),
        noise: c.buffer.decode(state),
        peerAddress: flags & 1 ? ipv4.decode(state) : null,
        relayAddress: flags & 2 ? ipv4.decode(state) : null
      };
    }
  };
  var relayInfo = {
    preencode(state, m) {
      state.end += 12;
    },
    encode(state, m) {
      ipv4.encode(state, m.relayAddress);
      ipv4.encode(state, m.peerAddress);
    },
    decode(state) {
      return {
        relayAddress: ipv4.decode(state),
        peerAddress: ipv4.decode(state)
      };
    }
  };
  var relayInfoArray = c.array(relayInfo);
  var holepunchInfo = {
    preencode(state, m) {
      c.uint.preencode(state, m.id);
      relayInfoArray.preencode(state, m.relays);
    },
    encode(state, m) {
      c.uint.encode(state, m.id);
      relayInfoArray.encode(state, m.relays);
    },
    decode(state) {
      return {
        id: c.uint.decode(state),
        relays: relayInfoArray.decode(state)
      };
    }
  };
  var udxInfo = {
    preencode(state, m) {
      state.end += 2;
      c.uint.preencode(state, m.id);
      c.uint.preencode(state, m.seq);
    },
    encode(state, m) {
      c.uint.encode(state, 1);
      c.uint.encode(state, m.reusableSocket ? 1 : 0);
      c.uint.encode(state, m.id);
      c.uint.encode(state, m.seq);
    },
    decode(state) {
      const version = c.uint.decode(state);
      const features = c.uint.decode(state);
      return {
        version,
        reusableSocket: (features & 1) !== 0,
        id: c.uint.decode(state),
        seq: c.uint.decode(state)
      };
    }
  };
  var secretStreamInfo = {
    preencode(state, m) {
      c.uint.preencode(state, 1);
    },
    encode(state, m) {
      c.uint.encode(state, 1);
    },
    decode(state) {
      return {
        version: c.uint.decode(state)
      };
    }
  };
  var relayThroughInfo = {
    preencode(state, m) {
      c.uint.preencode(state, 1);
      c.uint.preencode(state, 0);
      c.fixed32.preencode(state, m.publicKey);
      c.fixed32.preencode(state, m.token);
    },
    encode(state, m) {
      c.uint.encode(state, 1);
      c.uint.encode(state, 0);
      c.fixed32.encode(state, m.publicKey);
      c.fixed32.encode(state, m.token);
    },
    decode(state) {
      const version = c.uint.decode(state);
      c.uint.decode(state);
      return {
        version,
        publicKey: c.fixed32.decode(state),
        token: c.fixed32.decode(state)
      };
    }
  };
  exports.noisePayload = {
    preencode(state, m) {
      state.end += 4;
      if (m.holepunch)
        holepunchInfo.preencode(state, m.holepunch);
      if (m.addresses4 && m.addresses4.length)
        ipv4Array.preencode(state, m.addresses4);
      if (m.addresses6 && m.addresses6.length)
        ipv6Array.preencode(state, m.addresses6);
      if (m.udx)
        udxInfo.preencode(state, m.udx);
      if (m.secretStream)
        secretStreamInfo.preencode(state, m.secretStream);
      if (m.relayThrough)
        relayThroughInfo.preencode(state, m.relayThrough);
    },
    encode(state, m) {
      let flags = 0;
      if (m.holepunch)
        flags |= 1;
      if (m.addresses4 && m.addresses4.length)
        flags |= 2;
      if (m.addresses6 && m.addresses6.length)
        flags |= 4;
      if (m.udx)
        flags |= 8;
      if (m.secretStream)
        flags |= 16;
      if (m.relayThrough)
        flags |= 32;
      c.uint.encode(state, 1);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.error);
      c.uint.encode(state, m.firewall);
      if (m.holepunch)
        holepunchInfo.encode(state, m.holepunch);
      if (m.addresses4 && m.addresses4.length)
        ipv4Array.encode(state, m.addresses4);
      if (m.addresses6 && m.addresses6.length)
        ipv6Array.encode(state, m.addresses6);
      if (m.udx)
        udxInfo.encode(state, m.udx);
      if (m.secretStream)
        secretStreamInfo.encode(state, m.secretStream);
      if (m.relayThrough)
        relayThroughInfo.encode(state, m.relayThrough);
    },
    decode(state) {
      const version = c.uint.decode(state);
      if (version !== 1) {
        return {
          version,
          error: 0,
          firewall: 0,
          holepunch: null,
          addresses4: [],
          addresses6: [],
          udx: null,
          secretStream: null,
          relayThrough: null
        };
      }
      const flags = c.uint.decode(state);
      return {
        version,
        error: c.uint.decode(state),
        firewall: c.uint.decode(state),
        holepunch: (flags & 1) !== 0 ? holepunchInfo.decode(state) : null,
        addresses4: (flags & 2) !== 0 ? ipv4Array.decode(state) : [],
        addresses6: (flags & 4) !== 0 ? ipv6Array.decode(state) : [],
        udx: (flags & 8) !== 0 ? udxInfo.decode(state) : null,
        secretStream: (flags & 16) !== 0 ? secretStreamInfo.decode(state) : null,
        relayThrough: (flags & 32) !== 0 ? relayThroughInfo.decode(state) : null
      };
    }
  };
  exports.holepunch = {
    preencode(state, m) {
      state.end += 2;
      c.uint.preencode(state, m.id);
      c.buffer.preencode(state, m.payload);
      if (m.peerAddress)
        ipv4.preencode(state, m.peerAddress);
    },
    encode(state, m) {
      const flags = m.peerAddress ? 1 : 0;
      c.uint.encode(state, flags);
      c.uint.encode(state, m.mode);
      c.uint.encode(state, m.id);
      c.buffer.encode(state, m.payload);
      if (m.peerAddress)
        ipv4.encode(state, m.peerAddress);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        mode: c.uint.decode(state),
        id: c.uint.decode(state),
        payload: c.buffer.decode(state),
        peerAddress: flags & 1 ? ipv4.decode(state) : null
      };
    }
  };
  exports.holepunchPayload = {
    preencode(state, m) {
      state.end += 4;
      if (m.addresses)
        ipv4Array.preencode(state, m.addresses);
      if (m.remoteAddress)
        state.end += 6;
      if (m.token)
        state.end += 32;
      if (m.remoteToken)
        state.end += 32;
    },
    encode(state, m) {
      const flags = (m.connected ? 1 : 0) | (m.punching ? 2 : 0) | (m.addresses ? 4 : 0) | (m.remoteAddress ? 8 : 0) | (m.token ? 16 : 0) | (m.remoteToken ? 32 : 0);
      c.uint.encode(state, flags);
      c.uint.encode(state, m.error);
      c.uint.encode(state, m.firewall);
      c.uint.encode(state, m.round);
      if (m.addresses)
        ipv4Array.encode(state, m.addresses);
      if (m.remoteAddress)
        ipv4.encode(state, m.remoteAddress);
      if (m.token)
        c.fixed32.encode(state, m.token);
      if (m.remoteToken)
        c.fixed32.encode(state, m.remoteToken);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        error: c.uint.decode(state),
        firewall: c.uint.decode(state),
        round: c.uint.decode(state),
        connected: (flags & 1) !== 0,
        punching: (flags & 2) !== 0,
        addresses: (flags & 4) !== 0 ? ipv4Array.decode(state) : null,
        remoteAddress: (flags & 8) !== 0 ? ipv4.decode(state) : null,
        token: (flags & 16) !== 0 ? c.fixed32.decode(state) : null,
        remoteToken: (flags & 32) !== 0 ? c.fixed32.decode(state) : null
      };
    }
  };
  var peer = exports.peer = {
    preencode(state, m) {
      state.end += 32;
      ipv4Array.preencode(state, m.relayAddresses);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.publicKey);
      ipv4Array.encode(state, m.relayAddresses);
    },
    decode(state) {
      return {
        publicKey: c.fixed32.decode(state),
        relayAddresses: ipv4Array.decode(state)
      };
    }
  };
  exports.peers = c.array(peer);
  exports.announce = {
    preencode(state, m) {
      state.end++;
      if (m.peer)
        peer.preencode(state, m.peer);
      if (m.refresh)
        state.end += 32;
      if (m.signature)
        state.end += 64;
    },
    encode(state, m) {
      const flags = (m.peer ? 1 : 0) | (m.refresh ? 2 : 0) | (m.signature ? 4 : 0);
      c.uint.encode(state, flags);
      if (m.peer)
        peer.encode(state, m.peer);
      if (m.refresh)
        c.fixed32.encode(state, m.refresh);
      if (m.signature)
        c.fixed64.encode(state, m.signature);
    },
    decode(state) {
      const flags = c.uint.decode(state);
      return {
        peer: (flags & 1) !== 0 ? peer.decode(state) : null,
        refresh: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,
        signature: (flags & 4) !== 0 ? c.fixed64.decode(state) : null
      };
    }
  };
  exports.mutableSignable = {
    preencode(state, m) {
      c.uint.preencode(state, m.seq);
      c.buffer.preencode(state, m.value);
    },
    encode(state, m) {
      c.uint.encode(state, m.seq);
      c.buffer.encode(state, m.value);
    },
    decode(state) {
      return {
        seq: c.uint.decode(state),
        value: c.buffer.decode(state)
      };
    }
  };
  exports.mutablePutRequest = {
    preencode(state, m) {
      c.fixed32.preencode(state, m.publicKey);
      c.uint.preencode(state, m.seq);
      c.buffer.preencode(state, m.value);
      c.fixed64.preencode(state, m.signature);
    },
    encode(state, m) {
      c.fixed32.encode(state, m.publicKey);
      c.uint.encode(state, m.seq);
      c.buffer.encode(state, m.value);
      c.fixed64.encode(state, m.signature);
    },
    decode(state) {
      return {
        publicKey: c.fixed32.decode(state),
        seq: c.uint.decode(state),
        value: c.buffer.decode(state),
        signature: c.fixed64.decode(state)
      };
    }
  };
  exports.mutableGetResponse = {
    preencode(state, m) {
      c.uint.preencode(state, m.seq);
      c.buffer.preencode(state, m.value);
      c.fixed64.preencode(state, m.signature);
    },
    encode(state, m) {
      c.uint.encode(state, m.seq);
      c.buffer.encode(state, m.value);
      c.fixed64.encode(state, m.signature);
    },
    decode(state) {
      return {
        seq: c.uint.decode(state),
        value: c.buffer.decode(state),
        signature: c.fixed64.decode(state)
      };
    }
  };
});

// node_modules/hyperdht/lib/socket-pool.js
var require_socket_pool = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var LINGER_TIME = 3000;
  module.exports = class SocketPool {
    constructor(dht, host) {
      this._dht = dht;
      this._sockets = new Map;
      this._lingering = new Set;
      this._host = host;
      this.routes = new SocketRoutes(this);
    }
    _onmessage(ref, data, address) {
      this._dht.onmessage(ref.socket, data, address);
    }
    _add(ref) {
      this._sockets.set(ref.socket, ref);
    }
    _remove(ref) {
      this._sockets.delete(ref.socket);
      this._lingering.delete(ref);
    }
    lookup(socket) {
      return this._sockets.get(socket) || null;
    }
    setReusable(socket, bool) {
      const ref = this.lookup(socket);
      if (ref)
        ref.reusable = bool;
    }
    acquire() {
      return new SocketRef(this);
    }
    async destroy() {
      const closing = [];
      for (const ref of this._sockets.values()) {
        ref._unlinger();
        closing.push(ref.socket.close());
      }
      await Promise.allSettled(closing);
    }
  };

  class SocketRoutes {
    constructor(pool) {
      this._pool = pool;
      this._routes = new Map;
    }
    add(publicKey, rawStream) {
      if (rawStream.socket)
        this._onconnect(publicKey, rawStream);
      else
        rawStream.on("connect", this._onconnect.bind(this, publicKey, rawStream));
    }
    get(publicKey) {
      const id = b4a.toString(publicKey, "hex");
      const route = this._routes.get(id);
      if (!route)
        return null;
      return route;
    }
    _onconnect(publicKey, rawStream) {
      const id = b4a.toString(publicKey, "hex");
      const socket = rawStream.socket;
      let route = this._routes.get(id);
      if (!route) {
        const gc = () => {
          if (this._routes.get(id) === route)
            this._routes.delete(id);
          socket.removeListener("close", gc);
        };
        route = {
          socket,
          address: { host: rawStream.remoteHost, port: rawStream.remotePort },
          gc
        };
        this._routes.set(id, route);
        socket.on("close", gc);
      }
      this._pool.setReusable(socket, true);
      rawStream.on("error", () => {
        this._pool.setReusable(socket, false);
        if (!route)
          route = this._routes.get(id);
        if (route && route.socket === socket)
          route.gc();
      });
    }
  }

  class SocketRef {
    constructor(pool) {
      this._pool = pool;
      this.onholepunchmessage = noop;
      this.reusable = false;
      this.socket = pool._dht.udx.createSocket();
      this.socket.on("close", this._onclose.bind(this)).on("message", this._onmessage.bind(this)).on("idle", this._onidle.bind(this)).on("busy", this._onbusy.bind(this)).bind(0, this._pool._host);
      this._refs = 1;
      this._released = false;
      this._closed = false;
      this._timeout = null;
      this._wasBusy = false;
      this._pool._add(this);
    }
    _onclose() {
      this._pool._remove(this);
    }
    _onmessage(data, address) {
      if (data.byteLength > 1) {
        this._pool._onmessage(this, data, address);
      } else {
        this.onholepunchmessage(data, address, this);
      }
    }
    _onidle() {
      this._closeMaybe();
    }
    _onbusy() {
      this._wasBusy = true;
      this._unlinger();
    }
    _reset() {
      this.onholepunchmessage = noop;
    }
    _closeMaybe() {
      if (this._refs === 0 && this.socket.idle && !this._timeout)
        this._close();
    }
    _lingeringClose() {
      this._pool._lingering.delete(this);
      this._timeout = null;
      this._closeMaybe();
    }
    _close() {
      this._unlinger();
      if (this.reusable && this._wasBusy) {
        this._wasBusy = false;
        this._pool._lingering.add(this);
        this._timeout = setTimeout(this._lingeringClose.bind(this), LINGER_TIME);
        return;
      }
      this._closed = true;
      this.socket.close();
    }
    _unlinger() {
      if (this._timeout !== null) {
        clearTimeout(this._timeout);
        this._pool._lingering.delete(this);
        this._timeout = null;
      }
    }
    get free() {
      return this._refs === 0;
    }
    active() {
      this._refs++;
      this._unlinger();
    }
    inactive() {
      this._refs--;
      this._closeMaybe();
    }
    address() {
      return this.socket.address();
    }
    release() {
      if (this._released)
        return;
      this._released = true;
      this._reset();
      this._refs--;
      this._closeMaybe();
    }
  }
  function noop() {}
});

// node_modules/record-cache/index.js
var require_record_cache = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var EMPTY = [];
  module.exports = RecordCache;
  function RecordSet() {
    this.list = [];
    this.map = new Map;
  }
  RecordSet.prototype.add = function(record, value) {
    var k = toString(record);
    var r = this.map.get(k);
    if (r)
      return false;
    r = { index: this.list.length, record: value || record };
    this.list.push(r);
    this.map.set(k, r);
    return true;
  };
  RecordSet.prototype.remove = function(record) {
    var k = toString(record);
    var r = this.map.get(k);
    if (!r)
      return false;
    swap(this.list, r.index, this.list.length - 1);
    this.list.pop();
    this.map.delete(k);
    return true;
  };
  function RecordStore() {
    this.records = new Map;
    this.size = 0;
  }
  RecordStore.prototype.add = function(name, record, value) {
    var r = this.records.get(name);
    if (!r) {
      r = new RecordSet;
      this.records.set(name, r);
    }
    if (r.add(record, value)) {
      this.size++;
      return true;
    }
    return false;
  };
  RecordStore.prototype.remove = function(name, record, value) {
    var r = this.records.get(name);
    if (!r)
      return false;
    if (r.remove(record, value)) {
      this.size--;
      if (!r.map.size)
        this.records.delete(name);
      return true;
    }
    return false;
  };
  RecordStore.prototype.get = function(name) {
    var r = this.records.get(name);
    return r ? r.list : EMPTY;
  };
  function RecordCache(opts) {
    if (!(this instanceof RecordCache))
      return new RecordCache(opts);
    if (!opts)
      opts = {};
    this.maxSize = opts.maxSize || Infinity;
    this.maxAge = opts.maxAge || 0;
    this._onstale = opts.onStale || opts.onstale || null;
    this._fresh = new RecordStore;
    this._stale = new RecordStore;
    this._interval = null;
    this._gced = false;
    if (this.maxAge && this.maxAge < Infinity) {
      var tick = Math.ceil(2 / 3 * this.maxAge);
      this._interval = setInterval(this._gcAuto.bind(this), tick);
      if (this._interval.unref)
        this._interval.unref();
    }
  }
  Object.defineProperty(RecordCache.prototype, "size", {
    get: function() {
      return this._fresh.size + this._stale.size;
    }
  });
  RecordCache.prototype.add = function(name, record, value) {
    this._stale.remove(name, record, value);
    if (this._fresh.add(name, record, value) && this._fresh.size > this.maxSize) {
      this._gc();
    }
  };
  RecordCache.prototype.remove = function(name, record, value) {
    this._fresh.remove(name, record, value);
    this._stale.remove(name, record, value);
  };
  RecordCache.prototype.get = function(name, n) {
    var a = this._fresh.get(name);
    var b = this._stale.get(name);
    var aLen = a.length;
    var bLen = b.length;
    var len = aLen + bLen;
    if (n > len || !n)
      n = len;
    var result = new Array(n);
    for (var i = 0;i < n; i++) {
      var j = Math.floor(Math.random() * (aLen + bLen));
      if (j < aLen) {
        result[i] = a[j].record;
        swap(a, j, --aLen);
      } else {
        j -= aLen;
        result[i] = b[j].record;
        swap(b, j, --bLen);
      }
    }
    return result;
  };
  RecordCache.prototype._gcAuto = function() {
    if (!this._gced)
      this._gc();
    this._gced = false;
  };
  RecordCache.prototype._gc = function() {
    if (this._onstale && this._stale.size > 0)
      this._onstale(this._stale);
    this._stale = this._fresh;
    this._fresh = new RecordStore;
    this._gced = true;
  };
  RecordCache.prototype.clear = function() {
    this._gc();
    this._gc();
  };
  RecordCache.prototype.destroy = function() {
    this.clear();
    clearInterval(this._interval);
    this._interval = null;
  };
  function toString(record) {
    return b4a.isBuffer(record) ? b4a.toString(record, "hex") : record;
  }
  function swap(list, a, b) {
    var tmp = list[a];
    tmp.index = b;
    list[b].index = a;
    list[a] = list[b];
    list[b] = tmp;
  }
});

// node_modules/xache/index.js
var require_xache = __commonJS((exports, module) => {
  module.exports = class MaxCache {
    constructor({ maxSize, maxAge, createMap, ongc }) {
      this.maxSize = maxSize;
      this.maxAge = maxAge;
      this.ongc = ongc || null;
      this._createMap = createMap || defaultCreateMap;
      this._latest = this._createMap();
      this._oldest = this._createMap();
      this._retained = this._createMap();
      this._gced = false;
      this._interval = null;
      if (this.maxAge > 0 && this.maxAge < Infinity) {
        const tick = Math.ceil(2 / 3 * this.maxAge);
        this._interval = setInterval(this._gcAuto.bind(this), tick);
        if (this._interval.unref)
          this._interval.unref();
      }
    }
    *[Symbol.iterator]() {
      for (const it of [this._latest, this._oldest, this._retained]) {
        yield* it;
      }
    }
    *keys() {
      for (const it of [this._latest, this._oldest, this._retained]) {
        yield* it.keys();
      }
    }
    *values() {
      for (const it of [this._latest, this._oldest, this._retained]) {
        yield* it.values();
      }
    }
    destroy() {
      this.clear();
      clearInterval(this._interval);
      this._interval = null;
    }
    clear() {
      this._gced = true;
      this._latest.clear();
      this._oldest.clear();
      this._retained.clear();
    }
    set(k, v) {
      if (this._retained.has(k))
        return this;
      this._latest.set(k, v);
      this._oldest.delete(k) || this._retained.delete(k);
      if (this._latest.size >= this.maxSize)
        this._gc();
      return this;
    }
    retain(k, v) {
      this._retained.set(k, v);
      this._latest.delete(k) || this._oldest.delete(k);
      return this;
    }
    delete(k) {
      return this._latest.delete(k) || this._oldest.delete(k) || this._retained.delete(k);
    }
    has(k) {
      return this._latest.has(k) || this._oldest.has(k) || this._retained.has(k);
    }
    get(k) {
      if (this._latest.has(k)) {
        return this._latest.get(k);
      }
      if (this._oldest.has(k)) {
        const v = this._oldest.get(k);
        this._latest.set(k, v);
        this._oldest.delete(k);
        return v;
      }
      if (this._retained.has(k)) {
        return this._retained.get(k);
      }
      return null;
    }
    _gcAuto() {
      if (!this._gced)
        this._gc();
      this._gced = false;
    }
    _gc() {
      this._gced = true;
      if (this.ongc !== null && this._oldest.size > 0)
        this.ongc(this._oldest);
      this._oldest = this._latest;
      this._latest = this._createMap();
    }
  };
  function defaultCreateMap() {
    return new Map;
  }
});

// node_modules/hyperdht/lib/encode.js
var require_encode2 = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var cenc = require_compact_encoding();
  function encodeUnslab(enc, m) {
    const state = cenc.state();
    enc.preencode(state, m);
    state.buffer = b4a.allocUnsafeSlow(state.end);
    enc.encode(state, m);
    return state.buffer;
  }
  module.exports = {
    encodeUnslab
  };
});

// node_modules/hyperdht/lib/constants.js
var require_constants2 = __commonJS((exports) => {
  var crypto = require_hypercore_crypto();
  var COMMANDS = exports.COMMANDS = {
    PEER_HANDSHAKE: 0,
    PEER_HOLEPUNCH: 1,
    FIND_PEER: 2,
    LOOKUP: 3,
    ANNOUNCE: 4,
    UNANNOUNCE: 5,
    MUTABLE_PUT: 6,
    MUTABLE_GET: 7,
    IMMUTABLE_PUT: 8,
    IMMUTABLE_GET: 9
  };
  exports.BOOTSTRAP_NODES = global.Pear?.config.dht?.bootstrap || [
    "88.99.3.86@node1.hyperdht.org:49737",
    "142.93.90.113@node2.hyperdht.org:49737",
    "138.68.147.8@node3.hyperdht.org:49737"
  ];
  exports.KNOWN_NODES = global.Pear?.config.dht?.nodes || [];
  exports.FIREWALL = {
    UNKNOWN: 0,
    OPEN: 1,
    CONSISTENT: 2,
    RANDOM: 3
  };
  exports.ERROR = {
    NONE: 0,
    ABORTED: 1,
    VERSION_MISMATCH: 2,
    TRY_LATER: 3,
    SEQ_REUSED: 16,
    SEQ_TOO_LOW: 17
  };
  var [
    NS_ANNOUNCE,
    NS_UNANNOUNCE,
    NS_MUTABLE_PUT,
    NS_PEER_HANDSHAKE,
    NS_PEER_HOLEPUNCH
  ] = crypto.namespace("hyperswarm/dht", [
    COMMANDS.ANNOUNCE,
    COMMANDS.UNANNOUNCE,
    COMMANDS.MUTABLE_PUT,
    COMMANDS.PEER_HANDSHAKE,
    COMMANDS.PEER_HOLEPUNCH
  ]);
  exports.NS = {
    ANNOUNCE: NS_ANNOUNCE,
    UNANNOUNCE: NS_UNANNOUNCE,
    MUTABLE_PUT: NS_MUTABLE_PUT,
    PEER_HANDSHAKE: NS_PEER_HANDSHAKE,
    PEER_HOLEPUNCH: NS_PEER_HOLEPUNCH
  };
});

// node_modules/hyperdht/lib/persistent.js
var require_persistent = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var sodium = require_sodium_native();
  var RecordCache = require_record_cache();
  var Cache = require_xache();
  var b4a = require_b4a();
  var unslab = require_unslab();
  var { encodeUnslab } = require_encode2();
  var m = require_messages5();
  var { NS, ERROR } = require_constants2();
  var EMPTY = b4a.alloc(0);
  var TMP = b4a.allocUnsafe(32);
  var rawArray = c.array(c.raw);
  module.exports = class Persistent {
    constructor(dht, opts) {
      this.dht = dht;
      this.records = new RecordCache(opts.records);
      this.refreshes = new Cache(opts.refreshes);
      this.mutables = new Cache(opts.mutables);
      this.immutables = new Cache(opts.immutables);
    }
    onlookup(req) {
      if (!req.target)
        return;
      const k = b4a.toString(req.target, "hex");
      const records = this.records.get(k, 20);
      const fwd = this.dht._router.get(k);
      if (fwd && records.length < 20)
        records.push(fwd.record);
      req.reply(records.length ? c.encode(rawArray, records) : null);
    }
    onfindpeer(req) {
      if (!req.target)
        return;
      const fwd = this.dht._router.get(req.target);
      req.reply(fwd ? fwd.record : null);
    }
    unannounce(target, publicKey) {
      const k = b4a.toString(target, "hex");
      sodium.crypto_generichash(TMP, publicKey);
      if (b4a.equals(TMP, target))
        this.dht._router.delete(k);
      this.records.remove(k, publicKey);
    }
    onunannounce(req) {
      if (!req.target || !req.token)
        return;
      const unann = decode(m.announce, req.value);
      if (unann === null)
        return;
      const { peer, signature } = unann;
      if (!peer || !signature)
        return;
      const signable = annSignable(req.target, req.token, this.dht.id, unann, NS.UNANNOUNCE);
      if (!sodium.crypto_sign_verify_detached(signature, signable, peer.publicKey)) {
        return;
      }
      this.unannounce(req.target, peer.publicKey);
      req.reply(null, { token: false, closerNodes: false });
    }
    _onrefresh(token, req) {
      sodium.crypto_generichash(TMP, token);
      const activeRefresh = b4a.toString(TMP, "hex");
      const r = this.refreshes.get(activeRefresh);
      if (!r)
        return;
      const { announceSelf, k, record } = r;
      const publicKey = record.subarray(0, 32);
      if (announceSelf) {
        this.dht._router.set(k, {
          relay: req.from,
          record,
          onconnect: null,
          onholepunch: null
        });
        this.records.remove(k, publicKey);
      } else {
        this.records.add(k, publicKey, record);
      }
      this.refreshes.delete(activeRefresh);
      this.refreshes.set(b4a.toString(token, "hex"), r);
      req.reply(null, { token: false, closerNodes: false });
    }
    onannounce(req) {
      if (!req.target || !req.token || !this.dht.id)
        return;
      const ann = decode(m.announce, req.value);
      if (ann === null)
        return;
      const signable = annSignable(req.target, req.token, this.dht.id, ann, NS.ANNOUNCE);
      const { peer, refresh, signature } = ann;
      if (!peer) {
        if (!refresh)
          return;
        this._onrefresh(refresh, req);
        return;
      }
      if (!signature || !sodium.crypto_sign_verify_detached(signature, signable, peer.publicKey)) {
        return;
      }
      if (peer.relayAddresses.length > 3) {
        peer.relayAddresses = peer.relayAddresses.slice(0, 3);
      }
      sodium.crypto_generichash(TMP, peer.publicKey);
      const k = b4a.toString(req.target, "hex");
      const announceSelf = b4a.equals(TMP, req.target);
      const record = encodeUnslab(m.peer, peer);
      if (announceSelf) {
        this.dht._router.set(k, {
          relay: req.from,
          record,
          onconnect: null,
          onholepunch: null
        });
        this.records.remove(k, peer.publicKey);
      } else {
        this.records.add(k, peer.publicKey, record);
      }
      if (refresh) {
        this.refreshes.set(b4a.toString(refresh, "hex"), { k, record, announceSelf });
      }
      req.reply(null, { token: false, closerNodes: false });
    }
    onmutableget(req) {
      if (!req.target || !req.value)
        return;
      let seq = 0;
      try {
        seq = c.decode(c.uint, req.value);
      } catch {
        return;
      }
      const k = b4a.toString(req.target, "hex");
      const value = this.mutables.get(k);
      if (!value) {
        req.reply(null);
        return;
      }
      const localSeq = c.decode(c.uint, value);
      req.reply(localSeq < seq ? null : value);
    }
    onmutableput(req) {
      if (!req.target || !req.token || !req.value)
        return;
      const p = decode(m.mutablePutRequest, req.value);
      if (!p)
        return;
      const { publicKey, seq, value, signature } = p;
      const hash = b4a.allocUnsafe(32);
      sodium.crypto_generichash(hash, publicKey);
      if (!b4a.equals(hash, req.target))
        return;
      if (!value || !verifyMutable(signature, seq, value, publicKey))
        return;
      const k = b4a.toString(hash, "hex");
      const local = this.mutables.get(k);
      if (local) {
        const existing = c.decode(m.mutableGetResponse, local);
        if (existing.value && existing.seq === seq && b4a.compare(value, existing.value) !== 0) {
          req.error(ERROR.SEQ_REUSED);
          return;
        }
        if (seq < existing.seq) {
          req.error(ERROR.SEQ_TOO_LOW);
          return;
        }
      }
      this.mutables.set(k, encodeUnslab(m.mutableGetResponse, { seq, value, signature }));
      req.reply(null);
    }
    onimmutableget(req) {
      if (!req.target)
        return;
      const k = b4a.toString(req.target, "hex");
      const value = this.immutables.get(k);
      req.reply(value || null);
    }
    onimmutableput(req) {
      if (!req.target || !req.token || !req.value)
        return;
      const hash = b4a.alloc(32);
      sodium.crypto_generichash(hash, req.value);
      if (!b4a.equals(hash, req.target))
        return;
      const k = b4a.toString(hash, "hex");
      this.immutables.set(k, unslab(req.value));
      req.reply(null);
    }
    destroy() {
      this.records.destroy();
      this.refreshes.destroy();
      this.mutables.destroy();
      this.immutables.destroy();
    }
    static signMutable(seq, value, keyPair) {
      const signable = b4a.allocUnsafe(32 + 32);
      const hash = signable.subarray(32);
      signable.set(NS.MUTABLE_PUT, 0);
      sodium.crypto_generichash(hash, c.encode(m.mutableSignable, { seq, value }));
      return sign(signable, keyPair);
    }
    static verifyMutable(signature, seq, value, publicKey) {
      return verifyMutable(signature, seq, value, publicKey);
    }
    static signAnnounce(target, token, id, ann, keyPair) {
      return sign(annSignable(target, token, id, ann, NS.ANNOUNCE), keyPair);
    }
    static signUnannounce(target, token, id, ann, keyPair) {
      return sign(annSignable(target, token, id, ann, NS.UNANNOUNCE), keyPair);
    }
  };
  function verifyMutable(signature, seq, value, publicKey) {
    const signable = b4a.allocUnsafe(32 + 32);
    const hash = signable.subarray(32);
    signable.set(NS.MUTABLE_PUT, 0);
    sodium.crypto_generichash(hash, c.encode(m.mutableSignable, { seq, value }));
    return sodium.crypto_sign_verify_detached(signature, signable, publicKey);
  }
  function annSignable(target, token, id, ann, ns) {
    const signable = b4a.allocUnsafe(32 + 32);
    const hash = signable.subarray(32);
    signable.set(ns, 0);
    sodium.crypto_generichash_batch(hash, [
      target,
      id,
      token,
      c.encode(m.peer, ann.peer),
      ann.refresh || EMPTY
    ]);
    return signable;
  }
  function sign(signable, keyPair) {
    if (keyPair.sign) {
      return keyPair.sign(signable);
    }
    const secretKey = keyPair.secretKey ? keyPair.secretKey : keyPair;
    const signature = b4a.allocUnsafe(64);
    sodium.crypto_sign_detached(signature, signable, secretKey);
    return signature;
  }
  function decode(enc, val) {
    try {
      return val && c.decode(enc, val);
    } catch (err) {
      return null;
    }
  }
});

// node_modules/hyperdht/lib/errors.js
var require_errors5 = __commonJS((exports, module) => {
  module.exports = class DHTError extends Error {
    constructor(msg, code, fn = DHTError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "DHTError";
    }
    static BAD_HANDSHAKE_REPLY(msg = "Bad handshake reply") {
      return new DHTError(msg, "BAD_HANDSHAKE_REPLY", DHTError.BAD_HANDSHAKE_REPLY);
    }
    static BAD_HOLEPUNCH_REPLY(msg = "Bad holepunch reply") {
      return new DHTError(msg, "BAD_HOLEPUNCH_REPLY", DHTError.BAD_HOLEPUNCH_REPLY);
    }
    static HOLEPUNCH_ABORTED(msg = "Holepunch aborted") {
      return new DHTError(msg, "HOLEPUNCH_ABORTED", DHTError.HOLEPUNCH_ABORTED);
    }
    static HOLEPUNCH_INVALID(msg = "Invalid holepunch payload") {
      return new DHTError(msg, "HOLEPUNCH_INVALID", DHTError.HOLEPUNCH_INVALID);
    }
    static HOLEPUNCH_PROBE_TIMEOUT(msg = "Holepunching probe did not finish in time") {
      return new DHTError(msg, "HOLEPUNCH_PROBE_TIMEOUT", DHTError.HOLEPUNCH_PROBE_TIMEOUT);
    }
    static HOLEPUNCH_DOUBLE_RANDOMIZED_NATS(msg = "Both remote and local NATs are randomized") {
      return new DHTError(msg, "HOLEPUNCH_DOUBLE_RANDOMIZED_NATS", DHTError.HOLEPUNCH_DOUBLE_RANDOMIZED_NATS);
    }
    static CANNOT_HOLEPUNCH(msg = "Cannot holepunch to remote") {
      return new DHTError(msg, "CANNOT_HOLEPUNCH", DHTError.CANNOT_HOLEPUNCH);
    }
    static REMOTE_NOT_HOLEPUNCHING(msg = "Remote is not holepunching") {
      return new DHTError(msg, "REMOTE_NOT_HOLEPUNCHING", DHTError.REMOTE_NOT_HOLEPUNCHING);
    }
    static REMOTE_NOT_HOLEPUNCHABLE(msg = "Remote is not holepunchable") {
      return new DHTError(msg, "REMOTE_NOT_HOLEPUNCHABLE", DHTError.REMOTE_NOT_HOLEPUNCHABLE);
    }
    static REMOTE_ABORTED(msg = "Remote aborted") {
      return new DHTError(msg, "REMOTE_ABORTED", DHTError.REMOTE_ABORTED);
    }
    static HANDSHAKE_UNFINISHED(msg = "Handshake did not finish") {
      return new DHTError(msg, "HANDSHAKE_UNFINISHED", DHTError.HANDSHAKE_UNFINISHED);
    }
    static HANDSHAKE_INVALID(msg = "Received invalid handshake") {
      return new DHTError(msg, "HANDSHAKE_INVALID", DHTError.HANDSHAKE_INVALID);
    }
    static ALREADY_LISTENING(msg = "Already listening") {
      return new DHTError(msg, "ALREADY_LISTENING", DHTError.ALREADY_LISTENING);
    }
    static KEYPAIR_ALREADY_USED(msg = "Keypair already used") {
      return new DHTError(msg, "KEYPAIR_ALREADY_USED", DHTError.KEYPAIR_ALREADY_USED);
    }
    static NODE_DESTROYED(msg = "Node destroyed") {
      return new DHTError(msg, "NODE_DESTROYED", DHTError.NODE_DESTROYED);
    }
    static PEER_CONNECTION_FAILED(msg = "Could not connect to peer") {
      return new DHTError(msg, "PEER_CONNECTION_FAILED", DHTError.PEER_CONNECTION_FAILED);
    }
    static PEER_NOT_FOUND(msg = "Peer not found") {
      return new DHTError(msg, "PEER_NOT_FOUND", DHTError.PEER_NOT_FOUND);
    }
    static STREAM_NOT_CONNECTED(msg = "Stream is not connected") {
      return new DHTError(msg, "STREAM_NOT_CONNECTED", DHTError.STREAM_DISCONNECTED);
    }
    static SERVER_INCOMPATIBLE(msg = "Server is using an incompatible version") {
      return new DHTError(msg, "SERVER_INCOMPATIBLE", DHTError.SERVER_INCOMPATIBLE);
    }
    static SERVER_ERROR(msg = "Server returned an error") {
      return new DHTError(msg, "SERVER_ERROR", DHTError.SERVER_ERROR);
    }
    static DUPLICATE_CONNECTION(msg = "Duplicate connection") {
      return new DHTError(msg, "DUPLICATE_CONNECTION", DHTError.DUPLICATE_CONNECTION);
    }
    static RELAY_ABORTED(msg = "Relay aborted") {
      return new DHTError(msg, "RELAY_ABORTED", DHTError.RELAY_ABORTED);
    }
    static SUSPENDED(msg = "Suspended") {
      return new DHTError(msg, "SUSPENDED", DHTError.SUSPENDED);
    }
  };
});

// node_modules/hyperdht/lib/router.js
var require_router = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var Cache = require_xache();
  var safetyCatch = require_safety_catch();
  var b4a = require_b4a();
  var { handshake, holepunch } = require_messages5();
  var { COMMANDS } = require_constants2();
  var { BAD_HANDSHAKE_REPLY, BAD_HOLEPUNCH_REPLY } = require_errors5();
  var FROM_CLIENT = 0;
  var FROM_SERVER = 1;
  var FROM_RELAY = 2;
  var FROM_SECOND_RELAY = 3;
  var REPLY = 4;
  module.exports = class Router {
    constructor(dht, opts) {
      this.dht = dht;
      this.forwards = new Cache(opts.forwards);
    }
    set(target, state) {
      if (state.onpeerhandshake) {
        this.forwards.retain(toString(target), state);
      } else {
        this.forwards.set(toString(target), state);
      }
    }
    get(target) {
      return this.forwards.get(toString(target));
    }
    delete(target) {
      this.forwards.delete(toString(target));
    }
    destroy() {
      this.forwards.destroy();
    }
    async peerHandshake(target, { noise, peerAddress, relayAddress, socket, session }, to) {
      const dht = this.dht;
      const requestValue = c.encode(handshake, {
        mode: FROM_CLIENT,
        noise,
        peerAddress,
        relayAddress
      });
      const res = await dht.request({ command: COMMANDS.PEER_HANDSHAKE, target, value: requestValue }, to, { socket, session });
      const hs = decode(handshake, res.value);
      if (!hs || hs.mode !== REPLY || (to.host !== res.from.host || to.port !== res.from.port) || !hs.noise) {
        throw BAD_HANDSHAKE_REPLY();
      }
      return {
        noise: hs.noise,
        relayed: !!hs.peerAddress,
        serverAddress: hs.peerAddress || to,
        clientAddress: res.to
      };
    }
    async onpeerhandshake(req) {
      const hs = req.value && decode(handshake, req.value);
      if (!hs)
        return;
      const { mode, noise, peerAddress, relayAddress } = hs;
      const state = req.target && this.get(req.target);
      const isServer = !!(state && state.onpeerhandshake);
      const relay = state && state.relay;
      if (isServer) {
        let reply = null;
        try {
          reply = noise && await state.onpeerhandshake({ noise, peerAddress }, req);
        } catch (e) {
          safetyCatch(e);
          return;
        }
        if (!reply || !reply.noise)
          return;
        const opts = { socket: reply.socket, closerNodes: false, token: false };
        switch (mode) {
          case FROM_CLIENT: {
            req.reply(c.encode(handshake, { mode: REPLY, noise: reply.noise, peerAddress: null }), opts);
            return;
          }
          case FROM_RELAY: {
            req.relay(c.encode(handshake, { mode: FROM_SERVER, noise: reply.noise, peerAddress }), req.from, opts);
            return;
          }
          case FROM_SECOND_RELAY: {
            if (!relayAddress)
              return;
            req.relay(c.encode(handshake, { mode: FROM_SERVER, noise: reply.noise, peerAddress }), relayAddress, opts);
            return;
          }
        }
      } else {
        switch (mode) {
          case FROM_CLIENT: {
            if (!noise)
              return;
            if (!relay && !relayAddress) {
              req.reply(null, { token: false, closerNodes: true });
              return;
            }
            req.relay(c.encode(handshake, { mode: FROM_RELAY, noise, peerAddress: req.from, relayAddress: null }), relayAddress || relay);
            return;
          }
          case FROM_RELAY: {
            if (!relay || !noise)
              return;
            req.relay(c.encode(handshake, { mode: FROM_SECOND_RELAY, noise, peerAddress, relayAddress: req.from }), relay);
            return;
          }
          case FROM_SERVER: {
            if (!peerAddress || !noise)
              return;
            req.reply(c.encode(handshake, { mode: REPLY, noise, peerAddress: req.from, relayAddress: null }), { to: peerAddress, closerNodes: false, token: false });
            return;
          }
        }
      }
    }
    async peerHolepunch(target, { id, payload, peerAddress, socket, session }, to) {
      const dht = this.dht;
      const requestValue = c.encode(holepunch, {
        mode: FROM_CLIENT,
        id,
        payload,
        peerAddress
      });
      const res = await dht.request({ command: COMMANDS.PEER_HOLEPUNCH, target, value: requestValue }, to, { socket, session });
      const hp = decode(holepunch, res.value);
      if (!hp || hp.mode !== REPLY || (to.host !== res.from.host || to.port !== res.from.port)) {
        throw BAD_HOLEPUNCH_REPLY();
      }
      return {
        from: res.from,
        to: res.to,
        payload: hp.payload,
        peerAddress: hp.peerAddress || to
      };
    }
    async onpeerholepunch(req) {
      const hp = req.value && decode(holepunch, req.value);
      if (!hp)
        return;
      const { mode, id, payload, peerAddress } = hp;
      const state = req.target && this.get(req.target);
      const isServer = !!(state && state.onpeerholepunch);
      const relay = state && state.relay;
      switch (mode) {
        case FROM_CLIENT: {
          if (!peerAddress && !relay)
            return;
          req.relay(c.encode(holepunch, { mode: FROM_RELAY, id, payload, peerAddress: req.from }), peerAddress || relay);
          return;
        }
        case FROM_RELAY: {
          if (!isServer || !peerAddress)
            return;
          let reply = null;
          try {
            reply = await state.onpeerholepunch({ id, payload, peerAddress }, req);
          } catch (e) {
            safetyCatch(e);
            return;
          }
          if (!reply)
            return;
          const opts = { socket: reply.socket, closerNodes: false, token: false };
          req.relay(c.encode(holepunch, { mode: FROM_SERVER, id: 0, payload: reply.payload, peerAddress }), req.from, opts);
          return;
        }
        case FROM_SERVER: {
          req.reply(c.encode(holepunch, { mode: REPLY, id, payload, peerAddress: req.from }), { to: peerAddress, closerNodes: false, token: false });
          return;
        }
      }
    }
  };
  function decode(enc, val) {
    try {
      return c.decode(enc, val);
    } catch {
      return null;
    }
  }
  function toString(t) {
    return typeof t === "string" ? t : b4a.toString(t, "hex");
  }
});

// node_modules/compact-encoding-bitfield/index.js
var require_compact_encoding_bitfield = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  module.exports = function bitfield(length) {
    if (length > 64)
      throw new RangeError("Bitfield cannot be larger than 64 bits");
    let byteLength;
    if (length < 8)
      byteLength = 1;
    else if (length <= 16)
      byteLength = 2;
    else if (length <= 32)
      byteLength = 4;
    else
      byteLength = 8;
    return {
      preencode(state) {
        state.end++;
        if (byteLength === 1)
          ;
        else if (byteLength === 2)
          c.uint16.preencode(state);
        else if (byteLength === 4)
          c.uint32.preencode(state);
        else
          c.uint64.preencode(state);
      },
      encode(state, b) {
        if (byteLength === 1)
          ;
        else if (byteLength === 2)
          c.uint8.encode(state, 253);
        else if (byteLength === 4)
          c.uint8.encode(state, 254);
        else
          c.uint8.encode(state, 255);
        if (typeof b === "number") {
          if (byteLength === 1)
            c.uint8.encode(state, b);
          else if (byteLength === 2)
            c.uint16.encode(state, b);
          else if (byteLength === 4)
            c.uint32.encode(state, b);
          else
            c.uint64.encode(state, b);
        } else {
          state.buffer.set(b, state.start);
          if (b.byteLength < byteLength) {
            state.buffer.fill(0, state.start + b.byteLength, state.start + byteLength);
          }
          state.start += byteLength;
        }
      },
      decode(state) {
        const byte = state.buffer[state.start];
        let byteLength2;
        if (byte <= 252)
          byteLength2 = 1;
        else if (byte === 253)
          byteLength2 = 2;
        else if (byte === 254)
          byteLength2 = 4;
        else
          byteLength2 = 8;
        if (byteLength2 > 1)
          state.start++;
        if (state.end - state.start < byteLength2)
          throw new Error("Out of bounds");
        const b = state.buffer.subarray(state.start, state.start += byteLength2);
        return length <= 8 ? b.subarray(0, 1) : b;
      }
    };
  };
});

// node_modules/bits-to-bytes/index.js
var require_bits_to_bytes = __commonJS((exports, module) => {
  var b4a = require_b4a();
  function byteLength(size) {
    return Math.ceil(size / 8);
  }
  function get(buffer, bit) {
    const n = buffer.BYTES_PER_ELEMENT * 8;
    const offset = bit & n - 1;
    const i = (bit - offset) / n;
    return (buffer[i] & 1 << offset) !== 0;
  }
  function set(buffer, bit, value = true) {
    const n = buffer.BYTES_PER_ELEMENT * 8;
    const offset = bit & n - 1;
    const i = (bit - offset) / n;
    const mask = 1 << offset;
    if (value) {
      if ((buffer[i] & mask) !== 0)
        return false;
    } else {
      if ((buffer[i] & mask) === 0)
        return false;
    }
    buffer[i] ^= mask;
    return true;
  }
  function setRange(buffer, start, end, value = true) {
    const n = buffer.BYTES_PER_ELEMENT * 8;
    let remaining = end - start;
    let offset = start & n - 1;
    let i = (start - offset) / n;
    let changed = false;
    while (remaining > 0) {
      const mask = 2 ** Math.min(remaining, n - offset) - 1 << offset;
      if (value) {
        if ((buffer[i] & mask) !== mask) {
          buffer[i] |= mask;
          changed = true;
        }
      } else {
        if ((buffer[i] & mask) !== 0) {
          buffer[i] &= ~mask;
          changed = true;
        }
      }
      remaining -= n - offset;
      offset = 0;
      i++;
    }
    return changed;
  }
  function fill(buffer, value, start = 0, end = buffer.byteLength * 8) {
    const n = buffer.BYTES_PER_ELEMENT * 8;
    let i, j;
    {
      const offset = start & n - 1;
      i = (start - offset) / n;
      if (offset !== 0) {
        const mask = 2 ** Math.min(n - offset, end - start) - 1 << offset;
        if (value)
          buffer[i] |= mask;
        else
          buffer[i] &= ~mask;
        i++;
      }
    }
    {
      const offset = end & n - 1;
      j = (end - offset) / n;
      if (offset !== 0 && j >= i) {
        const mask = 2 ** offset - 1;
        if (value)
          buffer[j] |= mask;
        else
          buffer[j] &= ~mask;
      }
    }
    return buffer.fill(value ? 2 ** n - 1 : 0, i, j);
  }
  function toggle(buffer, bit) {
    const n = buffer.BYTES_PER_ELEMENT * 8;
    const offset = bit & n - 1;
    const i = (bit - offset) / n;
    const mask = 1 << offset;
    buffer[i] ^= mask;
    return (buffer[i] & mask) !== 0;
  }
  function remove(buffer, bit) {
    return set(buffer, bit, false);
  }
  function removeRange(buffer, start, end) {
    return setRange(buffer, start, end, false);
  }
  function indexOf(buffer, value, position = 0) {
    for (let i = position, n = buffer.byteLength * 8;i < n; i++) {
      if (get(buffer, i) === value)
        return i;
    }
    return -1;
  }
  function lastIndexOf(buffer, value, position = buffer.byteLength * 8 - 1) {
    for (let i = position;i >= 0; i--) {
      if (get(buffer, i) === value)
        return i;
    }
    return -1;
  }
  function of(...bits) {
    return from(bits);
  }
  function from(bits) {
    const buffer = b4a.alloc(byteLength(bits.length));
    for (let i = 0;i < bits.length; i++)
      set(buffer, i, bits[i]);
    return buffer;
  }
  function* iterator(buffer) {
    for (let i = 0, n = buffer.byteLength * 8;i < n; i++)
      yield get(buffer, i);
  }
  module.exports = {
    byteLength,
    get,
    set,
    setRange,
    fill,
    toggle,
    remove,
    removeRange,
    indexOf,
    lastIndexOf,
    of,
    from,
    iterator
  };
});

// node_modules/blind-relay/lib/errors.js
var require_errors6 = __commonJS((exports, module) => {
  module.exports = class BlindRelayError extends Error {
    constructor(msg, code, fn = BlindRelayError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "BlindRelayError";
    }
    static DUPLICATE_CHANNEL(msg = "Duplicate channel") {
      return new BlindRelayError(msg, "DUPLICATE_CHANNEL", BlindRelayError.DUPLICATE_CHANNEL);
    }
    static CHANNEL_CLOSED(msg = "Channel closed") {
      return new BlindRelayError(msg, "CHANNEL_CLOSED", BlindRelayError.CHANNEL_CLOSED);
    }
    static CHANNEL_DESTROYED(msg = "Channel destroyed") {
      return new BlindRelayError(msg, "CHANNEL_DESTROYED", BlindRelayError.CHANNEL_DESTROYED);
    }
    static ALREADY_PAIRING(msg = "Already pairing") {
      return new BlindRelayError(msg, "ALREADY_PAIRING", BlindRelayError.ALREADY_PAIRING);
    }
    static PAIRING_CANCELLED(msg = "Pairing cancelled") {
      return new BlindRelayError(msg, "PAIRING_CANCELLED", BlindRelayError.PAIRING_CANCELLED);
    }
  };
});

// node_modules/blind-relay/index.js
var require_blind_relay = __commonJS((exports) => {
  var EventEmitter = __require("events");
  var Protomux = require_protomux();
  var { Readable } = require_streamx();
  var sodium = require_sodium_native();
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var bitfield = require_compact_encoding_bitfield();
  var bits = require_bits_to_bytes();
  var errors = require_errors6();
  exports.Server = class BlindRelayServer extends EventEmitter {
    constructor(opts = {}) {
      super();
      const {
        createStream
      } = opts;
      this._createStream = createStream;
      this._pairing = new Map;
      this._sessions = new Set;
    }
    get sessions() {
      return this._sessions[Symbol.iterator]();
    }
    accept(stream, opts) {
      const session = new BlindRelaySession(this, stream, opts);
      this._sessions.add(session);
      return session;
    }
    async close() {
      const ending = [];
      for (const session of this._sessions) {
        ending.push(session.end());
      }
      await Promise.all(ending);
      this._pairing.clear();
    }
  };

  class BlindRelaySession extends EventEmitter {
    constructor(server, stream, opts = {}) {
      super();
      const {
        id,
        handshake,
        handshakeEncoding
      } = opts;
      this._server = server;
      this._mux = Protomux.from(stream);
      this._channel = this._mux.createChannel({
        protocol: "blind-relay",
        id,
        handshake: handshake ? handshakeEncoding || c.raw : null,
        onopen: this._onopen.bind(this),
        onclose: this._onclose.bind(this),
        ondestroy: this._ondestroy.bind(this)
      });
      this._pair = this._channel.addMessage({
        encoding: m.pair,
        onmessage: this._onpair.bind(this)
      });
      this._unpair = this._channel.addMessage({
        encoding: m.unpair,
        onmessage: this._onunpair.bind(this)
      });
      this._ending = null;
      this._destroyed = false;
      this._error = null;
      this._pairing = new Set;
      this._streams = new Map;
      this._onerror = (err) => this.emit("error", err);
      this._channel.open(handshake);
    }
    get closed() {
      return this._channel.closed;
    }
    get mux() {
      return this._mux;
    }
    get stream() {
      return this._mux.stream;
    }
    _onopen() {
      this.emit("open");
    }
    _onclose() {
      this._ending = Promise.resolve();
      const err = this._error || errors.CHANNEL_CLOSED();
      for (const token of this._pairing) {
        this._server._pairing.delete(token.toString("hex"));
      }
      for (const stream of this._streams.values()) {
        stream.off("error", this._onerror).on("error", noop).destroy(err);
      }
      this._pairing.clear();
      this._streams.clear();
      this._server._sessions.delete(this);
      this.emit("close");
    }
    _ondestroy() {
      this._destroyed = true;
      this.emit("destroy");
    }
    _onpair({ isInitiator, token, id: remoteId }) {
      const keyString = token.toString("hex");
      let pair = this._server._pairing.get(keyString);
      if (pair === undefined) {
        pair = new BlindRelayPair(token);
        this._server._pairing.set(keyString, pair);
      } else if (pair.links[+isInitiator])
        return;
      this._pairing.add(keyString);
      pair.links[+isInitiator] = new BlindRelayLink(this, isInitiator, remoteId);
      if (!pair.paired)
        return;
      this._server._pairing.delete(keyString);
      for (const link of pair.links) {
        link.createStream();
      }
      for (const { isInitiator: isInitiator2, session, stream } of pair.links) {
        const remote = pair.remote(isInitiator2);
        stream.on("error", session._onerror).on("close", () => session._streams.delete(keyString)).relayTo(remote.stream);
        session._pairing.delete(keyString);
        session._streams.set(keyString, stream);
      }
      for (const { isInitiator: isInitiator2, session, remoteId: remoteId2, stream } of pair.links) {
        session._pair.send({
          isInitiator: isInitiator2,
          token,
          id: stream.id,
          seq: 0
        });
        session._endMaybe();
        session.emit("pair", isInitiator2, token, stream, remoteId2);
      }
    }
    _onunpair({ token }) {
      const keyString = token.toString("hex");
      const pair = this._server._pairing.get(keyString);
      if (pair) {
        for (const link of pair.links) {
          if (link)
            link.session._pairing.delete(keyString);
        }
        return this._server._pairing.delete(keyString);
      }
      const stream = this._streams.get(keyString);
      if (stream) {
        stream.off("error", this._onerror).on("error", noop).destroy(errors.PAIRING_CANCELLED());
        this._streams.delete(keyString);
      }
    }
    cork() {
      this._channel.cork();
    }
    uncork() {
      this._channel.uncork();
    }
    async end() {
      if (this._ending)
        return this._ending;
      this._ending = EventEmitter.once(this, "close");
      this._endMaybe();
      return this._ending;
    }
    _endMaybe() {
      if (this._ending && this._pairing.size === 0) {
        this._channel.close();
      }
    }
    destroy(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this._error = err || errors.CHANNEL_DESTROYED();
      this._channel.close();
    }
  }

  class BlindRelayPair {
    constructor(token) {
      this.token = token;
      this.links = [null, null];
    }
    get paired() {
      return this.links[0] !== null && this.links[1] !== null;
    }
    remote(isInitiator) {
      return this.links[isInitiator ? 0 : 1];
    }
  }

  class BlindRelayLink {
    constructor(session, isInitiator, remoteId) {
      this.session = session;
      this.isInitiator = isInitiator;
      this.remoteId = remoteId;
      this.stream = null;
    }
    createStream() {
      if (this.stream)
        return;
      this.stream = this.session._server._createStream({
        firewall: this._onfirewall.bind(this)
      });
    }
    _onfirewall(socket, port, host) {
      this.stream.connect(socket, this.remoteId, port, host);
      return false;
    }
  }
  exports.Client = class BlindRelayClient extends EventEmitter {
    static _clients = new WeakMap;
    static from(stream, opts) {
      let client = this._clients.get(stream);
      if (client)
        return client;
      client = new this(stream, opts);
      this._clients.set(stream, client);
      return client;
    }
    constructor(stream, opts = {}) {
      super();
      const {
        id,
        handshake,
        handshakeEncoding
      } = opts;
      this._mux = Protomux.from(stream);
      this._channel = this._mux.createChannel({
        protocol: "blind-relay",
        id,
        handshake: handshake ? handshakeEncoding || c.raw : null,
        onopen: this._onopen.bind(this),
        onclose: this._onclose.bind(this),
        ondestroy: this._ondestroy.bind(this)
      });
      this._pair = this._channel.addMessage({
        encoding: m.pair,
        onmessage: this._onpair.bind(this)
      });
      this._unpair = this._channel.addMessage({
        encoding: m.unpair
      });
      this._ending = false;
      this._destroyed = false;
      this._error = null;
      this._requests = new Map;
      this._channel.open(handshake);
    }
    get closed() {
      return this._channel.closed;
    }
    get mux() {
      return this._mux;
    }
    get stream() {
      return this._mux.stream;
    }
    get requests() {
      return this._requests.values();
    }
    _onopen() {
      this.emit("open");
    }
    _onclose() {
      this._ending = Promise.resolve();
      const err = this._error || errors.CHANNEL_CLOSED();
      for (const request of this._requests.values()) {
        request.destroy(err);
      }
      this._requests.clear();
      this.constructor._clients.delete(this.stream);
      this.emit("close");
    }
    _ondestroy() {
      this._destroyed = true;
      this.emit("destroy");
    }
    _onpair({ isInitiator, token, id: remoteId }) {
      const request = this._requests.get(token.toString("hex"));
      if (request === undefined || request.isInitiator !== isInitiator)
        return;
      request.push(remoteId);
      request.push(null);
      this.emit("pair", request.isInitiator, request.token, request.stream, remoteId);
    }
    pair(isInitiator, token, stream) {
      if (this._destroyed)
        throw errors.CHANNEL_DESTROYED();
      const keyString = token.toString("hex");
      if (this._requests.has(keyString))
        throw errors.ALREADY_PAIRING();
      const request = new BlindRelayRequest(this, isInitiator, token, stream);
      this._requests.set(keyString, request);
      return request;
    }
    unpair(token) {
      if (this._destroyed)
        throw errors.CHANNEL_DESTROYED();
      const request = this._requests.get(token.toString("hex"));
      if (request)
        request.destroy(errors.PAIRING_CANCELLED());
      this._unpair.send({ token });
    }
    cork() {
      this._channel.cork();
    }
    uncork() {
      this._channel.uncork();
    }
    async end() {
      if (this._ending)
        return this._ending;
      this._ending = EventEmitter.once(this, "close");
      this._endMaybe();
      return this._ending;
    }
    _endMaybe() {
      if (this._ending && this._requests.size === 0) {
        this._channel.close();
      }
    }
    destroy(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this._error = err || errors.CHANNEL_DESTROYED();
      this._channel.close();
    }
  };

  class BlindRelayRequest extends Readable {
    constructor(client, isInitiator, token, stream) {
      super();
      this.client = client;
      this.isInitiator = isInitiator;
      this.token = token;
      this.stream = stream;
    }
    _open(cb) {
      if (this.client._destroyed)
        return cb(errors.CHANNEL_DESTROYED());
      this.client._pair.send({
        isInitiator: this.isInitiator,
        token: this.token,
        id: this.stream.id,
        seq: 0
      });
      cb(null);
    }
    _destroy(cb) {
      this.client._requests.delete(this.token.toString("hex"));
      cb(null);
      this.client._endMaybe();
    }
  }
  exports.token = function token(buf = b4a.allocUnsafe(32)) {
    sodium.randombytes_buf(buf);
    return buf;
  };
  function noop() {}
  var m = exports.messages = {};
  var flags = bitfield(7);
  m.pair = {
    preencode(state, m2) {
      flags.preencode(state);
      c.fixed32.preencode(state, m2.token);
      c.uint.preencode(state, m2.id);
      c.uint.preencode(state, m2.seq);
    },
    encode(state, m2) {
      flags.encode(state, bits.of(m2.isInitiator));
      c.fixed32.encode(state, m2.token);
      c.uint.encode(state, m2.id);
      c.uint.encode(state, m2.seq);
    },
    decode(state) {
      const [isInitiator] = bits.iterator(flags.decode(state));
      return {
        isInitiator,
        token: c.fixed32.decode(state),
        id: c.uint.decode(state),
        seq: c.uint.decode(state)
      };
    }
  };
  m.unpair = {
    preencode(state, m2) {
      flags.preencode(state);
      c.fixed32.preencode(state, m2.token);
    },
    encode(state, m2) {
      flags.encode(state, bits.of());
      c.fixed32.encode(state, m2.token);
    },
    decode(state) {
      flags.decode(state);
      return {
        token: c.fixed32.decode(state)
      };
    }
  };
});

// node_modules/hyperdht/lib/noise-wrap.js
var require_noise_wrap = __commonJS((exports, module) => {
  var NoiseSecretStream = require_secret_stream();
  var NoiseHandshake = require_noise();
  var curve = require_noise_curve_ed();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var sodium = require_sodium_native();
  var m = require_messages5();
  var { NS } = require_constants2();
  var { HANDSHAKE_UNFINISHED } = require_errors5();
  var NOISE_PROLOUGE = NS.PEER_HANDSHAKE;
  module.exports = class NoiseWrap {
    constructor(keyPair, remotePublicKey) {
      this.isInitiator = !!remotePublicKey;
      this.remotePublicKey = remotePublicKey;
      this.keyPair = keyPair;
      this.handshake = new NoiseHandshake("IK", this.isInitiator, keyPair, { curve });
      this.handshake.initialise(NOISE_PROLOUGE, remotePublicKey);
    }
    send(payload) {
      const buf = c.encode(m.noisePayload, payload);
      return this.handshake.send(buf);
    }
    recv(buf) {
      const payload = c.decode(m.noisePayload, this.handshake.recv(buf));
      this.remotePublicKey = b4a.toBuffer(this.handshake.rs);
      return payload;
    }
    final() {
      if (!this.handshake.complete)
        throw HANDSHAKE_UNFINISHED();
      const holepunchSecret = b4a.allocUnsafe(32);
      sodium.crypto_generichash(holepunchSecret, NS.PEER_HOLEPUNCH, this.handshake.hash);
      return {
        isInitiator: this.isInitiator,
        publicKey: this.keyPair.publicKey,
        streamId: this.streamId,
        remotePublicKey: this.remotePublicKey,
        remoteId: NoiseSecretStream.id(this.handshake.hash, !this.isInitiator),
        holepunchSecret,
        hash: b4a.toBuffer(this.handshake.hash),
        rx: b4a.toBuffer(this.handshake.rx),
        tx: b4a.toBuffer(this.handshake.tx)
      };
    }
  };
});

// node_modules/hyperdht/lib/sleeper.js
var require_sleeper = __commonJS((exports, module) => {
  module.exports = class Sleeper {
    constructor() {
      this._timeout = null;
      this._resolve = null;
      this._start = (resolve) => {
        this._resolve = resolve;
      };
      this._trigger = () => {
        if (this._resolve === null)
          return;
        const resolve = this._resolve;
        this._timeout = null;
        this._resolve = null;
        resolve();
      };
    }
    pause(ms) {
      const p = new Promise(this._start);
      if (this._timeout !== null) {
        clearTimeout(this._timeout);
        this._trigger();
      }
      this._timeout = setTimeout(this._trigger, ms);
      return p;
    }
    resume() {
      if (this._timeout !== null) {
        clearTimeout(this._timeout);
        this._trigger();
      }
    }
  };
});

// node_modules/hyperdht/lib/announcer.js
var require_announcer = __commonJS((exports, module) => {
  var safetyCatch = require_safety_catch();
  var c = require_compact_encoding();
  var Signal = require_signal_promise();
  var { encodeUnslab } = require_encode2();
  var Sleeper = require_sleeper();
  var m = require_messages5();
  var Persistent = require_persistent();
  var { COMMANDS } = require_constants2();
  var MIN_ACTIVE = 3;
  module.exports = class Announcer {
    constructor(dht, keyPair, target, opts = {}) {
      this.dht = dht;
      this.keyPair = keyPair;
      this.target = target;
      this.relays = [];
      this.relayAddresses = [];
      this.stopped = false;
      this.suspended = false;
      this.record = encodeUnslab(m.peer, { publicKey: keyPair.publicKey, relayAddresses: [] });
      this.online = new Signal;
      this._refreshing = false;
      this._closestNodes = null;
      this._active = null;
      this._sleeper = new Sleeper;
      this._resumed = new Signal;
      this._signAnnounce = opts.signAnnounce || Persistent.signAnnounce;
      this._signUnannounce = opts.signUnannounce || Persistent.signUnannounce;
      this._updating = null;
      this._activeQuery = null;
      this._unannouncing = null;
      this._serverRelays = [
        new Map,
        new Map,
        new Map
      ];
    }
    isRelay(addr) {
      const id = addr.host + ":" + addr.port;
      const [a, b, c2] = this._serverRelays;
      return a.has(id) || b.has(id) || c2.has(id);
    }
    async suspend({ log = noop } = {}) {
      if (this.suspended)
        return;
      this.suspended = true;
      log("Suspending announcer");
      this.online.notify();
      if (this._activeQuery)
        this._activeQuery.destroy();
      this._sleeper.resume();
      if (this._updating)
        await this._updating;
      log("Suspending announcer (post update)");
      if (this.suspended === false || this.stopped)
        return;
      log("Suspending announcer (pre unannounce)");
      await this._unannounceCurrent();
      log("Suspending announcer (post unannounce)");
    }
    resume() {
      if (!this.suspended)
        return;
      this.suspended = false;
      this.refresh();
      this._sleeper.resume();
      this._resumed.notify();
    }
    refresh() {
      if (this.stopped)
        return;
      this._refreshing = true;
    }
    async start() {
      if (this.stopped)
        return;
      this._active = this._runUpdate();
      await this._active;
      if (this.stopped)
        return;
      this._active = this._background();
    }
    async stop() {
      this.stopped = true;
      this.online.notify();
      this._sleeper.resume();
      this._resumed.notify();
      await this._active;
      await this._unannounceCurrent();
    }
    async _unannounceCurrent() {
      while (this._unannouncing !== null)
        await this._unannouncing;
      const un = this._unannouncing = this._unannounceAll(this._serverRelays[2].values());
      await this._unannouncing;
      if (un === this._unannouncing)
        this._unannouncing = null;
    }
    async _background() {
      while (!this.dht.destroyed && !this.stopped) {
        try {
          this._refreshing = false;
          for (let i = 0;i < 100 && !this.stopped && !this._refreshing && !this.suspended; i++) {
            const pings = [];
            for (const node of this._serverRelays[2].values()) {
              pings.push(this.dht.ping(node));
            }
            const active = await resolved(pings);
            if (active < Math.min(pings.length, MIN_ACTIVE)) {
              this.refresh();
            }
            if (this.stopped)
              return;
            if (!this.suspended && !this._refreshing)
              await this._sleeper.pause(3000);
          }
          while (!this.stopped && this.suspended)
            await this._resumed.wait();
          if (!this.stopped)
            await this._runUpdate();
          while (!this.dht.online && !this.stopped && !this.suspended) {
            await this.online.wait();
          }
        } catch (err) {
          safetyCatch(err);
        }
      }
    }
    async _runUpdate() {
      this._updating = this._update();
      await this._updating;
      this._updating = null;
    }
    async _update() {
      while (this._unannouncing)
        await this._unannouncing;
      this._cycle();
      const q = this._activeQuery = this.dht.findPeer(this.target, { hash: false, nodes: this._closestNodes });
      try {
        await q.finished();
      } catch {}
      this._activeQuery = null;
      if (this.stopped || this.suspended)
        return;
      const ann = [];
      const replies = pickBest(q.closestReplies);
      const relays = [];
      const relayAddresses = [];
      if (!this.dht.firewalled) {
        const addr = this.dht.remoteAddress();
        if (addr)
          relayAddresses.push(addr);
      }
      for (const msg of replies) {
        ann.push(this._commit(msg, relays, relayAddresses));
      }
      await Promise.allSettled(ann);
      if (this.stopped || this.suspended)
        return;
      this._closestNodes = q.closestNodes;
      this.relays = relays;
      this.relayAddresses = relayAddresses;
      const removed = [];
      for (const [key, value] of this._serverRelays[1]) {
        if (!this._serverRelays[2].has(key))
          removed.push(value);
      }
      await this._unannounceAll(removed);
    }
    _unannounceAll(relays) {
      const unann = [];
      for (const r of relays)
        unann.push(this._unannounce(r));
      return Promise.allSettled(unann);
    }
    async _unannounce(to) {
      const unann = {
        peer: {
          publicKey: this.keyPair.publicKey,
          relayAddresses: []
        },
        refresh: null,
        signature: null
      };
      const { from, token, value } = await this.dht.request({
        token: null,
        command: COMMANDS.FIND_PEER,
        target: this.target,
        value: null
      }, to);
      if (!token || !from.id || !value)
        return;
      unann.signature = await this._signUnannounce(this.target, token, from.id, unann, this.keyPair);
      await this.dht.request({
        token,
        command: COMMANDS.UNANNOUNCE,
        target: this.target,
        value: c.encode(m.announce, unann)
      }, to);
    }
    async _commit(msg, relays, relayAddresses) {
      const ann = {
        peer: {
          publicKey: this.keyPair.publicKey,
          relayAddresses: []
        },
        refresh: null,
        signature: null
      };
      ann.signature = await this._signAnnounce(this.target, msg.token, msg.from.id, ann, this.keyPair);
      const res = await this.dht.request({
        token: msg.token,
        command: COMMANDS.ANNOUNCE,
        target: this.target,
        value: c.encode(m.announce, ann)
      }, msg.from);
      if (res.error !== 0)
        return;
      if (relayAddresses.length < 3)
        relayAddresses.push({ host: msg.from.host, port: msg.from.port });
      relays.push({ relayAddress: msg.from, peerAddress: msg.to });
      this._serverRelays[2].set(msg.from.host + ":" + msg.from.port, msg.from);
    }
    _cycle() {
      const tmp = this._serverRelays[0];
      this._serverRelays[0] = this._serverRelays[1];
      this._serverRelays[1] = this._serverRelays[2];
      this._serverRelays[2] = tmp;
      tmp.clear();
    }
  };
  function resolved(ps) {
    let replied = 0;
    let ticks = ps.length + 1;
    return new Promise((resolve) => {
      for (const p of ps)
        p.then(push, tick);
      tick();
      function push(v) {
        replied++;
        tick();
      }
      function tick() {
        if (--ticks === 0)
          resolve(replied);
      }
    });
  }
  function pickBest(replies) {
    return replies.slice(0, 3);
  }
  function noop() {}
});

// node_modules/hyperdht/lib/crypto.js
var require_crypto = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var b4a = require_b4a();
  function hash(data) {
    const out = b4a.allocUnsafe(32);
    sodium.crypto_generichash(out, data);
    return out;
  }
  function unslabbedHash(data) {
    const out = b4a.allocUnsafeSlow(32);
    sodium.crypto_generichash(out, data);
    return out;
  }
  function createKeyPair(seed) {
    const publicKey = b4a.alloc(32);
    const secretKey = b4a.alloc(64);
    if (seed)
      sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);
    else
      sodium.crypto_sign_keypair(publicKey, secretKey);
    return { publicKey, secretKey };
  }
  module.exports = {
    hash,
    unslabbedHash,
    createKeyPair
  };
});

// node_modules/hyperdht/lib/secure-payload.js
var require_secure_payload = __commonJS((exports, module) => {
  var sodium = require_sodium_native();
  var b4a = require_b4a();
  var { holepunchPayload } = require_messages5();
  module.exports = class HolepunchPayload {
    constructor(holepunchSecret) {
      this._sharedSecret = holepunchSecret;
      this._localSecret = b4a.allocUnsafe(32);
      sodium.randombytes_buf(this._localSecret);
    }
    decrypt(buffer) {
      const state = { start: 24, end: buffer.byteLength - 16, buffer };
      if (state.end <= state.start)
        return null;
      const nonce = buffer.subarray(0, 24);
      const msg = state.buffer.subarray(state.start, state.end);
      const cipher = state.buffer.subarray(state.start);
      if (!sodium.crypto_secretbox_open_easy(msg, cipher, nonce, this._sharedSecret))
        return null;
      try {
        return holepunchPayload.decode(state);
      } catch {
        return null;
      }
    }
    encrypt(payload) {
      const state = { start: 24, end: 24, buffer: null };
      holepunchPayload.preencode(state, payload);
      state.buffer = b4a.allocUnsafe(state.end + 16);
      const nonce = state.buffer.subarray(0, 24);
      const msg = state.buffer.subarray(state.start, state.end);
      const cipher = state.buffer.subarray(state.start);
      holepunchPayload.encode(state, payload);
      sodium.randombytes_buf(nonce);
      sodium.crypto_secretbox_easy(cipher, msg, nonce, this._sharedSecret);
      return state.buffer;
    }
    token(addr) {
      const out = b4a.allocUnsafe(32);
      sodium.crypto_generichash(out, b4a.from(addr.host), this._localSecret);
      return out;
    }
  };
});

// node_modules/hyperdht/lib/nat.js
var require_nat = __commonJS((exports, module) => {
  var { FIREWALL } = require_constants2();
  module.exports = class Nat {
    constructor(dht, session, socket) {
      this._samplesHost = [];
      this._samplesFull = [];
      this._visited = new Map;
      this._resolve = null;
      this._minSamples = 4;
      this._autoSampling = false;
      this.dht = dht;
      this.session = session;
      this.socket = socket;
      this.sampled = 0;
      this.firewall = dht.firewalled ? FIREWALL.UNKNOWN : FIREWALL.OPEN;
      this.addresses = null;
      this.analyzing = new Promise((resolve) => {
        this._resolve = resolve;
      });
    }
    autoSample(retry = true) {
      if (this._autoSampling)
        return;
      this._autoSampling = true;
      const self = this;
      const socket = this.socket;
      const maxPings = this._minSamples;
      let skip = this.dht.nodes.length >= 8 ? 5 : 0;
      let pending = 0;
      for (let node = this.dht.nodes.latest;node && this.sampled + pending < maxPings; node = node.prev) {
        if (skip > 0) {
          skip--;
          continue;
        }
        const ref = node.host + ":" + node.port;
        if (this._visited.has(ref))
          continue;
        this._visited.set(ref, 1);
        pending++;
        this.session.ping(node, { socket, retry: false }).then(onpong, onskip);
      }
      pending++;
      onskip();
      function onpong(res) {
        self.add(res.to, res.from);
        onskip();
      }
      function onskip() {
        if (--pending === 0 && self.sampled < self._minSamples) {
          if (retry) {
            self._autoSampling = false;
            self.autoSample(false);
            return;
          }
          self._resolve();
        }
      }
    }
    destroy() {
      this._autoSampling = true;
      this._minSamples = 0;
      this._resolve();
    }
    unfreeze() {
      this.frozen = false;
      this._updateFirewall();
      this._updateAddresses();
    }
    freeze() {
      this.frozen = true;
    }
    _updateFirewall() {
      if (!this.dht.firewalled) {
        this.firewall = FIREWALL.OPEN;
        return;
      }
      if (this.sampled < 3)
        return;
      const max = this._samplesFull[0].hits;
      if (max >= 3) {
        this.firewall = FIREWALL.CONSISTENT;
        return;
      }
      if (max === 1) {
        this.firewall = FIREWALL.RANDOM;
        return;
      }
      if (this._samplesHost.length === 1 && this.sampled > 3) {
        this.firewall = FIREWALL.RANDOM;
        return;
      }
      if (this._samplesHost.length > 1 && this._samplesFull[1].hits > 1) {
        this.firewall = FIREWALL.CONSISTENT;
        return;
      }
      if (this.sampled > 4) {
        this.firewall = FIREWALL.RANDOM;
      }
    }
    _updateAddresses() {
      if (this.firewall === FIREWALL.UNKNOWN) {
        this.addresses = null;
        return;
      }
      if (this.firewall === FIREWALL.RANDOM) {
        this.addresses = [this._samplesHost[0]];
        return;
      }
      if (this.firewall === FIREWALL.CONSISTENT) {
        this.addresses = [];
        for (const addr of this._samplesFull) {
          if (addr.hits >= 2 || this.addresses.length < 2)
            this.addresses.push(addr);
        }
      }
    }
    update() {
      if (this.dht.firewalled && this.firewall === FIREWALL.OPEN) {
        this.firewall = FIREWALL.UNKNOWN;
      }
      this._updateFirewall();
      this._updateAddresses();
    }
    add(addr, from) {
      const ref = from.host + ":" + from.port;
      if (this._visited.get(ref) === 2)
        return;
      this._visited.set(ref, 2);
      addSample(this._samplesHost, addr.host, 0);
      addSample(this._samplesFull, addr.host, addr.port);
      if ((++this.sampled >= 3 || !this.dht.firewalled) && !this.frozen) {
        this.update();
      }
      if (this.firewall === FIREWALL.CONSISTENT || this.firewall === FIREWALL.OPEN) {
        this._resolve();
      } else if (this.sampled >= this._minSamples) {
        this._resolve();
      }
    }
  };
  function addSample(samples, host, port) {
    for (let i = 0;i < samples.length; i++) {
      const s = samples[i];
      if (s.port !== port || s.host !== host)
        continue;
      s.hits++;
      for (;i > 0; i--) {
        const prev = samples[i - 1];
        if (prev.hits >= s.hits)
          return;
        samples[i - 1] = s;
        samples[i] = prev;
      }
      return;
    }
    samples.push({
      host,
      port,
      hits: 1
    });
  }
});

// node_modules/hyperdht/lib/holepuncher.js
var require_holepuncher = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var Nat = require_nat();
  var Sleeper = require_sleeper();
  var { FIREWALL } = require_constants2();
  var BIRTHDAY_SOCKETS = 256;
  var HOLEPUNCH = b4a.from([0]);
  var HOLEPUNCH_TTL = 5;
  var DEFAULT_TTL = 64;
  var MAX_REOPENS = 3;
  module.exports = class Holepuncher {
    constructor(dht, session, isInitiator, remoteFirewall = FIREWALL.UNKNOWN) {
      const holder = dht._socketPool.acquire();
      this.dht = dht;
      this.session = session;
      this.nat = new Nat(dht, session, holder.socket);
      this.nat.autoSample();
      this.isInitiator = isInitiator;
      this.onconnect = noop;
      this.onabort = noop;
      this.punching = false;
      this.connected = false;
      this.destroyed = false;
      this.randomized = false;
      this.remoteFirewall = remoteFirewall;
      this.remoteAddresses = [];
      this.remoteHolepunching = false;
      this._sleeper = new Sleeper;
      this._reopening = null;
      this._timeout = null;
      this._punching = null;
      this._allHolders = [];
      this._holder = this._addRef(holder);
    }
    get socket() {
      return this._holder.socket;
    }
    updateRemote({ punching, firewall, addresses, verified }) {
      const remoteAddresses = [];
      if (addresses) {
        for (const addr of addresses) {
          remoteAddresses.push({
            host: addr.host,
            port: addr.port,
            verified: verified === addr.host || this._isVerified(addr.host)
          });
        }
      }
      this.remoteFirewall = firewall;
      this.remoteAddresses = remoteAddresses;
      this.remoteHolepunching = punching;
    }
    _isVerified(host) {
      for (const addr of this.remoteAddresses) {
        if (addr.verified && addr.host === host) {
          return true;
        }
      }
      return false;
    }
    ping(addr, socket = this._holder.socket) {
      return holepunch(socket, addr, false);
    }
    openSession(addr, socket = this._holder.socket) {
      return holepunch(socket, addr, true);
    }
    async analyze(allowReopen) {
      await this.nat.analyzing;
      if (this._unstable()) {
        if (!allowReopen)
          return false;
        if (!this._reopening)
          this._reopening = this._reopen();
        return this._reopening;
      }
      return true;
    }
    _unstable() {
      const firewall = this.nat.firewall;
      return this.remoteFirewall >= FIREWALL.RANDOM && firewall >= FIREWALL.RANDOM || firewall === FIREWALL.UNKNOWN;
    }
    _reset() {
      const prev = this._holder;
      this._allHolders.pop();
      this._holder = this._addRef(this.dht._socketPool.acquire());
      prev.release();
      this.nat.destroy();
      this.nat = new Nat(this.dht, this.session, this._holder.socket);
      this.nat.autoSample();
    }
    _addRef(ref) {
      this._allHolders.push(ref);
      ref.onholepunchmessage = (msg, rinfo) => this._onholepunchmessage(msg, rinfo, ref);
      return ref;
    }
    _onholepunchmessage(_, addr, ref) {
      if (!this.isInitiator) {
        holepunch(ref.socket, addr, false);
        return;
      }
      if (this.connected)
        return;
      this.connected = true;
      this.punching = false;
      for (const r of this._allHolders) {
        if (r === ref)
          continue;
        r.release();
      }
      this._allHolders[0] = ref;
      while (this._allHolders.length > 1)
        this._allHolders.pop();
      this._decrementRandomized();
      this.onconnect(ref.socket, addr.port, addr.host);
    }
    _done() {
      return this.destroyed || this.connected;
    }
    async _reopen() {
      for (let i = 0;this._unstable() && i < MAX_REOPENS && !this._done() && !this.punching; i++) {
        this._reset();
        await this.nat.analyzing;
      }
      return coerceFirewall(this.nat.firewall) === FIREWALL.CONSISTENT;
    }
    punch() {
      if (!this._punching)
        this._punching = this._punch();
      return this._punching;
    }
    async _punch() {
      if (this._done() || !this.remoteAddresses.length)
        return false;
      this.punching = true;
      const local = coerceFirewall(this.nat.firewall);
      const remote = coerceFirewall(this.remoteFirewall);
      let remoteVerifiedAddress = null;
      for (const addr of this.remoteAddresses) {
        if (addr.verified) {
          remoteVerifiedAddress = addr;
          break;
        }
      }
      if (local === FIREWALL.CONSISTENT && remote === FIREWALL.CONSISTENT) {
        this.dht.stats.punches.consistent++;
        this._consistentProbe();
        return true;
      }
      if (!remoteVerifiedAddress)
        return false;
      if (local === FIREWALL.CONSISTENT && remote >= FIREWALL.RANDOM) {
        this.dht.stats.punches.random++;
        this._incrementRandomized();
        this._randomProbes(remoteVerifiedAddress);
        return true;
      }
      if (local >= FIREWALL.RANDOM && remote === FIREWALL.CONSISTENT) {
        this.dht.stats.punches.random++;
        this._incrementRandomized();
        await this._openBirthdaySockets(remoteVerifiedAddress);
        if (this.punching)
          this._keepAliveRandomNat(remoteVerifiedAddress);
        return true;
      }
      return false;
    }
    async _consistentProbe() {
      if (!this.isInitiator)
        await this._sleeper.pause(1000);
      let tries = 0;
      while (this.punching && tries++ < 10) {
        for (const addr of this.remoteAddresses) {
          if (!addr.verified && (tries & 3) !== 0)
            continue;
          await holepunch(this._holder.socket, addr, false);
        }
        if (this.punching)
          await this._sleeper.pause(1000);
      }
      this._autoDestroy();
    }
    async _randomProbes(remoteAddr) {
      let tries = 1750;
      while (this.punching && tries-- > 0) {
        const addr = { host: remoteAddr.host, port: randomPort() };
        await holepunch(this._holder.socket, addr, false);
        if (this.punching)
          await this._sleeper.pause(20);
      }
      this._autoDestroy();
    }
    async _keepAliveRandomNat(remoteAddr) {
      let i = 0;
      let lowTTLRounds = 1;
      await this._sleeper.pause(100);
      let tries = 1750;
      while (this.punching && tries-- > 0) {
        if (i === this._allHolders.length) {
          i = 0;
          if (lowTTLRounds > 0)
            lowTTLRounds--;
        }
        await holepunch(this._allHolders[i++].socket, remoteAddr, lowTTLRounds > 0);
        if (this.punching)
          await this._sleeper.pause(20);
      }
      this._autoDestroy();
    }
    async _openBirthdaySockets(remoteAddr) {
      while (this.punching && this._allHolders.length < BIRTHDAY_SOCKETS) {
        const ref = this._addRef(this.dht._socketPool.acquire());
        await holepunch(ref.socket, remoteAddr, HOLEPUNCH_TTL);
      }
    }
    _autoDestroy() {
      if (!this.connected)
        this.destroy();
    }
    _incrementRandomized() {
      if (!this.randomized) {
        this.randomized = true;
        this.dht._randomPunches++;
      }
    }
    _decrementRandomized() {
      if (this.randomized) {
        this.dht._lastRandomPunch = Date.now();
        this.randomized = false;
        this.dht._randomPunches--;
      }
    }
    destroy() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.punching = false;
      for (const ref of this._allHolders)
        ref.release();
      this._allHolders = [];
      this.nat.destroy();
      if (!this.connected) {
        this._decrementRandomized();
        this.onabort();
      }
    }
    static ping(socket, addr) {
      return holepunch(socket, addr, false);
    }
    static localAddresses(socket) {
      return localAddresses(socket);
    }
    static matchAddress(myAddresses, externalAddresses) {
      return matchAddress(myAddresses, externalAddresses);
    }
  };
  function holepunch(socket, addr, lowTTL) {
    return socket.send(HOLEPUNCH, addr.port, addr.host, lowTTL ? HOLEPUNCH_TTL : DEFAULT_TTL);
  }
  function randomPort() {
    return 1000 + Math.random() * 64536 | 0;
  }
  function coerceFirewall(fw) {
    return fw === FIREWALL.OPEN ? FIREWALL.CONSISTENT : fw;
  }
  function localAddresses(socket) {
    const addrs = [];
    const { host, port } = socket.address();
    if (host === "127.0.0.1")
      return [{ host, port }];
    for (const n of socket.udx.networkInterfaces()) {
      if (n.family !== 4 || n.internal)
        continue;
      addrs.push({ host: n.host, port });
    }
    if (addrs.length === 0) {
      addrs.push({ host: "127.0.0.1", port });
    }
    return addrs;
  }
  function matchAddress(localAddresses2, remoteLocalAddresses) {
    if (remoteLocalAddresses.length === 0)
      return null;
    let best = { segment: 1, addr: null };
    for (const localAddress of localAddresses2) {
      const a = localAddress.host.split(".");
      for (const remoteAddress of remoteLocalAddresses) {
        const b = remoteAddress.host.split(".");
        if (a[0] === b[0]) {
          if (best.segment === 1)
            best = { segment: 2, addr: remoteAddress };
          if (a[1] === b[1]) {
            if (best.segment === 2)
              best = { segment: 3, addr: remoteAddress };
            if (a[2] === b[2])
              return remoteAddress;
          }
        }
      }
    }
    return best.addr;
  }
  function noop() {}
});

// node_modules/bogon/index.js
var require_bogon = __commonJS((exports, module) => {
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var net = require_compact_encoding_net();
  module.exports = exports = function isBogon(ip) {
    return isBogonIP(ensureBuffer(ip));
  };
  exports.isBogon = exports;
  exports.isPrivate = function isPrivate(ip) {
    return isPrivateIP(ensureBuffer(ip));
  };
  function isBogonIP(ip) {
    return isPrivateIP(ip) || isReservedIP(ip);
  }
  function isPrivateIP(ip) {
    return ip.byteLength === 4 ? isPrivateIPv4(ip) : false;
  }
  function isPrivateIPv4(ip) {
    return ip[0] === 10 || ip[0] === 100 && ip[1] >= 64 && ip[1] <= 127 || ip[0] === 127 || ip[0] === 169 && ip[1] === 254 || ip[0] === 172 && ip[1] >= 16 && ip[1] <= 31 || ip[0] === 192 && ip[1] === 168;
  }
  function isReservedIP(ip) {
    return ip.byteLength === 4 ? isReservedIPv4(ip) : isReservedIPv6(ip);
  }
  function isReservedIPv4(ip) {
    return ip[0] === 0 || ip[0] === 192 && ip[1] === 0 && ip[2] === 0 || ip[0] === 192 && ip[1] === 0 && ip[2] === 2 || ip[0] === 198 && ip[1] >= 18 && ip[1] <= 19 || ip[0] === 198 && ip[1] === 51 && ip[2] === 100 || ip[0] === 203 && ip[1] === 0 && ip[2] === 113 || ip[0] >= 224 && ip[0] <= 239 || ip[0] >= 240 || ip[0] === 255 && ip[1] === 255 && ip[2] === 255 && ip[3] === 255;
  }
  function isReservedIPv6(ip) {
    return ip[0] === 0 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 && ip[5] === 0 && ip[6] === 0 && ip[7] === 0 && ip[8] === 0 && ip[9] === 0 && ip[10] === 0 && ip[11] === 0 && ip[12] === 0 && ip[13] === 0 && ip[14] === 0 && ip[15] <= 1 || ip[0] === 0 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 && ip[5] === 0 && ip[6] === 0 && ip[7] === 0 && ip[8] === 0 && ip[9] === 0 && (ip[10] === 0 || ip[10] === 255) && (ip[11] === 0 || ip[11] === 255) || ip[0] === 1 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 && ip[5] === 0 && ip[6] === 0 && ip[7] === 0 || ip[0] === 32 && ip[1] === 1 && ip[2] === 0 && ip[3] >= 16 && ip[3] <= 31 || ip[0] === 32 && ip[1] === 1 && ip[2] === 0 && ip[3] >= 32 && ip[3] <= 47 || ip[0] === 32 && ip[1] === 1 && ip[2] === 13 && ip[3] === 184 || ip[0] >= 252 && ip[0] <= 253 || ip[0] === 254 && ip[1] >= 128 && ip[1] <= 191 || ip[0] === 255;
  }
  var state = c.state(0, 0, b4a.allocUnsafe(1 + 16));
  function ensureBuffer(ip) {
    if (b4a.isBuffer(ip))
      return ip;
    net.ip.preencode(state, ip);
    net.ip.encode(state, ip);
    const buffer = state.buffer.subarray(1, state.end);
    state.start = 0;
    state.end = 0;
    return buffer;
  }
});

// node_modules/hyperdht/lib/server.js
var require_server = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var safetyCatch = require_safety_catch();
  var NoiseSecretStream = require_secret_stream();
  var b4a = require_b4a();
  var relay = require_blind_relay();
  var NoiseWrap = require_noise_wrap();
  var Announcer = require_announcer();
  var { FIREWALL, ERROR } = require_constants2();
  var { unslabbedHash } = require_crypto();
  var SecurePayload = require_secure_payload();
  var Holepuncher = require_holepuncher();
  var { isPrivate } = require_bogon();
  var { ALREADY_LISTENING, NODE_DESTROYED, KEYPAIR_ALREADY_USED } = require_errors5();
  var HANDSHAKE_CLEAR_WAIT = 1e4;
  var HANDSHAKE_INITIAL_TIMEOUT = 1e4;
  module.exports = class Server extends EventEmitter {
    constructor(dht, opts = {}) {
      super();
      this.dht = dht;
      this.target = null;
      this.closed = false;
      this.firewall = opts.firewall || (() => false);
      this.holepunch = opts.holepunch || (() => true);
      this.relayThrough = opts.relayThrough || null;
      this.relayKeepAlive = opts.relayKeepAlive || 5000;
      this.pool = opts.pool || null;
      this.createHandshake = opts.createHandshake || defaultCreateHandshake;
      this.createSecretStream = opts.createSecretStream || defaultCreateSecretStream;
      this.suspended = false;
      this._shareLocalAddress = opts.shareLocalAddress !== false;
      this._reusableSocket = !!opts.reusableSocket;
      this._neverPunch = opts.holepunch === false;
      this._keyPair = null;
      this._announcer = null;
      this._connects = new Map;
      this._holepunches = [];
      this._listening = null;
      this._closing = null;
    }
    get listening() {
      return this._listening !== null;
    }
    get publicKey() {
      return this._keyPair && this._keyPair.publicKey;
    }
    get relayAddresses() {
      return this._announcer ? this._announcer.relayAddresses : [];
    }
    onconnection(encryptedSocket) {
      this.emit("connection", encryptedSocket);
    }
    async suspend({ log = noop } = {}) {
      log("Suspending hyperdht server");
      if (this._listening !== null)
        await this._listening;
      log("Suspending hyperdht server (post listening)");
      this.suspended = true;
      this._clearAll();
      return this._announcer ? this._announcer.suspend({ log }) : Promise.resolve();
    }
    async resume() {
      if (this._listening !== null)
        await this._listening;
      this.suspended = false;
      return this._announcer ? this._announcer.resume() : Promise.resolve();
    }
    address() {
      if (!this._keyPair)
        return null;
      return {
        publicKey: this._keyPair.publicKey,
        host: this.dht.host,
        port: this.dht.port
      };
    }
    close() {
      if (this._closing)
        return this._closing;
      this._closing = this._close();
      return this._closing;
    }
    _gc() {
      this.dht.listening.delete(this);
      if (this.target)
        this.dht._router.delete(this.target);
    }
    async _stopListening() {
      try {
        if (this._announcer)
          await this._announcer.stop();
      } catch {}
      this._announcer = null;
      this._listening = null;
      this._keyPair = null;
    }
    async _close() {
      if (this._listening === null) {
        this.closed = true;
        this.emit("close");
        return;
      }
      try {
        await this._listening;
      } catch {}
      this._gc();
      this._clearAll();
      await this._stopListening();
      this.closed = true;
      this.emit("close");
    }
    _clearAll() {
      while (this._holepunches.length > 0) {
        const h = this._holepunches.pop();
        if (h && h.puncher)
          h.puncher.destroy();
        if (h && h.clearing)
          clearTimeout(h.clearing);
        if (h && h.prepunching)
          clearTimeout(h.prepunching);
        if (h && h.rawStream)
          h.rawStream.destroy();
      }
      this._connects.clear();
    }
    async listen(keyPair = this.dht.defaultKeyPair, opts = {}) {
      if (this._listening !== null)
        throw ALREADY_LISTENING();
      if (this.dht.destroyed)
        throw NODE_DESTROYED();
      this._listening = this._listen(keyPair, opts);
      await this._listening;
      return this;
    }
    async _listen(keyPair, opts) {
      this.dht.listening.add(this);
      try {
        await this.dht.bind();
        if (this._closing)
          return;
        for (const s of this.dht.listening) {
          if (s._keyPair && b4a.equals(s._keyPair.publicKey, keyPair.publicKey)) {
            throw KEYPAIR_ALREADY_USED();
          }
        }
        this.target = unslabbedHash(keyPair.publicKey);
        this._keyPair = keyPair;
        this._announcer = new Announcer(this.dht, keyPair, this.target, opts);
        this.dht._router.set(this.target, {
          relay: null,
          record: this._announcer.record,
          onpeerhandshake: this._onpeerhandshake.bind(this),
          onpeerholepunch: this._onpeerholepunch.bind(this)
        });
        this._localAddresses().catch(safetyCatch);
        await this._announcer.start();
      } catch (err) {
        await this._stopListening();
        this._gc();
        throw err;
      }
      if (this._closing)
        return;
      if (this.suspended)
        await this._announcer.suspend();
      if (this._closing)
        return;
      if (this.dht.destroyed)
        throw NODE_DESTROYED();
      if (this.pool)
        this.pool._attachServer(this);
      this.emit("listening");
    }
    refresh() {
      if (this._announcer)
        this._announcer.refresh();
    }
    notifyOnline() {
      if (this._announcer)
        this._announcer.online.notify();
    }
    _localAddresses() {
      return this.dht.validateLocalAddresses(Holepuncher.localAddresses(this.dht.io.serverSocket));
    }
    async _addHandshake(k, noise, clientAddress, { from, to: serverAddress, socket }, direct) {
      let id = this._holepunches.indexOf(null);
      if (id === -1)
        id = this._holepunches.push(null) - 1;
      const hs = {
        round: 0,
        reply: null,
        puncher: null,
        payload: null,
        rawStream: null,
        encryptedSocket: null,
        prepunching: null,
        firewalled: true,
        clearing: null,
        onsocket: null,
        relayTimeout: null,
        relayToken: null,
        relaySocket: null,
        relayClient: null,
        relayPaired: false
      };
      this._holepunches[id] = hs;
      const handshake = this.createHandshake(this._keyPair, null);
      let remotePayload;
      try {
        remotePayload = await handshake.recv(noise);
      } catch (err) {
        safetyCatch(err);
        this._clearLater(hs, id, k);
        return null;
      }
      if (this._closing || this.suspended)
        return null;
      try {
        hs.firewalled = await this.firewall(handshake.remotePublicKey, remotePayload, clientAddress);
      } catch (err) {
        safetyCatch(err);
      }
      if (this._closing || this.suspended)
        return null;
      if (hs.firewalled) {
        this._clearLater(hs, id, k);
        return null;
      }
      const error = remotePayload.version === 1 ? remotePayload.udx ? ERROR.NONE : ERROR.ABORTED : ERROR.VERSION_MISMATCH;
      const addresses = [];
      const ourRemoteAddr = this.dht.remoteAddress();
      const ourLocalAddrs = this._shareLocalAddress ? await this._localAddresses() : null;
      if (this._closing || this.suspended)
        return null;
      if (ourRemoteAddr)
        addresses.push(ourRemoteAddr);
      if (ourLocalAddrs)
        addresses.push(...ourLocalAddrs);
      if (error === ERROR.NONE) {
        let autoDestroy2 = function() {
          if (hs.puncher)
            hs.puncher.destroy();
        };
        var autoDestroy = autoDestroy2;
        hs.rawStream = this.dht.createRawStream({
          framed: true,
          firewall(socket2, port, host) {
            if (hs.relaySocket && isRelay(hs.relaySocket, socket2, port, host)) {
              return false;
            }
            hs.onsocket(socket2, port, host);
            return false;
          }
        });
        hs.rawStream.on("error", autoDestroy2);
        hs.onsocket = (socket2, port, host) => {
          if (hs.rawStream === null)
            return;
          this._clearLater(hs, id, k);
          if (hs.prepunching) {
            clearTimeout(hs.prepunching);
            hs.prepunching = null;
          }
          if (this._reusableSocket && remotePayload.udx.reusableSocket) {
            this.dht._socketPool.routes.add(handshake.remotePublicKey, hs.rawStream);
          }
          hs.rawStream.removeListener("error", autoDestroy2);
          if (hs.rawStream.connected) {
            const remoteChanging = hs.rawStream.changeRemote(socket2, remotePayload.udx.id, port, host);
            if (remoteChanging)
              remoteChanging.catch(safetyCatch);
          } else {
            hs.rawStream.connect(socket2, remotePayload.udx.id, port, host);
            hs.encryptedSocket = this.createSecretStream(false, hs.rawStream, {
              handshake: h,
              keepAlive: this.dht.connectionKeepAlive
            });
            this.onconnection(hs.encryptedSocket);
          }
          if (hs.puncher) {
            hs.puncher.onabort = noop;
            hs.puncher.destroy();
          }
          hs.rawStream = null;
        };
      }
      const relayThrough = selectRelay(this.relayThrough);
      if (relayThrough)
        hs.relayToken = relay.token();
      try {
        hs.reply = await handshake.send({
          error,
          firewall: ourRemoteAddr ? FIREWALL.OPEN : FIREWALL.UNKNOWN,
          holepunch: ourRemoteAddr ? null : { id, relays: this._announcer.relays },
          addresses4: addresses,
          addresses6: null,
          udx: {
            reusableSocket: this._reusableSocket,
            id: hs.rawStream ? hs.rawStream.id : 0,
            seq: 0
          },
          secretStream: {},
          relayThrough: relayThrough ? { publicKey: relayThrough, token: hs.relayToken } : null
        });
      } catch (err) {
        safetyCatch(err);
        hs.rawStream.destroy();
        this._clearLater(hs, id, k);
        return null;
      }
      if (this._closing || this.suspended) {
        hs.rawStream.destroy();
        return null;
      }
      const h = handshake.final();
      if (error !== ERROR.NONE) {
        hs.rawStream.destroy();
        this._clearLater(hs, id, k);
        return hs;
      }
      if (relayThrough || remotePayload.relayThrough) {
        this._relayConnection(hs, relayThrough, remotePayload, h);
      }
      if (remotePayload.firewall === FIREWALL.OPEN || direct) {
        const sock = direct ? socket : this.dht.socket;
        this.dht.stats.punches.open++;
        hs.onsocket(sock, clientAddress.port, clientAddress.host);
        return hs;
      }
      const onabort = () => {
        if (hs.prepunching)
          clearTimeout(hs.prepunching);
        hs.prepunching = null;
        hs.rawStream.on("close", () => this._clearLater(hs, id, k));
        if (hs.relayToken === null)
          hs.rawStream.destroy();
      };
      if (!direct && clientAddress.host === serverAddress.host) {
        const clientAddresses = remotePayload.addresses4.filter(onlyPrivateHosts);
        if (clientAddresses.length > 0 && this._shareLocalAddress) {
          const myAddresses = await this._localAddresses();
          const addr = Holepuncher.matchAddress(myAddresses, clientAddresses);
          if (addr) {
            hs.prepunching = setTimeout(onabort, HANDSHAKE_INITIAL_TIMEOUT);
            return hs;
          }
        }
      }
      if (this._closing || this.suspended)
        return null;
      if (ourRemoteAddr || this._neverPunch) {
        hs.prepunching = setTimeout(onabort, HANDSHAKE_INITIAL_TIMEOUT);
        return hs;
      }
      hs.payload = new SecurePayload(h.holepunchSecret);
      hs.puncher = new Holepuncher(this.dht, this.dht.session(), false, remotePayload.firewall);
      hs.puncher.onconnect = hs.onsocket;
      hs.puncher.onabort = onabort;
      hs.prepunching = setTimeout(hs.puncher.destroy.bind(hs.puncher), HANDSHAKE_INITIAL_TIMEOUT);
      return hs;
    }
    _clearLater(hs, id, k) {
      if (hs.clearing)
        return;
      hs.clearing = setTimeout(() => this._clear(hs, id, k), HANDSHAKE_CLEAR_WAIT);
    }
    _clear(hs, id, k) {
      if (id >= this._holepunches.length || this._holepunches[id] !== hs)
        return;
      if (hs.clearing)
        clearTimeout(hs.clearing);
      this._holepunches[id] = null;
      while (this._holepunches.length > 0 && this._holepunches[this._holepunches.length - 1] === null) {
        this._holepunches.pop();
      }
      this._connects.delete(k);
    }
    async _onpeerhandshake({ noise, peerAddress }, req) {
      const k = b4a.toString(noise, "hex");
      let p = this._connects.get(k);
      if (!p) {
        p = this._addHandshake(k, noise, peerAddress || req.from, req, !peerAddress);
        this._connects.set(k, p);
      }
      const h = await p;
      if (!h)
        return null;
      if (this._closing !== null || this.suspended)
        return null;
      return { socket: h.puncher && h.puncher.socket, noise: h.reply };
    }
    async _onpeerholepunch({ id, peerAddress, payload }, req) {
      const h = id < this._holepunches.length ? this._holepunches[id] : null;
      if (!h)
        return null;
      if (!peerAddress || this._closing !== null || this.suspended)
        return null;
      const p = h.puncher;
      if (!p || !p.socket)
        return this._abort(h);
      const remotePayload = h.payload.decrypt(payload);
      if (!remotePayload)
        return null;
      const isServerRelay = this._announcer.isRelay(req.from);
      const { error, firewall, round, punching, addresses, remoteAddress, remoteToken } = remotePayload;
      if (error !== ERROR.NONE) {
        if (round >= h.round)
          h.round = round;
        return this._abort(h);
      }
      const token = h.payload.token(peerAddress);
      const echoed = isServerRelay && !!remoteToken && b4a.equals(token, remoteToken);
      if (req.socket === p.socket) {
        p.nat.add(req.to, req.from);
      }
      if (round >= h.round) {
        h.round = round;
        p.updateRemote({ punching, firewall, addresses, verified: echoed ? peerAddress.host : null });
      }
      let stable = await p.analyze(false);
      if (p.destroyed)
        return null;
      if (!p.remoteHolepunching && !stable) {
        stable = await p.analyze(true);
        if (p.destroyed)
          return null;
        if (!stable)
          return this._abort(h);
      }
      if (isConsistent(p.nat.firewall) && remoteAddress && hasSameAddr(p.nat.addresses, remoteAddress)) {
        await p.ping(peerAddress);
        if (p.destroyed)
          return null;
      }
      if (p.remoteHolepunching) {
        if (!this.holepunch(p.remoteFirewall, p.nat.firewall, p.remoteAddresses, p.nat.addresses)) {
          return p.destroyed ? null : this._abort(h);
        }
        if (h.prepunching) {
          clearTimeout(h.prepunching);
          h.prepunching = null;
        }
        if (p.remoteFirewall >= FIREWALL.RANDOM || p.nat.firewall >= FIREWALL.RANDOM) {
          if (this.dht._randomPunches >= this.dht._randomPunchLimit || Date.now() - this.dht._lastRandomPunch < this.dht._randomPunchInterval) {
            if (!h.relayToken)
              return this._abort(h, ERROR.TRY_LATER);
            return {
              socket: p.socket,
              payload: h.payload.encrypt({
                error: ERROR.TRY_LATER,
                firewall: p.nat.firewall,
                round: h.round,
                connected: p.connected,
                punching: p.punching,
                addresses: p.nat.addresses,
                remoteAddress: null,
                token: isServerRelay ? token : null,
                remoteToken: remotePayload.token
              })
            };
          }
        }
        const punching2 = await p.punch();
        if (p.destroyed)
          return null;
        if (!punching2)
          return this._abort(h);
      }
      if (p.nat.firewall !== FIREWALL.UNKNOWN) {
        p.nat.freeze();
      }
      return {
        socket: p.socket,
        payload: h.payload.encrypt({
          error: ERROR.NONE,
          firewall: p.nat.firewall,
          round: h.round,
          connected: p.connected,
          punching: p.punching,
          addresses: p.nat.addresses,
          remoteAddress: null,
          token: isServerRelay ? token : null,
          remoteToken: remotePayload.token
        })
      };
    }
    _abort(h, error = ERROR.ABORTED) {
      if (!h.payload) {
        if (h.puncher)
          h.puncher.destroy();
        return null;
      }
      const payload = h.payload.encrypt({
        error,
        firewall: FIREWALL.UNKNOWN,
        round: h.round,
        connected: false,
        punching: false,
        addresses: null,
        remoteAddress: null,
        token: null,
        remoteToken: null
      });
      h.puncher.destroy();
      return { socket: this.dht.socket, payload };
    }
    _relayConnection(hs, relayThrough, remotePayload, h) {
      let isInitiator;
      let publicKey;
      let token;
      if (relayThrough) {
        isInitiator = true;
        publicKey = relayThrough;
        token = hs.relayToken;
      } else {
        isInitiator = false;
        publicKey = remotePayload.relayThrough.publicKey;
        token = remotePayload.relayThrough.token;
      }
      hs.relayToken = token;
      hs.relaySocket = this.dht.connect(publicKey);
      hs.relaySocket.setKeepAlive(this.relayKeepAlive);
      hs.relayClient = relay.Client.from(hs.relaySocket, { id: hs.relaySocket.publicKey });
      hs.relayTimeout = setTimeout(onabort, 15000);
      hs.relayClient.pair(isInitiator, token, hs.rawStream).on("error", onabort).on("data", (remoteId) => {
        if (hs.relayTimeout)
          clearRelayTimeout(hs);
        if (hs.rawStream === null) {
          onabort(null);
          return;
        }
        hs.relayPaired = true;
        if (hs.prepunching)
          clearTimeout(hs.prepunching);
        hs.prepunching = null;
        const {
          remotePort,
          remoteHost,
          socket
        } = hs.relaySocket.rawStream;
        hs.rawStream.on("close", () => hs.relaySocket.destroy()).connect(socket, remoteId, remotePort, remoteHost);
        hs.encryptedSocket = this.createSecretStream(false, hs.rawStream, { handshake: h });
        this.onconnection(hs.encryptedSocket);
      });
      function onabort() {
        if (hs.relayTimeout)
          clearRelayTimeout(hs);
        const socket = hs.relaySocket;
        hs.relayToken = null;
        hs.relaySocket = null;
        if (socket)
          socket.destroy();
      }
    }
  };
  function clearRelayTimeout(hs) {
    clearTimeout(hs.relayTimeout);
    hs.relayTimeout = null;
  }
  function isConsistent(fw) {
    return fw === FIREWALL.OPEN || fw === FIREWALL.CONSISTENT;
  }
  function hasSameAddr(addrs, other) {
    if (addrs === null)
      return false;
    for (const addr of addrs) {
      if (addr.port === other.port && addr.host === other.host)
        return true;
    }
    return false;
  }
  function defaultCreateHandshake(keyPair, remotePublicKey) {
    return new NoiseWrap(keyPair, remotePublicKey);
  }
  function defaultCreateSecretStream(isInitiator, rawStream, opts) {
    return new NoiseSecretStream(isInitiator, rawStream, opts);
  }
  function onlyPrivateHosts(addr) {
    return isPrivate(addr.host);
  }
  function isRelay(relaySocket, socket, port, host) {
    const stream = relaySocket.rawStream;
    if (!stream)
      return false;
    if (stream.socket !== socket)
      return false;
    return port === stream.remotePort && host === stream.remoteHost;
  }
  function selectRelay(relayThrough) {
    if (typeof relayThrough === "function")
      relayThrough = relayThrough();
    if (relayThrough === null)
      return null;
    if (Array.isArray(relayThrough))
      return relayThrough[Math.floor(Math.random() * relayThrough.length)];
    return relayThrough;
  }
  function noop() {}
});

// node_modules/hyperdht/lib/semaphore.js
var require_semaphore = __commonJS((exports, module) => {
  var DONE = Promise.resolve(true);
  var DESTROYED = Promise.resolve(false);
  module.exports = class Semaphore {
    constructor(limit = 1) {
      this.limit = limit;
      this.active = 0;
      this.waiting = [];
      this.destroyed = false;
      this._onwait = (resolve) => {
        this.waiting.push(resolve);
      };
    }
    wait() {
      if (this.destroyed === true)
        return DESTROYED;
      if (this.active < this.limit && this.waiting.length === 0) {
        this.active++;
        return DONE;
      }
      return new Promise(this._onwait);
    }
    signal() {
      if (this.destroyed === true)
        return;
      this.active--;
      while (this.active < this.limit && this.waiting.length > 0 && this.destroyed === false) {
        this.active++;
        this.waiting.shift()(true);
      }
    }
    async flush() {
      if (this.destroyed === true)
        return;
      this.limit = 1;
      await this.wait();
      this.signal();
    }
    destroy() {
      this.destroyed = true;
      this.active = 0;
      while (this.waiting.length)
        this.waiting.pop()(false);
    }
  };
});

// node_modules/hyperdht/lib/connect.js
var require_connect = __commonJS((exports, module) => {
  var NoiseSecretStream = require_secret_stream();
  var b4a = require_b4a();
  var relay = require_blind_relay();
  var { isPrivate, isBogon } = require_bogon();
  var safetyCatch = require_safety_catch();
  var unslab = require_unslab();
  var Semaphore = require_semaphore();
  var NoiseWrap = require_noise_wrap();
  var SecurePayload = require_secure_payload();
  var Holepuncher = require_holepuncher();
  var Sleeper = require_sleeper();
  var { FIREWALL, ERROR } = require_constants2();
  var { unslabbedHash } = require_crypto();
  var {
    CANNOT_HOLEPUNCH,
    HANDSHAKE_INVALID,
    HOLEPUNCH_ABORTED,
    HOLEPUNCH_INVALID,
    HOLEPUNCH_PROBE_TIMEOUT,
    HOLEPUNCH_DOUBLE_RANDOMIZED_NATS,
    PEER_CONNECTION_FAILED,
    PEER_NOT_FOUND,
    REMOTE_ABORTED,
    REMOTE_NOT_HOLEPUNCHABLE,
    REMOTE_NOT_HOLEPUNCHING,
    SERVER_ERROR,
    SERVER_INCOMPATIBLE,
    RELAY_ABORTED,
    SUSPENDED
  } = require_errors5();
  module.exports = function connect(dht, publicKey, opts = {}) {
    const pool = opts.pool || null;
    if (pool && pool.has(publicKey))
      return pool.get(publicKey);
    publicKey = unslab(publicKey);
    const keyPair = opts.keyPair || dht.defaultKeyPair;
    const relayThrough = selectRelay(opts.relayThrough || null);
    const encryptedSocket = (opts.createSecretStream || defaultCreateSecretStream)(true, null, {
      publicKey: keyPair.publicKey,
      remotePublicKey: publicKey,
      autoStart: false,
      keepAlive: dht.connectionKeepAlive
    });
    if (dht.suspended || !dht._connectable) {
      encryptedSocket.destroy(SUSPENDED());
      return encryptedSocket;
    }
    if (pool)
      pool._attachStream(encryptedSocket, false);
    const c = {
      dht,
      session: dht.session(),
      relayAddresses: opts.relayAddresses || [],
      pool,
      round: 0,
      target: unslabbedHash(publicKey),
      remotePublicKey: publicKey,
      reusableSocket: !!opts.reusableSocket,
      handshake: (opts.createHandshake || defaultCreateHandshake)(keyPair, publicKey),
      request: null,
      requesting: false,
      lan: opts.localConnection !== false,
      firewall: FIREWALL.UNKNOWN,
      rawStream: dht.createRawStream({ framed: true, firewall }),
      connect: null,
      query: null,
      puncher: null,
      payload: null,
      passiveConnectTimeout: null,
      serverSocket: null,
      serverAddress: null,
      onsocket: null,
      sleeper: new Sleeper,
      encryptedSocket,
      relayTimeout: null,
      relayThrough,
      relayToken: relayThrough ? relay.token() : null,
      relaySocket: null,
      relayClient: null,
      relayPaired: false,
      relayKeepAlive: opts.relayKeepAlive || 5000
    };
    c.rawStream.on("error", autoDestroy);
    c.rawStream.once("connect", () => {
      c.rawStream.removeListener("error", autoDestroy);
    });
    encryptedSocket.on("close", function() {
      if (c.passiveConnectTimeout)
        clearPassiveConnectTimeout(c);
      if (c.query)
        c.query.destroy();
      if (c.puncher)
        c.puncher.destroy();
      if (c.rawStream)
        c.rawStream.destroy();
      c.session.destroy();
      c.sleeper.resume();
    });
    if (dht.suspended)
      encryptedSocket.destroy(SUSPENDED());
    else
      connectAndHolepunch(c, opts);
    return encryptedSocket;
    function autoDestroy(err) {
      maybeDestroyEncryptedSocket(c, err);
    }
    function firewall(socket, port, host) {
      if (c.relaySocket && isRelay(c.relaySocket, socket, port, host)) {
        return false;
      }
      if (c.onsocket) {
        c.onsocket(socket, port, host);
      } else {
        c.serverSocket = socket;
        c.serverAddress = { port, host };
      }
      return false;
    }
  };
  function isDone(c) {
    if (c.encryptedSocket.destroying || !!(c.puncher && c.puncher.connected)) {
      return true;
    }
    if (c.encryptedSocket.rawStream === null) {
      return false;
    }
    if (c.relaySocket && !!(c.puncher && !c.puncher.connected && !c.puncher.destroyed)) {
      return false;
    }
    return true;
  }
  async function retryRoute(c, route) {
    const ref = c.dht._socketPool.lookup(route.socket);
    if (!ref) {
      if (route.socket === c.dht.socket) {
        await connectThroughNode(c, route.address, c.dht.socket);
      }
      return;
    }
    ref.active();
    try {
      await connectThroughNode(c, route.address, route.socket);
    } catch {}
    ref.inactive();
  }
  async function connectAndHolepunch(c, opts) {
    const route = c.reusableSocket ? c.dht._socketPool.routes.get(c.remotePublicKey) : null;
    if (route) {
      await retryRoute(c, route);
      if (isDone(c))
        return;
    }
    await findAndConnect(c, opts);
    if (isDone(c))
      return;
    if (!c.connect) {
      maybeDestroyEncryptedSocket(c, HANDSHAKE_INVALID());
      return;
    }
    await holepunch(c, opts);
  }
  function getFirstRemoteAddress(addrs, serverAddress) {
    for (const addr of addrs) {
      if (isBogon(addr.host))
        continue;
      return addr;
    }
    return serverAddress;
  }
  async function holepunch(c, opts) {
    let { relayAddress, serverAddress, clientAddress, payload } = c.connect;
    const remoteHolepunchable = !!(payload.holepunch && payload.holepunch.relays.length);
    const relayed = diffAddress(serverAddress, relayAddress);
    if (payload.firewall === FIREWALL.OPEN || relayed && !remoteHolepunchable) {
      const addr = getFirstRemoteAddress(payload.addresses4, serverAddress);
      if (addr) {
        const socket = c.dht.socket;
        c.dht.stats.punches.open++;
        c.onsocket(socket, addr.port, addr.host);
        return;
      }
    }
    const onabort = () => {
      c.session.destroy();
      maybeDestroyEncryptedSocket(c, HOLEPUNCH_ABORTED());
    };
    if (c.firewall === FIREWALL.OPEN) {
      c.passiveConnectTimeout = setTimeout(onabort, 1e4);
      return;
    }
    if (c.lan && relayed && clientAddress.host === serverAddress.host) {
      const serverAddresses = payload.addresses4.filter(onlyPrivateHosts);
      if (serverAddresses.length > 0) {
        const myAddresses = Holepuncher.localAddresses(c.dht.io.serverSocket);
        const addr = Holepuncher.matchAddress(myAddresses, serverAddresses) || serverAddresses[0];
        const socket = c.dht.io.serverSocket;
        try {
          await c.dht.ping(addr);
        } catch {
          maybeDestroyEncryptedSocket(c, HOLEPUNCH_ABORTED());
          return;
        }
        c.onsocket(socket, addr.port, addr.host);
        return;
      }
    }
    if (!remoteHolepunchable) {
      maybeDestroyEncryptedSocket(c, CANNOT_HOLEPUNCH());
      return;
    }
    c.puncher = new Holepuncher(c.dht, c.session, true, payload.firewall);
    c.puncher.onconnect = c.onsocket;
    c.puncher.onabort = onabort;
    const serverRelay = pickServerRelay(payload.holepunch.relays, relayAddress);
    let probe;
    try {
      probe = await probeRound(c, opts.fastOpen === false ? null : serverAddress, serverRelay, true);
    } catch (err) {
      destroyPuncher(c);
      maybeDestroyEncryptedSocket(c, err);
      return;
    }
    if (isDone(c) || !probe)
      return;
    const { token, peerAddress } = probe;
    if (!diffAddress(serverRelay.relayAddress, relayAddress) && diffAddress(serverAddress, peerAddress)) {
      serverAddress = peerAddress;
      await c.puncher.openSession(serverAddress);
      if (isDone(c))
        return;
    }
    if (opts.holepunch && !opts.holepunch(c.puncher.remoteFirewall, c.puncher.nat.firewall, c.puncher.remoteAddresses, c.puncher.nat.addresses)) {
      await abort(c, serverRelay, HOLEPUNCH_ABORTED("Client aborted holepunch"));
      return;
    }
    try {
      await roundPunch(c, serverAddress, token, relayAddress, serverRelay, false);
    } catch (err) {
      destroyPuncher(c);
      maybeDestroyEncryptedSocket(c, err);
    }
  }
  async function findAndConnect(c, opts) {
    let attempts = 0;
    let closestNodes = opts.relayAddresses && opts.relayAddresses.length ? opts.relayAddresses : null;
    if (c.dht._persistent) {
      const route = c.dht._router.get(c.target);
      if (route && route.relay !== null)
        closestNodes = [{ host: route.relay.host, port: route.relay.port }];
    }
    const sem = new Semaphore(2);
    const signal = sem.signal.bind(sem);
    const tries = closestNodes !== null ? 2 : 1;
    try {
      for (let i = 0;i < tries && !isDone(c) && !c.connect; i++) {
        c.query = c.dht.findPeer(c.target, { hash: false, session: c.session, closestNodes, onlyClosestNodes: closestNodes !== null });
        for await (const data of c.query) {
          await sem.wait();
          if (isDone(c))
            return;
          if (c.connect) {
            sem.signal();
            break;
          }
          attempts++;
          connectThroughNode(c, data.from, null).then(signal, signal);
        }
        closestNodes = null;
      }
      c.query = null;
      if (isDone(c))
        return;
      await sem.flush();
      if (isDone(c))
        return;
    } catch (err) {
      c.query = null;
      maybeDestroyEncryptedSocket(c, err);
      return;
    }
    if (!c.connect) {
      maybeDestroyEncryptedSocket(c, attempts ? PEER_CONNECTION_FAILED() : PEER_NOT_FOUND());
    }
  }
  async function connectThroughNode(c, address, socket) {
    if (!c.requesting) {
      const addr = c.dht.remoteAddress();
      const localAddrs = c.lan ? Holepuncher.localAddresses(c.dht.io.serverSocket) : null;
      const addresses4 = [];
      if (addr)
        addresses4.push(addr);
      if (localAddrs)
        addresses4.push(...localAddrs);
      c.firewall = addr ? FIREWALL.OPEN : FIREWALL.UNKNOWN;
      c.requesting = true;
      c.request = await c.handshake.send({
        error: ERROR.NONE,
        firewall: c.firewall,
        holepunch: null,
        addresses4,
        addresses6: [],
        udx: {
          reusableSocket: c.reusableSocket,
          id: c.rawStream.id,
          seq: 0
        },
        secretStream: {},
        relayThrough: c.relayThrough ? { publicKey: c.relayThrough, token: c.relayToken } : null
      });
      if (isDone(c))
        return;
    }
    const { serverAddress, clientAddress, relayed, noise } = await c.dht._router.peerHandshake(c.target, { noise: c.request, socket, session: c.session }, address);
    if (isDone(c) || c.connect)
      return;
    const payload = await c.handshake.recv(noise);
    if (isDone(c) || !payload)
      return;
    if (payload.version !== 1) {
      maybeDestroyEncryptedSocket(c, SERVER_INCOMPATIBLE());
      return;
    }
    if (payload.error !== ERROR.NONE) {
      maybeDestroyEncryptedSocket(c, SERVER_ERROR());
      return;
    }
    if (!payload.udx) {
      maybeDestroyEncryptedSocket(c, SERVER_ERROR("Server did not send UDX data"));
      return;
    }
    const hs = c.handshake.final();
    c.handshake = null;
    c.request = null;
    c.requesting = false;
    c.connect = {
      relayed,
      relayAddress: address,
      clientAddress,
      serverAddress,
      payload
    };
    c.payload = new SecurePayload(hs.holepunchSecret);
    c.onsocket = function(socket2, port, host) {
      if (c.rawStream === null)
        return;
      if (c.rawStream.connected) {
        const remoteChanging = c.rawStream.changeRemote(socket2, c.connect.payload.udx.id, port, host);
        if (remoteChanging)
          remoteChanging.catch(safetyCatch);
      } else {
        c.rawStream.connect(socket2, c.connect.payload.udx.id, port, host);
        c.encryptedSocket.start(c.rawStream, { handshake: hs });
      }
      if (c.reusableSocket && payload.udx.reusableSocket) {
        c.dht._socketPool.routes.add(c.remotePublicKey, c.rawStream);
      }
      if (c.puncher) {
        c.puncher.onabort = noop;
        c.puncher.destroy();
      }
      if (c.passiveConnectTimeout) {
        clearPassiveConnectTimeout(c);
      }
      c.rawStream = null;
    };
    if (payload.relayThrough || c.relayThrough) {
      relayConnection(c, c.relayThrough, payload, hs);
    }
    if (c.serverSocket) {
      c.onsocket(c.serverSocket, c.serverAddress.port, c.serverAddress.host);
      return;
    }
    if (!relayed) {
      c.onsocket(socket || c.dht.socket, address.port, address.host);
    }
    c.session.destroy();
  }
  async function updateHolepunch(c, peerAddress, relayAddr, payload) {
    const holepunch2 = await c.dht._router.peerHolepunch(c.target, {
      id: c.connect.payload.holepunch.id,
      payload: c.payload.encrypt(payload),
      peerAddress,
      socket: c.puncher.socket,
      session: c.session
    }, relayAddr);
    if (isDone(c))
      return null;
    const remotePayload = c.payload.decrypt(holepunch2.payload);
    if (!remotePayload) {
      throw HOLEPUNCH_INVALID();
    }
    const { error, firewall, punching, addresses, remoteToken } = remotePayload;
    if (error === ERROR.TRY_LATER && c.relayToken && payload.punching) {
      return {
        tryLater: true,
        ...holepunch2,
        payload: remotePayload
      };
    }
    if (error !== ERROR.NONE) {
      throw REMOTE_ABORTED("Remote aborted with error code " + error);
    }
    const echoed = !!(remoteToken && payload.token && b4a.equals(remoteToken, payload.token));
    c.puncher.updateRemote({ punching, firewall, addresses, verified: echoed ? peerAddress.host : null });
    return {
      tryLater: false,
      ...holepunch2,
      payload: remotePayload
    };
  }
  async function probeRound(c, serverAddress, serverRelay, retry) {
    if (serverAddress)
      await c.puncher.openSession(serverAddress);
    if (isDone(c))
      return null;
    const reply = await updateHolepunch(c, serverRelay.peerAddress, serverRelay.relayAddress, {
      error: ERROR.NONE,
      firewall: c.puncher.nat.firewall,
      round: c.round++,
      connected: false,
      punching: false,
      addresses: c.puncher.nat.addresses,
      remoteAddress: serverAddress,
      token: null,
      remoteToken: null
    });
    if (isDone(c) || !reply)
      return null;
    const { peerAddress } = reply;
    const { address, token } = reply.payload;
    c.puncher.nat.add(reply.to, reply.from);
    if (c.puncher.remoteFirewall < FIREWALL.RANDOM && address && address.host && address.port && diffAddress(address, serverAddress)) {
      await c.puncher.openSession(address);
      if (isDone(c))
        return null;
    }
    if (c.puncher.remoteFirewall === FIREWALL.UNKNOWN) {
      await c.sleeper.pause(1000);
      if (isDone(c))
        return null;
    }
    let stable = await c.puncher.analyze(false);
    if (isDone(c))
      return null;
    if (!stable) {
      stable = await c.puncher.analyze(true);
      if (isDone(c))
        return null;
      if (stable)
        return probeRound(c, serverAddress, serverRelay, false);
    }
    if ((c.puncher.remoteFirewall === FIREWALL.UNKNOWN || !token) && retry) {
      return probeRound(c, serverAddress, serverRelay, false);
    }
    if (c.puncher.remoteFirewall === FIREWALL.UNKNOWN || c.puncher.nat.firewall === FIREWALL.UNKNOWN) {
      await abort(c, serverRelay, HOLEPUNCH_PROBE_TIMEOUT());
      return null;
    }
    if (c.puncher.remoteFirewall >= FIREWALL.RANDOM && c.puncher.nat.firewall >= FIREWALL.RANDOM) {
      await abort(c, serverRelay, HOLEPUNCH_DOUBLE_RANDOMIZED_NATS());
      return null;
    }
    return { token, peerAddress };
  }
  async function roundPunch(c, serverAddress, remoteToken, clientRelay, serverRelay, delayed) {
    c.puncher.nat.freeze();
    const isRandom = c.puncher.remoteFirewall >= FIREWALL.RANDOM || c.puncher.nat.firewall >= FIREWALL.RANDOM;
    if (isRandom) {
      while (c.dht._randomPunches >= c.dht._randomPunchLimit || Date.now() - c.dht._lastRandomPunch < c.dht._randomPunchInterval) {
        if (!c.relayToken)
          throw HOLEPUNCH_ABORTED();
        if (!delayed) {
          delayed = true;
          await updateHolepunch(c, serverAddress, clientRelay, {
            error: ERROR.NONE,
            firewall: c.puncher.nat.firewall,
            round: c.round++,
            connected: false,
            punching: false,
            addresses: c.puncher.nat.addresses,
            remoteAddress: null,
            token: c.payload.token(serverAddress),
            remoteToken
          });
          if (isDone(c))
            return;
        }
        await tryLater(c);
        if (isDone(c))
          return;
      }
    }
    if (isRandom)
      c.dht._randomPunches++;
    let reply;
    try {
      reply = await updateHolepunch(c, delayed ? serverRelay.peerAddress : serverAddress, delayed ? serverRelay.relayAddress : clientRelay, {
        error: ERROR.NONE,
        firewall: c.puncher.nat.firewall,
        round: c.round++,
        connected: false,
        punching: true,
        addresses: c.puncher.nat.addresses,
        remoteAddress: null,
        token: delayed ? null : c.payload.token(serverAddress),
        remoteToken
      });
    } finally {
      if (isRandom)
        c.dht._randomPunches--;
    }
    if (isDone(c))
      return;
    if (!reply)
      return;
    if (reply.tryLater) {
      await tryLater(c);
      if (isDone(c))
        return;
      return roundPunch(c, serverAddress, remoteToken, clientRelay, serverRelay, true);
    }
    if (!c.puncher.remoteHolepunching) {
      throw REMOTE_NOT_HOLEPUNCHING();
    }
    if (!await c.puncher.punch()) {
      throw REMOTE_NOT_HOLEPUNCHABLE();
    }
  }
  async function tryLater(c) {
    if (!c.relayToken)
      throw HOLEPUNCH_ABORTED();
    await c.sleeper.pause(1e4 + Math.round(Math.random() * 1e4));
  }
  function maybeDestroyEncryptedSocket(c, err) {
    if (isDone(c))
      return;
    if (c.encryptedSocket.rawStream)
      return;
    if (c.relaySocket)
      return;
    if (c.puncher && !c.puncher.destroyed)
      return;
    c.session.destroy();
    c.encryptedSocket.destroy(err);
  }
  async function abort(c, { peerAddress, relayAddress }, err) {
    try {
      await updateHolepunch(peerAddress, relayAddress, {
        error: ERROR.ABORTED,
        firewall: FIREWALL.UNKNOWN,
        round: c.round++,
        connected: false,
        punching: false,
        addresses: null,
        remoteAddress: null,
        token: null,
        remoteToken: null
      });
    } catch {}
    destroyPuncher(c);
    maybeDestroyEncryptedSocket(c, err);
  }
  function relayConnection(c, relayThrough, payload, hs) {
    let isInitiator;
    let publicKey;
    let token;
    if (payload.relayThrough) {
      isInitiator = false;
      publicKey = payload.relayThrough.publicKey;
      token = payload.relayThrough.token;
    } else {
      isInitiator = true;
      publicKey = relayThrough;
      token = c.relayToken;
    }
    c.relayToken = token;
    c.relaySocket = c.dht.connect(publicKey);
    c.relaySocket.setKeepAlive(c.relayKeepAlive);
    c.relayClient = relay.Client.from(c.relaySocket, { id: c.relaySocket.publicKey });
    c.relayTimeout = setTimeout(onabort, 15000, null);
    c.relayClient.pair(isInitiator, token, c.rawStream).on("error", onabort).on("data", ondata);
    function ondata(remoteId) {
      if (c.relayTimeout)
        clearRelayTimeout(c);
      if (c.rawStream === null) {
        onabort(null);
        return;
      }
      c.relayPaired = true;
      const {
        remotePort,
        remoteHost,
        socket
      } = c.relaySocket.rawStream;
      c.rawStream.on("close", () => c.relaySocket.destroy()).connect(socket, remoteId, remotePort, remoteHost);
      c.encryptedSocket.start(c.rawStream, { handshake: hs });
    }
    function onabort(err) {
      if (c.relayTimeout)
        clearRelayTimeout(c);
      const socket = c.relaySocket;
      c.relayToken = null;
      c.relaySocket = null;
      if (socket)
        socket.destroy();
      maybeDestroyEncryptedSocket(c, err || RELAY_ABORTED());
    }
  }
  function clearPassiveConnectTimeout(c) {
    clearTimeout(c.passiveConnectTimeout);
    c.passiveConnectTimeout = null;
  }
  function clearRelayTimeout(c) {
    clearTimeout(c.relayTimeout);
    c.relayTimeout = null;
  }
  function destroyPuncher(c) {
    if (c.puncher)
      c.puncher.destroy();
    c.session.destroy();
  }
  function pickServerRelay(relays, clientRelay) {
    for (const r of relays) {
      if (!diffAddress(r.relayAddress, clientRelay))
        return r;
    }
    return relays[0];
  }
  function diffAddress(a, b) {
    return a.host !== b.host || a.port !== b.port;
  }
  function defaultCreateHandshake(keyPair, remotePublicKey) {
    return new NoiseWrap(keyPair, remotePublicKey);
  }
  function defaultCreateSecretStream(isInitiator, rawStream, opts) {
    return new NoiseSecretStream(isInitiator, rawStream, opts);
  }
  function onlyPrivateHosts(addr) {
    return isPrivate(addr.host);
  }
  function isRelay(relaySocket, socket, port, host) {
    const stream = relaySocket.rawStream;
    if (!stream)
      return false;
    if (stream.socket !== socket)
      return false;
    return port === stream.remotePort && host === stream.remoteHost;
  }
  function selectRelay(relayThrough) {
    if (typeof relayThrough === "function")
      relayThrough = relayThrough();
    if (relayThrough === null)
      return null;
    if (Array.isArray(relayThrough))
      return relayThrough[Math.floor(Math.random() * relayThrough.length)];
    return relayThrough;
  }
  function noop() {}
});

// node_modules/hyperdht/lib/raw-stream-set.js
var require_raw_stream_set = __commonJS((exports, module) => {
  module.exports = class RawStreamSet {
    constructor(dht) {
      this._dht = dht;
      this._prefix = 16 - 1;
      this._streams = new Map;
    }
    add(opts) {
      const self = this;
      let id = 0;
      while (true) {
        id = Math.random() * 4294967296 >>> 0;
        if (this._streams.has(id & this._prefix))
          continue;
        break;
      }
      if (2 * this._streams.size >= this._prefix) {
        this._prefix = 2 * this._prefix + 1;
        const next = new Map;
        for (const stream2 of this._streams.values()) {
          next.set(stream2.id & this._prefix, stream2);
        }
        this._streams = next;
      }
      const stream = this._dht.udx.createStream(id, opts);
      this._streams.set(id & this._prefix, stream);
      stream.on("close", onclose);
      return stream;
      function onclose() {
        self._streams.delete(id & self._prefix);
      }
    }
    async clear() {
      const destroying = [];
      for (const stream of this._streams.values()) {
        destroying.push(new Promise((resolve) => stream.once("close", resolve).destroy()));
      }
      await Promise.allSettled(destroying);
    }
  };
});

// node_modules/hyperdht/lib/connection-pool.js
var require_connection_pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var b4a = require_b4a();
  var errors = require_errors5();
  module.exports = class ConnectionPool extends EventEmitter {
    constructor(dht) {
      super();
      this._dht = dht;
      this._servers = new Map;
      this._connecting = new Map;
      this._connections = new Map;
    }
    _attachServer(server) {
      const keyString = b4a.toString(server.publicKey, "hex");
      this._servers.set(keyString, server);
      server.on("close", () => {
        this._servers.delete(keyString);
      }).on("connection", (socket) => {
        this._attachStream(socket, true);
      });
    }
    _attachStream(stream, opened) {
      const existing = this.get(stream.remotePublicKey);
      if (existing) {
        const keepNew = stream.isInitiator === existing.isInitiator || b4a.compare(stream.publicKey, stream.remotePublicKey) > 0;
        if (keepNew) {
          let closed = false;
          const onclose = () => {
            closed = true;
          };
          existing.on("error", noop).on("close", () => {
            if (closed)
              return;
            stream.off("error", noop).off("close", onclose);
            this._attachStream(stream, opened);
          }).destroy(errors.DUPLICATE_CONNECTION());
          stream.on("error", noop).on("close", onclose);
        } else {
          stream.on("error", noop).destroy(errors.DUPLICATE_CONNECTION());
        }
        return;
      }
      const session = new ConnectionRef(this, stream);
      const keyString = b4a.toString(stream.remotePublicKey, "hex");
      if (opened) {
        this._connections.set(keyString, session);
        stream.on("close", () => {
          this._connections.delete(keyString);
        });
        this.emit("connection", stream, session);
      } else {
        this._connecting.set(keyString, session);
        stream.on("error", noop).on("close", () => {
          if (opened)
            this._connections.delete(keyString);
          else
            this._connecting.delete(keyString);
        }).on("open", () => {
          opened = true;
          this._connecting.delete(keyString);
          this._connections.set(keyString, session);
          stream.off("error", noop);
          this.emit("connection", stream, session);
        });
      }
      return session;
    }
    get connecting() {
      return this._connecting.size;
    }
    get connections() {
      return this._connections.values();
    }
    has(publicKey) {
      const keyString = b4a.toString(publicKey, "hex");
      return this._connections.has(keyString) || this._connecting.has(keyString);
    }
    get(publicKey) {
      const keyString = b4a.toString(publicKey, "hex");
      const existing = this._connections.get(keyString) || this._connecting.get(keyString);
      return existing?._stream || null;
    }
  };

  class ConnectionRef {
    constructor(pool, stream) {
      this._pool = pool;
      this._stream = stream;
      this._refs = 0;
    }
    active() {
      this._refs++;
    }
    inactive() {
      this._refs--;
    }
    release() {
      this._stream.destroy();
    }
  }
  function noop() {}
});

// node_modules/hyperdht/index.js
var require_hyperdht = __commonJS((exports, module) => {
  var DHT = require_dht_rpc();
  var sodium = require_sodium_native();
  var c = require_compact_encoding();
  var b4a = require_b4a();
  var safetyCatch = require_safety_catch();
  var m = require_messages5();
  var SocketPool = require_socket_pool();
  var Persistent = require_persistent();
  var Router = require_router();
  var Server = require_server();
  var connect = require_connect();
  var { FIREWALL, BOOTSTRAP_NODES, KNOWN_NODES, COMMANDS } = require_constants2();
  var { hash, createKeyPair } = require_crypto();
  var { decode } = require_hypercore_id_encoding();
  var RawStreamSet = require_raw_stream_set();
  var ConnectionPool = require_connection_pool();
  var { STREAM_NOT_CONNECTED } = require_errors5();

  class HyperDHT extends DHT {
    constructor(opts = {}) {
      const port = opts.port || 49737;
      const bootstrap = opts.bootstrap || BOOTSTRAP_NODES;
      const nodes = opts.nodes || KNOWN_NODES;
      super({ ...opts, port, bootstrap, nodes, filterNode });
      const { router, persistent } = defaultCacheOpts(opts);
      this.defaultKeyPair = opts.keyPair || createKeyPair(opts.seed);
      this.listening = new Set;
      this.connectionKeepAlive = opts.connectionKeepAlive === false ? 0 : opts.connectionKeepAlive || 5000;
      this.stats = { punches: { consistent: 0, random: 0, open: 0 }, ...this.stats };
      this._router = new Router(this, router);
      this._socketPool = new SocketPool(this, opts.host || "0.0.0.0");
      this._rawStreams = new RawStreamSet(this);
      this._persistent = null;
      this._validatedLocalAddresses = new Map;
      this._lastRandomPunch = 0;
      this._connectable = true;
      this._randomPunchInterval = opts.randomPunchInterval || 20000;
      this._randomPunches = 0;
      this._randomPunchLimit = 1;
      this.once("persistent", () => {
        this._persistent = new Persistent(this, persistent);
      });
      this.on("network-change", () => {
        for (const server of this.listening)
          server.refresh();
      });
      this.on("network-update", () => {
        if (!this.online)
          return;
        for (const server of this.listening)
          server.notifyOnline();
      });
    }
    connect(remotePublicKey, opts) {
      return connect(this, decode(remotePublicKey), opts);
    }
    createServer(opts, onconnection) {
      if (typeof opts === "function")
        return this.createServer({}, opts);
      if (opts && opts.onconnection)
        onconnection = opts.onconnection;
      const s = new Server(this, opts);
      if (onconnection)
        s.on("connection", onconnection);
      return s;
    }
    pool() {
      return new ConnectionPool(this);
    }
    async resume({ log = noop } = {}) {
      await super.resume({ log });
      const resuming = [];
      for (const server of this.listening)
        resuming.push(server.resume());
      log("Resuming hyperdht servers");
      await Promise.allSettled(resuming);
      log("Done, hyperdht fully resumed");
    }
    async suspend({ log = noop } = {}) {
      this._connectable = false;
      const suspending = [];
      for (const server of this.listening)
        suspending.push(server.suspend());
      log("Suspending all hyperdht servers");
      await Promise.allSettled(suspending);
      log("Done, clearing all raw streams");
      await this._rawStreams.clear();
      log("Done, suspending dht-rpc");
      await super.suspend({ log });
      log("Done, clearing raw streams again");
      await this._rawStreams.clear();
      log("Done, hyperdht fully suspended");
      this._connectable = true;
    }
    async destroy({ force = false } = {}) {
      if (!force) {
        const closing = [];
        for (const server of this.listening)
          closing.push(server.close());
        await Promise.allSettled(closing);
      }
      this._router.destroy();
      if (this._persistent)
        this._persistent.destroy();
      await this._rawStreams.clear();
      await this._socketPool.destroy();
      await super.destroy();
    }
    async validateLocalAddresses(addresses) {
      const list = [];
      const socks = [];
      const waiting = [];
      for (const addr of addresses) {
        const { host } = addr;
        if (this._validatedLocalAddresses.has(host)) {
          if (await this._validatedLocalAddresses.get(host)) {
            list.push(addr);
          }
          continue;
        }
        const sock = this.udx.createSocket();
        try {
          sock.bind(0, host);
        } catch {
          this._validatedLocalAddresses.set(host, Promise.resolve(false));
          continue;
        }
        socks.push(sock);
        const promise = new Promise((resolve) => {
          sock.on("message", () => resolve(true));
          setTimeout(() => resolve(false), 500);
          sock.trySend(b4a.alloc(1), sock.address().port, addr.host);
        });
        this._validatedLocalAddresses.set(host, promise);
        waiting.push(addr);
      }
      for (const addr of waiting) {
        const { host } = addr;
        if (this._validatedLocalAddresses.has(host)) {
          if (await this._validatedLocalAddresses.get(host)) {
            list.push(addr);
          }
          continue;
        }
      }
      for (const sock of socks)
        await sock.close();
      return list;
    }
    findPeer(publicKey, opts = {}) {
      const target = opts.hash === false ? publicKey : hash(publicKey);
      opts = { ...opts, map: mapFindPeer };
      return this.query({ target, command: COMMANDS.FIND_PEER, value: null }, opts);
    }
    lookup(target, opts = {}) {
      opts = { ...opts, map: mapLookup };
      return this.query({ target, command: COMMANDS.LOOKUP, value: null }, opts);
    }
    lookupAndUnannounce(target, keyPair, opts = {}) {
      const unannounces = [];
      const dht = this;
      const userCommit = opts.commit || noop;
      const signUnannounce = opts.signUnannounce || Persistent.signUnannounce;
      if (this._persistent !== null) {
        this._persistent.unannounce(target, keyPair.publicKey);
      }
      opts = { ...opts, map, commit };
      return this.query({ target, command: COMMANDS.LOOKUP, value: null }, opts);
      async function commit(reply, dht2, query) {
        await Promise.all(unannounces);
        return userCommit(reply, dht2, query);
      }
      function map(reply) {
        const data = mapLookup(reply);
        if (!data || !data.token)
          return data;
        let found = data.peers.length >= 20;
        for (let i = 0;!found && i < data.peers.length; i++) {
          found = b4a.equals(data.peers[i].publicKey, keyPair.publicKey);
        }
        if (!found)
          return data;
        if (!data.from.id)
          return data;
        unannounces.push(dht._requestUnannounce(keyPair, dht, target, data.token, data.from, signUnannounce).catch(safetyCatch));
        return data;
      }
    }
    unannounce(target, keyPair, opts = {}) {
      return this.lookupAndUnannounce(target, keyPair, opts).finished();
    }
    announce(target, keyPair, relayAddresses, opts = {}) {
      const signAnnounce = opts.signAnnounce || Persistent.signAnnounce;
      opts = { ...opts, commit };
      return opts.clear ? this.lookupAndUnannounce(target, keyPair, opts) : this.lookup(target, opts);
      function commit(reply, dht) {
        return dht._requestAnnounce(keyPair, dht, target, reply.token, reply.from, relayAddresses, signAnnounce);
      }
    }
    async immutableGet(target, opts = {}) {
      opts = { ...opts, map: mapImmutable };
      const query = this.query({ target, command: COMMANDS.IMMUTABLE_GET, value: null }, opts);
      const check = b4a.allocUnsafe(32);
      for await (const node of query) {
        const { value } = node;
        sodium.crypto_generichash(check, value);
        if (b4a.equals(check, target))
          return node;
      }
      return null;
    }
    async immutablePut(value, opts = {}) {
      const target = b4a.allocUnsafe(32);
      sodium.crypto_generichash(target, value);
      opts = {
        ...opts,
        map: mapImmutable,
        commit(reply, dht) {
          return dht.request({ token: reply.token, target, command: COMMANDS.IMMUTABLE_PUT, value }, reply.from);
        }
      };
      const query = this.query({ target, command: COMMANDS.IMMUTABLE_GET, value: null }, opts);
      await query.finished();
      return { hash: target, closestNodes: query.closestNodes };
    }
    async mutableGet(publicKey, opts = {}) {
      let refresh = opts.refresh || null;
      let signed = null;
      let result = null;
      opts = { ...opts, map: mapMutable, commit: refresh ? commit : null };
      const target = b4a.allocUnsafe(32);
      sodium.crypto_generichash(target, publicKey);
      const userSeq = opts.seq || 0;
      const query = this.query({ target, command: COMMANDS.MUTABLE_GET, value: c.encode(c.uint, userSeq) }, opts);
      const latest = opts.latest !== false;
      for await (const node of query) {
        if (result && node.seq <= result.seq)
          continue;
        if (node.seq < userSeq || !Persistent.verifyMutable(node.signature, node.seq, node.value, publicKey))
          continue;
        if (!latest)
          return node;
        if (!result || node.seq > result.seq)
          result = node;
      }
      return result;
      function commit(reply, dht) {
        if (!signed && result && refresh) {
          if (refresh(result)) {
            signed = c.encode(m.mutablePutRequest, {
              publicKey,
              seq: result.seq,
              value: result.value,
              signature: result.signature
            });
          } else {
            refresh = null;
          }
        }
        return signed ? dht.request({ token: reply.token, target, command: COMMANDS.MUTABLE_PUT, value: signed }, reply.from) : Promise.resolve(null);
      }
    }
    async mutablePut(keyPair, value, opts = {}) {
      const signMutable = opts.signMutable || Persistent.signMutable;
      const target = b4a.allocUnsafe(32);
      sodium.crypto_generichash(target, keyPair.publicKey);
      const seq = opts.seq || 0;
      const signature = await signMutable(seq, value, keyPair);
      const signed = c.encode(m.mutablePutRequest, {
        publicKey: keyPair.publicKey,
        seq,
        value,
        signature
      });
      opts = {
        ...opts,
        map: mapMutable,
        commit(reply, dht) {
          return dht.request({ token: reply.token, target, command: COMMANDS.MUTABLE_PUT, value: signed }, reply.from);
        }
      };
      const query = this.query({ target, command: COMMANDS.MUTABLE_GET, value: c.encode(c.uint, 0) }, opts);
      await query.finished();
      return { publicKey: keyPair.publicKey, closestNodes: query.closestNodes, seq, signature };
    }
    onrequest(req) {
      switch (req.command) {
        case COMMANDS.PEER_HANDSHAKE: {
          this._router.onpeerhandshake(req);
          return true;
        }
        case COMMANDS.PEER_HOLEPUNCH: {
          this._router.onpeerholepunch(req);
          return true;
        }
      }
      if (this._persistent === null)
        return false;
      switch (req.command) {
        case COMMANDS.FIND_PEER: {
          this._persistent.onfindpeer(req);
          return true;
        }
        case COMMANDS.LOOKUP: {
          this._persistent.onlookup(req);
          return true;
        }
        case COMMANDS.ANNOUNCE: {
          this._persistent.onannounce(req);
          return true;
        }
        case COMMANDS.UNANNOUNCE: {
          this._persistent.onunannounce(req);
          return true;
        }
        case COMMANDS.MUTABLE_PUT: {
          this._persistent.onmutableput(req);
          return true;
        }
        case COMMANDS.MUTABLE_GET: {
          this._persistent.onmutableget(req);
          return true;
        }
        case COMMANDS.IMMUTABLE_PUT: {
          this._persistent.onimmutableput(req);
          return true;
        }
        case COMMANDS.IMMUTABLE_GET: {
          this._persistent.onimmutableget(req);
          return true;
        }
      }
      return false;
    }
    static keyPair(seed) {
      return createKeyPair(seed);
    }
    static hash(data) {
      return hash(data);
    }
    static connectRawStream(encryptedStream, rawStream, remoteId) {
      const stream = encryptedStream.rawStream;
      if (!stream.connected)
        throw STREAM_NOT_CONNECTED();
      rawStream.connect(stream.socket, remoteId, stream.remotePort, stream.remoteHost);
    }
    createRawStream(opts) {
      return this._rawStreams.add(opts);
    }
    async _requestAnnounce(keyPair, dht, target, token, from, relayAddresses, sign) {
      const ann = {
        peer: {
          publicKey: keyPair.publicKey,
          relayAddresses: relayAddresses || []
        },
        refresh: null,
        signature: null
      };
      ann.signature = await sign(target, token, from.id, ann, keyPair);
      const value = c.encode(m.announce, ann);
      return dht.request({
        token,
        target,
        command: COMMANDS.ANNOUNCE,
        value
      }, from);
    }
    async _requestUnannounce(keyPair, dht, target, token, from, sign) {
      const unann = {
        peer: {
          publicKey: keyPair.publicKey,
          relayAddresses: []
        },
        signature: null
      };
      unann.signature = await sign(target, token, from.id, unann, keyPair);
      const value = c.encode(m.announce, unann);
      return dht.request({
        token,
        target,
        command: COMMANDS.UNANNOUNCE,
        value
      }, from);
    }
  }
  HyperDHT.BOOTSTRAP = BOOTSTRAP_NODES;
  HyperDHT.FIREWALL = FIREWALL;
  module.exports = HyperDHT;
  function mapLookup(node) {
    if (!node.value)
      return null;
    try {
      return {
        token: node.token,
        from: node.from,
        to: node.to,
        peers: c.decode(m.peers, node.value)
      };
    } catch {
      return null;
    }
  }
  function mapFindPeer(node) {
    if (!node.value)
      return null;
    try {
      return {
        token: node.token,
        from: node.from,
        to: node.to,
        peer: c.decode(m.peer, node.value)
      };
    } catch {
      return null;
    }
  }
  function mapImmutable(node) {
    if (!node.value)
      return null;
    return {
      token: node.token,
      from: node.from,
      to: node.to,
      value: node.value
    };
  }
  function mapMutable(node) {
    if (!node.value)
      return null;
    try {
      const { seq, value, signature } = c.decode(m.mutableGetResponse, node.value);
      return {
        token: node.token,
        from: node.from,
        to: node.to,
        seq,
        value,
        signature
      };
    } catch {
      return null;
    }
  }
  function noop() {}
  function filterNode(node) {
    return !(node.port === 49738 && (node.host === "134.209.28.98" || node.host === "167.99.142.185")) && !(node.port === 9400 && node.host === "35.233.47.252") && !(node.host === "150.136.142.116");
  }
  var defaultMaxSize = 65536;
  var defaultMaxAge = 20 * 60 * 1000;
  function defaultCacheOpts(opts) {
    const maxSize = opts.maxSize || defaultMaxSize;
    const maxAge = opts.maxAge || defaultMaxAge;
    return {
      router: {
        forwards: { maxSize, maxAge }
      },
      persistent: {
        records: { maxSize, maxAge },
        refreshes: { maxSize, maxAge },
        mutables: {
          maxSize: maxSize / 2 | 0,
          maxAge: opts.maxAge || 48 * 60 * 60 * 1000
        },
        immutables: {
          maxSize: maxSize / 2 | 0,
          maxAge: opts.maxAge || 48 * 60 * 60 * 1000
        }
      }
    };
  }
});

// node_modules/unordered-set/index.js
var require_unordered_set = __commonJS((exports) => {
  exports.add = add;
  exports.has = has;
  exports.remove = remove;
  exports.swap = swap;
  function add(list, item) {
    if (has(list, item))
      return item;
    item._index = list.length;
    list.push(item);
    return item;
  }
  function has(list, item) {
    return item._index < list.length && list[item._index] === item;
  }
  function remove(list, item) {
    if (!has(list, item))
      return null;
    var last = list.pop();
    if (last !== item) {
      list[item._index] = last;
      last._index = item._index;
    }
    return item;
  }
  function swap(list, a, b) {
    if (!has(list, a) || !has(list, b))
      return;
    var tmp = a._index;
    a._index = b._index;
    list[a._index] = a;
    b._index = tmp;
    list[b._index] = b;
  }
});

// node_modules/shuffled-priority-queue/index.js
var require_shuffled_priority_queue = __commonJS((exports, module) => {
  var set = require_unordered_set();
  module.exports = (opts) => new ShuffledPriorityQueue(opts);

  class ShuffledPriorityQueue {
    constructor(opts) {
      this.priorities = [];
      this.equals = opts && opts.equals || null;
    }
    get length() {
      return this.priorities.reduce(add, 0);
    }
    [Symbol.iterator]() {
      return new Iterator(this);
    }
    head() {
      for (let i = this.priorities.length - 1;i >= 0; i--) {
        const q = this.priorities[i];
        if (q.length)
          return shuffle(q, 0);
      }
      return null;
    }
    tail() {
      for (let i = 0;i < this.priorities.length; i++) {
        const q = this.priorities[i];
        if (q.length)
          return shuffle(q, 0);
      }
      return null;
    }
    prev(prev) {
      if (!prev)
        return this.tail();
      return next(this.priorities, prev, 1);
    }
    next(prev) {
      if (!prev)
        return this.head();
      return next(this.priorities, prev, -1);
    }
    shift() {
      return this.remove(this.head());
    }
    pop() {
      return this.remove(this.tail());
    }
    add(val) {
      const prio = val.priority || 0;
      while (prio >= this.priorities.length)
        this.priorities.push([]);
      set.add(this.priorities[prio], val);
      return val;
    }
    remove(val) {
      if (!val)
        return null;
      if (val._index === undefined) {
        val = this.find(val);
        if (!val)
          return null;
      }
      return set.remove(this.priorities[val.priority || 0], val);
    }
    has(val) {
      if (val._index === undefined)
        return this.find(val);
      const priority = val.priority || 0;
      if (priority >= this.priorities.length)
        return false;
      return set.has(this.priorities[priority], val);
    }
    find(val) {
      if (val._index !== undefined)
        return val;
      const prio = val.priority || 0;
      const qs = this.priorities;
      if (prio >= qs.length)
        return null;
      const q = qs[prio];
      for (let i = 0;i < q.length; i++) {
        if (this.equals(q[i], val))
          return q[i];
      }
      return null;
    }
  }

  class Iterator {
    constructor(queue) {
      this.prev = null;
      this.queue = queue;
    }
    next() {
      const next2 = this.queue.next(this.prev);
      this.prev = next2;
      return { done: !next2, value: next2 };
    }
  }
  function shuffle(q, i) {
    const ran = i + Math.floor(Math.random() * (q.length - i));
    set.swap(q, q[ran], q[i]);
    return q[i];
  }
  function next(queues, prev, inc) {
    let i = prev.priority || 0;
    let j = (prev._index || 0) + 1;
    while (true) {
      if (i < 0 || i >= queues.length)
        return null;
      const q = queues[i];
      if (j >= q.length) {
        i += inc;
        j = 0;
        continue;
      }
      return shuffle(q, j);
    }
  }
  function add(len, b) {
    return len + b.length;
  }
});

// node_modules/hyperswarm/lib/peer-info.js
var require_peer_info = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var b4a = require_b4a();
  var unslab = require_unslab();
  var MIN_CONNECTION_TIME = 15000;
  var VERY_LOW_PRIORITY = 0;
  var LOW_PRIORITY = 1;
  var NORMAL_PRIORITY = 2;
  var HIGH_PRIORITY = 3;
  var VERY_HIGH_PRIORITY = 4;
  module.exports = class PeerInfo extends EventEmitter {
    constructor({ publicKey, relayAddresses }) {
      super();
      this.publicKey = unslab(publicKey);
      this.relayAddresses = relayAddresses;
      this.reconnecting = true;
      this.proven = false;
      this.connectedTime = -1;
      this.disconnectedTime = 0;
      this.banned = false;
      this.tried = false;
      this.explicit = false;
      this.waiting = false;
      this.forceRelaying = false;
      this.queued = false;
      this.client = false;
      this.topics = [];
      this.attempts = 0;
      this.priority = NORMAL_PRIORITY;
      this._index = 0;
      this._flushTick = 0;
      this._seenTopics = new Set;
    }
    get server() {
      return !this.client;
    }
    get prioritized() {
      return this.priority >= NORMAL_PRIORITY;
    }
    _getPriority() {
      const peerIsStale = this.tried && !this.proven;
      if (peerIsStale || this.attempts > 3)
        return VERY_LOW_PRIORITY;
      if (this.attempts === 3)
        return LOW_PRIORITY;
      if (this.attempts === 2)
        return HIGH_PRIORITY;
      if (this.attempts === 1)
        return VERY_HIGH_PRIORITY;
      return NORMAL_PRIORITY;
    }
    _connected() {
      this.proven = true;
      this.connectedTime = Date.now();
    }
    _disconnected() {
      this.disconnectedTime = Date.now();
      if (this.connectedTime > -1) {
        if (this.disconnectedTime - this.connectedTime >= MIN_CONNECTION_TIME)
          this.attempts = 0;
        this.connectedTime = -1;
      }
      this.attempts++;
    }
    _deprioritize() {
      this.attempts = 3;
    }
    _reset() {
      this.client = false;
      this.proven = false;
      this.tried = false;
      this.attempts = 0;
    }
    _updatePriority() {
      if (this.explicit && this.attempts > 3)
        this._deprioritize();
      if (this.banned || this.queued || this.attempts > 3)
        return false;
      this.priority = this._getPriority();
      return true;
    }
    _topic(topic) {
      const topicString = b4a.toString(topic, "hex");
      if (this._seenTopics.has(topicString))
        return;
      this._seenTopics.add(topicString);
      this.topics.push(topic);
      this.emit("topic", topic);
    }
    reconnect(val) {
      this.reconnecting = !!val;
    }
    ban(val) {
      this.banned = !!val;
    }
    shouldGC() {
      return !(this.banned || this.queued || this.explicit || this.waiting);
    }
  };
});

// node_modules/hyperswarm/lib/bulk-timer.js
var require_bulk_timer = __commonJS((exports, module) => {
  module.exports = class BulkTimer {
    constructor(time, fn) {
      this._time = time;
      this._fn = fn;
      this._interval = null;
      this._next = [];
      this._pending = [];
      this._destroyed = false;
    }
    destroy() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      clearInterval(this._interval);
      this._interval = null;
    }
    _ontick() {
      if (!this._next.length && !this._pending.length)
        return;
      if (this._next.length)
        this._fn(this._next);
      this._next = this._pending;
      this._pending = [];
    }
    add(info) {
      if (this._destroyed)
        return;
      if (!this._interval) {
        this._interval = setInterval(this._ontick.bind(this), Math.floor(this._time * 0.66));
      }
      this._pending.push(info);
    }
  };
});

// node_modules/hyperswarm/lib/retry-timer.js
var require_retry_timer = __commonJS((exports, module) => {
  var BulkTimer = require_bulk_timer();
  var BACKOFF_JITTER = 500;
  var BACKOFF_S = 1000 + Math.round(BACKOFF_JITTER * Math.random());
  var BACKOFF_M = 5000 + Math.round(2 * BACKOFF_JITTER * Math.random());
  var BACKOFF_L = 15000 + Math.round(4 * BACKOFF_JITTER * Math.random());
  var BACKOFF_X = 1000 * 60 * 10 + Math.round(240 * BACKOFF_JITTER * Math.random());
  module.exports = class RetryTimer {
    constructor(push, { backoffs = [BACKOFF_S, BACKOFF_M, BACKOFF_L, BACKOFF_X], jitter = BACKOFF_JITTER } = {}) {
      this.jitter = jitter;
      this.backoffs = backoffs;
      this._sTimer = new BulkTimer(backoffs[0] + Math.round(jitter * Math.random()), push);
      this._mTimer = new BulkTimer(backoffs[1] + Math.round(jitter * Math.random()), push);
      this._lTimer = new BulkTimer(backoffs[2] + Math.round(jitter * Math.random()), push);
      this._xTimer = new BulkTimer(backoffs[3] + Math.round(jitter * Math.random()), push);
    }
    _selectRetryTimer(peerInfo) {
      if (peerInfo.banned || !peerInfo.reconnecting)
        return null;
      if (peerInfo.attempts > 3) {
        return peerInfo.explicit ? this._xTimer : null;
      }
      if (peerInfo.attempts === 0)
        return this._sTimer;
      if (peerInfo.proven) {
        switch (peerInfo.attempts) {
          case 1:
            return this._sTimer;
          case 2:
            return this._mTimer;
          case 3:
            return this._lTimer;
        }
      } else {
        switch (peerInfo.attempts) {
          case 1:
            return this._mTimer;
          case 2:
            return this._lTimer;
          case 3:
            return this._lTimer;
        }
      }
      return null;
    }
    add(peerInfo) {
      const timer = this._selectRetryTimer(peerInfo);
      if (!timer)
        return false;
      timer.add(peerInfo);
      return true;
    }
    destroy() {
      this._sTimer.destroy();
      this._mTimer.destroy();
      this._lTimer.destroy();
      this._xTimer.destroy();
    }
  };
});

// node_modules/hyperswarm/lib/connection-set.js
var require_connection_set = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class ConnectionSet {
    constructor() {
      this._byPublicKey = new Map;
    }
    [Symbol.iterator]() {
      return this._byPublicKey.values();
    }
    get size() {
      return this._byPublicKey.size;
    }
    has(publicKey) {
      return this._byPublicKey.has(b4a.toString(publicKey, "hex"));
    }
    get(publicKey) {
      return this._byPublicKey.get(b4a.toString(publicKey, "hex"));
    }
    add(connection) {
      this._byPublicKey.set(b4a.toString(connection.remotePublicKey, "hex"), connection);
    }
    delete(connection) {
      const keyString = b4a.toString(connection.remotePublicKey, "hex");
      const existing = this._byPublicKey.get(keyString);
      if (existing !== connection)
        return;
      this._byPublicKey.delete(keyString);
    }
  };
});

// node_modules/hyperswarm/lib/peer-discovery.js
var require_peer_discovery = __commonJS((exports, module) => {
  var safetyCatch = require_safety_catch();
  var b4a = require_b4a();
  var REFRESH_INTERVAL = 1000 * 60 * 10;
  var RANDOM_JITTER = 1000 * 60 * 2;
  var DELAY_GRACE_PERIOD = 1000 * 30;
  module.exports = class PeerDiscovery {
    constructor(swarm, topic, { limit = Infinity, wait = null, suspended = false, onpeer = noop, onerror = safetyCatch }) {
      this.limit = limit;
      this.swarm = swarm;
      this.topic = topic;
      this.isClient = false;
      this.isServer = false;
      this.destroyed = false;
      this.destroying = null;
      this.suspended = suspended;
      this._sessions = [];
      this._clientSessions = 0;
      this._serverSessions = 0;
      this._onpeer = onpeer;
      this._onerror = onerror;
      this._activeQuery = null;
      this._timer = null;
      this._currentRefresh = null;
      this._closestNodes = null;
      this._firstAnnounce = true;
      this._needsUnannounce = false;
      this._refreshes = 0;
      this._wait = wait;
    }
    session({ server = true, client = true, limit = Infinity, onerror = safetyCatch }) {
      if (this.destroyed)
        throw new Error("PeerDiscovery is destroyed");
      const session = new PeerDiscoverySession(this);
      session.refresh({ server, client, limit }).catch(onerror);
      this._sessions.push(session);
      return session;
    }
    _refreshLater(eager) {
      const jitter = Math.round(Math.random() * RANDOM_JITTER);
      const delay = !eager ? REFRESH_INTERVAL + jitter : jitter;
      if (this._timer)
        clearTimeout(this._timer);
      const startTime = Date.now();
      this._timer = setTimeout(() => {
        const overdue = Date.now() - startTime > delay + DELAY_GRACE_PERIOD;
        if (overdue)
          this._refreshLater(true);
        else
          this.refresh().catch(this._onerror);
      }, delay);
    }
    _isActive() {
      return !this.destroyed && !this.suspended;
    }
    async _refresh() {
      if (this.suspended)
        return;
      const clock = ++this._refreshes;
      if (this._wait) {
        await this._wait;
        this._wait = null;
        if (clock !== this._refreshes || !this._isActive())
          return;
      }
      const clear = this.isServer && this._firstAnnounce;
      if (clear)
        this._firstAnnounce = false;
      const opts = {
        clear,
        closestNodes: this._closestNodes
      };
      if (this.isServer) {
        await this.swarm.listen();
        if (clock !== this._refreshes || !this._isActive())
          return;
        this._needsUnannounce = true;
      }
      const announcing = this.isServer;
      const query = this._activeQuery = announcing ? this.swarm.dht.announce(this.topic, this.swarm.keyPair, this.swarm.server.relayAddresses, opts) : this._needsUnannounce ? this.swarm.dht.lookupAndUnannounce(this.topic, this.swarm.keyPair, opts) : this.swarm.dht.lookup(this.topic, opts);
      try {
        for await (const data of this._activeQuery) {
          if (!this.isClient || !this._isActive())
            continue;
          for (const peer of data.peers) {
            if (this.limit === 0)
              return;
            this.limit--;
            this._onpeer(peer, data);
          }
        }
      } catch (err) {
        if (this._isActive())
          throw err;
      } finally {
        if (this._activeQuery === query) {
          this._activeQuery = null;
          if (!this.destroyed && !this.suspended)
            this._refreshLater(false);
        }
      }
      this._closestNodes = query.closestNodes;
      if (clock !== this._refreshes)
        return;
      if (!announcing)
        this._needsUnannounce = false;
    }
    async refresh() {
      if (this.destroyed)
        throw new Error("PeerDiscovery is destroyed");
      const server = this._serverSessions > 0;
      const client = this._clientSessions > 0;
      if (this.suspended)
        return;
      if (server === this.isServer && client === this.isClient) {
        if (this._currentRefresh)
          return this._currentRefresh;
        this._currentRefresh = this._refresh();
      } else {
        if (this._activeQuery)
          this._activeQuery.destroy();
        this.isServer = server;
        this.isClient = client;
        this._currentRefresh = this._refresh();
      }
      const refresh = this._currentRefresh;
      try {
        await refresh;
      } catch {
        return false;
      } finally {
        if (refresh === this._currentRefresh) {
          this._currentRefresh = null;
        }
      }
      return true;
    }
    async flushed() {
      if (this.swarm.listening)
        await this.swarm.listening;
      try {
        await this._currentRefresh;
        return true;
      } catch {
        return false;
      }
    }
    async _destroyMaybe() {
      if (this.destroyed)
        return;
      try {
        if (this._sessions.length === 0)
          await this.swarm.leave(this.topic);
        else if (this._serverSessions === 0 && this._needsUnannounce)
          await this.refresh();
      } catch (err) {
        safetyCatch(err);
      }
    }
    destroy() {
      if (this.destroying)
        return this.destroying;
      this.destroying = this._destroy();
      return this.destroying;
    }
    async _abort(log) {
      const id = log === noop ? "" : b4a.toString(this.topic, "hex");
      log("Aborting discovery", id);
      if (this._wait)
        await this._wait;
      log("Aborting discovery (post wait)", id);
      if (this._activeQuery) {
        this._activeQuery.destroy();
        this._activeQuery = null;
      }
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      let nodes = this._closestNodes;
      if (this._currentRefresh) {
        try {
          await this._currentRefresh;
        } catch {}
      }
      log("Aborting discovery (post refresh)", id);
      if (this._isActive())
        return;
      if (!nodes)
        nodes = this._closestNodes;
      else if (this._closestNodes !== nodes) {
        const len = nodes.length;
        for (const newer of this._closestNodes) {
          if (newer.id && !hasNode(nodes, len, newer))
            nodes.push(newer);
        }
      }
      if (this._needsUnannounce) {
        log("Unannouncing discovery", id);
        if (nodes && nodes.length)
          await this.swarm.dht.unannounce(this.topic, this.swarm.keyPair, { closestNodes: nodes, onlyClosestNodes: true, force: true });
        this._needsUnannounce = false;
        log("Unannouncing discovery (done)", id);
      }
    }
    _destroy() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      return this._abort(noop);
    }
    async suspend({ log = noop } = {}) {
      if (this.suspended)
        return;
      this.suspended = true;
      try {
        await this._abort(log);
      } catch {}
    }
    resume() {
      if (!this.suspended)
        return;
      this.suspended = false;
      this.refresh().catch(noop);
    }
  };

  class PeerDiscoverySession {
    constructor(discovery) {
      this.discovery = discovery;
      this.isClient = false;
      this.isServer = false;
      this.destroyed = false;
    }
    get swarm() {
      return this.discovery.swarm;
    }
    get topic() {
      return this.discovery.topic;
    }
    async refresh({ client = this.isClient, server = this.isServer, limit = Infinity } = {}) {
      if (this.destroyed)
        throw new Error("PeerDiscovery is destroyed");
      if (!client && !server)
        throw new Error("Cannot refresh with neither client nor server option");
      if (client !== this.isClient) {
        this.isClient = client;
        this.discovery._clientSessions += client ? 1 : -1;
      }
      if (server !== this.isServer) {
        this.isServer = server;
        this.discovery._serverSessions += server ? 1 : -1;
      }
      this.discovery.limit = limit;
      return this.discovery.refresh();
    }
    async flushed() {
      return this.discovery.flushed();
    }
    async destroy() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      if (this.isClient)
        this.discovery._clientSessions--;
      if (this.isServer)
        this.discovery._serverSessions--;
      const index = this.discovery._sessions.indexOf(this);
      const head = this.discovery._sessions.pop();
      if (head !== this)
        this.discovery._sessions[index] = head;
      return this.discovery._destroyMaybe();
    }
  }
  function hasNode(nodes, len, node) {
    for (let i = 0;i < len; i++) {
      const existing = nodes[i];
      if (existing.id && b4a.equals(existing.id, node.id))
        return true;
    }
    return false;
  }
  function noop() {}
});

// node_modules/hyperswarm/index.js
var require_hyperswarm = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var DHT = require_hyperdht();
  var spq = require_shuffled_priority_queue();
  var b4a = require_b4a();
  var unslab = require_unslab();
  var PeerInfo = require_peer_info();
  var RetryTimer = require_retry_timer();
  var ConnectionSet = require_connection_set();
  var PeerDiscovery = require_peer_discovery();
  var MAX_PEERS = 64;
  var MAX_PARALLEL = 3;
  var MAX_CLIENT_CONNECTIONS = Infinity;
  var MAX_SERVER_CONNECTIONS = Infinity;
  var ERR_MISSING_TOPIC = "Topic is required and must be a 32-byte buffer";
  var ERR_DESTROYED = "Swarm has been destroyed";
  var ERR_DUPLICATE = "Duplicate connection";
  module.exports = class Hyperswarm extends EventEmitter {
    constructor(opts = {}) {
      super();
      const {
        seed,
        relayThrough,
        keyPair = DHT.keyPair(seed),
        maxPeers = MAX_PEERS,
        maxClientConnections = MAX_CLIENT_CONNECTIONS,
        maxServerConnections = MAX_SERVER_CONNECTIONS,
        maxParallel = MAX_PARALLEL,
        firewall = allowAll
      } = opts;
      this.keyPair = keyPair;
      this.dht = opts.dht || new DHT({
        bootstrap: opts.bootstrap,
        nodes: opts.nodes,
        port: opts.port
      });
      this.server = this.dht.createServer({
        firewall: this._handleFirewall.bind(this),
        relayThrough: this._maybeRelayConnection.bind(this)
      }, this._handleServerConnection.bind(this));
      this.destroyed = false;
      this.suspended = false;
      this.maxPeers = maxPeers;
      this.maxClientConnections = maxClientConnections;
      this.maxServerConnections = maxServerConnections;
      this.maxParallel = maxParallel;
      this.relayThrough = relayThrough || null;
      this.connecting = 0;
      this.connections = new Set;
      this.peers = new Map;
      this.explicitPeers = new Set;
      this.listening = null;
      this.stats = {
        updates: 0,
        connects: {
          client: {
            opened: 0,
            closed: 0,
            attempted: 0
          },
          server: {
            opened: 0,
            closed: 0
          }
        }
      };
      this._discovery = new Map;
      this._timer = new RetryTimer(this._requeue.bind(this), {
        backoffs: opts.backoffs,
        jitter: opts.jitter
      });
      this._queue = spq();
      this._allConnections = new ConnectionSet;
      this._pendingFlushes = [];
      this._flushTick = 0;
      this._drainingQueue = false;
      this._clientConnections = 0;
      this._serverConnections = 0;
      this._firewall = firewall;
      this.dht.on("network-change", this._handleNetworkChange.bind(this));
      this.on("update", this._handleUpdate);
    }
    _maybeRelayConnection(force) {
      if (!this.relayThrough)
        return null;
      return this.relayThrough(force);
    }
    _enqueue(peerInfo) {
      if (peerInfo.queued)
        return;
      peerInfo.queued = true;
      peerInfo._flushTick = this._flushTick;
      this._queue.add(peerInfo);
      this._attemptClientConnections();
    }
    _requeue(batch) {
      if (this.suspended)
        return;
      for (const peerInfo of batch) {
        peerInfo.waiting = false;
        if (peerInfo._updatePriority() === false || this._allConnections.has(peerInfo.publicKey) || peerInfo.queued)
          continue;
        peerInfo.queued = true;
        peerInfo._flushTick = this._flushTick;
        this._queue.add(peerInfo);
      }
      this._attemptClientConnections();
    }
    _flushMaybe(peerInfo) {
      for (let i = 0;i < this._pendingFlushes.length; i++) {
        const flush = this._pendingFlushes[i];
        if (peerInfo._flushTick > flush.tick)
          continue;
        if (--flush.missing > 0)
          continue;
        flush.onflush(true);
        this._pendingFlushes.splice(i--, 1);
      }
    }
    _flushAllMaybe() {
      if (this.connecting > 0 || this._allConnections.size < this.maxPeers && this._clientConnections < this.maxClientConnections) {
        return false;
      }
      while (this._pendingFlushes.length) {
        const flush = this._pendingFlushes.pop();
        flush.onflush(true);
      }
      return true;
    }
    _shouldConnectExplicit() {
      return !this.destroyed && !this.suspended && this.connecting < this.maxParallel;
    }
    _shouldConnect() {
      return !this.destroyed && !this.suspended && this.connecting < this.maxParallel && this._allConnections.size < this.maxPeers && this._clientConnections < this.maxClientConnections;
    }
    _shouldRequeue(peerInfo) {
      if (this.suspended)
        return false;
      if (peerInfo.explicit)
        return true;
      for (const topic of peerInfo.topics) {
        if (this._discovery.has(b4a.toString(topic, "hex")) && !this.destroyed) {
          return true;
        }
      }
      return false;
    }
    _connect(peerInfo, queued) {
      if (peerInfo.banned || this._allConnections.has(peerInfo.publicKey)) {
        if (queued)
          this._flushMaybe(peerInfo);
        return;
      }
      if (this._handleFirewall(peerInfo.publicKey, null)) {
        peerInfo.ban(true);
        if (queued)
          this._flushMaybe(peerInfo);
        return;
      }
      const relayThrough = this._maybeRelayConnection(peerInfo.forceRelaying);
      const conn = this.dht.connect(peerInfo.publicKey, {
        relayAddresses: peerInfo.relayAddresses,
        keyPair: this.keyPair,
        relayThrough
      });
      this._allConnections.add(conn);
      this.stats.connects.client.attempted++;
      this.connecting++;
      this._clientConnections++;
      let opened = false;
      const onerror = (err) => {
        if (this.relayThrough && shouldForceRelaying(err.code)) {
          peerInfo.forceRelaying = true;
          peerInfo.attempts = 0;
        }
      };
      conn.on("error", onerror);
      conn.on("open", () => {
        opened = true;
        this.stats.connects.client.opened++;
        this._connectDone();
        this.connections.add(conn);
        conn.removeListener("error", onerror);
        peerInfo._connected();
        peerInfo.client = true;
        this.emit("connection", conn, peerInfo);
        if (queued)
          this._flushMaybe(peerInfo);
        this.emit("update");
      });
      conn.on("close", () => {
        if (!opened)
          this._connectDone();
        this.stats.connects.client.closed++;
        this.connections.delete(conn);
        this._allConnections.delete(conn);
        this._clientConnections--;
        peerInfo._disconnected();
        peerInfo.waiting = this._shouldRequeue(peerInfo) && this._timer.add(peerInfo);
        this._maybeDeletePeer(peerInfo);
        if (!opened && queued)
          this._flushMaybe(peerInfo);
        this._attemptClientConnections();
        this.emit("update");
      });
      this.emit("update");
    }
    _connectDone() {
      this.connecting--;
      if (this.connecting < this.maxParallel)
        this._attemptClientConnections();
      if (this.connecting === 0)
        this._flushAllMaybe();
    }
    _attemptClientConnections() {
      if (this._drainingQueue)
        return;
      this._drainingQueue = true;
      for (const peerInfo of this.explicitPeers) {
        if (!this._shouldConnectExplicit())
          break;
        if (peerInfo.attempts >= 5 || Date.now() - peerInfo.disconnectedTime < peerInfo.attempts * 1000)
          continue;
        this._connect(peerInfo, false);
      }
      while (this._queue.length && this._shouldConnect()) {
        const peerInfo = this._queue.shift();
        peerInfo.queued = false;
        this._connect(peerInfo, true);
      }
      this._drainingQueue = false;
      if (this.connecting === 0)
        this._flushAllMaybe();
    }
    _handleFirewall(remotePublicKey, payload) {
      if (this.suspended)
        return true;
      if (b4a.equals(remotePublicKey, this.keyPair.publicKey))
        return true;
      const peerInfo = this.peers.get(b4a.toString(remotePublicKey, "hex"));
      if (peerInfo && peerInfo.banned)
        return true;
      return this._firewall(remotePublicKey, payload);
    }
    _handleServerConnectionSwap(existing, conn) {
      let closed = false;
      existing.on("close", () => {
        if (closed)
          return;
        conn.removeListener("error", noop);
        conn.removeListener("close", onclose);
        this._handleServerConnection(conn);
      });
      conn.on("error", noop);
      conn.on("close", onclose);
      function onclose() {
        closed = true;
      }
    }
    _handleServerConnection(conn) {
      if (this.destroyed || this.suspended) {
        conn.on("error", noop);
        return conn.destroy(ERR_DESTROYED);
      }
      const existing = this._allConnections.get(conn.remotePublicKey);
      if (existing) {
        const existingIsOutdated = existing.rawBytesRead > 0 && existing.rawBytesWritten > 0;
        const expectedInitiator = b4a.compare(conn.publicKey, conn.remotePublicKey) > 0;
        const keepNew = existingIsOutdated || expectedInitiator === conn.isInitiator;
        if (keepNew === false) {
          existing.sendKeepAlive();
          conn.on("error", noop);
          conn.destroy(new Error(ERR_DUPLICATE));
          return;
        }
        existing.on("error", noop);
        existing.destroy(new Error(ERR_DUPLICATE));
        this._handleServerConnectionSwap(existing, conn);
        return;
      }
      this.stats.connects.server.opened++;
      const peerInfo = this._upsertPeer(conn.remotePublicKey, null);
      this.connections.add(conn);
      this._allConnections.add(conn);
      this._serverConnections++;
      conn.on("close", () => {
        this.connections.delete(conn);
        this._allConnections.delete(conn);
        this._serverConnections--;
        this.stats.connects.server.closed++;
        this._maybeDeletePeer(peerInfo);
        this._attemptClientConnections();
        this.emit("update");
      });
      peerInfo.client = false;
      this.emit("connection", conn, peerInfo);
      this.emit("update");
    }
    _upsertPeer(publicKey, relayAddresses) {
      if (b4a.equals(publicKey, this.keyPair.publicKey))
        return null;
      const keyString = b4a.toString(publicKey, "hex");
      let peerInfo = this.peers.get(keyString);
      if (peerInfo) {
        peerInfo.relayAddresses = relayAddresses;
        return peerInfo;
      }
      peerInfo = new PeerInfo({
        publicKey,
        relayAddresses
      });
      this.peers.set(keyString, peerInfo);
      return peerInfo;
    }
    _handleUpdate() {
      this.stats.updates++;
    }
    _maybeDeletePeer(peerInfo) {
      if (!peerInfo.shouldGC())
        return;
      const hasActiveConn = this._allConnections.has(peerInfo.publicKey);
      if (hasActiveConn)
        return;
      const keyString = b4a.toString(peerInfo.publicKey, "hex");
      this.peers.delete(keyString);
    }
    _handlePeer(peer, topic) {
      const peerInfo = this._upsertPeer(peer.publicKey, peer.relayAddresses);
      if (peerInfo)
        peerInfo._topic(topic);
      if (!peerInfo || this._allConnections.has(peer.publicKey))
        return;
      if (!peerInfo.prioritized || peerInfo.server)
        peerInfo._reset();
      if (peerInfo._updatePriority()) {
        this._enqueue(peerInfo);
      }
    }
    async _handleNetworkChange() {
      for (const conn of this._allConnections) {
        conn.sendKeepAlive();
      }
      const refreshes = [];
      for (const discovery of this._discovery.values()) {
        refreshes.push(discovery.refresh());
      }
      await Promise.allSettled(refreshes);
    }
    status(key) {
      return this._discovery.get(b4a.toString(key, "hex")) || null;
    }
    listen() {
      if (!this.listening)
        this.listening = this.server.listen(this.keyPair);
      return this.listening;
    }
    join(topic, opts = {}) {
      if (!topic)
        throw new Error(ERR_MISSING_TOPIC);
      topic = unslab(topic);
      const topicString = b4a.toString(topic, "hex");
      let discovery = this._discovery.get(topicString);
      if (discovery && !discovery.destroyed) {
        return discovery.session(opts);
      }
      discovery = new PeerDiscovery(this, topic, {
        limit: opts.limit,
        wait: discovery ? discovery.destroy() : null,
        suspended: this.suspended,
        onpeer: (peer) => this._handlePeer(peer, topic)
      });
      this._discovery.set(topicString, discovery);
      return discovery.session(opts);
    }
    async leave(topic) {
      if (!topic)
        throw new Error(ERR_MISSING_TOPIC);
      const topicString = b4a.toString(topic, "hex");
      if (!this._discovery.has(topicString))
        return Promise.resolve();
      const discovery = this._discovery.get(topicString);
      try {
        await discovery.destroy();
      } catch {}
      if (this._discovery.get(topicString) === discovery) {
        this._discovery.delete(topicString);
      }
    }
    joinPeer(publicKey) {
      const peerInfo = this._upsertPeer(publicKey, null);
      if (!peerInfo)
        return;
      if (!this.explicitPeers.has(peerInfo)) {
        peerInfo.explicit = true;
        this.explicitPeers.add(peerInfo);
      }
      if (this._allConnections.has(publicKey))
        return;
      if (peerInfo._updatePriority()) {
        this._enqueue(peerInfo);
      }
    }
    leavePeer(publicKey) {
      const keyString = b4a.toString(publicKey, "hex");
      if (!this.peers.has(keyString))
        return;
      const peerInfo = this.peers.get(keyString);
      peerInfo.explicit = false;
      this.explicitPeers.delete(peerInfo);
      this._maybeDeletePeer(peerInfo);
    }
    async flush() {
      const allFlushed = [...this._discovery.values()].map((v) => v.flushed());
      await Promise.all(allFlushed);
      if (this._flushAllMaybe())
        return true;
      const pendingSize = this._allConnections.size - this.connections.size;
      if (!this._queue.length && !pendingSize)
        return true;
      return new Promise((resolve) => {
        this._pendingFlushes.push({
          onflush: resolve,
          missing: this._queue.length + pendingSize,
          tick: this._flushTick++
        });
      });
    }
    async clear() {
      const cleared = Promise.allSettled([...this._discovery.values()].map((d) => d.destroy()));
      this._discovery.clear();
      return cleared;
    }
    async destroy({ force } = {}) {
      if (this.destroyed && !force)
        return;
      this.destroyed = true;
      this._timer.destroy();
      if (!force)
        await this.clear();
      await this.server.close();
      while (this._pendingFlushes.length) {
        const flush = this._pendingFlushes.pop();
        flush.onflush(false);
      }
      await this.dht.destroy({ force });
    }
    async suspend({ log = noop } = {}) {
      if (this.suspended)
        return;
      const promises = [];
      promises.push(this.server.suspend({ log }));
      for (const discovery of this._discovery.values()) {
        promises.push(discovery.suspend({ log }));
      }
      for (const connection of this._allConnections) {
        connection.destroy();
      }
      this.suspended = true;
      log("Suspending server and discovery... (" + promises.length + ")");
      await Promise.allSettled(promises);
      log("Done, suspending the dht...");
      await this.dht.suspend({ log });
      log("Done, swarm fully suspended");
    }
    async resume({ log = noop } = {}) {
      if (!this.suspended)
        return;
      log("Resuming the dht");
      await this.dht.resume();
      log("Done, resuming the server");
      await this.server.resume();
      log("Done, all discovery");
      for (const discovery of this._discovery.values()) {
        discovery.resume();
      }
      this._attemptClientConnections();
      this.suspended = false;
    }
    topics() {
      return this._discovery.values();
    }
  };
  function noop() {}
  function allowAll() {
    return false;
  }
  function shouldForceRelaying(code) {
    return code === "HOLEPUNCH_ABORTED" || code === "HOLEPUNCH_DOUBLE_RANDOMIZED_NATS" || code === "REMOTE_NOT_HOLEPUNCHABLE";
  }
});

// node_modules/blind-pairing-core/lib/messages.js
var require_messages6 = __commonJS((exports, module) => {
  var c = require_compact_encoding();
  var Invite = {
    preencode(state, i) {
      state.end++;
      state.end++;
      c.fixed32.preencode(state, i.seed);
      if (i.discoveryKey)
        c.fixed32.preencode(state, i.discoveryKey);
      if (i.expires)
        c.uint32.preencode(state, Math.floor(i.expires / 1000));
    },
    encode(state, i) {
      c.uint.encode(state, 1);
      c.uint.encode(state, (i.discoveryKey ? 1 : 0) | (i.expires ? 2 : 0) | (i.sensitive ? 4 : 0) | (i.testInvitation ? 8 : 0));
      c.fixed32.encode(state, i.seed);
      if (i.discoveryKey)
        c.fixed32.encode(state, i.discoveryKey);
      if (i.expires)
        c.uint32.encode(state, Math.floor(i.expires / 1000));
    },
    decode(state) {
      const version = c.uint.decode(state);
      if (version !== 1) {
        throw new Error("Unknown invite version");
      }
      const flags = c.uint.decode(state);
      return {
        seed: c.fixed32.decode(state),
        discoveryKey: flags & 1 ? c.fixed32.decode(state) : null,
        expires: flags & 2 ? c.uint32.decode(state) * 1000 : 0,
        sensitive: (flags & 4) !== 0,
        testInvitation: (flags & 8) !== 0
      };
    }
  };
  var RequestPayload = {
    preencode(state, p) {
      c.buffer.preencode(state, p.session);
      c.buffer.preencode(state, p.data);
    },
    encode(state, p) {
      c.buffer.encode(state, p.session);
      c.buffer.encode(state, p.data);
    },
    decode(state) {
      return {
        session: c.buffer.decode(state),
        data: c.buffer.decode(state)
      };
    }
  };
  var ResponseStatus = c.uint;
  var AdditionalData = {
    preencode(state, m) {
      c.buffer.preencode(state, m.data);
      c.fixed64.preencode(state, m.signature);
    },
    encode(state, m) {
      c.buffer.encode(state, m.data);
      c.fixed64.encode(state, m.signature);
    },
    decode(state) {
      return {
        data: c.buffer.decode(state),
        signature: c.fixed64.decode(state)
      };
    }
  };
  var ResponsePayload = {
    preencode(state, p) {
      ResponseStatus.preencode(state, p.status);
      if (p.status !== 0)
        return;
      let flags = 0;
      if (p.encryptionKey)
        flags |= 1;
      if (p.additional)
        flags |= 2;
      c.uint.preencode(state, flags);
      c.fixed32.preencode(state, p.key);
      if (p.encryptionKey)
        c.fixed32.preencode(state, p.encryptionKey);
      if (p.additional)
        AdditionalData.preencode(state, p.additional);
    },
    encode(state, p) {
      ResponseStatus.encode(state, p.status);
      if (p.status !== 0)
        return;
      let flags = 0;
      if (p.encryptionKey)
        flags |= 1;
      if (p.additional)
        flags |= 2;
      c.uint.encode(state, flags);
      c.fixed32.encode(state, p.key);
      if (p.encryptionKey)
        c.fixed32.encode(state, p.encryptionKey);
      if (p.additional)
        AdditionalData.encode(state, p.additional);
    },
    decode(state) {
      const status = ResponseStatus.decode(state);
      if (status !== 0) {
        return {
          status,
          key: null,
          encryptionKey: null,
          additional: null
        };
      }
      const flags = c.uint.decode(state);
      const key = c.fixed32.decode(state);
      const encryptionKey = (flags & 1) !== 0 ? c.fixed32.decode(state) : null;
      const additional = (flags & 2) !== 0 ? AdditionalData.decode(state) : null;
      return {
        status: 0,
        key,
        encryptionKey,
        additional
      };
    }
  };
  var InviteRequest = {
    preencode(state, i) {
      c.fixed32.preencode(state, i.inviteId);
      RequestPayload.preencode(state, i.payload);
    },
    encode(state, i) {
      c.fixed32.encode(state, i.inviteId);
      RequestPayload.encode(state, i.payload);
    },
    decode(state) {
      return {
        inviteId: c.fixed32.decode(state),
        payload: RequestPayload.decode(state)
      };
    }
  };
  var InviteResponse = {
    preencode(state, i) {
      c.fixed32.preencode(state, i.id);
      c.buffer.preencode(state, i.payload);
    },
    encode(state, i) {
      c.fixed32.encode(state, i.id);
      c.buffer.encode(state, i.payload);
    },
    decode(state) {
      return {
        id: c.fixed32.decode(state),
        payload: c.buffer.decode(state)
      };
    }
  };
  var InviteData = {
    preencode(state, i) {
      c.fixed64.preencode(state, i.signature);
      c.buffer.preencode(state, i.userData);
    },
    encode(state, i) {
      c.fixed64.encode(state, i.signature);
      c.buffer.encode(state, i.userData);
    },
    decode(state) {
      return {
        signature: c.fixed64.decode(state),
        userData: c.buffer.decode(state)
      };
    }
  };
  var InviteReceipt = {
    preencode(state, i) {
      c.fixed32.preencode(state, i.session);
      c.fixed64.preencode(state, i.signature);
      c.buffer.preencode(state, i.userData);
    },
    encode(state, i) {
      c.fixed32.encode(state, i.session);
      c.fixed64.encode(state, i.signature);
      c.buffer.encode(state, i.userData);
    },
    decode(state) {
      return {
        session: c.fixed32.decode(state),
        signature: c.fixed64.decode(state),
        userData: c.buffer.decode(state)
      };
    }
  };
  var AuthData = {
    preencode(state, i) {
      c.buffer.preencode(state, i.session);
      c.buffer.preencode(state, i.userData);
    },
    encode(state, i) {
      c.buffer.encode(state, i.session);
      c.buffer.encode(state, i.userData);
    },
    decode(state) {
      return {
        session: c.buffer.decode(state),
        userData: c.buffer.decode(state)
      };
    }
  };
  module.exports = {
    Invite,
    ResponsePayload,
    InviteRequest,
    InviteResponse,
    InviteData,
    InviteReceipt,
    AuthData
  };
});

// node_modules/blind-pairing-core/lib/errors.js
var require_errors7 = __commonJS((exports, module) => {
  module.exports = class PairingError extends Error {
    constructor(msg, code, fn = PairingError) {
      super(`${code}: ${msg}`);
      this.code = code;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, fn);
      }
    }
    get name() {
      return "PairingError";
    }
    static PAIRING_REJECTED(msg = "Pairing was rejected") {
      return new PairingError(msg, "PAIRING_REJECTED", PairingError.PAIRING_REJECTED);
    }
    static INVITE_USED(msg = "Invite has been used") {
      return new PairingError(msg, "INVITE_USED", PairingError.INVITE_USED);
    }
    static INVITE_EXPIRED(msg = "Invite has expireds") {
      return new PairingError(msg, "INVITE_EXPIRED", PairingError.INVITE_EXPIRED);
    }
  };
});

// node_modules/blind-pairing-core/index.js
var require_blind_pairing_core = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var sodium = require_sodium_native();
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var c = require_compact_encoding();
  var {
    Invite,
    ResponsePayload,
    InviteRequest,
    InviteResponse,
    InviteData,
    InviteReceipt,
    PersistedRequest,
    AuthData
  } = require_messages6();
  var {
    PAIRING_REJECTED,
    INVITE_USED,
    INVITE_EXPIRED
  } = require_errors7();
  var [
    NS_SIGNATURE,
    NS_TOKEN,
    NS_INVITE_ID,
    NS_REQUEST_ID,
    NS_SESSION,
    NS_SESSION_KEY,
    NS_ENCRYPT,
    NS_NONCE
  ] = crypto.namespace("blind-pairing", 8);

  class CandidateRequest extends EventEmitter {
    constructor(invite, userData, opts = {}) {
      super();
      if (b4a.isBuffer(invite)) {
        invite = c.decode(Invite, invite);
      }
      this.discoveryKey = invite.discoveryKey;
      this.seed = invite.seed;
      this.keyPair = crypto.keyPair(this.seed);
      this.inviteId = deriveInviteId(this.keyPair.publicKey);
      this.userData = userData;
      this.token = deriveToken(this.keyPair.publicKey, userData);
      this.session = opts.session || createSessionToken(this.token);
      this.id = deriveRequestId(this.session);
      this.payload = createAuth(this.userData, this.keyPair, this.session);
      this._encoded = null;
      this.auth = null;
    }
    static from(buf) {
      const info = c.decode(PersistedRequest, buf);
      const { seed, discoveryKey, userData } = info;
      const request = new CandidateRequest({ discoveryKey, seed }, userData);
      if (info.key) {
        request.key = info.key;
        request.token = null;
        request.payload = null;
      }
      return request;
    }
    handleResponse(payload) {
      if (b4a.isBuffer(payload)) {
        payload = this._decodeResponse(payload);
      }
      try {
        this._openResponse(payload);
      } catch (err) {
        this.emit("rejected", err);
        return null;
      }
      this._onAccept();
      return this.auth;
    }
    _openResponse(payload) {
      try {
        const response = openReply(payload, this.payload.session, this.keyPair.publicKey);
        this.response = c.decode(ResponsePayload, response);
      } catch (e) {
        throw new Error("Could not decrypt reply.");
      }
      const { status, key, encryptionKey, additional } = this.response;
      if (status !== 0) {
        switch (status) {
          case 1:
            throw PAIRING_REJECTED();
          case 2:
            throw INVITE_USED();
          case 3:
            throw INVITE_EXPIRED();
        }
      }
      if (b4a.compare(crypto.discoveryKey(key), this.discoveryKey)) {
        throw new Error("Invite response does not match discoveryKey");
      }
      if (additional && !crypto.verify(additional.data, additional.signature, this.keyPair.publicKey)) {
        throw new Error("Additional data failed verification");
      }
      this.auth = { key, encryptionKey, data: additional ? additional.data : null };
    }
    _onAccept() {
      this.emit("accepted", this.auth);
      this.destroy();
    }
    _decodeResponse(buf) {
      try {
        const { payload } = c.decode(InviteResponse, buf);
        return payload;
      } catch {
        throw new Error("Could not decode response.");
      }
    }
    destroy() {
      this.token = null;
      this.payload = null;
      this.emit("destroyed");
    }
    encode() {
      if (!this._encoded)
        this._encoded = c.encode(InviteRequest, this);
      return this._encoded;
    }
  }

  class MemberRequest {
    constructor(inviteId, requestData) {
      this.inviteId = inviteId;
      this.requestData = requestData;
      this._opened = false;
      this._confirmed = false;
      this._denied = false;
      this.discoveryKey = null;
      this.publicKey = null;
      this.userData = null;
      this.session = null;
      this.id = null;
      this.receipt = null;
      this._payload = null;
      this.response = null;
    }
    static from(req) {
      if (b4a.isBuffer(req)) {
        return MemberRequest.from(c.decode(InviteRequest, req));
      }
      return new MemberRequest(req.inviteId, req.payload);
    }
    confirm({ key, encryptionKey, additional }) {
      if (this._confirmed || this._denied || !this._opened)
        return;
      this._confirmed = true;
      const payload = c.encode(ResponsePayload, { status: 0, key, encryptionKey, additional });
      this._payload = createReply(payload, this.session, this.publicKey);
      this._respond();
    }
    deny({ status = 1 } = {}) {
      if (this._confirmed || this._denied)
        return;
      this._denied = true;
      if (!status)
        return;
      const payload = c.encode(ResponsePayload, {
        status,
        key: null,
        encryptionKey: null,
        additional: null
      });
      this._payload = createReply(payload, this.session, this.publicKey);
      this._respond();
    }
    respond() {
      return {
        id: this.id,
        payload: this._payload
      };
    }
    _respond() {
      this.response = c.encode(InviteResponse, this.respond());
    }
    open(publicKey) {
      if (this._opened && b4a.equals(this.publicKey, publicKey))
        return this.userData;
      try {
        this.receipt = openAuth(this.requestData, publicKey);
        const { userData, session } = c.decode(InviteReceipt, this.receipt);
        this.userData = userData;
        this.session = session;
        this.token = deriveToken(publicKey, userData);
        this.id = deriveRequestId(this.session);
      } catch (e) {
        throw new Error("Failed to open invite with provided key");
      }
      this.publicKey = publicKey;
      this._opened = true;
      return this.userData;
    }
  }
  exports.CandidateRequest = CandidateRequest;
  exports.MemberRequest = MemberRequest;
  exports.createInvite = createInvite;
  exports.decodeInvite = decodeInvite;
  exports.verifyReceipt = verifyReceipt;
  exports.createReceipt = createReceipt;
  exports.Invite = Invite;
  function createReceipt(invite, userData) {
    const req = new CandidateRequest(invite, userData);
    const receipt = openAuth(req.payload, req.keyPair.publicKey);
    return { id: deriveInviteId(req.keyPair.publicKey), receipt };
  }
  function verifyReceipt(receipt, publicKey) {
    if (b4a.isBuffer(receipt)) {
      receipt = c.decode(InviteReceipt, receipt);
    }
    const { session, signature, userData } = receipt;
    const signData = c.encode(AuthData, { userData, session });
    if (!verifySignature(signData, signature, publicKey))
      return null;
    return userData;
  }
  function deriveInviteId(publicKey) {
    return crypto.hash([NS_INVITE_ID, publicKey]);
  }
  function deriveKey(publicKey) {
    const out = b4a.allocUnsafe(sodium.crypto_aead_xchacha20poly1305_ietf_KEYBYTES);
    return crypto.hash([NS_ENCRYPT, publicKey], out);
  }
  function deriveNonce(publicKey, sessionToken) {
    const out = b4a.allocUnsafe(sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES);
    return crypto.hash([NS_NONCE, publicKey, sessionToken], out);
  }
  function deriveToken(publicKey, userData) {
    return crypto.hash([NS_TOKEN, publicKey, userData]);
  }
  function createSessionToken(token) {
    return crypto.hash([NS_SESSION, token]);
  }
  function deriveRequestId(sessionToken) {
    return crypto.hash([NS_REQUEST_ID, sessionToken]);
  }
  function createInvite(key, opts = {}) {
    const {
      discoveryKey = crypto.discoveryKey(key),
      expires = 0,
      seed = crypto.randomBytes(32),
      sensitive = false,
      data,
      testInvitation = false
    } = opts;
    const keyPair = crypto.keyPair(seed);
    const additional = data ? {
      data,
      signature: crypto.sign(data, keyPair.secretKey)
    } : null;
    return {
      id: deriveInviteId(keyPair.publicKey),
      invite: c.encode(Invite, { seed, discoveryKey, expires, sensitive, testInvitation }),
      seed,
      publicKey: keyPair.publicKey,
      additional,
      discoveryKey,
      expires,
      sensitive,
      testInvitation
    };
  }
  function decodeInvite(invite) {
    const data = c.decode(Invite, invite);
    return {
      id: deriveInviteId(crypto.keyPair(data.seed).publicKey),
      ...data
    };
  }
  function encrypt(data, nonce, secretKey) {
    const output = b4a.allocUnsafe(data.byteLength + sodium.crypto_aead_xchacha20poly1305_ietf_ABYTES);
    sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(output, data, nonce, null, nonce, secretKey);
    return output;
  }
  function decrypt(data, nonce, secretKey) {
    const output = b4a.allocUnsafe(data.byteLength - sodium.crypto_aead_xchacha20poly1305_ietf_ABYTES);
    sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(output, null, data, nonce, nonce, secretKey);
    return output;
  }
  function createAuth(userData, invitationKeyPair, session) {
    const secret = deriveKey(invitationKeyPair.publicKey);
    const nonce = deriveNonce(invitationKeyPair.publicKey, session);
    const signData = c.encode(AuthData, { userData, session });
    const signature = createSignature(signData, invitationKeyPair.secretKey);
    const inviteData = c.encode(InviteData, { userData, signature });
    const data = encrypt(inviteData, nonce, secret);
    return {
      session,
      data
    };
  }
  function openAuth(payload, invitationKey) {
    const secret = deriveKey(invitationKey);
    const { session, data } = payload;
    const nonce = deriveNonce(invitationKey, session);
    let plaintext;
    try {
      plaintext = decrypt(data, nonce, secret);
    } catch {
      throw new Error("Decryption failed.");
    }
    const { userData, signature } = c.decode(InviteData, plaintext);
    const receipt = { session, signature, userData };
    if (!verifyReceipt(receipt, invitationKey)) {
      throw new Error("Invalid reply");
    }
    return c.encode(InviteReceipt, { session, signature, userData });
  }
  function createReply(payload, sessionToken, invitationKey) {
    const sessionKey = crypto.hash([NS_SESSION_KEY, invitationKey, sessionToken]);
    const secret = deriveKey(sessionKey);
    const nonce = deriveNonce(sessionKey, sessionToken);
    return encrypt(payload, nonce, secret);
  }
  function openReply(data, sessionToken, invitationKey) {
    const sessionKey = crypto.hash([NS_SESSION_KEY, invitationKey, sessionToken]);
    const secret = deriveKey(sessionKey);
    const nonce = deriveNonce(sessionKey, sessionToken);
    return decrypt(data, nonce, secret);
  }
  function createSignature(data, secretKey) {
    const signature = b4a.allocUnsafe(sodium.crypto_sign_BYTES);
    const namespaced = b4a.allocUnsafe(32 + data.byteLength);
    namespaced.set(NS_SIGNATURE, 0);
    namespaced.set(data, 32);
    sodium.crypto_sign_detached(signature, namespaced, secretKey);
    return signature;
  }
  function verifySignature(data, signature, publicKey) {
    const namespaced = b4a.allocUnsafe(32 + data.byteLength);
    namespaced.set(NS_SIGNATURE, 0);
    namespaced.set(data, 32);
    return sodium.crypto_sign_verify_detached(signature, namespaced, publicKey);
  }
});

// node_modules/blind-pairing/index.js
var require_blind_pairing = __commonJS((exports, module) => {
  var crypto = require_hypercore_crypto();
  var b4a = require_b4a();
  var safetyCatch = require_safety_catch();
  var ReadyResource = require_ready_resource();
  var Xache = require_xache();
  var { MemberRequest, CandidateRequest, createInvite, decodeInvite, verifyReceipt, Invite } = require_blind_pairing_core();
  var Protomux = require_protomux();
  var c = require_compact_encoding();
  var debounce = require_debounceify();
  var isOptions = require_is_options();
  var [NS_EPHEMERAL, NS_REPLY, NS_DISCOVERY] = crypto.namespace("blind-pairing/dht", 3);
  var DEFAULT_POLL = 7 * 60 * 1000;
  var PEER_INTERVAL = 1000;

  class TimeoutPromise {
    constructor(ms) {
      this.ms = ms;
      this.resolve = null;
      this.timeout = null;
      this.destroyed = false;
      this.suspended = false;
      this._resolveBound = this._resolve.bind(this);
      this._ontimerBound = this._ontimer.bind(this);
    }
    wait() {
      if (this.destroyed)
        return Promise.resolve();
      if (this.resolve)
        this._resolve();
      return new Promise(this._ontimerBound);
    }
    suspend() {
      this.suspended = true;
      if (this.timeout !== null)
        clearTimeout(this.timeout);
      this.timeout = null;
    }
    resume() {
      this.suspended = false;
      if (this.resolve)
        this._resolve();
    }
    destroy() {
      this.destroyed = true;
      if (this.resolve)
        this._resolve();
    }
    _ontimer(resolve) {
      this.resolve = resolve;
      if (!this.suspended)
        this.timeout = setTimeout(this._resolveBound, this.ms);
    }
    _resolve() {
      if (this.timeout !== null)
        clearTimeout(this.timeout);
      const resolve = this.resolve;
      this.timeout = null;
      this.resolve = null;
      resolve();
    }
  }

  class BlindPairing extends ReadyResource {
    constructor(swarm, { poll = DEFAULT_POLL, onincoming = noop } = {}) {
      super();
      this.swarm = swarm;
      this.poll = poll;
      this.active = new Map;
      this.suspended = false;
      this._onincoming = onincoming;
      this._onconnectionBound = this._onconnection.bind(this);
      this._refreshBound = this.refresh.bind(this);
      this._refreshing = null;
      this.swarm.on("connection", this._onconnectionBound);
      this.swarm.dht.on("network-change", this._refreshBound);
    }
    static Invite = Invite;
    static createInvite(key, opts) {
      return createInvite(key, opts);
    }
    static decodeInvite(invite) {
      return decodeInvite(invite);
    }
    static verifyReceipt(receipt, publicKey) {
      return verifyReceipt(receipt, publicKey);
    }
    static createRequest(invite, userData) {
      return new CandidateRequest(invite, userData);
    }
    async suspend() {
      if (this.suspended)
        return;
      this.suspended = true;
      const all = [];
      for (const ref of this.active.values()) {
        if (ref.candidate)
          all.push(ref.candidate._suspend());
        if (ref.member)
          all.push(ref.member._suspend());
      }
      await Promise.allSettled(all);
    }
    resume() {
      if (!this.suspended)
        return;
      this.suspended = false;
      this.refresh().catch(safetyCatch);
    }
    async refresh() {
      if (this._refreshing) {
        await this._refreshing;
        return;
      }
      if (this.closing || this.suspended)
        return;
      const r = this._refreshing = this._refresh();
      try {
        await r;
      } finally {
        if (r === this._refreshing)
          this._refreshing = null;
      }
    }
    async _refresh() {
      if (this.closing || this.suspended)
        return;
      const all = [];
      for (const ref of this.active.values()) {
        if (ref.candidate)
          all.push(ref.candidate.refresh());
        if (ref.member)
          all.push(ref.member.refresh());
      }
      await Promise.allSettled(all);
    }
    addMember(opts) {
      return new Member(this, opts);
    }
    addCandidate(request, opts) {
      if (isOptions(request))
        return this.addCandidate(null, request);
      if (!request)
        request = new CandidateRequest(opts.invite, opts.userData);
      return new Candidate(this, request, opts);
    }
    async _close() {
      this.swarm.removeListener("connection", this._onconnectionBound);
      this.swarm.dht.removeListener("network-change", this._refreshBound);
      const all = [];
      for (const conn of this.swarm.connections) {
        const mux = getMuxer(conn);
        mux.unpair({ protocol: "blind-pairing" });
        for (const ref of this.active.values())
          mux.unpair({ protocol: "blind-pairing", id: ref.discoveryKey });
      }
      for (const ref of this.active.values()) {
        if (ref.member)
          all.push(ref.member.close());
        if (ref.candidate)
          all.push(ref.candidate.close());
        if (ref.discovery)
          all.push(ref.discovery.destroy());
      }
      await Promise.allSettled(all);
    }
    _randomPoll() {
      return randomInterval(this.poll);
    }
    _add(discoveryKey) {
      const id = b4a.toString(discoveryKey, "hex");
      const t = this.active.get(id);
      if (t)
        return t;
      const fresh = {
        id,
        discoveryKey,
        member: null,
        candidate: null,
        channels: new Set,
        alwaysServer: false,
        alwaysClient: false,
        discovery: null
      };
      this.active.set(id, fresh);
      return fresh;
    }
    _swarm(ref) {
      const server = ref.alwaysServer || !!ref.member;
      const client = ref.alwaysClient || !!ref.candidate;
      if (ref.discovery && ref.discovery.isServer === server && ref.discovery.isClient === client) {
        return;
      }
      if (ref.discovery)
        ref.discovery.destroy().catch(safetyCatch);
      if (!server && !client)
        return;
      ref.discovery = this.swarm.join(ref.discoveryKey, { server, client });
      this._attachToSwarm(ref);
    }
    _attachToSwarm(ref) {
      for (const conn of this.swarm.connections) {
        const mux = getMuxer(conn);
        this._attachToMuxer(mux, ref.discoveryKey, ref);
      }
    }
    _gc(ref) {
      if (ref.member || ref.candidate) {
        if (ref.discovery)
          this._swarm(ref);
        return false;
      }
      this.active.delete(ref.id);
      for (const ch of ref.channels)
        ch.close();
      for (const conn of this.swarm.connections) {
        const mux = getMuxer(conn);
        mux.unpair({ protocol: "blind-pairing", id: ref.discoveryKey });
      }
      if (ref.discovery)
        ref.discovery.destroy().catch(safetyCatch);
      return true;
    }
    _onconnection(conn) {
      const mux = getMuxer(conn);
      mux.pair({ protocol: "blind-pairing" }, this._onincoming);
      for (const ref of this.active.values()) {
        this._attachToMuxer(mux, ref.discoveryKey, ref);
      }
    }
    _attachToMuxer(mux, discoveryKey, ref) {
      if (!ref)
        ref = this._add(discoveryKey);
      const ch = mux.createChannel({
        protocol: "blind-pairing",
        id: discoveryKey,
        messages: [
          { encoding: c.buffer, onmessage: (req) => this._onpairingrequest(ch, ref, req) },
          { encoding: c.buffer, onmessage: (res) => this._onpairingresponse(ch, ref, res) }
        ],
        onclose: () => {
          ref.channels.delete(ch);
          if (ref.candidate)
            ref.candidate.visited.delete(ch);
        }
      });
      if (ch === null)
        return;
      ch.open();
      mux.pair({ protocol: "blind-pairing", id: discoveryKey }, () => this._attachToMuxer(mux, discoveryKey, null));
      ref.channels.add(ch);
      if (ref.candidate)
        ref.candidate.broadcast();
    }
    async _onpairingrequest(ch, ref, req) {
      if (!ref.member)
        return;
      const request = await ref.member._addRequest(req);
      if (!request)
        return;
      ch.messages[1].send(request.response);
    }
    async _onpairingresponse(ch, ref, res) {
      if (!ref.candidate)
        return;
      await ref.candidate._addResponse(res, false);
    }
  }

  class Member extends ReadyResource {
    constructor(blind, { announce = true, discoveryKey, onadd = noop } = {}) {
      super();
      if (!discoveryKey) {
        throw new Error("Must provide discoveryKey");
      }
      const ref = blind._add(discoveryKey);
      if (ref.member) {
        throw new Error("Active member already exist");
      }
      ref.member = this;
      this._pendingRequests = new Map;
      this.blind = blind;
      this.dht = blind.swarm.dht;
      this.discoveryKey = discoveryKey;
      this.pairingDiscoveryKey = deriveDiscoveryKey(discoveryKey);
      this.timeout = new TimeoutPromise(blind._randomPoll());
      this.pairing = null;
      this.skip = new Xache({ maxSize: 512 });
      this.ref = ref;
      this.onadd = onadd;
      this._activeQuery = null;
      this._activePoll = null;
      this._closestNodes = null;
      this._autoAnnounce = announce;
      this.ready();
    }
    announce() {
      if (this.pairing)
        return this.pairing;
      this.blind._swarm(this.ref);
      this.pairing = this._run();
      this.pairing.catch(safetyCatch);
      return this.pairing;
    }
    async flushed() {
      if (!this.ref.discovery)
        return;
      return this.ref.discovery.flushed();
    }
    _open() {
      if (this._autoAnnounce)
        this.announce();
      else
        this.blind._attachToSwarm(this.ref);
    }
    _suspend() {
      this.timeout.suspend();
      return this._abort();
    }
    async _abort() {
      if (this._activeQuery)
        this._activeQuery.destroy();
      while (this._activePoll !== null)
        await this._activePoll;
    }
    async refresh() {
      await this._abort();
      this.timeout.resume();
    }
    async _close() {
      this.ref.member = null;
      this.blind._gc(this.ref);
      this.timeout.destroy();
      await this._abort();
      try {
        await this.pairing;
      } catch {}
    }
    async _run() {
      while (!this.closing) {
        this._activePoll = this._poll();
        await this._activePoll;
        this._activePoll = null;
        await this.timeout.wait();
      }
    }
    async _poll() {
      const visited = new Set;
      let alwaysClient = false;
      if (this._activeQuery)
        this._activeQuery.destroy();
      const query = this._activeQuery = this.dht.lookup(this.pairingDiscoveryKey, { closestNodes: this._closestNodes });
      try {
        for await (const data of this._activeQuery) {
          if (this.closing || this.blind.suspended)
            return;
          for (const peer of data.peers) {
            const id = b4a.toString(peer.publicKey, "hex");
            if (visited.has(id) || this.skip.get(id))
              continue;
            visited.add(id);
            try {
              if (await this._add(peer.publicKey, id))
                alwaysClient = true;
            } catch (err) {
              safetyCatch(err);
            }
            if (this.closing || this.blind.suspended)
              return;
            if (alwaysClient && !this.ref.alwaysClient) {
              this.ref.alwaysClient = true;
              this.blind._swarm(this.ref);
            }
          }
        }
      } catch {} finally {
        const nodes = this._activeQuery.closestNodes;
        if (this._activeQuery === query)
          this._activeQuery = null;
        if (nodes && nodes.length > 0)
          this._closestNodes = nodes;
      }
      if (alwaysClient)
        this._revertClientAfterFlush();
    }
    async _revertClientAfterFlush() {
      try {
        await this.blind.swarm.flush();
      } catch {
        return;
      }
      if (this.closing || this.blind.suspended)
        return;
      this.ref.alwaysClient = false;
      this.blind._swarm(this.ref);
    }
    async _addRequest(value) {
      let request = null;
      try {
        request = MemberRequest.from(value);
      } catch {
        return null;
      }
      request.discoveryKey = this.discoveryKey;
      const session = b4a.toString(request.requestData.session, "hex");
      if (!this._pendingRequests.has(session)) {
        this._pendingRequests.set(session, {
          request,
          promise: this.onadd(request)
        });
      }
      const pending = this._pendingRequests.get(session);
      try {
        await pending.promise;
      } catch (e) {
        safetyCatch(e);
        return null;
      }
      this._pendingRequests.delete(session);
      if (!pending.request.response)
        return null;
      return pending.request;
    }
    async _add(publicKey, id) {
      const node = await this.dht.mutableGet(publicKey, { latest: false });
      if (!node)
        return false;
      this.skip.set(id, true);
      const request = await this._addRequest(node.value);
      if (!request)
        return false;
      const replyKeyPair = deriveReplyKeyPair(request.token);
      await this.dht.mutablePut(replyKeyPair, request.response);
      return true;
    }
  }

  class Candidate extends ReadyResource {
    constructor(blind, request, { discoveryKey = request.discoveryKey, onadd = noop } = {}) {
      super();
      const ref = blind._add(discoveryKey);
      if (ref.candidate) {
        throw new Error("Active candidate already exist");
      }
      ref.candidate = this;
      this.blind = blind;
      this.discoveryKey = discoveryKey;
      this.pairingDiscoveryKey = deriveDiscoveryKey(discoveryKey);
      this.dht = blind.swarm.dht;
      this.request = request;
      this.token = request.token;
      this.timeout = new TimeoutPromise(blind._randomPoll());
      this.announced = false;
      this.gcing = null;
      this.ref = ref;
      this.paired = null;
      this.pairing = null;
      this.onadd = onadd;
      this.signal = null;
      this.visited = new Set;
      this.broadcast = debounce(this._broadcast.bind(this));
      this._activePoll = null;
      this.ready();
    }
    _open() {
      this.blind._swarm(this.ref);
      this.pairing = this._run();
      this.broadcast();
    }
    _suspend() {
      this.timeout.suspend();
    }
    async refresh() {
      while (this._activePoll !== null)
        await this._activePoll;
      this.announced = false;
      this.timeout.resume();
    }
    async _close() {
      this.ref.candidate = null;
      this.blind._gc(this.ref);
      this.timeout.destroy();
      this.visited.clear();
      await this.pairing;
      if (this.gcing)
        await this.gcing;
    }
    async _addResponse(value, gc) {
      if (this.paired)
        return;
      const paired = this.request.handleResponse(value);
      if (!paired)
        return;
      this.paired = paired;
      if (this.signal)
        this.signal.destroy();
      if ((gc || this.announced) && !this.gcing)
        this.gcing = this._gc();
      await this.onadd(paired);
      this.timeout.destroy();
    }
    async _run() {
      while (!this._done()) {
        this._activePoll = this._poll();
        await this._activePoll;
        this._activePoll = null;
        if (this._done())
          break;
        await this.timeout.wait();
      }
      this.close().catch(safetyCatch);
      return this.paired;
    }
    _done() {
      return !!(this.closing || this.paired);
    }
    async _announce() {
      const eph = deriveEphemeralKeyPair(this.token);
      await this.dht.mutablePut(eph, this.request.encode());
      if (this._done())
        return;
      await this.dht.announce(this.pairingDiscoveryKey, eph).finished();
      if (this._done())
        return;
      if (!this.paired) {
        this.ref.alwaysServer = true;
        this.blind._swarm(this.ref);
      }
      this.emit("announce");
    }
    async _gc() {
      const eph = deriveEphemeralKeyPair(this.token);
      try {
        await this.dht.unannounce(this.pairingDiscoveryKey, eph);
      } catch (err) {
        safetyCatch(err);
      }
    }
    _sendRequest(ch) {
      ch.messages[0].send(this.request.encode());
      this.visited.add(ch);
    }
    async _broadcast() {
      for (const channel of this.closestPeers()) {
        this.signal = new TimeoutPromise(randomInterval(PEER_INTERVAL));
        if (channel)
          this._sendRequest(channel);
        await this.signal.wait();
        if (this.paired || this.suspended)
          break;
      }
    }
    *closestPeers() {
      while (!this.paired) {
        const closest = Infinity;
        let channel = null;
        for (const ch of this.ref.channels) {
          if (this.visited.has(ch))
            continue;
          const { rtt } = ch._mux.stream.rawStream;
          if (rtt < closest)
            channel = ch;
        }
        if (!channel)
          return;
        yield channel;
      }
    }
    async _poll() {
      try {
        const value = await this._getReply();
        if (this._done() || this.blind.suspended)
          return;
        if (value) {
          await this._addResponse(value, true);
          if (this._done() || this.blind.suspended)
            return;
        }
        if (!this.announced) {
          this.announced = true;
          await this._announce();
        }
      } catch {}
    }
    async _getReply() {
      const { publicKey } = deriveReplyKeyPair(this.token);
      const node = await this.dht.mutableGet(publicKey, { latest: false });
      if (!node)
        return null;
      return node.value;
    }
  }
  module.exports = BlindPairing;
  function noop() {}
  function deriveReplyKeyPair(token) {
    return crypto.keyPair(crypto.hash([NS_REPLY, token]));
  }
  function deriveEphemeralKeyPair(token) {
    return crypto.keyPair(crypto.hash([NS_EPHEMERAL, token]));
  }
  function deriveDiscoveryKey(discoveryKey) {
    return crypto.hash([NS_DISCOVERY, discoveryKey]);
  }
  function getMuxer(stream) {
    if (stream.userData)
      return stream.userData;
    const protocol = Protomux.from(stream);
    stream.setKeepAlive(5000);
    stream.userData = protocol;
    return protocol;
  }
  function randomInterval(n) {
    return n + n * 0.5 * Math.random() | 0;
  }
});

// node_modules/hyperblobs/lib/prefetcher.js
var require_prefetcher = __commonJS((exports, module) => {
  var MAX_READAHEAD_TARGET = 0.05;
  module.exports = class Prefetcher {
    constructor(core, { max = 64, start = 0, end = core.length, linear = true } = {}) {
      this.core = core;
      this.max = max;
      this.range = null;
      this.startBound = start;
      this.endBound = end;
      this.maxReadAhead = Math.max(max * 2, Math.floor((end - start) * MAX_READAHEAD_TARGET));
      this.start = start;
      this.end = start;
      this.linear = linear;
      this.missing = 0;
      this._ondownloadBound = this._ondownload.bind(this);
      this.core.on("download", this._ondownloadBound);
    }
    _ondownload(index) {
      if (this.range && index < this.end && this.start <= index) {
        this.missing--;
        this._update();
      }
    }
    destroy() {
      this.core.off("download", this._ondownloadBound);
      if (this.range)
        this.range.destroy();
      this.range = null;
      this.max = 0;
    }
    update(position) {
      this.start = position;
      if (!this.range)
        this._update();
    }
    _update() {
      if (this.missing >= this.max)
        return;
      if (this.range)
        this.range.destroy();
      let end = this.end;
      while (end < this.endBound && this.missing < this.max) {
        end = this.core.core.bitfield.firstUnset(end) + 1;
        if (end >= this.endBound)
          break;
        this.missing++;
      }
      if (end > this.start + this.maxReadAhead)
        end = this.start + this.maxReadAhead;
      if (end >= this.endBound)
        end = this.endBound;
      this.end = end;
      if (this.start >= this.end)
        return;
      this.range = this.core.download({
        start: this.start,
        end: this.end,
        linear: this.linear
      });
    }
  };
});

// node_modules/hyperblobs/lib/streams.js
var require_streams3 = __commonJS((exports, module) => {
  var { Readable, Writable } = require_streamx();
  var { BLOCK_NOT_AVAILABLE } = require_hypercore_errors();
  var Prefetcher = require_prefetcher();

  class BlobWriteStream extends Writable {
    constructor(core, lock, opts) {
      super(opts);
      this.id = {};
      this.core = core;
      this._lock = lock;
      this._release = null;
      this._batch = [];
    }
    _open(cb) {
      this.core.ready().then(() => {
        this._lock((release) => {
          this._release = release;
          this.id.byteOffset = this.core.byteLength;
          this.id.blockOffset = this.core.length;
          return cb(null);
        });
      }, (err) => cb(err));
    }
    _final(cb) {
      this._append((err) => {
        if (err)
          return cb(err);
        this.id.blockLength = this.core.length - this.id.blockOffset;
        this.id.byteLength = this.core.byteLength - this.id.byteOffset;
        return cb(null);
      });
    }
    _destroy(cb) {
      if (this._release)
        this._release();
      cb(null);
    }
    _append(cb) {
      if (!this._batch.length)
        return cb(null);
      return this.core.append(this._batch).then(() => {
        this._batch = [];
        return cb(null);
      }, (err) => {
        this._batch = [];
        return cb(err);
      });
    }
    _write(data, cb) {
      this._batch.push(data);
      if (this._batch.length >= 16)
        return this._append(cb);
      return cb(null);
    }
  }

  class BlobReadStream extends Readable {
    constructor(core, id, opts = {}) {
      super(opts);
      this.id = id;
      this.core = core.session({ wait: opts.wait, timeout: opts.timeout });
      const start = id.blockOffset;
      const end = id.blockOffset + id.blockLength;
      const noPrefetch = opts.wait === false || opts.prefetch === false || !core.core;
      this._prefetch = noPrefetch ? null : new Prefetcher(this.core, { max: opts.prefetch, start, end });
      this._lastPrefetch = null;
      this._pos = opts.start !== undefined ? id.byteOffset + opts.start : id.byteOffset;
      if (opts.length !== undefined)
        this._end = this._pos + opts.length;
      else if (opts.end !== undefined)
        this._end = id.byteOffset + opts.end + 1;
      else
        this._end = id.byteOffset + id.byteLength;
      this._index = 0;
      this._relativeOffset = 0;
      this._bytesRead = 0;
    }
    _open(cb) {
      if (this._pos === this.id.byteOffset) {
        this._index = this.id.blockOffset;
        this._relativeOffset = 0;
        return cb(null);
      }
      this.core.seek(this._pos, {
        start: this.id.blockOffset,
        end: this.id.blockOffset + this.id.blockLength
      }).then((result) => {
        if (!result)
          return cb(BLOCK_NOT_AVAILABLE());
        this._index = result[0];
        this._relativeOffset = result[1];
        return cb(null);
      }, (err) => cb(err));
    }
    _predestroy() {
      if (this._prefetch)
        this._prefetch.destroy();
      this.core.close().then(noop, noop);
    }
    _destroy(cb) {
      if (this._prefetch)
        this._prefetch.destroy();
      this.core.close().then(cb, cb);
    }
    _read(cb) {
      if (this._pos >= this._end) {
        this.push(null);
        return cb(null);
      }
      if (this._prefetch)
        this._prefetch.update(this._index);
      this.core.get(this._index).then((block) => {
        if (!block)
          return cb(BLOCK_NOT_AVAILABLE());
        const remainder = this._end - this._pos;
        if (this._relativeOffset || remainder < block.length) {
          block = block.subarray(this._relativeOffset, this._relativeOffset + remainder);
        }
        this._index++;
        this._relativeOffset = 0;
        this._pos += block.length;
        this._bytesRead += block.length;
        this.push(block);
        return cb(null);
      }, (err) => cb(err));
    }
  }
  module.exports = {
    BlobReadStream,
    BlobWriteStream
  };
  function noop() {}
});

// node_modules/speedometer/index.js
var require_speedometer = __commonJS((exports, module) => {
  var tick = 1;
  var maxTick = 65535;
  var resolution = 4;
  var timer;
  var inc = function() {
    tick = tick + 1 & maxTick;
  };
  module.exports = function(seconds) {
    if (!timer) {
      timer = setInterval(inc, 1000 / resolution | 0);
      if (timer.unref)
        timer.unref();
    }
    var size = resolution * (seconds || 5);
    var buffer = [0];
    var pointer = 1;
    var last = tick - 1 & maxTick;
    return function(delta) {
      var dist = tick - last & maxTick;
      if (dist > size)
        dist = size;
      last = tick;
      while (dist--) {
        if (pointer === size)
          pointer = 0;
        buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
        pointer++;
      }
      if (delta)
        buffer[pointer - 1] += delta;
      var top = buffer[pointer - 1];
      var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
      return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
    };
  };
});

// node_modules/hyperblobs/lib/monitor.js
var require_monitor = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var speedometer = require_speedometer();
  module.exports = class Monitor extends EventEmitter {
    constructor(blobs, id) {
      super();
      if (!id)
        throw new Error("id is required");
      this.blobs = blobs;
      this.id = id;
      this.peers = 0;
      this.uploadSpeedometer = null;
      this.downloadSpeedometer = null;
      const stats = {
        startTime: 0,
        percentage: 0,
        peers: 0,
        speed: 0,
        blocks: 0,
        totalBytes: 0,
        monitoringBytes: 0,
        targetBytes: 0,
        targetBlocks: 0
      };
      this.uploadStats = { ...stats };
      this.downloadStats = { ...stats };
      this.uploadStats.targetBytes = this.downloadStats.targetBytes = this.id.byteLength;
      this.uploadStats.targetBlocks = this.downloadStats.targetBlocks = this.id.blockLength;
      this.uploadStats.peers = this.downloadStats.peers = this.peers = this.blobs.core.peers.length;
      this.uploadSpeedometer = speedometer();
      this.downloadSpeedometer = speedometer();
    }
    destroy() {
      return this.close();
    }
    close() {
      this.blobs._removeMonitor(this);
    }
    _onUpload(index, bytes, from) {
      this._updateStats(this.uploadSpeedometer, this.uploadStats, index, bytes, from);
    }
    _onDownload(index, bytes, from) {
      this._updateStats(this.downloadSpeedometer, this.downloadStats, index, bytes, from);
    }
    _updatePeers() {
      this.uploadStats.peers = this.downloadStats.peers = this.peers = this.blobs.core.peers.length;
      this.emit("update");
    }
    _updateStats(speed, stats, index, bytes) {
      if (this.closing)
        return;
      if (!isWithinRange(index, this.id))
        return;
      if (!stats.startTime)
        stats.startTime = Date.now();
      stats.speed = speed(bytes);
      stats.blocks++;
      stats.totalBytes += bytes;
      stats.monitoringBytes += bytes;
      stats.percentage = toFixed(stats.blocks / stats.targetBlocks * 100);
      this.emit("update");
    }
    downloadSpeed() {
      return this.downloadSpeedometer ? this.downloadSpeedometer() : 0;
    }
    uploadSpeed() {
      return this.uploadSpeedometer ? this.uploadSpeedometer() : 0;
    }
  };
  function isWithinRange(index, { blockOffset, blockLength }) {
    return index >= blockOffset && index < blockOffset + blockLength;
  }
  function toFixed(n) {
    return Math.round(n * 100) / 100;
  }
});

// node_modules/hyperblobs/index.js
var require_hyperblobs = __commonJS((exports, module) => {
  var mutexify = require_mutexify();
  var b4a = require_b4a();
  var { BlobReadStream, BlobWriteStream } = require_streams3();
  var Monitor = require_monitor();
  var DEFAULT_BLOCK_SIZE = 2 ** 16;

  class HyperBlobsBatch {
    constructor(blobs) {
      this.blobs = blobs;
      this.blocks = [];
      this.bytes = 0;
    }
    ready() {
      return this.blobs.ready();
    }
    async put(buffer) {
      if (!this.blobs.core.opened)
        await this.blobs.core.ready();
      const blockSize = this.blobs.blockSize;
      const result = {
        blockOffset: this.blobs.core.length + this.blocks.length,
        blockLength: 0,
        byteOffset: this.blobs.core.byteLength + this.bytes,
        byteLength: 0
      };
      let offset = 0;
      while (offset < buffer.byteLength) {
        const blk = buffer.subarray(offset, offset + blockSize);
        offset += blockSize;
        result.blockLength++;
        result.byteLength += blk.byteLength;
        this.bytes += blk.byteLength;
        this.blocks.push(blk);
      }
      return result;
    }
    async get(id) {
      if (id.blockOffset < this.blobs.core.length) {
        return this.blobs.get(id);
      }
      const bufs = [];
      for (let i = id.blockOffset - this.blobs.core.length;i < id.blockOffset + id.blockLength; i++) {
        if (i >= this.blocks.length)
          return null;
        bufs.push(this.blocks[i]);
      }
      return bufs.length === 1 ? bufs[0] : b4a.concat(bufs);
    }
    async flush() {
      await this.blobs.core.append(this.blocks);
      this.blocks = [];
      this.bytes = 0;
    }
    close() {}
  }

  class Hyperblobs {
    constructor(core, opts = {}) {
      this.core = core;
      this.blockSize = opts.blockSize || DEFAULT_BLOCK_SIZE;
      this._lock = mutexify();
      this._monitors = new Set;
      this._boundUpdatePeers = this._updatePeers.bind(this);
      this._boundOnUpload = this._onUpload.bind(this);
      this._boundOnDownload = this._onDownload.bind(this);
    }
    get key() {
      return this.core.key;
    }
    get discoveryKey() {
      return this.core.discoveryKey;
    }
    get feed() {
      return this.core;
    }
    get locked() {
      return this._lock.locked;
    }
    replicate(isInitiator, opts) {
      return this.core.replicate(isInitiator, opts);
    }
    ready() {
      return this.core.ready();
    }
    close() {
      return this.core.close();
    }
    batch() {
      return new HyperBlobsBatch(this);
    }
    snapshot() {
      return new Hyperblobs(this.core.snapshot());
    }
    async put(blob, opts) {
      if (!b4a.isBuffer(blob))
        blob = b4a.from(blob);
      const blockSize = opts && opts.blockSize || this.blockSize;
      const stream = this.createWriteStream(opts);
      for (let i = 0;i < blob.length; i += blockSize) {
        stream.write(blob.subarray(i, i + blockSize));
      }
      stream.end();
      return new Promise((resolve, reject) => {
        stream.once("error", reject);
        stream.once("close", () => resolve(stream.id));
      });
    }
    async _getAll(id, opts) {
      if (id.blockLength === 1)
        return this.core.get(id.blockOffset, opts);
      const promises = new Array(id.blockLength);
      for (let i = 0;i < id.blockLength; i++) {
        promises[i] = this.core.get(id.blockOffset + i, opts);
      }
      const blocks = await Promise.all(promises);
      for (let i = 0;i < id.blockLength; i++) {
        if (blocks[i] === null)
          return null;
      }
      return b4a.concat(blocks);
    }
    async get(id, opts) {
      const all = !opts || !opts.start && opts.length === undefined && opts.end === undefined && !opts.core;
      if (all)
        return this._getAll(id, opts);
      const res = [];
      try {
        for await (const block of this.createReadStream(id, opts)) {
          res.push(block);
        }
      } catch (error) {
        if (error.code === "BLOCK_NOT_AVAILABLE")
          return null;
        throw error;
      }
      if (res.length === 1)
        return res[0];
      return b4a.concat(res);
    }
    async clear(id, opts) {
      return this.core.clear(id.blockOffset, id.blockOffset + id.blockLength, opts);
    }
    createReadStream(id, opts) {
      const core = opts && opts.core ? opts.core : this.core;
      return new BlobReadStream(core, id, opts);
    }
    createWriteStream(opts) {
      const core = opts && opts.core ? opts.core : this.core;
      return new BlobWriteStream(core, this._lock, opts);
    }
    monitor(id) {
      const monitor = new Monitor(this, id);
      if (this._monitors.size === 0)
        this._startListening();
      this._monitors.add(monitor);
      return monitor;
    }
    _removeMonitor(mon) {
      this._monitors.delete(mon);
      if (this._monitors.size === 0)
        this._stopListening();
    }
    _updatePeers() {
      for (const m of this._monitors)
        m._updatePeers();
    }
    _onUpload(index, bytes, from) {
      for (const m of this._monitors)
        m._onUpload(index, bytes, from);
    }
    _onDownload(index, bytes, from) {
      for (const m of this._monitors)
        m._onDownload(index, bytes, from);
    }
    _startListening() {
      this.core.on("peer-add", this._boundUpdatePeers);
      this.core.on("peer-remove", this._boundUpdatePeers);
      this.core.on("upload", this._boundOnUpload);
      this.core.on("download", this._boundOnDownload);
    }
    _stopListening() {
      this.core.off("peer-add", this._boundUpdatePeers);
      this.core.off("peer-remove", this._boundUpdatePeers);
      this.core.off("upload", this._boundOnUpload);
      this.core.off("download", this._boundOnDownload);
    }
  }
  module.exports = Hyperblobs;
});

// node_modules/unix-path-resolve/index.js
var require_unix_path_resolve = __commonJS((exports, module) => {
  module.exports = resolve;
  function parse(addr) {
    const names = addr.split(/[/\\]/);
    const r = {
      isAbsolute: false,
      names
    };
    if (names.length === 0)
      return r;
    if (names.length > 1 && names[0].endsWith(":")) {
      r.isAbsolute = true;
      if (names[0].length === 2) {
        r.names = names.slice(1);
        return r;
      }
      if (names[0] === "file:") {
        r.names = names.slice(1);
        return r;
      }
      r.names = names.slice(3);
      return r;
    }
    r.isAbsolute = addr.startsWith("/") || addr.startsWith("\\");
    return r;
  }
  function resolve(a, b = "") {
    const ap = parse(a);
    const bp = parse(b);
    if (bp.isAbsolute) {
      return resolveNames([], bp.names);
    }
    if (!ap.isAbsolute) {
      throw new Error("One of the two paths must be absolute");
    }
    return resolveNames(ap.names, bp.names);
  }
  function toString(p, names) {
    for (let i = 0;i < names.length; i++) {
      if (names[i] === "")
        continue;
      if (names[i] === ".")
        continue;
      if (names[i] === "..") {
        if (p.length === 1)
          throw new Error("Path cannot be resolved, too many '..'");
        p = p.slice(0, p.lastIndexOf("/")) || "/";
        continue;
      }
      p += p.length === 1 ? names[i] : "/" + names[i];
    }
    return p;
  }
  function resolveNames(a, b) {
    return toString(toString("/", a), b);
  }
});

// node_modules/same-data/index.js
var require_same_data = __commonJS((exports, module) => {
  module.exports = sameData;
  function type(o) {
    const t = typeof o;
    return t === "object" ? Array.isArray(o) ? "array" : isTypedArray(o) ? typeof o.equals === "function" ? "buffer" : "array" : o === null ? "null" : "object" : t;
  }
  function isTypedArray(a) {
    return !!a && typeof a.length === "number" && ArrayBuffer.isView(a.array);
  }
  function sameData(a, b) {
    if (a === b)
      return true;
    const ta = type(a);
    const tb = type(b);
    if (ta !== tb)
      return false;
    if (ta === "buffer")
      return a.equals(b);
    if (ta === "array") {
      if (a.length !== b.length)
        return false;
      for (let i = 0;i < a.length; i++) {
        if (!sameData(a[i], b[i]))
          return false;
      }
      return true;
    }
    if (ta !== "object")
      return false;
    const ea = Object.entries(a);
    const eb = Object.entries(b);
    if (ea.length !== eb.length)
      return false;
    ea.sort(cmp);
    eb.sort(cmp);
    for (let i = 0;i < ea.length; i++) {
      if (ea[i][0] !== eb[i][0] || !sameData(ea[i][1], eb[i][1]))
        return false;
    }
    return true;
  }
  function cmp(a, b) {
    return a[0] === b[0] ? 0 : a[0] < b[0] ? -1 : 1;
  }
});

// node_modules/binary-stream-equals/index.js
var require_binary_stream_equals = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = function(a, b) {
    return new Promise((resolve, reject) => binaryEquals(a, b, resolve, reject));
  };
  function binaryEquals(a, b, resolve, reject) {
    let aBuf = null;
    let aEnded = false;
    let bBuf = null;
    let bEnded = false;
    let closed = 0;
    let done = false;
    let error = null;
    let equals = false;
    a.on("readable", tick);
    a.on("end", onend);
    a.on("error", onerror);
    a.on("close", onclose);
    b.on("readable", tick);
    b.on("end", onend);
    b.on("error", onerror);
    b.on("close", onclose);
    function onerror(err) {
      error = err;
      a.destroy();
      b.destroy();
    }
    function onclose() {
      if (++closed !== 2)
        return;
      if (error !== null && done === false)
        reject(error);
      else
        resolve(equals);
    }
    function ondone(eq) {
      if (done)
        return;
      done = true;
      equals = eq;
      a.destroy();
      b.destroy();
    }
    function onend() {
      if (this === a)
        aEnded = true;
      else
        bEnded = true;
      tick();
    }
    function tick() {
      while (done === false) {
        if (aBuf === null)
          aBuf = a.read();
        if (bBuf === null)
          bBuf = b.read();
        if (aBuf === null && bBuf === null && aEnded && bEnded) {
          ondone(true);
          return;
        }
        if (aBuf !== null && (bBuf === null && bEnded)) {
          ondone(false);
          return;
        }
        if (bBuf !== null && (aBuf === null && aEnded)) {
          ondone(false);
          return;
        }
        if (aBuf === null || bBuf === null)
          return;
        if (aBuf.byteLength === bBuf.byteLength) {
          if (b4a.equals(aBuf, bBuf)) {
            aBuf = bBuf = null;
            continue;
          }
          ondone(false);
          return;
        }
        const min = Math.min(aBuf.byteLength, bBuf.byteLength);
        if (b4a.equals(aBuf.subarray(0, min), bBuf.subarray(0, min))) {
          aBuf = aBuf.byteLength === min ? null : aBuf.subarray(min);
          bBuf = bBuf.byteLength === min ? null : bBuf.subarray(min);
          continue;
        }
        ondone(false);
        return;
      }
    }
  }
});

// node_modules/mirror-drive/index.js
var require_mirror_drive = __commonJS((exports, module) => {
  var sameData = require_same_data();
  var unixPathResolve = require_unix_path_resolve();
  var streamEquals = require_binary_stream_equals();
  module.exports = class MirrorDrive {
    constructor(src, dst, opts = {}) {
      this.src = src;
      this.dst = dst;
      this.prefix = opts.prefix || "/";
      this.dryRun = !!opts.dryRun;
      this.prune = opts.prune !== false;
      this.includeEquals = !!opts.includeEquals;
      this.filter = opts.filter || null;
      this.metadataEquals = opts.metadataEquals || null;
      this.batch = !!opts.batch;
      this.entries = opts.entries || null;
      this.count = { files: 0, add: 0, remove: 0, change: 0 };
      this.bytesRemoved = 0;
      this.bytesAdded = 0;
      this.iterator = this._mirror();
      this._ignore = opts.ignore ? toIgnoreFunction(opts.ignore) : null;
    }
    [Symbol.asyncIterator]() {
      return this.iterator;
    }
    async done() {
      while (true) {
        const { done } = await this.iterator.next();
        if (done)
          break;
      }
    }
    async* _mirror() {
      await this.src.ready();
      await this.dst.ready();
      if (this.dst.core && !this.dst.core.writable)
        throw new Error("Destination must be writable");
      const dst = this.batch ? this.dst.batch() : this.dst;
      if (this.prune) {
        for await (const [key, dstEntry, srcEntry] of this._list(this.dst, this.src)) {
          if (srcEntry)
            continue;
          this.count.remove++;
          this.bytesRemoved += blobLength(dstEntry);
          yield { op: "remove", key, bytesRemoved: blobLength(dstEntry), bytesAdded: 0 };
          if (!this.dryRun)
            await dst.del(key);
        }
      }
      if (this.src.download && !this.entries) {
        const dl = this.src.download(this.prefix);
        if (dl.catch)
          dl.catch(noop);
      }
      for await (const [key, srcEntry, dstEntry] of this._list(this.src, dst, { filter: this.filter })) {
        if (!srcEntry)
          continue;
        this.count.files++;
        if (await same(this, srcEntry, dstEntry)) {
          if (this.includeEquals)
            yield { op: "equal", key, bytesRemoved: 0, bytesAdded: 0 };
          continue;
        }
        if (dstEntry) {
          this.count.change++;
          this.bytesRemoved += blobLength(dstEntry);
          this.bytesAdded += blobLength(srcEntry);
          yield { op: "change", key, bytesRemoved: blobLength(dstEntry), bytesAdded: blobLength(srcEntry) };
        } else {
          this.count.add++;
          this.bytesAdded += blobLength(srcEntry);
          yield { op: "add", key, bytesRemoved: 0, bytesAdded: blobLength(srcEntry) };
        }
        if (this.dryRun) {
          continue;
        }
        if (srcEntry.value.linkname) {
          await dst.symlink(key, srcEntry.value.linkname);
        } else {
          await pipeline(this.src.createReadStream(srcEntry), dst.createWriteStream(key, { executable: srcEntry.value.executable, metadata: srcEntry.value.metadata }));
        }
      }
      if (this.batch)
        await dst.flush();
    }
    async* _list(a, b, opts) {
      const list = this.entries || a.list(this.prefix, { ignore: this._ignore });
      for await (const entry of list) {
        const key = typeof entry === "object" ? entry.key : entry;
        if (opts && opts.filter && !opts.filter(key))
          continue;
        const entryA = await a.entry(entry);
        const entryB = await b.entry(key);
        yield [key, entryA, entryB];
      }
    }
  };
  function blobLength(entry) {
    return entry.value.blob ? entry.value.blob.byteLength : 0;
  }
  function pipeline(rs, ws) {
    return new Promise((resolve, reject) => {
      rs.pipe(ws, (err) => {
        if (err)
          reject(err);
        else
          resolve();
      });
    });
  }
  async function same(m, srcEntry, dstEntry) {
    if (!dstEntry)
      return false;
    if (srcEntry.value.linkname || dstEntry.value.linkname) {
      return srcEntry.value.linkname === dstEntry.value.linkname;
    }
    if (srcEntry.value.executable !== dstEntry.value.executable)
      return false;
    if (!sizeEquals(srcEntry, dstEntry))
      return false;
    if (!metadataEquals(m, srcEntry, dstEntry))
      return false;
    return streamEquals(m.src.createReadStream(srcEntry), m.dst.createReadStream(dstEntry));
  }
  function sizeEquals(srcEntry, dstEntry) {
    const srcBlob = srcEntry.value.blob;
    const dstBlob = dstEntry.value.blob;
    if (!srcBlob && !dstBlob)
      return true;
    if (!srcBlob || !dstBlob)
      return false;
    return srcBlob.byteLength === dstBlob.byteLength;
  }
  function metadataEquals(m, srcEntry, dstEntry) {
    if (!m.src.supportsMetadata || !m.dst.supportsMetadata)
      return true;
    const srcMetadata = srcEntry.value.metadata;
    const dstMetadata = dstEntry.value.metadata;
    if (m.metadataEquals) {
      return m.metadataEquals(srcMetadata, dstMetadata);
    }
    const noMetadata = !srcMetadata && !dstMetadata;
    const identicalMetadata = !!(srcMetadata && dstMetadata && sameData(srcMetadata, dstMetadata));
    return noMetadata || identicalMetadata;
  }
  function toIgnoreFunction(ignore) {
    if (typeof ignore === "function")
      return ignore;
    const all = [].concat(ignore).map((e) => unixPathResolve("/", e));
    return (key) => all.some((path) => path === key || key.startsWith(path + "/"));
  }
  function noop() {}
});

// node_modules/hyperdrive/lib/monitor.js
var require_monitor2 = __commonJS((exports, module) => {
  var ReadyResource = require_ready_resource();
  var safetyCatch = require_safety_catch();
  var speedometer = require_speedometer();
  module.exports = class Monitor extends ReadyResource {
    constructor(drive, opts = {}) {
      super();
      this.drive = drive;
      this.blobs = null;
      this.name = opts.name || null;
      this.entry = opts.entry || null;
      this.peers = 0;
      this._boundOnUpload = this._onUpload.bind(this);
      this._boundOnDownload = this._onDownload.bind(this);
      this._boundPeerUpdate = this._updatePeers.bind(this);
      const stats = {
        startTime: 0,
        percentage: 0,
        peers: 0,
        speed: 0,
        blocks: 0,
        totalBytes: 0,
        monitoringBytes: 0,
        targetBytes: 0,
        targetBlocks: 0
      };
      this.uploadStats = { ...stats };
      this.downloadStats = { ...stats };
      this.uploadSpeedometer = null;
      this.downloadSpeedometer = null;
      this.ready().catch(safetyCatch);
    }
    async _open() {
      await this.drive.ready();
      this.blobs = await this.drive.getBlobs();
      if (!this.entry && this.name)
        this.entry = await this.drive.entry(this.name);
      if (this.entry)
        this._setEntryInfo();
      this.uploadSpeedometer = speedometer();
      this.downloadSpeedometer = speedometer();
      this._updatePeers();
      this.blobs.core.on("peer-add", this._boundPeerUpdate);
      this.blobs.core.on("peer-remove", this._boundPeerUpdate);
      this.blobs.core.on("upload", this._boundOnUpload);
      this.blobs.core.on("download", this._boundOnDownload);
    }
    async _close() {
      this.blobs.core.off("peer-add", this._boundPeerUpdate);
      this.blobs.core.off("peer-remove", this._boundPeerUpdate);
      this.blobs.core.off("upload", this._boundOnUpload);
      this.blobs.core.off("download", this._boundOnDownload);
      this.drive.monitors.delete(this);
    }
    _setEntryInfo() {
      if (!this.downloadStats.targetBytes || !this.downloadStats.targetBlocks) {
        this.downloadStats.targetBytes = this.entry.value.blob.byteLength;
        this.downloadStats.targetBlocks = this.entry.value.blob.blockLength;
      }
      if (!this.uploadStats.targetBytes || !this.uploadStats.targetBlocks) {
        this.uploadStats.targetBytes = this.entry.value.blob.byteLength;
        this.uploadStats.targetBlocks = this.entry.value.blob.blockLength;
      }
    }
    _onUpload(index, bytes, from) {
      this._updateStats(this.uploadSpeedometer, this.uploadStats, index, bytes, from);
    }
    _onDownload(index, bytes, from) {
      this._updateStats(this.downloadSpeedometer, this.downloadStats, index, bytes, from);
    }
    _updatePeers() {
      this.uploadStats.peers = this.downloadStats.peers = this.peers = this.blobs.core.peers.length;
    }
    _updateStats(speed, stats, index, bytes, from) {
      if (!this.entry || this.closing)
        return;
      if (!isWithinRange(index, this.entry))
        return;
      if (!stats.startTime)
        stats.startTime = Date.now();
      stats.speed = speed(bytes);
      stats.blocks++;
      stats.monitoringBytes += bytes;
      stats.totalBytes += bytes;
      stats.percentage = toFixed(stats.blocks / stats.targetBlocks * 100);
      this.emit("update");
    }
    downloadSpeed() {
      return this.downloadSpeedometer ? this.downloadSpeedometer() : 0;
    }
    uploadSpeed() {
      return this.uploadSpeedometer ? this.uploadSpeedometer() : 0;
    }
  };
  function isWithinRange(index, entry) {
    if (!entry || !entry.value)
      return;
    const { blockOffset, blockLength } = entry.value.blob;
    return index >= blockOffset && index < blockOffset + blockLength;
  }
  function toFixed(n) {
    return Math.round(n * 100) / 100;
  }
});

// node_modules/hyperdrive/lib/download.js
var require_download2 = __commonJS((exports, module) => {
  var ReadyResource = require_ready_resource();
  module.exports = class Download extends ReadyResource {
    constructor(drive, folder, options) {
      super();
      this.drive = drive;
      this.folder = folder;
      this.options = options || {};
      this.downloads = [];
      this.destroyed = false;
      this.ready().catch(noop);
    }
    async _open() {
      const drive = this.drive;
      const entry = !this.folder || this.folder.endsWith("/") ? null : await drive.entry(this.folder, this.options);
      if (entry) {
        const b = entry.value.blob;
        if (!b)
          return;
        const blobs = await drive.getBlobs();
        const download = blobs.core.download({ start: b.blockOffset, length: b.blockLength });
        this.downloads.push(download);
        return;
      }
      for await (const _ of drive.list(this.folder, this.options)) {}
      for await (const entry2 of drive.list(this.folder, this.options)) {
        const b = entry2.value.blob;
        if (!b)
          continue;
        const blobs = await drive.getBlobs();
        this.downloads.push(blobs.core.download({ start: b.blockOffset, length: b.blockLength }));
      }
    }
    _close() {
      for (const d of this.downloads) {
        d.destroy();
      }
    }
    destroy() {
      this.destroyed = true;
      this._safeBackgroundDestroy();
    }
    async _safeBackgroundDestroy() {
      try {
        await this.ready();
      } catch {}
      await this.close();
    }
    async done() {
      await this.ready();
      await Promise.allSettled(this.downloads.map((d) => d.done()));
    }
  };
  function noop() {}
});

// node_modules/hyperdrive/index.js
var require_hyperdrive = __commonJS((exports, module) => {
  var Hyperbee = require_hyperbee();
  var Hyperblobs = require_hyperblobs();
  var isOptions = require_is_options();
  var { Writable, Readable } = require_streamx();
  var unixPathResolve = require_unix_path_resolve();
  var MirrorDrive = require_mirror_drive();
  var SubEncoder = require_sub_encoder();
  var ReadyResource = require_ready_resource();
  var safetyCatch = require_safety_catch();
  var crypto = require_hypercore_crypto();
  var Hypercore = require_hypercore();
  var { BLOCK_NOT_AVAILABLE, BAD_ARGUMENT } = require_hypercore_errors();
  var Monitor = require_monitor2();
  var Download = require_download2();
  var keyEncoding = new SubEncoder("files", "utf-8");
  var [BLOBS] = crypto.namespace("hyperdrive", 1);
  module.exports = class Hyperdrive extends ReadyResource {
    constructor(corestore, key, opts = {}) {
      super();
      if (isOptions(key)) {
        opts = key;
        key = null;
      }
      this.corestore = corestore;
      this.db = opts._db || makeBee(key, corestore, opts);
      this.core = this.db.core;
      this.blobs = null;
      this.supportsMetadata = true;
      this.encryptionKey = opts.encryptionKey || null;
      this.monitors = new Set;
      this._active = opts.active !== false;
      this._openingBlobs = null;
      this._onwait = opts.onwait || null;
      this._batching = !!(opts._checkout === null && opts._db);
      this._checkout = opts._checkout || null;
      this.ready().catch(safetyCatch);
    }
    [Symbol.asyncIterator]() {
      return this.entries()[Symbol.asyncIterator]();
    }
    static async getDriveKey(corestore) {
      const core = makeBee(undefined, corestore);
      await core.ready();
      const key = core.key;
      await core.close();
      return key;
    }
    static getContentKey(m, key) {
      if (m instanceof Hypercore) {
        if (m.core.compat)
          return null;
        return Hyperdrive.getContentKey(m.manifest, m.key);
      }
      const manifest = generateContentManifest(m, key);
      if (!manifest)
        return null;
      return Hypercore.key(manifest);
    }
    static getContentManifest(m, key) {
      return generateContentManifest(m, key);
    }
    _generateBlobsManifest() {
      const m = this.db.core.manifest;
      if (this.db.core.core.compat)
        return null;
      return generateContentManifest(m, this.core.key);
    }
    get id() {
      return this.core.id;
    }
    get key() {
      return this.core.key;
    }
    get discoveryKey() {
      return this.core.discoveryKey;
    }
    get contentKey() {
      return this.blobs?.core.key;
    }
    get version() {
      return this.db.version;
    }
    get writable() {
      return this.core.writable;
    }
    get readable() {
      return this.core.readable;
    }
    findingPeers() {
      return this.corestore.findingPeers();
    }
    async truncate(version, { blobs = -1 } = {}) {
      if (!this.opened)
        await this.ready();
      if (version > this.core.length) {
        throw BAD_ARGUMENT("Bad truncation length");
      }
      const blobsVersion = blobs === -1 ? await this.getBlobsLength(version) : blobs;
      const bl = await this.getBlobs();
      if (blobsVersion > bl.core.length) {
        throw BAD_ARGUMENT("Bad truncation length");
      }
      await this.core.truncate(version);
      await bl.core.truncate(blobsVersion);
    }
    async getBlobsLength(checkout) {
      if (!this.opened)
        await this.ready();
      if (!checkout)
        checkout = this.version;
      const c = this.db.checkout(checkout);
      try {
        return await getBlobsLength(c);
      } finally {
        await c.close();
      }
    }
    replicate(isInitiator, opts) {
      return this.corestore.replicate(isInitiator, opts);
    }
    update(opts) {
      return this.db.update(opts);
    }
    _makeCheckout(snapshot) {
      return new Hyperdrive(this.corestore, this.key, {
        onwait: this._onwait,
        encryptionKey: this.encryptionKey,
        _checkout: this._checkout || this,
        _db: snapshot
      });
    }
    checkout(version) {
      return this._makeCheckout(this.db.checkout(version));
    }
    batch() {
      return new Hyperdrive(this.corestore, this.key, {
        onwait: this._onwait,
        encryptionKey: this.encryptionKey,
        _checkout: null,
        _db: this.db.batch()
      });
    }
    setActive(bool) {
      const active = !!bool;
      if (active === this._active)
        return;
      this._active = active;
      this.core.setActive(active);
      if (this.blobs)
        this.blobs.core.setActive(active);
    }
    async flush() {
      await this.db.flush();
      return this.close();
    }
    async _close() {
      if (this.blobs && (!this._checkout || this.blobs !== this._checkout.blobs)) {
        await this.blobs.core.close();
      }
      await this.db.close();
      if (!this._checkout && !this._batching) {
        await this.corestore.close();
      }
      await this.closeMonitors();
    }
    async _openBlobsFromHeader(opts) {
      if (this.blobs)
        return true;
      const header = await getBee(this.db).getHeader(opts);
      if (!header)
        return false;
      if (this.blobs)
        return true;
      const contentKey = header.metadata && header.metadata.contentFeed && header.metadata.contentFeed.subarray(0, 32);
      const blobsKey = contentKey || Hypercore.key(this._generateBlobsManifest());
      if (!blobsKey || blobsKey.length < 32)
        throw new Error("Invalid or no Blob store key set");
      const blobsCore = this.corestore.get({
        key: blobsKey,
        cache: false,
        onwait: this._onwait,
        encryptionKey: this.encryptionKey,
        keyPair: !contentKey && this.db.core.writable ? this.db.core.keyPair : null,
        active: this._active
      });
      await blobsCore.ready();
      if (this.closing) {
        await blobsCore.close();
        return false;
      }
      this.blobs = new Hyperblobs(blobsCore);
      this.emit("blobs", this.blobs);
      this.emit("content-key", blobsCore.key);
      return true;
    }
    async _open() {
      if (this._checkout) {
        await this._checkout.ready();
        this.blobs = this._checkout.blobs;
        return;
      }
      await this._openBlobsFromHeader({ wait: false });
      if (this.db.core.writable && !this.blobs) {
        const m = this._generateBlobsManifest();
        const blobsCore = this.corestore.get({
          manifest: m,
          name: m ? null : this.db.core.id + "/blobs",
          cache: false,
          onwait: this._onwait,
          encryptionKey: this.encryptionKey,
          compat: this.db.core.core.compat,
          active: this._active,
          keyPair: m && this.db.core.writable ? this.db.core.keyPair : null
        });
        await blobsCore.ready();
        this.blobs = new Hyperblobs(blobsCore);
        if (!m)
          getBee(this.db).metadata.contentFeed = this.blobs.core.key;
        this.emit("blobs", this.blobs);
        this.emit("content-key", blobsCore.key);
      }
      await this.db.ready();
      if (!this.blobs) {
        this._openingBlobs = this._openBlobsFromHeader();
        this._openingBlobs.catch(safetyCatch);
      }
    }
    async getBlobs() {
      if (this.blobs)
        return this.blobs;
      if (this._checkout) {
        this.blobs = await this._checkout.getBlobs();
      } else {
        await this.ready();
        await this._openingBlobs;
      }
      return this.blobs;
    }
    monitor(name, opts = {}) {
      const monitor = new Monitor(this, { name, ...opts });
      this.monitors.add(monitor);
      return monitor;
    }
    async closeMonitors() {
      const closing = [];
      for (const monitor of this.monitors)
        closing.push(monitor.close());
      await Promise.allSettled(closing);
    }
    async get(name, opts) {
      const node = await this.entry(name, opts);
      if (!node?.value.blob)
        return null;
      await this.getBlobs();
      const res = await this.blobs.get(node.value.blob, opts);
      if (res === null)
        throw BLOCK_NOT_AVAILABLE();
      return res;
    }
    async put(name, buf, { executable = false, metadata = null } = {}) {
      await this.getBlobs();
      const blob = await this.blobs.put(buf);
      return this.db.put(std(name, false), { executable, linkname: null, blob, metadata }, { keyEncoding });
    }
    async del(name) {
      return this.db.del(std(name, false), { keyEncoding });
    }
    compare(a, b) {
      const diff = a.seq - b.seq;
      return diff > 0 ? 1 : diff < 0 ? -1 : 0;
    }
    async clear(name, opts) {
      if (!this.opened)
        await this.ready();
      let node = null;
      try {
        node = await this.entry(name, { wait: false });
      } catch {}
      if (node === null || this.blobs === null) {
        return opts && opts.diff ? { blocks: 0 } : null;
      }
      return this.blobs.clear(node.value.blob, opts);
    }
    async clearAll(opts) {
      if (!this.opened)
        await this.ready();
      if (this.blobs === null) {
        return opts && opts.diff ? { blocks: 0 } : null;
      }
      return this.blobs.core.clear(0, this.blobs.core.length, opts);
    }
    async purge() {
      if (this._checkout || this._batch)
        throw new Error("Can only purge the main session");
      await this.ready();
      await this.close();
      const proms = [this.core.purge()];
      if (this.blobs)
        proms.push(this.blobs.core.purge());
      await Promise.all(proms);
    }
    async symlink(name, dst, { metadata = null } = {}) {
      return this.db.put(std(name, false), { executable: false, linkname: dst, blob: null, metadata }, { keyEncoding });
    }
    async entry(name, opts) {
      if (!opts || !opts.follow)
        return this._entry(name, opts);
      for (let i = 0;i < 16; i++) {
        const node = await this._entry(name, opts);
        if (!node || !node.value.linkname)
          return node;
        name = unixPathResolve(node.key, node.value.linkname);
      }
      throw new Error("Recursive symlink");
    }
    async _entry(name, opts) {
      if (typeof name !== "string")
        return name;
      return this.db.get(std(name, false), { ...opts, keyEncoding });
    }
    async exists(name) {
      return await this.entry(name) !== null;
    }
    watch(folder) {
      folder = std(folder || "/", true);
      return this.db.watch(prefixRange(folder), { keyEncoding, map: (snap) => this._makeCheckout(snap) });
    }
    diff(length, folder, opts) {
      if (typeof folder === "object" && folder && !opts)
        return this.diff(length, null, folder);
      folder = std(folder || "/", true);
      return this.db.createDiffStream(length, prefixRange(folder), { ...opts, keyEncoding });
    }
    async downloadDiff(length, folder, opts) {
      const dls = [];
      for await (const entry of this.diff(length, folder, opts)) {
        if (!entry.left)
          continue;
        const b = entry.left.value.blob;
        if (!b)
          continue;
        const blobs = await this.getBlobs();
        dls.push(blobs.core.download({ start: b.blockOffset, length: b.blockLength }));
      }
      return new Download(dls);
    }
    async downloadRange(dbRanges, blobRanges) {
      const dls = [];
      await this.ready();
      for (const range of dbRanges) {
        dls.push(this.db.core.download(range));
      }
      const blobs = await this.getBlobs();
      for (const range of blobRanges) {
        dls.push(blobs.core.download(range));
      }
      return new Download(dls);
    }
    entries(range, opts) {
      const stream = this.db.createReadStream(range, { ...opts, keyEncoding });
      if (opts && opts.ignore)
        stream._readableState.map = createStreamMapIgnore(opts.ignore);
      return stream;
    }
    download(folder = "/", opts) {
      if (typeof folder === "object")
        return this.download(undefined, folder);
      return new Download(this, folder, opts);
    }
    async has(path) {
      const blobs = await this.getBlobs();
      const entry = !path || path.endsWith("/") ? null : await this.entry(path);
      if (entry) {
        const b = entry.value.blob;
        if (!b)
          return false;
        return await blobs.core.has(b.blockOffset, b.blockOffset + b.blockLength);
      }
      for await (const entry2 of this.list(path)) {
        const b = entry2.value.blob;
        if (!b)
          continue;
        const has = await blobs.core.has(b.blockOffset, b.blockOffset + b.blockLength);
        if (!has)
          return false;
      }
      return true;
    }
    list(folder, opts = {}) {
      if (typeof folder === "object")
        return this.list(undefined, folder);
      folder = std(folder || "/", true);
      const ignore = opts.ignore ? toIgnoreFunction(opts.ignore) : null;
      const stream = opts && opts.recursive === false ? shallowReadStream(this.db, folder, false, ignore, opts) : this.entries(prefixRange(folder), { ...opts, ignore });
      return stream;
    }
    readdir(folder, opts) {
      folder = std(folder || "/", true);
      return shallowReadStream(this.db, folder, true, null, opts);
    }
    mirror(out, opts) {
      return new MirrorDrive(this, out, opts);
    }
    createReadStream(name, opts) {
      const self = this;
      let destroyed = false;
      let rs = null;
      const stream = new Readable({
        open(cb) {
          self.getBlobs().then(onblobs, cb);
          function onblobs() {
            self.entry(name).then(onnode, cb);
          }
          function onnode(node) {
            if (destroyed)
              return cb(null);
            if (!node)
              return cb(new Error("Blob does not exist"));
            if (self.closing)
              return cb(new Error("Closed"));
            if (!node.value.blob) {
              stream.push(null);
              return cb(null);
            }
            rs = self.blobs.createReadStream(node.value.blob, opts);
            rs.on("data", function(data) {
              if (!stream.push(data))
                rs.pause();
            });
            rs.on("end", function() {
              stream.push(null);
            });
            rs.on("error", function(err) {
              stream.destroy(err);
            });
            cb(null);
          }
        },
        read(cb) {
          rs.resume();
          cb(null);
        },
        predestroy() {
          destroyed = true;
          if (rs)
            rs.destroy();
        }
      });
      return stream;
    }
    createWriteStream(name, { executable = false, metadata = null } = {}) {
      const self = this;
      let destroyed = false;
      let ws = null;
      let ondrain = null;
      let onfinish = null;
      const stream = new Writable({
        open(cb) {
          self.getBlobs().then(onblobs, cb);
          function onblobs() {
            if (destroyed)
              return cb(null);
            ws = self.blobs.createWriteStream();
            ws.on("error", function(err) {
              stream.destroy(err);
            });
            ws.on("close", function() {
              const err = new Error("Closed");
              callOndrain(err);
              callOnfinish(err);
            });
            ws.on("finish", function() {
              callOnfinish(null);
            });
            ws.on("drain", function() {
              callOndrain(null);
            });
            cb(null);
          }
        },
        write(data, cb) {
          if (ws.write(data) === true)
            return cb(null);
          ondrain = cb;
        },
        final(cb) {
          onfinish = cb;
          ws.end();
        },
        predestroy() {
          destroyed = true;
          if (ws)
            ws.destroy();
        }
      });
      return stream;
      function callOnfinish(err) {
        if (!onfinish)
          return;
        const cb = onfinish;
        onfinish = null;
        if (err)
          return cb(err);
        self.db.put(std(name, false), { executable, linkname: null, blob: ws.id, metadata }, { keyEncoding }).then(() => cb(null), cb);
      }
      function callOndrain(err) {
        if (ondrain) {
          const cb = ondrain;
          ondrain = null;
          cb(err);
        }
      }
    }
    static normalizePath(name) {
      return std(name, false);
    }
  };
  function shallowReadStream(files, folder, keys, ignore, opts) {
    let prev = "/";
    let prevName = "";
    return new Readable({
      async read(cb) {
        let node = null;
        try {
          node = await files.peek(prefixRange(folder, prev), { ...opts, keyEncoding });
        } catch (err) {
          return cb(err);
        }
        if (!node) {
          this.push(null);
          return cb(null);
        }
        const suffix = node.key.slice(folder.length + 1);
        const i = suffix.indexOf("/");
        const name = i === -1 ? suffix : suffix.slice(0, i);
        prev = "/" + name + (i === -1 ? "" : "0");
        if (name === prevName) {
          this._read(cb);
          return;
        }
        prevName = name;
        if (ignore && ignore(node.key)) {
          this._read(cb);
          return;
        }
        this.push(keys ? name : node);
        cb(null);
      }
    });
  }
  function makeBee(key, corestore, opts = {}) {
    const name = key ? undefined : "db";
    const core = corestore.get({ key, name, exclusive: true, onwait: opts.onwait, encryptionKey: opts.encryptionKey, compat: opts.compat, active: opts.active });
    return new Hyperbee(core, {
      keyEncoding: "utf-8",
      valueEncoding: "json",
      metadata: { contentFeed: null },
      extension: opts.extension
    });
  }
  function getBee(bee) {
    return bee.tree || bee;
  }
  function std(name, removeSlash) {
    name = unixPathResolve("/", name);
    if (removeSlash && name.endsWith("/"))
      name = name.slice(0, -1);
    validateFilename(name);
    return name;
  }
  function validateFilename(name) {
    if (name === "/")
      throw new Error("Invalid filename: " + name);
  }
  function prefixRange(name, prev = "/") {
    return { gt: name + prev, lt: name + "0" };
  }
  function generateContentManifest(m, key) {
    if (m.version < 1)
      return null;
    const signers = [];
    if (!key)
      key = Hypercore.key(m);
    for (const s of m.signers) {
      const namespace = crypto.hash([BLOBS, key, s.namespace]);
      signers.push({ ...s, namespace });
    }
    return {
      version: m.version,
      hash: "blake2b",
      allowPatch: m.allowPatch,
      quorum: m.quorum,
      signers,
      prologue: null
    };
  }
  async function getBlobsLength(db) {
    let length = 0;
    for await (const { value } of db.createReadStream()) {
      const b = value && value.blob;
      if (!b)
        continue;
      const len = b.blockOffset + b.blockLength;
      if (len > length)
        length = len;
    }
    return length;
  }
  function toIgnoreFunction(ignore) {
    if (typeof ignore === "function")
      return ignore;
    const all = [].concat(ignore).map((e) => unixPathResolve("/", e));
    return (key) => all.some((path) => path === key || key.startsWith(path + "/"));
  }
  function createStreamMapIgnore(ignore) {
    return (node) => ignore(node.key) ? null : node;
  }
});

// index.ts
var import_ready_resource = __toESM(require_ready_resource(), 1);
var import_autobase = __toESM(require_autobase2(), 1);
var import_hyperswarm = __toESM(require_hyperswarm(), 1);
var import_blind_pairing = __toESM(require_blind_pairing(), 1);
var z32 = __toESM(require_z32(), 1);
var b4a = __toESM(require_b4a(), 1);
var import_hyperdrive = __toESM(require_hyperdrive(), 1);
var import_hyperbee = __toESM(require_hyperbee(), 1);
var import_hyperblobs = __toESM(require_hyperblobs(), 1);
var noop = () => {};

class EasybasePairer extends import_ready_resource.default {
  store;
  invite;
  swarm;
  pairing;
  candidate;
  bootstrap;
  onresolve;
  onreject;
  easybase;
  base;
  viewType;
  constructor(store, invite, opts = {}) {
    super();
    this.store = store;
    this.invite = invite;
    this.swarm = null;
    this.pairing = null;
    this.candidate = null;
    this.bootstrap = opts.bootstrap || null;
    this.onresolve = null;
    this.onreject = null;
    this.easybase = null;
    this.base = null;
    this.viewType = opts.viewType || "default";
    this.ready().catch(noop);
  }
  async _open() {
    await this.store.ready();
    this.swarm = new import_hyperswarm.default({
      keyPair: await this.store.createKeyPair("hyperswarm"),
      bootstrap: this.bootstrap
    });
    const store = this.store;
    this.swarm.on("connection", (connection, peerInfo) => {
      store.replicate(connection);
    });
    this.pairing = new import_blind_pairing.default(this.swarm);
    const core = import_autobase.default.getLocalCore(this.store);
    await core.ready();
    const key = core.key;
    await core.close();
    this.candidate = this.pairing.addCandidate({
      invite: z32.decode(this.invite),
      userData: key,
      onadd: async (result) => {
        if (this.easybase === null) {
          this.easybase = new Easybase(this.store, {
            swarm: this.swarm,
            key: result.key,
            encryptionKey: result.encryptionKey,
            bootstrap: this.bootstrap,
            viewType: this.viewType
          });
        }
        this.swarm = null;
        this.store = null;
        if (this.onresolve)
          this._whenWritable();
        this.candidate?.close().catch(noop);
      }
    });
  }
  _whenWritable() {
    if (this.easybase?.base.writable)
      return;
    const check = () => {
      if (this.easybase?.base.writable) {
        this.easybase.base.off("update", check);
        this.onresolve?.(this.easybase);
      }
    };
    this.easybase?.base.on("update", check);
  }
  async _close() {
    if (this.candidate !== null) {
      await this.candidate.close();
    }
    if (this.swarm !== null) {
      await this.swarm.destroy();
    }
    if (this.store !== null) {
      await this.store.close();
    }
    if (this.onreject) {
      this.onreject(new Error("Pairing closed"));
    } else if (this.easybase) {
      await this.easybase.close();
    }
  }
  finished() {
    return new Promise((resolve, reject) => {
      this.onresolve = resolve;
      this.onreject = reject;
    });
  }
}

class Easybase extends import_ready_resource.default {
  store;
  swarm;
  base;
  bootstrap;
  member;
  pairing;
  replicate;
  debug;
  invitePublicKey;
  viewType;
  actions;
  constructor(corestore, opts) {
    super();
    this.store = corestore;
    this.swarm = opts.swarm || null;
    this.bootstrap = opts.bootstrap || null;
    this.member = null;
    this.pairing = null;
    this.replicate = opts.replicate !== false;
    this.debug = !!opts.key;
    this.invitePublicKey = opts.invitePublicKey || null;
    this.viewType = opts.viewType || "default";
    this.actions = opts.actions || {};
    const { encryptionKey, key } = opts;
    this.base = new import_autobase.default(this.store, key, {
      encrypt: true,
      encryptionKey,
      open: this._openView.bind(this),
      apply: this._apply.bind(this)
    });
    this.base.on("update", () => {
      if (!this.base?._interrupting)
        this.emit("update");
    });
    if (this.actions) {
      for (const [actionName, actionFn] of Object.entries(this.actions)) {
        this[actionName] = async (value) => {
          await this.base.append({ type: actionName, ...value });
        };
      }
    }
    this.ready().catch(noop);
  }
  _openView(store) {
    if (this.viewType === "hyperdrive") {
      return this._createHyperdriveView(store);
    }
    return store.get("view");
  }
  _createHyperdriveView(store) {
    const db = new import_hyperbee.default(store.get("db"), {
      keyEncoding: "utf-8",
      valueEncoding: "json",
      metadata: { contentFeed: null },
      extension: false
    });
    const blobs = new import_hyperblobs.default(store.get("blobs"));
    const drive = new import_hyperdrive.default(store, { _db: db });
    drive.blobs = blobs;
    this.base.db = db;
    return drive;
  }
  _isHyperdrive(view) {
    return this.viewType === "hyperdrive";
  }
  async _addInvite(view, record) {
    if (this._isHyperdrive(view)) {
      const fileName = `invite.json`;
      const buffer = Buffer.from(JSON.stringify(record));
      await view.put(fileName, buffer);
    } else {
      await view.append(record);
    }
  }
  async _delInvite(view, record) {
    if (this._isHyperdrive(view)) {
      const fileName = `invite.json`;
      await view.del(fileName);
    } else {
      throw new Error("Cannot delete invite from default view");
    }
  }
  async _apply(nodes, view, base) {
    for (const node of nodes) {
      const { type, record } = node.value;
      switch (type) {
        case "add-invite":
          await this._addInvite(view, record);
          break;
        case "del-invite":
          await this._delInvite(view, record);
          break;
        case "add-writer":
          await base.addWriter(Buffer.from(record.key, "hex"));
          break;
        case "remove-writer":
          await base.removeWriter(Buffer.from(record.key, "hex"));
          break;
        default:
          if (this.actions && type in this.actions) {
            await this.actions[type](node.value, { view, base });
          } else {
            throw new Error(`Unknown action: ${type}`);
          }
          break;
      }
    }
    if ("flush" in view && typeof view.flush === "function") {
      await view.flush();
    }
  }
  async _open() {
    await this.base.ready();
    if (this.replicate)
      await this._replicate();
  }
  async _close() {
    if (this.swarm) {
      await this.member?.close();
      await this.pairing?.close();
      await this.swarm.destroy();
    }
    if (this.viewType === "hyperdrive" && this.base.view) {
      try {
        await this.base.view.close();
      } catch (error) {
        console.log("Error closing Hyperdrive view:", error);
      }
    }
    await this.base.close();
  }
  get writerKey() {
    return this.base.local.key;
  }
  get key() {
    return this.base.key;
  }
  get discoveryKey() {
    return this.base.discoveryKey;
  }
  get encryptionKey() {
    return this.base.encryptionKey;
  }
  static pair(store, invite, opts) {
    return new EasybasePairer(store, invite, opts);
  }
  async createInvite(opts = {}) {
    await this.ready();
    const existing = await this.base.view.findOne("@easybase/invite", {});
    if (existing) {
      return z32.encode(existing.invite);
    }
    const { id, invite, publicKey, expires } = import_blind_pairing.default.createInvite(this.base.key);
    const record = { id, invite, publicKey, expires };
    await this.base.append({ type: "add-invite", record });
    return z32.encode(record.invite);
  }
  async deleteInvite() {
    await this.ready();
    let existing;
    if (this.viewType === "hyperdrive") {
      const data = await this.base.view.get("invite.json");
      if (data) {
        existing = JSON.parse(data.toString("utf-8"));
      }
    } else {
      existing = await this.base.view.findOne("@easybase/invite", {});
    }
    if (existing) {
      await this.base.append({ type: "del-invite", record: existing });
    }
  }
  async addWriter(key) {
    await this.base.append({
      type: "add-writer",
      record: {
        key: b4a.isBuffer(key) ? key : b4a.from(key)
      }
    });
    return true;
  }
  async removeWriter(key) {
    await this.base.append({
      type: "remove-writer",
      record: {
        key: b4a.isBuffer(key) ? key : b4a.from(key)
      }
    });
  }
  get writable() {
    return this.base.writable;
  }
  get hyperdriveView() {
    if (this.viewType === "hyperdrive") {
      return this.base.view;
    }
    return null;
  }
  get hyperbeeDb() {
    if (this.viewType === "hyperdrive") {
      return this.base.db;
    }
    return null;
  }
  get hyperblobs() {
    if (this.viewType === "hyperdrive" && this.base.view) {
      return this.base.view.blobs;
    }
    return null;
  }
  async _replicate() {
    await this.base.ready();
    if (this.swarm === null) {
      this.swarm = new import_hyperswarm.default({
        keyPair: await this.store.createKeyPair("hyperswarm"),
        bootstrap: this.bootstrap
      });
      this.swarm.on("connection", (connection, peerInfo) => {
        this.store.replicate(connection);
      });
    }
    this.pairing = new import_blind_pairing.default(this.swarm);
    this.member = this.pairing.addMember({
      discoveryKey: this.base.discoveryKey,
      onadd: async (candidate) => {
        const id = candidate.inviteId;
        candidate.open(candidate.publicKey);
        await this.addWriter(candidate.userData);
        candidate.confirm({
          key: this.base.key,
          encryptionKey: this.base.encryptionKey
        });
      }
    });
    this.swarm.join(this.base.discoveryKey);
  }
}
export {
  EasybasePairer,
  Easybase
};
